<!DOCTYPE html>
<html lang="zh" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>数学基础算法篇 | Minjie&#39;s Blog</title>
<meta name="keywords" content="算法, 哈希, 算法分析, 尾不等式, 数据流">
<meta name="description" content="金老师主讲的研究生课程《数学基础算法篇》完整笔记，从算法分析基础开始，系统介绍相似度搜索、概率不等式、流式数据处理、分布式计算、哈希技术、优化算法、图算法等内容，理论与实践相结合，为解决大规模数据处理问题提供数学和算法基础。
">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/mathematical-algorithms-lecture/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/code.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/code.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/code.png">
<link rel="apple-touch-icon" href="http://localhost:1313/code.png">
<link rel="mask-icon" href="http://localhost:1313/code.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/mathematical-algorithms-lecture/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Minjie&#39;s Blog (Alt + H)">Minjie&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Minjie&#39;s Blog">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="关于我">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      数学基础算法篇
    </h1>
    <div class="post-description">
      金老师主讲的研究生课程《数学基础算法篇》完整笔记，从算法分析基础开始，系统介绍相似度搜索、概率不等式、流式数据处理、分布式计算、哈希技术、优化算法、图算法等内容，理论与实践相结合，为解决大规模数据处理问题提供数学和算法基础。

    </div>
    <div class="post-meta"><span title='2025-12-21 15:50:54 +0800 CST'>2025年12月21日</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e7%ac%ac%e4%b8%80%e8%ae%b2-%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90" aria-label="第一讲 算法分析">第一讲 算法分析</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e7%ae%97%e6%b3%95%e7%ae%80%e4%bb%8b" aria-label="一、算法简介">一、算法简介</a></li>
                <li>
                    <a href="#%e4%ba%8c%e7%9b%b8%e4%bc%bc%e5%ba%a6%e6%90%9c%e7%b4%a2" aria-label="二、相似度搜索">二、相似度搜索</a></li>
                <li>
                    <a href="#%e4%b8%89%e9%ab%98%e7%bb%b4%e7%a9%ba%e9%97%b4%e7%9a%84%e7%9b%b8%e4%bc%bc%e6%80%a7%e6%90%9c%e7%b4%a2" aria-label="三、高维空间的相似性搜索">三、高维空间的相似性搜索</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e4%ba%8c%e8%ae%b2-%e5%b0%be%e4%b8%8d%e7%ad%89%e5%bc%8f" aria-label="第二讲 尾不等式">第二讲 尾不等式</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e5%b0%be%e4%b8%8d%e7%ad%89%e5%bc%8f%e5%88%86%e6%9e%90%e6%a6%82%e8%a6%81" aria-label="一、尾不等式分析概要">一、尾不等式分析概要</a></li>
                <li>
                    <a href="#%e4%ba%8c%e4%b8%89%e4%b8%aa%e5%b8%b8%e8%a7%81%e7%9a%84%e5%b0%be%e4%b8%8d%e7%ad%89%e5%bc%8f" aria-label="二、三个常见的尾不等式">二、三个常见的尾不等式</a></li>
                <li>
                    <a href="#%e4%b8%89%e8%ae%a1%e6%95%b0%e9%97%ae%e9%a2%98" aria-label="三、计数问题">三、计数问题</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e4%b8%89%e8%ae%b2-%e6%95%b0%e6%8d%ae%e6%b5%81" aria-label="第三讲 数据流">第三讲 数据流</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e6%95%b0%e6%8d%ae%e6%b5%81%e6%a8%a1%e5%9e%8b" aria-label="一、数据流模型">一、数据流模型</a></li>
                <li>
                    <a href="#%e4%ba%8c%e9%a2%91%e7%b9%81%e5%85%83%e7%b4%a0-%e7%a1%ae%e5%ae%9a%e6%80%a7%e7%ae%97%e6%b3%95" aria-label="二、频繁元素-确定性算法">二、频繁元素-确定性算法</a></li>
                <li>
                    <a href="#%e4%b8%89%e9%a2%91%e7%b9%81%e5%85%83%e7%b4%a0-%e9%9a%8f%e6%9c%ba%e7%ae%97%e6%b3%95" aria-label="三、频繁元素-随机算法">三、频繁元素-随机算法</a></li>
                <li>
                    <a href="#%e5%9b%9b%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e6%a8%a1%e5%9e%8b" aria-label="四、滑动窗口模型">四、滑动窗口模型</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e5%9b%9b%e8%ae%b2-%e5%88%86%e5%b8%83%e5%bc%8f%e6%95%b0%e6%8d%ae%e6%b5%81" aria-label="第四讲 分布式数据流">第四讲 分布式数据流</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e5%88%86%e5%b8%83%e5%bc%8f%e6%95%b0%e6%8d%ae%e6%b5%81%e6%a8%a1%e5%9e%8b" aria-label="一、分布式数据流模型">一、分布式数据流模型</a></li>
                <li>
                    <a href="#%e4%ba%8c%e8%81%9a%e9%9b%86%e6%9f%a5%e8%af%a2" aria-label="二、聚集查询">二、聚集查询</a></li>
                <li>
                    <a href="#%e4%b8%89topk%e7%9b%91%e6%8e%a7" aria-label="三、topk监控">三、topk监控</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e4%ba%94%e8%ae%b2-%e5%93%88%e5%b8%8c" aria-label="第五讲 哈希">第五讲 哈希</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0%e5%92%8c%e5%93%88%e5%b8%8c%e8%a1%a8" aria-label="一、哈希函数和哈希表">一、哈希函数和哈希表</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8bloom-filter" aria-label="二、布隆过滤器（Bloom Filter）">二、布隆过滤器（Bloom Filter）</a></li>
                <li>
                    <a href="#%e4%b8%89%e6%9c%80%e5%b0%8f%e5%93%88%e5%b8%8c%e5%92%8clshlocality-sensitive-hashing" aria-label="三、最小哈希和LSH（Locality-Sensitive Hashing）">三、最小哈希和LSH（Locality-Sensitive Hashing）</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e5%85%ad%e8%ae%b2-%e7%ba%bf%e6%80%a7%e8%a7%84%e5%88%92%e4%b8%8e%e6%95%b4%e6%95%b0%e8%a7%84%e5%88%92" aria-label="第六讲 线性规划与整数规划">第六讲 线性规划与整数规划</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e7%ba%bf%e6%80%a7%e8%a7%84%e5%88%92%e5%8d%95%e7%ba%af%e5%bd%a2%e7%ae%97%e6%b3%95" aria-label="一、线性规划：单纯形算法">一、线性规划：单纯形算法</a></li>
                <li>
                    <a href="#%e4%ba%8c%e6%95%b4%e6%95%b0%e8%a7%84%e5%88%92%e9%97%ae%e9%a2%98%e5%ae%9a%e4%b9%89" aria-label="二、整数规划：问题定义">二、整数规划：问题定义</a></li>
                <li>
                    <a href="#%e4%b8%89%e6%95%b4%e6%95%b0%e8%a7%84%e5%88%92%e5%88%86%e6%94%af%e7%95%8c%e5%ae%9a%e6%b3%95branch-and-bound" aria-label="三、整数规划：分支界定法（Branch and Bound）">三、整数规划：分支界定法（Branch and Bound）</a></li>
                <li>
                    <a href="#%e5%9b%9b%e6%95%b4%e6%95%b0%e8%a7%84%e5%88%92%e5%88%87%e5%b9%b3%e9%9d%a2%e6%b3%95cutting-plane-method" aria-label="四、整数规划：切平面法（Cutting Plane Method）">四、整数规划：切平面法（Cutting Plane Method）</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e4%b8%83%e8%ae%b2-%e5%86%85%e5%ad%98%e8%ae%a1%e7%ae%97" aria-label="第七讲 内存计算">第七讲 内存计算</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e6%b5%b7%e9%87%8f%e5%86%85%e5%ad%98%e6%a6%82%e8%bf%b0" aria-label="一、海量内存概述">一、海量内存概述</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%9f%ba%e4%ba%8e%e5%8d%95%e6%9c%ba%e7%89%88%e5%86%85%e5%ad%98%e5%a2%9e%e5%a4%a7%e4%bc%98%e5%8a%bf" aria-label="二、基于单机版内存增大优势">二、基于单机版内存增大优势</a></li>
                <li>
                    <a href="#%e4%b8%89%e5%9f%ba%e4%ba%8e%e5%85%b1%e4%ba%ab%e5%bc%8f%e5%86%85%e5%ad%98%e5%92%8c%e5%88%86%e5%b8%83%e5%bc%8f%e5%86%85%e5%ad%98%e7%bb%93%e5%90%88%e6%9e%b6%e6%9e%84%e4%bc%98%e5%8a%bf" aria-label="三、基于共享式内存和分布式内存结合架构优势">三、基于共享式内存和分布式内存结合架构优势</a></li>
                <li>
                    <a href="#%e5%9b%9b%e6%80%bb%e7%bb%93" aria-label="四、总结">四、总结</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e5%85%ab%e8%ae%b2-%e7%a4%be%e5%8c%ba%e5%8f%91%e7%8e%b0" aria-label="第八讲 社区发现">第八讲 社区发现</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e5%9b%be%e5%88%87%e5%89%b2graph-partitioning" aria-label="一、图切割（Graph Partitioning）">一、图切割（Graph Partitioning）</a></li>
                <li>
                    <a href="#%e4%ba%8c%e8%be%b9%e4%bb%8b%e6%95%b0edge-betweenness" aria-label="二、边介数（Edge Betweenness）">二、边介数（Edge Betweenness）</a></li>
                <li>
                    <a href="#%e4%b8%89%e6%a8%a1%e5%9d%97%e5%ba%a6modularity" aria-label="三、模块度（Modularity）">三、模块度（Modularity）</a></li>
                <li>
                    <a href="#%e5%9b%9blouvain%e6%96%b9%e6%b3%95" aria-label="四、Louvain方法">四、Louvain方法</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e4%b9%9d%e8%ae%b2-%e5%ad%90%e6%a8%a1%e5%87%bd%e6%95%b0%e5%8f%8a%e5%85%b6%e5%ba%94%e7%94%a8" aria-label="第九讲 子模函数及其应用">第九讲 子模函数及其应用</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e5%ba%94%e7%94%a8%e8%83%8c%e6%99%af" aria-label="一、应用背景">一、应用背景</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%ad%90%e6%a8%a1%e5%87%bd%e6%95%b0submodular-function" aria-label="二、子模函数（Submodular Function）">二、子模函数（Submodular Function）</a></li>
                <li>
                    <a href="#%e4%b8%89%e9%9b%86%e5%90%88%e8%a6%86%e7%9b%96%e9%97%ae%e9%a2%98set-cover-problem" aria-label="三、集合覆盖问题（Set Cover Problem）">三、集合覆盖问题（Set Cover Problem）</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%af%be%e7%a8%8b%e6%80%bb%e7%bb%93" aria-label="课程总结">课程总结</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="第一讲-算法分析">第一讲 算法分析<a hidden class="anchor" aria-hidden="true" href="#第一讲-算法分析">#</a></h2>
<h3 id="一算法简介">一、算法简介<a hidden class="anchor" aria-hidden="true" href="#一算法简介">#</a></h3>
<p>算法分析是计算机科学的基础，用于评估算法的效率和资源消耗。</p>
<p><strong>算法复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度</strong>：衡量算法执行时间随输入规模增长的趋势</li>
<li><strong>空间复杂度</strong>：衡量算法所需存储空间随输入规模增长的趋势</li>
<li><strong>渐近分析</strong>：O、Ω、Θ记号</li>
</ul>
<p><strong>常见复杂度类型：</strong></p>
<ul>
<li>O(1)：常数时间</li>
<li>O(log n)：对数时间</li>
<li>O(n)：线性时间</li>
<li>O(n log n)：线性对数时间</li>
<li>O(n²)：平方时间</li>
<li>O(2ⁿ)：指数时间</li>
</ul>
<p><strong>算法设计范式：</strong></p>
<ul>
<li>分治法（Divide and Conquer）</li>
<li>动态规划（Dynamic Programming）</li>
<li>贪心算法（Greedy Algorithm）</li>
<li>回溯法（Backtracking）</li>
<li>分支界定法（Branch and Bound）</li>
</ul>
<h3 id="二相似度搜索">二、相似度搜索<a hidden class="anchor" aria-hidden="true" href="#二相似度搜索">#</a></h3>
<p>相似度搜索是在大规模数据中找到与查询对象相似的数据项。</p>
<p><strong>相似度度量：</strong></p>
<ul>
<li><strong>欧氏距离（Euclidean Distance）</strong>：
<pre tabindex="0"><code>d(x, y) = √(Σ(xᵢ - yᵢ)²)
</code></pre></li>
<li><strong>曼哈顿距离（Manhattan Distance）</strong>：
<pre tabindex="0"><code>d(x, y) = Σ|xᵢ - yᵢ|
</code></pre></li>
<li><strong>余弦相似度（Cosine Similarity）</strong>：
<pre tabindex="0"><code>sim(x, y) = (x·y) / (||x|| ||y||)
</code></pre></li>
<li><strong>Jaccard相似度</strong>：
<pre tabindex="0"><code>J(A, B) = |A ∩ B| / |A ∪ B|
</code></pre></li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>推荐系统</li>
<li>图像检索</li>
<li>文档相似度检测</li>
<li>近似最近邻搜索（ANN）</li>
</ul>
<p><strong>朴素方法的局限：</strong>
线性扫描的时间复杂度为O(n)，对于大规模数据集不可行。</p>
<h3 id="三高维空间的相似性搜索">三、高维空间的相似性搜索<a hidden class="anchor" aria-hidden="true" href="#三高维空间的相似性搜索">#</a></h3>
<p>在高维空间中，传统的索引结构（如KD树）性能退化严重，这被称为&quot;维度灾难&quot;。</p>
<p><strong>维度灾难（Curse of Dimensionality）：</strong></p>
<ul>
<li>数据点之间的距离趋于相等</li>
<li>数据点趋向于分布在空间的&quot;表面&quot;</li>
<li>索引结构的效率降低</li>
</ul>
<p><strong>解决方案：</strong></p>
<p><strong>1. 降维技术：</strong></p>
<ul>
<li>主成分分析（PCA）</li>
<li>随机投影</li>
<li>t-SNE</li>
</ul>
<p><strong>2. 近似算法：</strong></p>
<ul>
<li><strong>局部敏感哈希（LSH）</strong>：将相似的点以高概率映射到同一个桶</li>
<li><strong>乘积量化（Product Quantization）</strong>：将向量空间分解为子空间</li>
<li><strong>HNSW（Hierarchical Navigable Small World）</strong>：基于图的近似最近邻搜索</li>
</ul>
<p><strong>LSH的基本原理：</strong></p>
<ul>
<li>使用哈希函数族h，满足：相似的对象碰撞概率高，不相似的对象碰撞概率低</li>
<li>通过多个哈希函数和多个哈希表提高召回率</li>
<li>查询时只需检查哈希到同一桶的候选点</li>
</ul>
<hr>
<h2 id="第二讲-尾不等式">第二讲 尾不等式<a hidden class="anchor" aria-hidden="true" href="#第二讲-尾不等式">#</a></h2>
<h3 id="一尾不等式分析概要">一、尾不等式分析概要<a hidden class="anchor" aria-hidden="true" href="#一尾不等式分析概要">#</a></h3>
<p>尾不等式用于界定随机变量偏离其期望值的概率，在算法分析和概率算法设计中具有重要作用。</p>
<p><strong>为什么需要尾不等式：</strong></p>
<ul>
<li>期望值只描述了平均情况</li>
<li>需要了解&quot;坏情况&quot;发生的概率</li>
<li>为随机算法提供性能保证</li>
</ul>
<p><strong>应用领域：</strong></p>
<ul>
<li>随机算法分析</li>
<li>负载均衡</li>
<li>哈希表性能分析</li>
<li>采样算法</li>
</ul>
<h3 id="二三个常见的尾不等式">二、三个常见的尾不等式<a hidden class="anchor" aria-hidden="true" href="#二三个常见的尾不等式">#</a></h3>
<p><strong>1. Markov不等式（马尔可夫不等式）：</strong></p>
<p>对于非负随机变量X和a &gt; 0：</p>
<pre tabindex="0"><code>P(X ≥ a) ≤ E[X] / a
</code></pre><p><strong>特点：</strong></p>
<ul>
<li>只需要知道期望</li>
<li>界比较松</li>
<li>适用于任何非负随机变量</li>
</ul>
<p><strong>2. Chebyshev不等式（切比雪夫不等式）：</strong></p>
<p>对于随机变量X，有：</p>
<pre tabindex="0"><code>P(|X - E[X]| ≥ a) ≤ Var(X) / a²
</code></pre><p><strong>特点：</strong></p>
<ul>
<li>需要知道期望和方差</li>
<li>比Markov不等式更紧</li>
<li>不需要独立性假设</li>
</ul>
<p><strong>3. Chernoff界（切尔诺夫界）：</strong></p>
<p>对于独立的随机变量X₁, X₂, &hellip;, Xₙ ∈ [0,1]，令X = ΣXᵢ，μ = E[X]：</p>
<pre tabindex="0"><code>P(X ≥ (1+δ)μ) ≤ e^(-δ²μ/3)  (0 &lt; δ ≤ 1)
P(X ≤ (1-δ)μ) ≤ e^(-δ²μ/2)  (0 &lt; δ ≤ 1)
</code></pre><p><strong>特点：</strong></p>
<ul>
<li>界最紧，指数级衰减</li>
<li>需要独立性假设</li>
<li>广泛应用于随机算法分析</li>
</ul>
<h3 id="三计数问题">三、计数问题<a hidden class="anchor" aria-hidden="true" href="#三计数问题">#</a></h3>
<p><strong>问题描述：</strong>
估计一个数据流中不同元素的个数（基数估计）。</p>
<p><strong>朴素方法的问题：</strong></p>
<ul>
<li>存储所有元素需要O(n)空间</li>
<li>对于大规模数据流不可行</li>
</ul>
<p><strong>概率计数算法：</strong></p>
<p><strong>Flajolet-Martin算法：</strong></p>
<ol>
<li>使用哈希函数h将元素映射到[0, 2^L-1]</li>
<li>对每个元素计算其哈希值的尾部0的个数</li>
<li>记录观察到的最大尾部0个数R</li>
<li>估计值：2^R</li>
</ol>
<p><strong>原理：</strong></p>
<ul>
<li>如果有n个不同元素，期望看到log₂(n)个尾部0</li>
<li>使用多个哈希函数取平均值提高精度</li>
<li>空间复杂度：O(log log n)</li>
</ul>
<p><strong>HyperLogLog算法：</strong></p>
<ul>
<li>Flajolet-Martin的改进版本</li>
<li>使用调和平均数代替算术平均数</li>
<li>精度更高，误差约为1.04/√m（m为桶数）</li>
<li>空间效率极高</li>
</ul>
<hr>
<h2 id="第三讲-数据流">第三讲 数据流<a hidden class="anchor" aria-hidden="true" href="#第三讲-数据流">#</a></h2>
<h3 id="一数据流模型">一、数据流模型<a hidden class="anchor" aria-hidden="true" href="#一数据流模型">#</a></h3>
<p>数据流模型描述了数据以流的形式到达，只能顺序访问一次或有限次的计算场景。</p>
<p><strong>数据流的特点：</strong></p>
<ul>
<li>数据量巨大，无法全部存储</li>
<li>数据到达速度快，需要实时处理</li>
<li>只能进行一次或有限次扫描</li>
<li>需要在有限空间内近似计算</li>
</ul>
<p><strong>典型应用：</strong></p>
<ul>
<li>网络流量监控</li>
<li>金融交易分析</li>
<li>社交媒体数据处理</li>
<li>IoT传感器数据</li>
</ul>
<p><strong>数据流算法的目标：</strong></p>
<ul>
<li>使用亚线性（sublinear）空间</li>
<li>提供可证明的近似保证</li>
<li>单次扫描或少量扫描</li>
</ul>
<h3 id="二频繁元素-确定性算法">二、频繁元素-确定性算法<a hidden class="anchor" aria-hidden="true" href="#二频繁元素-确定性算法">#</a></h3>
<p><strong>问题定义：</strong>
找出数据流中出现频率超过某个阈值的元素（heavy hitters）。</p>
<p><strong>Misra-Gries算法：</strong></p>
<p><strong>算法描述：</strong></p>
<ol>
<li>维护最多k个计数器</li>
<li>对于每个到来的元素：
<ul>
<li>如果已有计数器，增加其计数</li>
<li>如果没有计数器且有空位，创建新计数器</li>
<li>如果没有空位，所有计数器减1，删除值为0的计数器</li>
</ul>
</li>
<li>输出计数器中的元素</li>
</ol>
<p><strong>性能保证：</strong></p>
<ul>
<li>空间复杂度：O(k)</li>
<li>如果元素出现次数 &gt; n/k，一定会被找到</li>
<li>可能有假阳性，但可以通过二次扫描验证</li>
</ul>
<p><strong>应用：</strong></p>
<ul>
<li>找出访问量最大的网页</li>
<li>检测网络中的大流量</li>
<li>识别热门话题</li>
</ul>
<h3 id="三频繁元素-随机算法">三、频繁元素-随机算法<a hidden class="anchor" aria-hidden="true" href="#三频繁元素-随机算法">#</a></h3>
<p><strong>Count-Min Sketch算法：</strong></p>
<p><strong>数据结构：</strong></p>
<ul>
<li>d × w 的二维计数器数组</li>
<li>d个独立的哈希函数h₁, h₂, &hellip;, h_d</li>
</ul>
<p><strong>算法操作：</strong></p>
<p><strong>更新（插入元素x）：</strong></p>
<pre tabindex="0"><code>对于 i = 1 到 d：
    count[i][hᵢ(x)] += 1
</code></pre><p><strong>查询（估计元素x的频率）：</strong></p>
<pre tabindex="0"><code>返回 min{count[i][hᵢ(x)] : i = 1..d}
</code></pre><p><strong>性能保证：</strong></p>
<ul>
<li>空间复杂度：O(d × w)</li>
<li>误差界：ε·n (n为总元素数)，概率至少1-δ</li>
<li>选择w = ⌈e/ε⌉, d = ⌈ln(1/δ)⌉</li>
<li>只会高估，不会低估</li>
</ul>
<p><strong>优势：</strong></p>
<ul>
<li>空间效率高</li>
<li>支持点查询和范围查询</li>
<li>可以处理删除操作（使用带符号的计数）</li>
</ul>
<h3 id="四滑动窗口模型">四、滑动窗口模型<a hidden class="anchor" aria-hidden="true" href="#四滑动窗口模型">#</a></h3>
<p><strong>问题描述：</strong>
只关心最近W个元素的统计特性，更早的数据被丢弃。</p>
<p><strong>挑战：</strong></p>
<ul>
<li>无法存储所有W个元素</li>
<li>需要及时更新统计信息</li>
</ul>
<p><strong>DGIM算法（用于计数）：</strong></p>
<p><strong>基本思想：</strong></p>
<ul>
<li>将窗口划分为桶（bucket）</li>
<li>每个桶代表一段连续的1</li>
<li>桶的大小是2的幂次</li>
<li>维护O(log W)个桶</li>
</ul>
<p><strong>桶的性质：</strong></p>
<ol>
<li>每种大小的桶最多2个</li>
<li>桶按时间戳排序</li>
<li>最老的桶可能不完整</li>
</ol>
<p><strong>查询操作：</strong>
统计窗口内1的个数 ≈ 完整桶的大小之和 + 半个最老桶</p>
<p><strong>误差保证：</strong></p>
<ul>
<li>相对误差：最多50%</li>
<li>可以通过增加每种大小桶的数量来降低误差</li>
</ul>
<p><strong>应用扩展：</strong></p>
<ul>
<li>滑动窗口中的平均值</li>
<li>滑动窗口中的中位数（近似）</li>
<li>滑动窗口中的distinct计数</li>
</ul>
<hr>
<h2 id="第四讲-分布式数据流">第四讲 分布式数据流<a hidden class="anchor" aria-hidden="true" href="#第四讲-分布式数据流">#</a></h2>
<h3 id="一分布式数据流模型">一、分布式数据流模型<a hidden class="anchor" aria-hidden="true" href="#一分布式数据流模型">#</a></h3>
<p>在分布式环境中，数据流分散在多个节点上，需要协调多个节点进行计算。</p>
<p><strong>系统架构：</strong></p>
<ul>
<li><strong>多个监测节点</strong>：每个节点观察部分数据流</li>
<li><strong>协调节点</strong>：汇总和处理来自监测节点的信息</li>
<li><strong>通信约束</strong>：最小化节点间的通信量</li>
</ul>
<p><strong>挑战：</strong></p>
<ul>
<li>数据分散性</li>
<li>通信开销</li>
<li>同步问题</li>
<li>节点故障</li>
</ul>
<p><strong>典型场景：</strong></p>
<ul>
<li>分布式网络监控</li>
<li>多数据中心的日志分析</li>
<li>边缘计算</li>
<li>CDN流量统计</li>
</ul>
<h3 id="二聚集查询">二、聚集查询<a hidden class="anchor" aria-hidden="true" href="#二聚集查询">#</a></h3>
<p><strong>问题定义：</strong>
计算分布在多个节点上的数据的聚集函数（如SUM、COUNT、AVG）。</p>
<p><strong>基本方法：</strong></p>
<p><strong>1. 连续聚集：</strong></p>
<ul>
<li>每个节点维护本地的统计信息</li>
<li>周期性发送给协调节点</li>
<li>协调节点汇总计算全局结果</li>
</ul>
<p><strong>2. 快照聚集：</strong></p>
<ul>
<li>在特定时刻获取全局快照</li>
<li>需要处理同步问题</li>
<li>使用逻辑时钟或物理时钟</li>
</ul>
<p><strong>优化技术：</strong></p>
<p><strong>采样与估计：</strong></p>
<ul>
<li>不发送所有数据，只发送样本</li>
<li>使用统计方法估计全局结果</li>
<li>权衡精度和通信开销</li>
</ul>
<p><strong>增量更新：</strong></p>
<ul>
<li>只发送变化部分</li>
<li>减少冗余通信</li>
<li>适用于变化缓慢的数据</li>
</ul>
<p><strong>数据结构支持：</strong></p>
<ul>
<li>使用Count-Min Sketch等概要结构</li>
<li>可以在协调节点合并</li>
<li>支持分布式查询</li>
</ul>
<h3 id="三topk监控">三、topk监控<a hidden class="anchor" aria-hidden="true" href="#三topk监控">#</a></h3>
<p><strong>问题定义：</strong>
实时监控分布式系统中全局的top-k元素（如最热门的k个商品、最活跃的k个用户）。</p>
<p><strong>挑战：</strong></p>
<ul>
<li>全局top-k可能不在任何单个节点的局部top-k中</li>
<li>需要在精度和通信量之间平衡</li>
<li>数据分布可能高度倾斜</li>
</ul>
<p><strong>解决方案：</strong></p>
<p><strong>1. 阈值算法：</strong></p>
<ul>
<li>协调节点维护全局top-k的阈值θ</li>
<li>每个节点报告超过θ的元素</li>
<li>动态调整θ以平衡通信量</li>
</ul>
<p><strong>算法流程：</strong></p>
<pre tabindex="0"><code>初始化：θ = 0
循环：
  1. 每个节点报告频率 &gt; θ 的元素
  2. 协调节点更新全局top-k
  3. 计算新阈值θ（如第k大元素的频率）
  4. 将θ广播给各节点
</code></pre><p><strong>2. 采样方法：</strong></p>
<ul>
<li>各节点以概率p采样元素</li>
<li>上传采样的数据到协调节点</li>
<li>基于采样数据估计全局top-k</li>
</ul>
<p><strong>3. 层次化监控：</strong></p>
<ul>
<li>构建监控树</li>
<li>中间节点聚合子节点的信息</li>
<li>减少单点通信压力</li>
</ul>
<p><strong>性能优化：</strong></p>
<ul>
<li><strong>局部过滤</strong>：只上传可能进入全局top-k的元素</li>
<li><strong>批量通信</strong>：积累一定数量的更新后批量发送</li>
<li><strong>缓存机制</strong>：利用时间局部性减少通信</li>
</ul>
<p><strong>实际应用：</strong></p>
<ul>
<li>实时热搜榜</li>
<li>分布式缓存的热点识别</li>
<li>网络安全中的异常检测</li>
<li>广告系统的CTR监控</li>
</ul>
<hr>
<h2 id="第五讲-哈希">第五讲 哈希<a hidden class="anchor" aria-hidden="true" href="#第五讲-哈希">#</a></h2>
<h3 id="一哈希函数和哈希表">一、哈希函数和哈希表<a hidden class="anchor" aria-hidden="true" href="#一哈希函数和哈希表">#</a></h3>
<p>哈希技术是一种通过哈希函数将数据映射到固定大小的表中的方法，实现快速的数据存储和检索。</p>
<p><strong>核心概念：</strong></p>
<ul>
<li><strong>哈希函数</strong>：将任意大小的数据映射到固定大小的值</li>
<li><strong>哈希表</strong>：基于数组实现的数据结构，通过哈希函数计算索引位置</li>
<li><strong>冲突处理</strong>：当不同的键映射到相同位置时的解决策略
<ul>
<li>链地址法（Chaining）</li>
<li>开放地址法（Open Addressing）</li>
</ul>
</li>
</ul>
<p><strong>时间复杂度：</strong></p>
<ul>
<li>平均情况：O(1) 查找、插入、删除</li>
<li>最坏情况：O(n)（当所有元素都冲突时）</li>
</ul>
<h3 id="二布隆过滤器bloom-filter">二、布隆过滤器（Bloom Filter）<a hidden class="anchor" aria-hidden="true" href="#二布隆过滤器bloom-filter">#</a></h3>
<p>布隆过滤器是一种空间高效的概率型数据结构，用于判断一个元素是否在集合中。</p>
<p><strong>特点：</strong></p>
<ul>
<li>可能产生假阳性（False Positive）：说存在但实际不存在</li>
<li>不会产生假阴性（False Negative）：说不存在就一定不存在</li>
<li>不支持删除操作（标准版本）</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>网页URL去重</li>
<li>垃圾邮件过滤</li>
<li>缓存穿透防护</li>
<li>大数据去重</li>
</ul>
<p><strong>工作原理：</strong></p>
<ol>
<li>使用k个不同的哈希函数</li>
<li>将元素映射到位数组的k个位置</li>
<li>查询时检查这k个位置是否都为1</li>
</ol>
<h3 id="三最小哈希和lshlocality-sensitive-hashing">三、最小哈希和LSH（Locality-Sensitive Hashing）<a hidden class="anchor" aria-hidden="true" href="#三最小哈希和lshlocality-sensitive-hashing">#</a></h3>
<p><strong>最小哈希（MinHash）：</strong>
用于估计两个集合的Jaccard相似度，常用于文档去重和相似度检测。</p>
<p><strong>局部敏感哈希（LSH）：</strong>
一种降维技术，使得相似的数据项以高概率被映射到相同的桶中。</p>
<p><strong>应用：</strong></p>
<ul>
<li>近似最近邻搜索</li>
<li>图像相似度检测</li>
<li>文本去重</li>
<li>推荐系统</li>
</ul>
<hr>
<h2 id="第六讲-线性规划与整数规划">第六讲 线性规划与整数规划<a hidden class="anchor" aria-hidden="true" href="#第六讲-线性规划与整数规划">#</a></h2>
<h3 id="一线性规划单纯形算法">一、线性规划：单纯形算法<a hidden class="anchor" aria-hidden="true" href="#一线性规划单纯形算法">#</a></h3>
<p><strong>线性规划问题标准形式：</strong></p>
<pre tabindex="0"><code>最大化/最小化：c^T x
约束条件：Ax ≤ b, x ≥ 0
</code></pre><p><strong>单纯形算法（Simplex Method）：</strong></p>
<ul>
<li>由George Dantzig于1947年提出</li>
<li>从可行域的一个顶点出发</li>
<li>沿着目标函数值改进的方向移动到相邻顶点</li>
<li>直到找到最优解或判定无界</li>
</ul>
<p><strong>算法步骤：</strong></p>
<ol>
<li>将问题转换为标准形式</li>
<li>找到初始基本可行解</li>
<li>检验数判断是否达到最优</li>
<li>若未达到最优，选择入基变量和出基变量</li>
<li>进行基变换，更新解</li>
<li>重复步骤3-5直到最优</li>
</ol>
<h3 id="二整数规划问题定义">二、整数规划：问题定义<a hidden class="anchor" aria-hidden="true" href="#二整数规划问题定义">#</a></h3>
<p>整数规划是线性规划的扩展，要求部分或全部变量取整数值。</p>
<p><strong>分类：</strong></p>
<ul>
<li><strong>纯整数规划</strong>：所有变量都必须是整数</li>
<li><strong>混合整数规划（MIP）</strong>：部分变量是整数，部分是连续变量</li>
<li><strong>0-1整数规划</strong>：变量只能取0或1</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>资源分配</li>
<li>生产计划</li>
<li>网络设计</li>
<li>任务调度</li>
</ul>
<h3 id="三整数规划分支界定法branch-and-bound">三、整数规划：分支界定法（Branch and Bound）<a hidden class="anchor" aria-hidden="true" href="#三整数规划分支界定法branch-and-bound">#</a></h3>
<p><strong>基本思想：</strong>
将原问题分解为若干子问题，通过界定（bounding）技术减少搜索空间。</p>
<p><strong>算法流程：</strong></p>
<ol>
<li><strong>松弛</strong>：求解去掉整数约束的线性规划松弛问题</li>
<li><strong>界定</strong>：用松弛问题的最优值作为上界（最大化问题）</li>
<li><strong>分支</strong>：选择一个非整数变量进行分支</li>
<li><strong>剪枝</strong>：
<ul>
<li>当前节点的界不如已知最优解时剪枝</li>
<li>松弛问题无可行解时剪枝</li>
<li>松弛问题的解满足整数约束时更新最优解</li>
</ul>
</li>
</ol>
<h3 id="四整数规划切平面法cutting-plane-method">四、整数规划：切平面法（Cutting Plane Method）<a hidden class="anchor" aria-hidden="true" href="#四整数规划切平面法cutting-plane-method">#</a></h3>
<p><strong>核心思想：</strong>
通过添加线性约束（切平面）逐步逼近整数规划的可行域，直到得到整数最优解。</p>
<p><strong>Gomory割平面：</strong></p>
<ul>
<li>从单纯形表中推导出的割平面</li>
<li>切掉当前非整数最优解</li>
<li>不切掉任何整数可行解</li>
</ul>
<p><strong>算法步骤：</strong></p>
<ol>
<li>求解线性规划松弛问题</li>
<li>若解为整数，则为最优解，算法结束</li>
<li>若解不为整数，生成割平面约束</li>
<li>将割平面加入原问题</li>
<li>重新求解并重复步骤2-4</li>
</ol>
<hr>
<h2 id="第七讲-内存计算">第七讲 内存计算<a hidden class="anchor" aria-hidden="true" href="#第七讲-内存计算">#</a></h2>
<h3 id="一海量内存概述">一、海量内存概述<a hidden class="anchor" aria-hidden="true" href="#一海量内存概述">#</a></h3>
<p>随着硬件技术的发展，单机内存容量已经可以达到TB级别，这为大数据处理带来了新的机遇。</p>
<p><strong>内存计算的优势：</strong></p>
<ul>
<li><strong>速度快</strong>：内存访问速度比磁盘快3-5个数量级</li>
<li><strong>延迟低</strong>：避免了磁盘I/O的延迟</li>
<li><strong>适合迭代计算</strong>：机器学习、图计算等需要多次迭代的场景</li>
</ul>
<p><strong>挑战：</strong></p>
<ul>
<li>成本较高</li>
<li>数据持久化问题</li>
<li>容错机制</li>
</ul>
<h3 id="二基于单机版内存增大优势">二、基于单机版内存增大优势<a hidden class="anchor" aria-hidden="true" href="#二基于单机版内存增大优势">#</a></h3>
<p><strong>单机大内存的应用场景：</strong></p>
<ul>
<li>内存数据库（如Redis, Memcached）</li>
<li>实时数据分析</li>
<li>高性能缓存系统</li>
<li>图数据处理</li>
</ul>
<p><strong>技术特点：</strong></p>
<ul>
<li>简化系统架构，减少网络通信开销</li>
<li>提高数据处理的吞吐量</li>
<li>适合中等规模的数据集</li>
</ul>
<p><strong>优化策略：</strong></p>
<ul>
<li>数据结构优化（压缩、列式存储）</li>
<li>NUMA-aware内存分配</li>
<li>大页内存（Huge Pages）的使用</li>
</ul>
<h3 id="三基于共享式内存和分布式内存结合架构优势">三、基于共享式内存和分布式内存结合架构优势<a hidden class="anchor" aria-hidden="true" href="#三基于共享式内存和分布式内存结合架构优势">#</a></h3>
<p><strong>混合架构设计：</strong></p>
<p><strong>共享式内存（Shared Memory）：</strong></p>
<ul>
<li>多个处理器共享同一物理内存空间</li>
<li>通信开销低</li>
<li>编程相对简单</li>
<li>可扩展性受限</li>
</ul>
<p><strong>分布式内存（Distributed Memory）：</strong></p>
<ul>
<li>每个节点有独立的内存空间</li>
<li>通过网络进行通信</li>
<li>可扩展性强</li>
<li>编程复杂度较高</li>
</ul>
<p><strong>结合架构的优势：</strong></p>
<ol>
<li><strong>弹性扩展</strong>：根据数据规模动态调整资源</li>
<li><strong>负载均衡</strong>：合理分配计算任务</li>
<li><strong>容错能力</strong>：数据副本和快照机制</li>
<li><strong>性能优化</strong>：本地内存访问 + 跨节点通信</li>
</ol>
<p><strong>典型系统：</strong></p>
<ul>
<li>Apache Spark（基于RDD的内存计算框架）</li>
<li>Apache Flink（流式和批处理统一计算）</li>
<li>Alluxio（分布式内存文件系统）</li>
</ul>
<h3 id="四总结">四、总结<a hidden class="anchor" aria-hidden="true" href="#四总结">#</a></h3>
<p>内存计算已成为大数据处理的重要技术方向：</p>
<ul>
<li>针对不同场景选择合适的架构</li>
<li>平衡性能、成本和可扩展性</li>
<li>结合持久化存储保证数据安全</li>
<li>关注新硬件技术（如持久化内存）的发展</li>
</ul>
<hr>
<h2 id="第八讲-社区发现">第八讲 社区发现<a hidden class="anchor" aria-hidden="true" href="#第八讲-社区发现">#</a></h2>
<p>社区发现是复杂网络分析中的重要问题，目标是找出网络中紧密连接的节点群组。</p>
<h3 id="一图切割graph-partitioning">一、图切割（Graph Partitioning）<a hidden class="anchor" aria-hidden="true" href="#一图切割graph-partitioning">#</a></h3>
<p><strong>目标：</strong>
将图分割成若干个子图，使得子图内部边多，子图之间边少。</p>
<p><strong>经典方法：</strong></p>
<ul>
<li><strong>最小割（Min-Cut）</strong>：最小化切割边的数量</li>
<li><strong>比率割（Ratio Cut）</strong>：考虑社区大小的平衡</li>
<li><strong>归一化割（Normalized Cut）</strong>：考虑节点度数的归一化</li>
</ul>
<p><strong>应用：</strong></p>
<ul>
<li>社交网络分析</li>
<li>生物网络聚类</li>
<li>图像分割</li>
</ul>
<h3 id="二边介数edge-betweenness">二、边介数（Edge Betweenness）<a hidden class="anchor" aria-hidden="true" href="#二边介数edge-betweenness">#</a></h3>
<p><strong>定义：</strong>
边介数是指网络中所有最短路径中经过该边的路径数量。</p>
<p><strong>GN算法（Girvan-Newman）：</strong></p>
<ol>
<li>计算网络中所有边的介数</li>
<li>移除介数最高的边</li>
<li>重新计算边介数</li>
<li>重复步骤2-3，直到达到期望的社区数量</li>
</ol>
<p><strong>特点：</strong></p>
<ul>
<li>能够发现层次化的社区结构</li>
<li>计算复杂度较高：O(m²n)</li>
<li>适用于小规模网络</li>
</ul>
<h3 id="三模块度modularity">三、模块度（Modularity）<a hidden class="anchor" aria-hidden="true" href="#三模块度modularity">#</a></h3>
<p><strong>定义：</strong>
模块度Q用于衡量网络社区划分的质量。</p>
<p><strong>公式：</strong></p>
<pre tabindex="0"><code>Q = (1/2m) Σ[Aᵢⱼ - (kᵢkⱼ/2m)]δ(cᵢ,cⱼ)
</code></pre><p>其中：</p>
<ul>
<li>m：边的总数</li>
<li>Aᵢⱼ：邻接矩阵</li>
<li>kᵢ：节点i的度</li>
<li>δ(cᵢ,cⱼ)：节点i和j是否在同一社区</li>
</ul>
<p><strong>特性：</strong></p>
<ul>
<li>Q值范围：[-0.5, 1]</li>
<li>Q &gt; 0.3通常表示有明显的社区结构</li>
<li>模块度最大化是NP困难问题</li>
</ul>
<h3 id="四louvain方法">四、Louvain方法<a hidden class="anchor" aria-hidden="true" href="#四louvain方法">#</a></h3>
<p>Louvain算法是一种基于模块度优化的快速社区发现算法。</p>
<p><strong>算法步骤：</strong></p>
<p><strong>第一阶段（模块度优化）：</strong></p>
<ol>
<li>初始化：每个节点为一个独立社区</li>
<li>遍历每个节点：
<ul>
<li>尝试将该节点移动到邻居节点所在的社区</li>
<li>计算模块度增益ΔQ</li>
<li>选择使ΔQ最大且为正的移动</li>
</ul>
</li>
<li>重复步骤2直到模块度不再增加</li>
</ol>
<p><strong>第二阶段（网络聚合）：</strong></p>
<ol>
<li>将同一社区的所有节点合并成一个超级节点</li>
<li>社区间的边权重等于原节点间边权重之和</li>
<li>对新网络重复第一阶段</li>
</ol>
<p><strong>重复两个阶段直到模块度不再显著增加。</strong></p>
<p><strong>优势：</strong></p>
<ul>
<li>时间复杂度：O(n log n)</li>
<li>能处理大规模网络（百万级节点）</li>
<li>能发现层次化社区结构</li>
<li>实现简单，效果好</li>
</ul>
<p><strong>应用案例：</strong></p>
<ul>
<li>社交网络社区检测</li>
<li>生物网络模块识别</li>
<li>知识图谱聚类</li>
</ul>
<hr>
<h2 id="第九讲-子模函数及其应用">第九讲 子模函数及其应用<a hidden class="anchor" aria-hidden="true" href="#第九讲-子模函数及其应用">#</a></h2>
<h3 id="一应用背景">一、应用背景<a hidden class="anchor" aria-hidden="true" href="#一应用背景">#</a></h3>
<p>子模函数在组合优化中有广泛应用，许多实际问题都具有子模性质。</p>
<p><strong>典型应用场景：</strong></p>
<ul>
<li>信息传播最大化</li>
<li>传感器布置优化</li>
<li>文档摘要</li>
<li>特征选择</li>
<li>图像分割</li>
</ul>
<h3 id="二子模函数submodular-function">二、子模函数（Submodular Function）<a hidden class="anchor" aria-hidden="true" href="#二子模函数submodular-function">#</a></h3>
<p><strong>定义：</strong>
集合函数f: 2^V → ℝ 是子模的，如果对于任意A ⊆ B ⊆ V 和 x ∉ B，有：</p>
<pre tabindex="0"><code>f(A ∪ {x}) - f(A) ≥ f(B ∪ {x}) - f(B)
</code></pre><p><strong>直观理解：</strong>
边际收益递减（Diminishing Returns）：向小集合添加元素的收益不小于向大集合添加相同元素的收益。</p>
<p><strong>常见子模函数：</strong></p>
<ol>
<li><strong>覆盖函数</strong>：f(S) = |∪ₛ∈S Cₛ|</li>
<li><strong>截断函数</strong>：f(S) = min(|S|, k)</li>
<li><strong>图割函数</strong></li>
<li><strong>熵函数</strong></li>
</ol>
<p><strong>性质：</strong></p>
<ul>
<li>子模函数的非负线性组合仍是子模的</li>
<li>子模函数的最小化可以在多项式时间内精确求解</li>
<li>子模函数的最大化是NP困难的，但存在近似算法</li>
</ul>
<h3 id="三集合覆盖问题set-cover-problem">三、集合覆盖问题（Set Cover Problem）<a hidden class="anchor" aria-hidden="true" href="#三集合覆盖问题set-cover-problem">#</a></h3>
<p><strong>问题定义：</strong>
给定全集U和若干子集S₁, S₂, &hellip;, Sₙ ⊆ U，找到最少数量的子集使其并集等于U。</p>
<p><strong>形式化：</strong></p>
<pre tabindex="0"><code>最小化：|S|
约束条件：∪ₛ∈S s = U
</code></pre><p><strong>复杂性：</strong></p>
<ul>
<li>NP困难问题</li>
<li>不存在常数因子近似算法（除非P=NP）</li>
</ul>
<p><strong>贪心算法：</strong></p>
<ol>
<li>初始化：S = ∅, R = U（未覆盖元素）</li>
<li>循环直到R = ∅：
<ul>
<li>选择覆盖R中最多元素的集合s</li>
<li>S = S ∪ {s}</li>
<li>R = R \ s</li>
</ul>
</li>
<li>返回S</li>
</ol>
<p><strong>性能保证：</strong></p>
<ul>
<li>贪心算法的近似比：O(ln n)</li>
<li>这是可达到的最好近似比（在P≠NP假设下）</li>
</ul>
<p><strong>子模性与贪心算法：</strong>
集合覆盖函数f(S) = |∪ₛ∈S s|是子模的，对于单调子模函数最大化：</p>
<ul>
<li>贪心算法保证(1 - 1/e)近似比</li>
<li>这个界是紧的</li>
</ul>
<p><strong>实际应用：</strong></p>
<ul>
<li><strong>设施选址</strong>：用最少的设施覆盖所有需求点</li>
<li><strong>无线网络覆盖</strong>：最小化基站数量</li>
<li><strong>测试用例选择</strong>：用最少的测试覆盖所有代码路径</li>
<li><strong>特征选择</strong>：选择最少的特征保持分类性能</li>
</ul>
<p><strong>高级话题：</strong></p>
<ul>
<li>加权集合覆盖</li>
<li>多目标集合覆盖</li>
<li>在线集合覆盖</li>
<li>分布式集合覆盖算法</li>
</ul>
<hr>
<h2 id="课程总结">课程总结<a hidden class="anchor" aria-hidden="true" href="#课程总结">#</a></h2>
<p>本课程系统地介绍了数学基础算法的核心内容，涵盖了从理论到实践的多个重要主题：</p>
<p><strong>基础理论部分（第1-2讲）：</strong></p>
<ul>
<li><strong>算法分析</strong>为评估算法效率提供了数学工具，相似度搜索和高维空间技术是现代大数据应用的基础</li>
<li><strong>尾不等式</strong>提供了随机算法性能的概率保证，是设计和分析概率算法的重要理论基础</li>
</ul>
<p><strong>数据流处理（第3-4讲）：</strong></p>
<ul>
<li><strong>数据流算法</strong>解决了在有限空间内处理海量数据的问题，频繁元素检测和滑动窗口模型在实时系统中应用广泛</li>
<li><strong>分布式数据流</strong>扩展到多节点场景，聚集查询和top-k监控为大规模分布式系统提供了实用解决方案</li>
</ul>
<p><strong>核心算法技术（第5-7讲）：</strong></p>
<ul>
<li><strong>哈希技术</strong>为大规模数据的快速检索和去重提供了基础工具，布隆过滤器和LSH在实际应用中具有重要价值</li>
<li><strong>线性规划与整数规划</strong>是运筹优化的核心方法，单纯形算法、分支界定法和切平面法为求解复杂优化问题提供了理论基础</li>
<li><strong>内存计算</strong>代表了大数据处理的技术趋势，通过合理利用单机大内存和分布式架构可以显著提升计算性能</li>
</ul>
<p><strong>图算法与优化（第8-9讲）：</strong></p>
<ul>
<li><strong>社区发现</strong>算法帮助我们理解复杂网络的结构特征，Louvain方法在实践中表现出色</li>
<li><strong>子模优化</strong>为许多实际问题提供了理论保证的近似算法，贪心策略在子模函数优化中具有良好的性能保证</li>
</ul>
<p><strong>核心思想总结：</strong></p>
<ol>
<li><strong>近似与权衡</strong>：在精确性和效率之间寻找平衡</li>
<li><strong>概率与随机化</strong>：利用随机化技术突破确定性算法的局限</li>
<li><strong>分布式思维</strong>：将算法扩展到大规模分布式环境</li>
<li><strong>理论保证</strong>：为实际算法提供可证明的性能边界</li>
</ol>
<p>这些算法和技术在实际应用中经常需要结合使用，深入理解其数学基础对于解决复杂的工程问题至关重要。掌握这些方法不仅能提升算法设计能力，更能在面对实际问题时选择合适的解决方案，在效率、精度和资源消耗之间做出明智的权衡。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
      <li><a href="http://localhost:1313/tags/%E5%93%88%E5%B8%8C/">哈希</a></li>
      <li><a href="http://localhost:1313/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">算法分析</a></li>
      <li><a href="http://localhost:1313/tags/%E5%B0%BE%E4%B8%8D%E7%AD%89%E5%BC%8F/">尾不等式</a></li>
      <li><a href="http://localhost:1313/tags/%E6%95%B0%E6%8D%AE%E6%B5%81/">数据流</a></li>
    </ul>
  </footer><div id="tw-comment"></div>
<script>
    
    const getStoredTheme = () => localStorage.getItem("pref-theme") === "light" ? "nord_light" : "dark_dimmed";
    const setGiscusTheme = () => {
        const sendMessage = (message) => {
            const iframe = document.querySelector('iframe.giscus-frame');
            if (iframe) {
                iframe.contentWindow.postMessage({giscus: message}, 'https://giscus.app');
            }
        }
        sendMessage({setConfig: {theme: getStoredTheme()}})
    }

    document.addEventListener("DOMContentLoaded", () => {
        const giscusAttributes = {
            "src": "https://giscus.app/client.js",
            "data-repo": "minjieblog\/minjieblog.github.io",
            "data-repo-id": "R_kgDOQjMm6A",
            "data-category": "Announcements",
            "data-category-id": "DIC_kwDOQjMm6M4Czb4B",
            "data-mapping": "pathname",
            "data-strict": "0",
            "data-reactions-enabled": "1",
            "data-emit-metadata": "0",
            "data-input-position": "bottom",
            "data-theme": getStoredTheme(),
            "data-lang": "zh-CN",
            "data-loading": "lazy",
            "crossorigin": "anonymous",
        };

        
        const giscusScript = document.createElement("script");
        Object.entries(giscusAttributes).forEach(
                ([key, value]) => giscusScript.setAttribute(key, value));
        document.querySelector("#tw-comment").appendChild(giscusScript);

        
        const themeSwitcher = document.querySelector("#theme-toggle");
        if (themeSwitcher) {
            themeSwitcher.addEventListener("click", setGiscusTheme);
        }
        const themeFloatSwitcher = document.querySelector("#theme-toggle-float");
        if (themeFloatSwitcher) {
            themeFloatSwitcher.addEventListener("click", setGiscusTheme);
        }
    });
</script>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://minjieblog.github.io/">©2025 Minjie&rsquo;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
