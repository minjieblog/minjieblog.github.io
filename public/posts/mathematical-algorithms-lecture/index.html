<!DOCTYPE html>
<html lang="zh" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>数学基础算法篇 | Minjie&#39;s Blog</title>
<meta name="keywords" content="算法, 哈希, 算法分析, 尾不等式, 数据流">
<meta name="description" content="金老师主讲的研究生课程《数学基础算法篇》完整笔记，从算法分析基础开始，系统介绍相似度搜索、概率不等式、流式数据处理、分布式计算、哈希技术、优化算法、图算法等内容，理论与实践相结合，为解决大规模数据处理问题提供数学和算法基础。
">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/mathematical-algorithms-lecture/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/code.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/code.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/code.png">
<link rel="apple-touch-icon" href="http://localhost:1313/code.png">
<link rel="mask-icon" href="http://localhost:1313/code.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/mathematical-algorithms-lecture/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Minjie&#39;s Blog (Alt + H)">Minjie&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Minjie&#39;s Blog">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="关于我">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      数学基础算法篇
    </h1>
    <div class="post-description">
      金老师主讲的研究生课程《数学基础算法篇》完整笔记，从算法分析基础开始，系统介绍相似度搜索、概率不等式、流式数据处理、分布式计算、哈希技术、优化算法、图算法等内容，理论与实践相结合，为解决大规模数据处理问题提供数学和算法基础。

    </div>
    <div class="post-meta"><span title='2025-12-21 15:50:54 +0800 CST'>2025年12月21日</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e7%ac%ac%e4%b8%80%e8%ae%b2-%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90" aria-label="第一讲 算法分析">第一讲 算法分析</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e7%ae%97%e6%b3%95%e7%ae%80%e4%bb%8b" aria-label="一、算法简介">一、算法简介</a></li>
                <li>
                    <a href="#%e4%ba%8c%e7%9b%b8%e4%bc%bc%e5%ba%a6%e6%90%9c%e7%b4%a2" aria-label="二、相似度搜索">二、相似度搜索</a></li>
                <li>
                    <a href="#%e4%b8%89%e9%ab%98%e7%bb%b4%e7%a9%ba%e9%97%b4%e7%9a%84%e7%9b%b8%e4%bc%bc%e6%80%a7%e6%90%9c%e7%b4%a2" aria-label="三、高维空间的相似性搜索">三、高维空间的相似性搜索</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e4%ba%8c%e8%ae%b2-%e5%b0%be%e4%b8%8d%e7%ad%89%e5%bc%8f" aria-label="第二讲 尾不等式">第二讲 尾不等式</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e5%b0%be%e4%b8%8d%e7%ad%89%e5%bc%8f%e5%88%86%e6%9e%90%e6%a6%82%e8%a6%81" aria-label="一、尾不等式分析概要">一、尾不等式分析概要</a></li>
                <li>
                    <a href="#%e4%ba%8c%e4%b8%89%e4%b8%aa%e5%b8%b8%e8%a7%81%e7%9a%84%e5%b0%be%e4%b8%8d%e7%ad%89%e5%bc%8f" aria-label="二、三个常见的尾不等式">二、三个常见的尾不等式</a></li>
                <li>
                    <a href="#%e4%b8%89%e8%ae%a1%e6%95%b0%e9%97%ae%e9%a2%98" aria-label="三、计数问题">三、计数问题</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e4%b8%89%e8%ae%b2-%e6%95%b0%e6%8d%ae%e6%b5%81" aria-label="第三讲 数据流">第三讲 数据流</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e6%95%b0%e6%8d%ae%e6%b5%81%e6%a8%a1%e5%9e%8b" aria-label="一、数据流模型">一、数据流模型</a></li>
                <li>
                    <a href="#%e4%ba%8c%e9%a2%91%e7%b9%81%e5%85%83%e7%b4%a0-%e7%a1%ae%e5%ae%9a%e6%80%a7%e7%ae%97%e6%b3%95" aria-label="二、频繁元素-确定性算法">二、频繁元素-确定性算法</a></li>
                <li>
                    <a href="#%e4%b8%89%e9%a2%91%e7%b9%81%e5%85%83%e7%b4%a0-%e9%9a%8f%e6%9c%ba%e7%ae%97%e6%b3%95" aria-label="三、频繁元素-随机算法">三、频繁元素-随机算法</a></li>
                <li>
                    <a href="#%e5%9b%9b%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e6%a8%a1%e5%9e%8b" aria-label="四、滑动窗口模型">四、滑动窗口模型</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e5%9b%9b%e8%ae%b2-%e5%88%86%e5%b8%83%e5%bc%8f%e6%95%b0%e6%8d%ae%e6%b5%81" aria-label="第四讲 分布式数据流">第四讲 分布式数据流</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e5%88%86%e5%b8%83%e5%bc%8f%e6%95%b0%e6%8d%ae%e6%b5%81%e6%a8%a1%e5%9e%8b" aria-label="一、分布式数据流模型">一、分布式数据流模型</a></li>
                <li>
                    <a href="#%e4%ba%8c%e8%81%9a%e9%9b%86%e6%9f%a5%e8%af%a2" aria-label="二、聚集查询">二、聚集查询</a></li>
                <li>
                    <a href="#%e4%b8%89topk%e7%9b%91%e6%8e%a7" aria-label="三、topk监控">三、topk监控</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e4%ba%94%e8%ae%b2-%e5%93%88%e5%b8%8c" aria-label="第五讲 哈希">第五讲 哈希</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0%e5%92%8c%e5%93%88%e5%b8%8c%e8%a1%a8" aria-label="一、哈希函数和哈希表">一、哈希函数和哈希表</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8bloom-filter" aria-label="二、布隆过滤器（Bloom Filter）">二、布隆过滤器（Bloom Filter）</a></li>
                <li>
                    <a href="#%e4%b8%89%e6%9c%80%e5%b0%8f%e5%93%88%e5%b8%8c%e5%92%8clshlocality-sensitive-hashing" aria-label="三、最小哈希和LSH（Locality-Sensitive Hashing）">三、最小哈希和LSH（Locality-Sensitive Hashing）</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e5%85%ad%e8%ae%b2-%e7%ba%bf%e6%80%a7%e8%a7%84%e5%88%92%e4%b8%8e%e6%95%b4%e6%95%b0%e8%a7%84%e5%88%92" aria-label="第六讲 线性规划与整数规划">第六讲 线性规划与整数规划</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e7%ba%bf%e6%80%a7%e8%a7%84%e5%88%92%e5%8d%95%e7%ba%af%e5%bd%a2%e7%ae%97%e6%b3%95" aria-label="一、线性规划：单纯形算法">一、线性规划：单纯形算法</a></li>
                <li>
                    <a href="#%e4%ba%8c%e6%95%b4%e6%95%b0%e8%a7%84%e5%88%92%e9%97%ae%e9%a2%98%e5%ae%9a%e4%b9%89" aria-label="二、整数规划：问题定义">二、整数规划：问题定义</a></li>
                <li>
                    <a href="#%e4%b8%89%e6%95%b4%e6%95%b0%e8%a7%84%e5%88%92%e5%88%86%e6%94%af%e7%95%8c%e5%ae%9a%e6%b3%95branch-and-bound" aria-label="三、整数规划：分支界定法（Branch and Bound）">三、整数规划：分支界定法（Branch and Bound）</a></li>
                <li>
                    <a href="#%e5%9b%9b%e6%95%b4%e6%95%b0%e8%a7%84%e5%88%92%e5%88%87%e5%b9%b3%e9%9d%a2%e6%b3%95cutting-plane-method" aria-label="四、整数规划：切平面法（Cutting Plane Method）">四、整数规划：切平面法（Cutting Plane Method）</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e4%b8%83%e8%ae%b2-%e5%86%85%e5%ad%98%e8%ae%a1%e7%ae%97" aria-label="第七讲 内存计算">第七讲 内存计算</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e6%b5%b7%e9%87%8f%e5%86%85%e5%ad%98%e6%a6%82%e8%bf%b0" aria-label="一、海量内存概述">一、海量内存概述</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%9f%ba%e4%ba%8e%e5%8d%95%e6%9c%ba%e7%89%88%e5%86%85%e5%ad%98%e5%a2%9e%e5%a4%a7%e4%bc%98%e5%8a%bf" aria-label="二、基于单机版内存增大优势">二、基于单机版内存增大优势</a></li>
                <li>
                    <a href="#%e4%b8%89%e5%9f%ba%e4%ba%8e%e5%85%b1%e4%ba%ab%e5%bc%8f%e5%86%85%e5%ad%98%e5%92%8c%e5%88%86%e5%b8%83%e5%bc%8f%e5%86%85%e5%ad%98%e7%bb%93%e5%90%88%e6%9e%b6%e6%9e%84%e4%bc%98%e5%8a%bf" aria-label="三、基于共享式内存和分布式内存结合架构优势">三、基于共享式内存和分布式内存结合架构优势</a></li>
                <li>
                    <a href="#%e5%9b%9b%e6%80%bb%e7%bb%93" aria-label="四、总结">四、总结</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e5%85%ab%e8%ae%b2-%e7%a4%be%e5%8c%ba%e5%8f%91%e7%8e%b0" aria-label="第八讲 社区发现">第八讲 社区发现</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e5%9b%be%e5%88%87%e5%89%b2graph-partitioning" aria-label="一、图切割（Graph Partitioning）">一、图切割（Graph Partitioning）</a><ul>
                        
                <li>
                    <a href="#1-%e7%a4%be%e5%8c%ba%e5%88%92%e5%88%86%e9%97%ae%e9%a2%98" aria-label="1. 社区划分问题">1. 社区划分问题</a></li>
                <li>
                    <a href="#2-%e8%af%84%e5%88%a4%e5%87%86%e5%88%99" aria-label="2. 评判准则">2. 评判准则</a></li>
                <li>
                    <a href="#3-%e5%89%b2cut%e7%9a%84%e5%ae%9a%e4%b9%89" aria-label="3. 割（Cut）的定义">3. 割（Cut）的定义</a></li>
                <li>
                    <a href="#4-%e6%9c%80%e5%b0%8f%e5%89%b2-minimum-cut" aria-label="4. 最小割 (Minimum-cut)">4. 最小割 (Minimum-cut)</a></li>
                <li>
                    <a href="#5-%e5%bd%92%e4%b8%80%e5%8c%96%e5%88%87%e5%89%b2-normalized-cut" aria-label="5. 归一化切割 (Normalized-cut)">5. 归一化切割 (Normalized-cut)</a></li>
                <li>
                    <a href="#6-%e7%bb%83%e4%b9%a0%e9%a2%98%e8%af%a6%e8%a7%a3" aria-label="6. 练习题详解">6. 练习题详解</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%8c%e8%be%b9%e4%bb%8b%e6%95%b0edge-betweenness" aria-label="二、边介数（Edge Betweenness）">二、边介数（Edge Betweenness）</a><ul>
                        
                <li>
                    <a href="#1-%e8%be%b9%e4%bb%8b%e6%95%b0%e7%9a%84%e5%ae%9a%e4%b9%89" aria-label="1. 边介数的定义">1. 边介数的定义</a></li>
                <li>
                    <a href="#2-girvan-newman%e6%96%b9%e6%b3%95%e7%ae%80%e7%a7%b0gn%e6%96%b9%e6%b3%95" aria-label="2. Girvan-Newman方法（简称GN方法）">2. Girvan-Newman方法（简称GN方法）</a></li>
                <li>
                    <a href="#3-gn%e6%96%b9%e6%b3%95%e6%a1%88%e4%be%8b%e5%88%86%e6%9e%90" aria-label="3. GN方法案例分析">3. GN方法案例分析</a></li>
                <li>
                    <a href="#4-%e5%a6%82%e4%bd%95%e8%ae%a1%e7%ae%97%e8%be%b9%e4%bb%8b%e6%95%b0" aria-label="4. 如何计算边介数">4. 如何计算边介数</a></li>
                <li>
                    <a href="#5-%e7%bb%83%e4%b9%a0%e9%a2%98" aria-label="5. 练习题">5. 练习题</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%89%e6%a8%a1%e5%9d%97%e5%ba%a6modularity" aria-label="三、模块度（Modularity）">三、模块度（Modularity）</a></li>
                <li>
                    <a href="#%e5%9b%9blouvain%e6%96%b9%e6%b3%95" aria-label="四、Louvain方法">四、Louvain方法</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e4%b9%9d%e8%ae%b2-%e5%ad%90%e6%a8%a1%e5%87%bd%e6%95%b0%e5%8f%8a%e5%85%b6%e5%ba%94%e7%94%a8" aria-label="第九讲 子模函数及其应用">第九讲 子模函数及其应用</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e5%ba%94%e7%94%a8%e8%83%8c%e6%99%af" aria-label="一、应用背景">一、应用背景</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%ad%90%e6%a8%a1%e5%87%bd%e6%95%b0submodular-function" aria-label="二、子模函数（Submodular Function）">二、子模函数（Submodular Function）</a></li>
                <li>
                    <a href="#%e4%b8%89%e9%9b%86%e5%90%88%e8%a6%86%e7%9b%96%e9%97%ae%e9%a2%98set-cover-problem" aria-label="三、集合覆盖问题（Set Cover Problem）">三、集合覆盖问题（Set Cover Problem）</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%af%be%e7%a8%8b%e6%80%bb%e7%bb%93" aria-label="课程总结">课程总结</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="第一讲-算法分析">第一讲 算法分析<a hidden class="anchor" aria-hidden="true" href="#第一讲-算法分析">#</a></h2>
<h3 id="一算法简介">一、算法简介<a hidden class="anchor" aria-hidden="true" href="#一算法简介">#</a></h3>
<p>算法分析是计算机科学的基础，用于评估算法的效率和资源消耗。</p>
<p><strong>算法复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度</strong>：衡量算法执行时间随输入规模增长的趋势</li>
<li><strong>空间复杂度</strong>：衡量算法所需存储空间随输入规模增长的趋势</li>
<li><strong>渐近分析</strong>：O、Ω、Θ记号</li>
</ul>
<p><strong>常见复杂度类型：</strong></p>
<ul>
<li>O(1)：常数时间</li>
<li>O(log n)：对数时间</li>
<li>O(n)：线性时间</li>
<li>O(n log n)：线性对数时间</li>
<li>O(n²)：平方时间</li>
<li>O(2ⁿ)：指数时间</li>
</ul>
<p><strong>算法设计范式：</strong></p>
<ul>
<li>分治法（Divide and Conquer）</li>
<li>动态规划（Dynamic Programming）</li>
<li>贪心算法（Greedy Algorithm）</li>
<li>回溯法（Backtracking）</li>
<li>分支界定法（Branch and Bound）</li>
</ul>
<h3 id="二相似度搜索">二、相似度搜索<a hidden class="anchor" aria-hidden="true" href="#二相似度搜索">#</a></h3>
<p>相似度搜索是在大规模数据中找到与查询对象相似的数据项。</p>
<p><strong>相似度度量：</strong></p>
<ul>
<li><strong>欧氏距离（Euclidean Distance）</strong>：
<pre tabindex="0"><code>d(x, y) = √(Σ(xᵢ - yᵢ)²)
</code></pre></li>
<li><strong>曼哈顿距离（Manhattan Distance）</strong>：
<pre tabindex="0"><code>d(x, y) = Σ|xᵢ - yᵢ|
</code></pre></li>
<li><strong>余弦相似度（Cosine Similarity）</strong>：
<pre tabindex="0"><code>sim(x, y) = (x·y) / (||x|| ||y||)
</code></pre></li>
<li><strong>Jaccard相似度</strong>：
<pre tabindex="0"><code>J(A, B) = |A ∩ B| / |A ∪ B|
</code></pre></li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>推荐系统</li>
<li>图像检索</li>
<li>文档相似度检测</li>
<li>近似最近邻搜索（ANN）</li>
</ul>
<p><strong>朴素方法的局限：</strong>
线性扫描的时间复杂度为O(n)，对于大规模数据集不可行。</p>
<h3 id="三高维空间的相似性搜索">三、高维空间的相似性搜索<a hidden class="anchor" aria-hidden="true" href="#三高维空间的相似性搜索">#</a></h3>
<p>在高维空间中，传统的索引结构（如KD树）性能退化严重，这被称为&quot;维度灾难&quot;。</p>
<p><strong>维度灾难（Curse of Dimensionality）：</strong></p>
<ul>
<li>数据点之间的距离趋于相等</li>
<li>数据点趋向于分布在空间的&quot;表面&quot;</li>
<li>索引结构的效率降低</li>
</ul>
<p><strong>解决方案：</strong></p>
<p><strong>1. 降维技术：</strong></p>
<ul>
<li>主成分分析（PCA）</li>
<li>随机投影</li>
<li>t-SNE</li>
</ul>
<p><strong>2. 近似算法：</strong></p>
<ul>
<li><strong>局部敏感哈希（LSH）</strong>：将相似的点以高概率映射到同一个桶</li>
<li><strong>乘积量化（Product Quantization）</strong>：将向量空间分解为子空间</li>
<li><strong>HNSW（Hierarchical Navigable Small World）</strong>：基于图的近似最近邻搜索</li>
</ul>
<p><strong>LSH的基本原理：</strong></p>
<ul>
<li>使用哈希函数族h，满足：相似的对象碰撞概率高，不相似的对象碰撞概率低</li>
<li>通过多个哈希函数和多个哈希表提高召回率</li>
<li>查询时只需检查哈希到同一桶的候选点</li>
</ul>
<hr>
<h2 id="第二讲-尾不等式">第二讲 尾不等式<a hidden class="anchor" aria-hidden="true" href="#第二讲-尾不等式">#</a></h2>
<h3 id="一尾不等式分析概要">一、尾不等式分析概要<a hidden class="anchor" aria-hidden="true" href="#一尾不等式分析概要">#</a></h3>
<p>尾不等式用于界定随机变量偏离其期望值的概率，在算法分析和概率算法设计中具有重要作用。</p>
<p><strong>为什么需要尾不等式：</strong></p>
<ul>
<li>期望值只描述了平均情况</li>
<li>需要了解&quot;坏情况&quot;发生的概率</li>
<li>为随机算法提供性能保证</li>
</ul>
<p><strong>应用领域：</strong></p>
<ul>
<li>随机算法分析</li>
<li>负载均衡</li>
<li>哈希表性能分析</li>
<li>采样算法</li>
</ul>
<h3 id="二三个常见的尾不等式">二、三个常见的尾不等式<a hidden class="anchor" aria-hidden="true" href="#二三个常见的尾不等式">#</a></h3>
<p><strong>1. Markov不等式（马尔可夫不等式）：</strong></p>
<p>对于非负随机变量X和a &gt; 0：</p>
<pre tabindex="0"><code>P(X ≥ a) ≤ E[X] / a
</code></pre><p><strong>特点：</strong></p>
<ul>
<li>只需要知道期望</li>
<li>界比较松</li>
<li>适用于任何非负随机变量</li>
</ul>
<p><strong>2. Chebyshev不等式（切比雪夫不等式）：</strong></p>
<p>对于随机变量X，有：</p>
<pre tabindex="0"><code>P(|X - E[X]| ≥ a) ≤ Var(X) / a²
</code></pre><p><strong>特点：</strong></p>
<ul>
<li>需要知道期望和方差</li>
<li>比Markov不等式更紧</li>
<li>不需要独立性假设</li>
</ul>
<p><strong>3. Chernoff界（切尔诺夫界）：</strong></p>
<p>对于独立的随机变量X₁, X₂, &hellip;, Xₙ ∈ [0,1]，令X = ΣXᵢ，μ = E[X]：</p>
<pre tabindex="0"><code>P(X ≥ (1+δ)μ) ≤ e^(-δ²μ/3)  (0 &lt; δ ≤ 1)
P(X ≤ (1-δ)μ) ≤ e^(-δ²μ/2)  (0 &lt; δ ≤ 1)
</code></pre><p><strong>特点：</strong></p>
<ul>
<li>界最紧，指数级衰减</li>
<li>需要独立性假设</li>
<li>广泛应用于随机算法分析</li>
</ul>
<h3 id="三计数问题">三、计数问题<a hidden class="anchor" aria-hidden="true" href="#三计数问题">#</a></h3>
<p><strong>问题描述：</strong>
估计一个数据流中不同元素的个数（基数估计）。</p>
<p><strong>朴素方法的问题：</strong></p>
<ul>
<li>存储所有元素需要O(n)空间</li>
<li>对于大规模数据流不可行</li>
</ul>
<p><strong>概率计数算法：</strong></p>
<p><strong>Flajolet-Martin算法：</strong></p>
<ol>
<li>使用哈希函数h将元素映射到[0, 2^L-1]</li>
<li>对每个元素计算其哈希值的尾部0的个数</li>
<li>记录观察到的最大尾部0个数R</li>
<li>估计值：2^R</li>
</ol>
<p><strong>原理：</strong></p>
<ul>
<li>如果有n个不同元素，期望看到log₂(n)个尾部0</li>
<li>使用多个哈希函数取平均值提高精度</li>
<li>空间复杂度：O(log log n)</li>
</ul>
<p><strong>HyperLogLog算法：</strong></p>
<ul>
<li>Flajolet-Martin的改进版本</li>
<li>使用调和平均数代替算术平均数</li>
<li>精度更高，误差约为1.04/√m（m为桶数）</li>
<li>空间效率极高</li>
</ul>
<hr>
<h2 id="第三讲-数据流">第三讲 数据流<a hidden class="anchor" aria-hidden="true" href="#第三讲-数据流">#</a></h2>
<h3 id="一数据流模型">一、数据流模型<a hidden class="anchor" aria-hidden="true" href="#一数据流模型">#</a></h3>
<p>数据流模型描述了数据以流的形式到达，只能顺序访问一次或有限次的计算场景。</p>
<p><strong>数据流的特点：</strong></p>
<ul>
<li>数据量巨大，无法全部存储</li>
<li>数据到达速度快，需要实时处理</li>
<li>只能进行一次或有限次扫描</li>
<li>需要在有限空间内近似计算</li>
</ul>
<p><strong>典型应用：</strong></p>
<ul>
<li>网络流量监控</li>
<li>金融交易分析</li>
<li>社交媒体数据处理</li>
<li>IoT传感器数据</li>
</ul>
<p><strong>数据流算法的目标：</strong></p>
<ul>
<li>使用亚线性（sublinear）空间</li>
<li>提供可证明的近似保证</li>
<li>单次扫描或少量扫描</li>
</ul>
<h3 id="二频繁元素-确定性算法">二、频繁元素-确定性算法<a hidden class="anchor" aria-hidden="true" href="#二频繁元素-确定性算法">#</a></h3>
<p><strong>问题定义：</strong>
找出数据流中出现频率超过某个阈值的元素（heavy hitters）。</p>
<p><strong>Misra-Gries算法：</strong></p>
<p><strong>算法描述：</strong></p>
<ol>
<li>维护最多k个计数器</li>
<li>对于每个到来的元素：
<ul>
<li>如果已有计数器，增加其计数</li>
<li>如果没有计数器且有空位，创建新计数器</li>
<li>如果没有空位，所有计数器减1，删除值为0的计数器</li>
</ul>
</li>
<li>输出计数器中的元素</li>
</ol>
<p><strong>性能保证：</strong></p>
<ul>
<li>空间复杂度：O(k)</li>
<li>如果元素出现次数 &gt; n/k，一定会被找到</li>
<li>可能有假阳性，但可以通过二次扫描验证</li>
</ul>
<p><strong>应用：</strong></p>
<ul>
<li>找出访问量最大的网页</li>
<li>检测网络中的大流量</li>
<li>识别热门话题</li>
</ul>
<h3 id="三频繁元素-随机算法">三、频繁元素-随机算法<a hidden class="anchor" aria-hidden="true" href="#三频繁元素-随机算法">#</a></h3>
<p><strong>Count-Min Sketch算法：</strong></p>
<p><strong>数据结构：</strong></p>
<ul>
<li>d × w 的二维计数器数组</li>
<li>d个独立的哈希函数h₁, h₂, &hellip;, h_d</li>
</ul>
<p><strong>算法操作：</strong></p>
<p><strong>更新（插入元素x）：</strong></p>
<pre tabindex="0"><code>对于 i = 1 到 d：
    count[i][hᵢ(x)] += 1
</code></pre><p><strong>查询（估计元素x的频率）：</strong></p>
<pre tabindex="0"><code>返回 min{count[i][hᵢ(x)] : i = 1..d}
</code></pre><p><strong>性能保证：</strong></p>
<ul>
<li>空间复杂度：O(d × w)</li>
<li>误差界：ε·n (n为总元素数)，概率至少1-δ</li>
<li>选择w = ⌈e/ε⌉, d = ⌈ln(1/δ)⌉</li>
<li>只会高估，不会低估</li>
</ul>
<p><strong>优势：</strong></p>
<ul>
<li>空间效率高</li>
<li>支持点查询和范围查询</li>
<li>可以处理删除操作（使用带符号的计数）</li>
</ul>
<h3 id="四滑动窗口模型">四、滑动窗口模型<a hidden class="anchor" aria-hidden="true" href="#四滑动窗口模型">#</a></h3>
<p><strong>问题描述：</strong>
只关心最近W个元素的统计特性，更早的数据被丢弃。</p>
<p><strong>挑战：</strong></p>
<ul>
<li>无法存储所有W个元素</li>
<li>需要及时更新统计信息</li>
</ul>
<p><strong>DGIM算法（用于计数）：</strong></p>
<p><strong>基本思想：</strong></p>
<ul>
<li>将窗口划分为桶（bucket）</li>
<li>每个桶代表一段连续的1</li>
<li>桶的大小是2的幂次</li>
<li>维护O(log W)个桶</li>
</ul>
<p><strong>桶的性质：</strong></p>
<ol>
<li>每种大小的桶最多2个</li>
<li>桶按时间戳排序</li>
<li>最老的桶可能不完整</li>
</ol>
<p><strong>查询操作：</strong>
统计窗口内1的个数 ≈ 完整桶的大小之和 + 半个最老桶</p>
<p><strong>误差保证：</strong></p>
<ul>
<li>相对误差：最多50%</li>
<li>可以通过增加每种大小桶的数量来降低误差</li>
</ul>
<p><strong>应用扩展：</strong></p>
<ul>
<li>滑动窗口中的平均值</li>
<li>滑动窗口中的中位数（近似）</li>
<li>滑动窗口中的distinct计数</li>
</ul>
<hr>
<h2 id="第四讲-分布式数据流">第四讲 分布式数据流<a hidden class="anchor" aria-hidden="true" href="#第四讲-分布式数据流">#</a></h2>
<h3 id="一分布式数据流模型">一、分布式数据流模型<a hidden class="anchor" aria-hidden="true" href="#一分布式数据流模型">#</a></h3>
<p>在分布式环境中，数据流分散在多个节点上，需要协调多个节点进行计算。</p>
<p><strong>系统架构：</strong></p>
<ul>
<li><strong>多个监测节点</strong>：每个节点观察部分数据流</li>
<li><strong>协调节点</strong>：汇总和处理来自监测节点的信息</li>
<li><strong>通信约束</strong>：最小化节点间的通信量</li>
</ul>
<p><strong>挑战：</strong></p>
<ul>
<li>数据分散性</li>
<li>通信开销</li>
<li>同步问题</li>
<li>节点故障</li>
</ul>
<p><strong>典型场景：</strong></p>
<ul>
<li>分布式网络监控</li>
<li>多数据中心的日志分析</li>
<li>边缘计算</li>
<li>CDN流量统计</li>
</ul>
<h3 id="二聚集查询">二、聚集查询<a hidden class="anchor" aria-hidden="true" href="#二聚集查询">#</a></h3>
<p><strong>问题定义：</strong>
计算分布在多个节点上的数据的聚集函数（如SUM、COUNT、AVG）。</p>
<p><strong>基本方法：</strong></p>
<p><strong>1. 连续聚集：</strong></p>
<ul>
<li>每个节点维护本地的统计信息</li>
<li>周期性发送给协调节点</li>
<li>协调节点汇总计算全局结果</li>
</ul>
<p><strong>2. 快照聚集：</strong></p>
<ul>
<li>在特定时刻获取全局快照</li>
<li>需要处理同步问题</li>
<li>使用逻辑时钟或物理时钟</li>
</ul>
<p><strong>优化技术：</strong></p>
<p><strong>采样与估计：</strong></p>
<ul>
<li>不发送所有数据，只发送样本</li>
<li>使用统计方法估计全局结果</li>
<li>权衡精度和通信开销</li>
</ul>
<p><strong>增量更新：</strong></p>
<ul>
<li>只发送变化部分</li>
<li>减少冗余通信</li>
<li>适用于变化缓慢的数据</li>
</ul>
<p><strong>数据结构支持：</strong></p>
<ul>
<li>使用Count-Min Sketch等概要结构</li>
<li>可以在协调节点合并</li>
<li>支持分布式查询</li>
</ul>
<h3 id="三topk监控">三、topk监控<a hidden class="anchor" aria-hidden="true" href="#三topk监控">#</a></h3>
<p><strong>问题定义：</strong>
实时监控分布式系统中全局的top-k元素（如最热门的k个商品、最活跃的k个用户）。</p>
<p><strong>挑战：</strong></p>
<ul>
<li>全局top-k可能不在任何单个节点的局部top-k中</li>
<li>需要在精度和通信量之间平衡</li>
<li>数据分布可能高度倾斜</li>
</ul>
<p><strong>解决方案：</strong></p>
<p><strong>1. 阈值算法：</strong></p>
<ul>
<li>协调节点维护全局top-k的阈值θ</li>
<li>每个节点报告超过θ的元素</li>
<li>动态调整θ以平衡通信量</li>
</ul>
<p><strong>算法流程：</strong></p>
<pre tabindex="0"><code>初始化：θ = 0
循环：
  1. 每个节点报告频率 &gt; θ 的元素
  2. 协调节点更新全局top-k
  3. 计算新阈值θ（如第k大元素的频率）
  4. 将θ广播给各节点
</code></pre><p><strong>2. 采样方法：</strong></p>
<ul>
<li>各节点以概率p采样元素</li>
<li>上传采样的数据到协调节点</li>
<li>基于采样数据估计全局top-k</li>
</ul>
<p><strong>3. 层次化监控：</strong></p>
<ul>
<li>构建监控树</li>
<li>中间节点聚合子节点的信息</li>
<li>减少单点通信压力</li>
</ul>
<p><strong>性能优化：</strong></p>
<ul>
<li><strong>局部过滤</strong>：只上传可能进入全局top-k的元素</li>
<li><strong>批量通信</strong>：积累一定数量的更新后批量发送</li>
<li><strong>缓存机制</strong>：利用时间局部性减少通信</li>
</ul>
<p><strong>实际应用：</strong></p>
<ul>
<li>实时热搜榜</li>
<li>分布式缓存的热点识别</li>
<li>网络安全中的异常检测</li>
<li>广告系统的CTR监控</li>
</ul>
<hr>
<h2 id="第五讲-哈希">第五讲 哈希<a hidden class="anchor" aria-hidden="true" href="#第五讲-哈希">#</a></h2>
<h3 id="一哈希函数和哈希表">一、哈希函数和哈希表<a hidden class="anchor" aria-hidden="true" href="#一哈希函数和哈希表">#</a></h3>
<p>哈希技术是一种通过哈希函数将数据映射到固定大小的表中的方法，实现快速的数据存储和检索。</p>
<p><strong>核心概念：</strong></p>
<ul>
<li><strong>哈希函数</strong>：将任意大小的数据映射到固定大小的值</li>
<li><strong>哈希表</strong>：基于数组实现的数据结构，通过哈希函数计算索引位置</li>
<li><strong>冲突处理</strong>：当不同的键映射到相同位置时的解决策略
<ul>
<li>链地址法（Chaining）</li>
<li>开放地址法（Open Addressing）</li>
</ul>
</li>
</ul>
<p><strong>时间复杂度：</strong></p>
<ul>
<li>平均情况：O(1) 查找、插入、删除</li>
<li>最坏情况：O(n)（当所有元素都冲突时）</li>
</ul>
<h3 id="二布隆过滤器bloom-filter">二、布隆过滤器（Bloom Filter）<a hidden class="anchor" aria-hidden="true" href="#二布隆过滤器bloom-filter">#</a></h3>
<p>布隆过滤器是一种空间高效的概率型数据结构，用于判断一个元素是否在集合中。</p>
<p><strong>特点：</strong></p>
<ul>
<li>可能产生假阳性（False Positive）：说存在但实际不存在</li>
<li>不会产生假阴性（False Negative）：说不存在就一定不存在</li>
<li>不支持删除操作（标准版本）</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>网页URL去重</li>
<li>垃圾邮件过滤</li>
<li>缓存穿透防护</li>
<li>大数据去重</li>
</ul>
<p><strong>工作原理：</strong></p>
<ol>
<li>使用k个不同的哈希函数</li>
<li>将元素映射到位数组的k个位置</li>
<li>查询时检查这k个位置是否都为1</li>
</ol>
<h3 id="三最小哈希和lshlocality-sensitive-hashing">三、最小哈希和LSH（Locality-Sensitive Hashing）<a hidden class="anchor" aria-hidden="true" href="#三最小哈希和lshlocality-sensitive-hashing">#</a></h3>
<p><strong>最小哈希（MinHash）：</strong>
用于估计两个集合的Jaccard相似度，常用于文档去重和相似度检测。</p>
<p><strong>局部敏感哈希（LSH）：</strong>
一种降维技术，使得相似的数据项以高概率被映射到相同的桶中。</p>
<p><strong>应用：</strong></p>
<ul>
<li>近似最近邻搜索</li>
<li>图像相似度检测</li>
<li>文本去重</li>
<li>推荐系统</li>
</ul>
<hr>
<h2 id="第六讲-线性规划与整数规划">第六讲 线性规划与整数规划<a hidden class="anchor" aria-hidden="true" href="#第六讲-线性规划与整数规划">#</a></h2>
<h3 id="一线性规划单纯形算法">一、线性规划：单纯形算法<a hidden class="anchor" aria-hidden="true" href="#一线性规划单纯形算法">#</a></h3>
<p><strong>线性规划问题标准形式：</strong></p>
<pre tabindex="0"><code>最大化/最小化：c^T x
约束条件：Ax ≤ b, x ≥ 0
</code></pre><p><strong>单纯形算法（Simplex Method）：</strong></p>
<ul>
<li>由George Dantzig于1947年提出</li>
<li>从可行域的一个顶点出发</li>
<li>沿着目标函数值改进的方向移动到相邻顶点</li>
<li>直到找到最优解或判定无界</li>
</ul>
<p><strong>算法步骤：</strong></p>
<ol>
<li>将问题转换为标准形式</li>
<li>找到初始基本可行解</li>
<li>检验数判断是否达到最优</li>
<li>若未达到最优，选择入基变量和出基变量</li>
<li>进行基变换，更新解</li>
<li>重复步骤3-5直到最优</li>
</ol>
<h3 id="二整数规划问题定义">二、整数规划：问题定义<a hidden class="anchor" aria-hidden="true" href="#二整数规划问题定义">#</a></h3>
<p>整数规划是线性规划的扩展，要求部分或全部变量取整数值。</p>
<p><strong>分类：</strong></p>
<ul>
<li><strong>纯整数规划</strong>：所有变量都必须是整数</li>
<li><strong>混合整数规划（MIP）</strong>：部分变量是整数，部分是连续变量</li>
<li><strong>0-1整数规划</strong>：变量只能取0或1</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>资源分配</li>
<li>生产计划</li>
<li>网络设计</li>
<li>任务调度</li>
</ul>
<h3 id="三整数规划分支界定法branch-and-bound">三、整数规划：分支界定法（Branch and Bound）<a hidden class="anchor" aria-hidden="true" href="#三整数规划分支界定法branch-and-bound">#</a></h3>
<p><strong>基本思想：</strong>
将原问题分解为若干子问题，通过界定（bounding）技术减少搜索空间。</p>
<p><strong>算法流程：</strong></p>
<ol>
<li><strong>松弛</strong>：求解去掉整数约束的线性规划松弛问题</li>
<li><strong>界定</strong>：用松弛问题的最优值作为上界（最大化问题）</li>
<li><strong>分支</strong>：选择一个非整数变量进行分支</li>
<li><strong>剪枝</strong>：
<ul>
<li>当前节点的界不如已知最优解时剪枝</li>
<li>松弛问题无可行解时剪枝</li>
<li>松弛问题的解满足整数约束时更新最优解</li>
</ul>
</li>
</ol>
<h3 id="四整数规划切平面法cutting-plane-method">四、整数规划：切平面法（Cutting Plane Method）<a hidden class="anchor" aria-hidden="true" href="#四整数规划切平面法cutting-plane-method">#</a></h3>
<p><strong>核心思想：</strong>
通过添加线性约束（切平面）逐步逼近整数规划的可行域，直到得到整数最优解。</p>
<p><strong>Gomory割平面：</strong></p>
<ul>
<li>从单纯形表中推导出的割平面</li>
<li>切掉当前非整数最优解</li>
<li>不切掉任何整数可行解</li>
</ul>
<p><strong>算法步骤：</strong></p>
<ol>
<li>求解线性规划松弛问题</li>
<li>若解为整数，则为最优解，算法结束</li>
<li>若解不为整数，生成割平面约束</li>
<li>将割平面加入原问题</li>
<li>重新求解并重复步骤2-4</li>
</ol>
<hr>
<h2 id="第七讲-内存计算">第七讲 内存计算<a hidden class="anchor" aria-hidden="true" href="#第七讲-内存计算">#</a></h2>
<h3 id="一海量内存概述">一、海量内存概述<a hidden class="anchor" aria-hidden="true" href="#一海量内存概述">#</a></h3>
<p>随着硬件技术的发展，单机内存容量已经可以达到TB级别，这为大数据处理带来了新的机遇。</p>
<p><strong>内存计算的优势：</strong></p>
<ul>
<li><strong>速度快</strong>：内存访问速度比磁盘快3-5个数量级</li>
<li><strong>延迟低</strong>：避免了磁盘I/O的延迟</li>
<li><strong>适合迭代计算</strong>：机器学习、图计算等需要多次迭代的场景</li>
</ul>
<p><strong>挑战：</strong></p>
<ul>
<li>成本较高</li>
<li>数据持久化问题</li>
<li>容错机制</li>
</ul>
<h3 id="二基于单机版内存增大优势">二、基于单机版内存增大优势<a hidden class="anchor" aria-hidden="true" href="#二基于单机版内存增大优势">#</a></h3>
<p><strong>单机大内存的应用场景：</strong></p>
<ul>
<li>内存数据库（如Redis, Memcached）</li>
<li>实时数据分析</li>
<li>高性能缓存系统</li>
<li>图数据处理</li>
</ul>
<p><strong>技术特点：</strong></p>
<ul>
<li>简化系统架构，减少网络通信开销</li>
<li>提高数据处理的吞吐量</li>
<li>适合中等规模的数据集</li>
</ul>
<p><strong>优化策略：</strong></p>
<ul>
<li>数据结构优化（压缩、列式存储）</li>
<li>NUMA-aware内存分配</li>
<li>大页内存（Huge Pages）的使用</li>
</ul>
<h3 id="三基于共享式内存和分布式内存结合架构优势">三、基于共享式内存和分布式内存结合架构优势<a hidden class="anchor" aria-hidden="true" href="#三基于共享式内存和分布式内存结合架构优势">#</a></h3>
<p><strong>混合架构设计：</strong></p>
<p><strong>共享式内存（Shared Memory）：</strong></p>
<ul>
<li>多个处理器共享同一物理内存空间</li>
<li>通信开销低</li>
<li>编程相对简单</li>
<li>可扩展性受限</li>
</ul>
<p><strong>分布式内存（Distributed Memory）：</strong></p>
<ul>
<li>每个节点有独立的内存空间</li>
<li>通过网络进行通信</li>
<li>可扩展性强</li>
<li>编程复杂度较高</li>
</ul>
<p><strong>结合架构的优势：</strong></p>
<ol>
<li><strong>弹性扩展</strong>：根据数据规模动态调整资源</li>
<li><strong>负载均衡</strong>：合理分配计算任务</li>
<li><strong>容错能力</strong>：数据副本和快照机制</li>
<li><strong>性能优化</strong>：本地内存访问 + 跨节点通信</li>
</ol>
<p><strong>典型系统：</strong></p>
<ul>
<li>Apache Spark（基于RDD的内存计算框架）</li>
<li>Apache Flink（流式和批处理统一计算）</li>
<li>Alluxio（分布式内存文件系统）</li>
</ul>
<h3 id="四总结">四、总结<a hidden class="anchor" aria-hidden="true" href="#四总结">#</a></h3>
<p>内存计算已成为大数据处理的重要技术方向：</p>
<ul>
<li>针对不同场景选择合适的架构</li>
<li>平衡性能、成本和可扩展性</li>
<li>结合持久化存储保证数据安全</li>
<li>关注新硬件技术（如持久化内存）的发展</li>
</ul>
<hr>
<h2 id="第八讲-社区发现">第八讲 社区发现<a hidden class="anchor" aria-hidden="true" href="#第八讲-社区发现">#</a></h2>
<p>社区发现是复杂网络分析中的重要问题，目标是找出网络中紧密连接的节点群组。</p>
<h3 id="一图切割graph-partitioning">一、图切割（Graph Partitioning）<a hidden class="anchor" aria-hidden="true" href="#一图切割graph-partitioning">#</a></h3>
<h4 id="1-社区划分问题">1. 社区划分问题<a hidden class="anchor" aria-hidden="true" href="#1-社区划分问题">#</a></h4>
<p>给定无向图 $G = (V, E)$，其中：</p>
<ul>
<li>$V$ 表示所有的顶点（节点）集合</li>
<li>$E$ 表示所有的边集合</li>
</ul>
<p><strong>任务：</strong> 将所有顶点分成两个不相交的组：</p>
<ul>
<li>组 $A$：包含一部分节点</li>
<li>组 $B = V\backslash A$：包含剩余的所有节点（即 $V$ 中除了 $A$ 之外的所有节点）</li>
</ul>
<p><strong>核心问题：</strong> 如何评判这个划分的好坏？</p>
<h4 id="2-评判准则">2. 评判准则<a hidden class="anchor" aria-hidden="true" href="#2-评判准则">#</a></h4>
<p>一个良好的社区划分应该满足：</p>
<ul>
<li><strong>最大化社区内部的连接数</strong>：同一个社区内的节点之间应该有尽可能多的边连接</li>
<li><strong>最小化社区之间的连接数</strong>：不同社区之间的连接应该尽可能少</li>
</ul>
<h4 id="3-割cut的定义">3. 割（Cut）的定义<a hidden class="anchor" aria-hidden="true" href="#3-割cut的定义">#</a></h4>
<p>为了量化划分的质量，我们引入&quot;割&quot;的概念。</p>
<p><strong>割(cut)</strong> 是指：只有一个端点在社区 $A$ 内，另一个端点在社区 $A$ 外的所有边的权重之和。</p>
<p>数学表达式：</p>
$$cut(A) = \sum_{i \in A, j \notin A} w_{ij}$$<p><strong>公式解释：</strong></p>
<ul>
<li>$i \in A$：节点 $i$ 在社区 $A$ 中</li>
<li>$j \notin A$：节点 $j$ 不在社区 $A$ 中（即在社区 $B$ 中）</li>
<li>$w_{ij}$：连接节点 $i$ 和节点 $j$ 的边的权重（如果是无权图，权重为1）</li>
<li>$\sum$：对所有满足条件的边进行求和</li>
</ul>
<p><strong>通俗理解：</strong> 割就是&quot;跨越两个社区的边的总权重&quot;，这个值越小，说明两个社区之间的连接越少，划分越好。</p>
<p><strong>求解方法：</strong> 存在多项式时间算法来求解最小割问题，特别是 <strong>Edmonds-Karp 算法</strong>，其时间复杂度为 $O(|V| \cdot |E|^2)$。</p>
<h4 id="4-最小割-minimum-cut">4. 最小割 (Minimum-cut)<a hidden class="anchor" aria-hidden="true" href="#4-最小割-minimum-cut">#</a></h4>
<p><strong>目标：</strong> 找到一个划分 $(A, B)$，使得 $cut(A,B)$ 的值最小。</p>
$$\arg\min_{A,B} cut(A,B)$$<p><strong>公式解释：</strong></p>
<ul>
<li>$\arg\min$：表示&quot;使得后面的值最小的参数&quot;</li>
<li>即找到使 $cut(A,B)$ 最小的划分方式 $(A, B)$</li>
</ul>
<p><strong>最小割的局限性：</strong></p>
<p>虽然最小割能找到连接最少的划分，但存在明显的问题：</p>
<ul>
<li><strong>只考虑簇间的联通性</strong>：只关心两个社区之间有多少连接</li>
<li><strong>不考虑簇内的连通性</strong>：不关心每个社区内部的结构</li>
<li><strong>可能产生不平衡的划分</strong>：例如，将一个孤立的节点分离出来，只需要切断很少的边，但这样的划分是没有意义的</li>
</ul>
<p><strong>举例说明：</strong> 假设有一个图，其中有一个节点只通过一条边连接到主图，那么最小割会将这个节点单独分离出来（只需切断1条边），但这样的划分显然不合理。</p>
<h4 id="5-归一化切割-normalized-cut">5. 归一化切割 (Normalized-cut)<a hidden class="anchor" aria-hidden="true" href="#5-归一化切割-normalized-cut">#</a></h4>
<p>为了解决最小割的问题，我们引入归一化切割，它同时考虑了簇间的连通性和各簇的规模。</p>
<p><strong>体积（Volume）的定义：</strong> 首先需要定义社区 $A$ 的&quot;体积&quot; $vol(A)$：</p>
$$vol(A) = \sum_{i \in A} k_i$$<p>其中 $k_i$ 是节点 $i$ 的度（degree），即连接到节点 $i$ 的所有边的权重之和。$vol(A)$ 表示至少有一个端点在社区 $A$ 中的所有边的总权重，反映了社区 $A$ 的&quot;规模&quot;或&quot;密度&quot;。</p>
<p><strong>归一化切割的定义：</strong></p>
$$ncut(A,B) = \frac{cut(A,B)}{vol(A)} + \frac{cut(A,B)}{vol(B)}$$<p><strong>公式解释：</strong></p>
<ul>
<li>第一项 $\frac{cut(A,B)}{vol(A)}$：割的大小相对于社区 $A$ 的规模</li>
<li>第二项 $\frac{cut(A,B)}{vol(B)}$：割的大小相对于社区 $B$ 的规模</li>
<li>两项相加：综合考虑两个社区的规模</li>
</ul>
<p><strong>为什么要归一化？</strong> 通过除以各自的体积，我们将割的大小&quot;标准化&quot;了。这样如果一个社区很大（$vol$ 很大），即使割的值不变，归一化后的值也会变小，从而避免了将单个节点分离出来的情况（因为单个节点的 $vol$ 很小，归一化后的值会很大）。</p>
<p><strong>优势：</strong></p>
<ul>
<li>使划分更加平衡，避免产生极小的社区</li>
<li>同时考虑了社区间的连接和社区的规模</li>
</ul>
<p><strong>挑战：</strong></p>
<ul>
<li>计算归一化割是 NP-hard 问题</li>
<li>需要使用近似算法或启发式方法来高效地找到好的划分</li>
</ul>
<h4 id="6-练习题详解">6. 练习题详解<a hidden class="anchor" aria-hidden="true" href="#6-练习题详解">#</a></h4>
<p><a href="https://postimg.cc/0zcNdF3z"><img alt="image.png" loading="lazy" src="https://i.postimg.cc/d0KTvKjj/image.png"></a></p>
<p><strong>题目：</strong> 对于给定的图(红色节点和绿色节点)，分别计算最优切割和最小切割的 $ncut$ 值。</p>
<p><strong>题目分析：</strong> 从图中可以看到两种切割方式：</p>
<ul>
<li><strong>最优切割</strong>（蓝色虚线）：在红色社区（左侧）和绿色社区（右侧）之间进行切割</li>
<li><strong>最小切割</strong>（红色虚线）：将右下角单个绿色节点孤立出来</li>
</ul>
<p><strong>（1）最小切割的 $ncut$ 值计算</strong></p>
<p>划分方式：社区 $A$ 为右下角单个绿色节点，社区 $B$ 为其余所有节点。</p>
<ul>
<li>$cut(A,B) = 1$（只有1条边连接孤立节点）</li>
<li>$vol(A) = 0$（节点完全孤立，内部没有边）</li>
<li>$ncut_{\text{min}} = \frac{1}{0} + \frac{1}{vol(B)} = +\infty$</li>
</ul>
<p>这说明<strong>将单个节点完全孤立是一个极差的划分</strong>！</p>
<p><strong>（2）最优切割的 $ncut$ 值计算</strong></p>
<p>划分方式：社区 $A$ 为所有红色节点（左侧6个节点），社区 $B$ 为所有绿色节点（右侧10个节点）。</p>
<ul>
<li>$cut(A,B) = 2$（2条边跨越蓝色虚线）</li>
<li>$vol(A) = 2 \times 9 = 18$（红色区域内部9条边）</li>
<li>$vol(B) = 2 \times 15 = 30$（绿色区域内部15条边）</li>
<li>$ncut_{\text{optimal}} = \frac{2}{30} + \frac{2}{18} = \frac{1}{15} + \frac{1}{9} = \frac{8}{45} \approx 0.178$</li>
</ul>
<p><strong>结果对比：</strong></p>
<table>
  <thead>
      <tr>
          <th>切割方式</th>
          <th>$cut(A,B)$</th>
          <th>$vol(A)$</th>
          <th>$vol(B)$</th>
          <th>$ncut$ 值</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>最小切割</td>
          <td>1</td>
          <td>0</td>
          <td>&gt;0</td>
          <td>$+\infty$</td>
      </tr>
      <tr>
          <td>最优切割</td>
          <td>2</td>
          <td>18</td>
          <td>30</td>
          <td>0.178</td>
      </tr>
  </tbody>
</table>
<p><strong>结论：</strong></p>
<ol>
<li>最小切割将单个节点孤立后，$vol(A) = 0$ 导致 $ncut$ 值趋向无穷大，这是最差的划分</li>
<li>最优切割虽然 $cut$ 值不是最小，但 $ncut$ 值很小，实现了平衡且合理的划分</li>
<li>归一化切割通过考虑社区规模，避免了不合理的极端划分，$ncut$ 值越小说明划分越好</li>
</ol>
<h3 id="二边介数edge-betweenness">二、边介数（Edge Betweenness）<a hidden class="anchor" aria-hidden="true" href="#二边介数edge-betweenness">#</a></h3>
<h4 id="1-边介数的定义">1. 边介数的定义<a hidden class="anchor" aria-hidden="true" href="#1-边介数的定义">#</a></h4>
<p><strong>边介数（Edge Betweenness）</strong>：通过该边的最短路径的数量。</p>
<p><strong>作用：</strong></p>
<ul>
<li>用于衡量图中一条边的重要性或中心性</li>
<li>反映图中有多少条最短路径经过该边</li>
</ul>
<p><strong>重要性判断：</strong></p>
<ul>
<li>若很多最短路径都经过该边，则该边对于保持图的高效连接性就非常重要</li>
<li>相反，如果仅少数最短路径经过该边，则该边的重要性就较低</li>
</ul>
<p><strong>应用价值：</strong></p>
<p>边介数有助于识别图中的关键连接，即这些连接一旦断裂会显著影响图中节点之间的通信效率。</p>
<p><strong>示例：</strong></p>
<p><a href="https://postimg.cc/mt507GNN"><img alt="image.png" loading="lazy" src="https://i.postimg.cc/L892K9J7/image.png"></a></p>
<p>在下图中，不同的边具有不同的边介数值：</p>
<ul>
<li>左侧的边：$b = 16$（有16条最短路径经过）</li>
<li>右侧的边：$b = 7.5$（有7.5条最短路径经过）</li>
</ul>
<p>边介数越大，该边在网络中的重要性越高。</p>
<h4 id="2-girvan-newman方法简称gn方法">2. Girvan-Newman方法（简称GN方法）<a hidden class="anchor" aria-hidden="true" href="#2-girvan-newman方法简称gn方法">#</a></h4>
<p><strong>GN方法定义：</strong></p>
<p>Girvan-Newman方法是一种基于边介数概念的层次聚类算法，适用于无向无权网络。</p>
<p><strong>算法流程：</strong></p>
<p>重复以下步骤直到没有边剩余：</p>
<ol>
<li><strong>计算边介数</strong>：计算网络中所有边的边介数</li>
<li><strong>移除边介数最高的边</strong>：找到边介数最大的边并将其从图中删除</li>
<li><strong>重新计算</strong>：在每个步骤后，需要重新计算剩余边的边介数</li>
</ol>
<p><strong>输出结果：</strong></p>
<ul>
<li>相连接的边构成社区</li>
<li>可输出网络的层次分解</li>
</ul>
<p><strong>重要提示：</strong> 在每个步骤，均需重新计算边介数，因为移除一条边会影响其他边的最短路径。</p>
<h4 id="3-gn方法案例分析">3. GN方法案例分析<a hidden class="anchor" aria-hidden="true" href="#3-gn方法案例分析">#</a></h4>
<p>考虑下图所示的网络，应用GN方法进行社区划分：</p>
<p><a href="https://postimg.cc/JtzSsnVg"><img alt="image.png" loading="lazy" src="https://i.postimg.cc/QNQDn96X/image.png"></a></p>
<p><strong>Step 1：</strong> 计算所有边的边介数，移除边介数最高的边（边7-8，边介数为49）</p>
<p>结果：图被分成两个主要部分</p>
<p><strong>Step 2：</strong> 重新计算剩余边的边介数，继续移除边介数最高的边</p>
<p>结果：进一步细分，形成更小的社区</p>
<p><strong>Step 3：</strong> 持续迭代，直到所有边都被移除</p>
<p>结果：每个节点成为独立的社区</p>
<p><strong>最终输出：层次状的网络划分</strong></p>
<p>通过记录每次移除边的顺序，可以构建一个层次树（dendrogram），展示网络在不同粒度下的社区结构。</p>
<h4 id="4-如何计算边介数">4. 如何计算边介数<a hidden class="anchor" aria-hidden="true" href="#4-如何计算边介数">#</a></h4>
<p><strong>（1）基本方法：构建根节点到其余子节点的最短路径数量</strong></p>
<p><strong>步骤1：构建最短路径树</strong></p>
<p>从起始节点（如节点A）开始，使用BFS构建到所有其他节点的最短路径树，并标记每个节点的层次：</p>
<ul>
<li>第0层：起始节点A</li>
<li>第1层：与A直接相连的节点（B, C, D, E）</li>
<li>第2层：距离A为2的节点（F, G, H）</li>
<li>第3层：距离A为3的节点（I, J）</li>
<li>第4层：距离A为4的节点（K）</li>
</ul>
<p><strong>步骤2：计算最短路径数量</strong></p>
<p>计算从起始节点A到网络中其他每个节点的最短路径数量。</p>
<p><strong>公式：</strong></p>
<p>从A到某个节点X的最短路径数量 = 所有能到达X的<strong>父节点</strong>的最短路径数量之和</p>
<p><strong>示例：</strong></p>
<p><a href="https://postimg.cc/xkR9L1fg"><img alt="image.png" loading="lazy" src="https://i.postimg.cc/0QgrRzLg/image.png"></a></p>
<ul>
<li>从A到H的最短路径数量 = 从A到D的最短路径数量 + 从A到E的最短路径数量</li>
<li>从A到K的最短路径数量 = 从A到I的最短路径数量 + 从A到J的最短路径数量</li>
</ul>
<p><strong>（2）自底向上计算边介数</strong>：如果存在多条最短路径，则可按比例划分边介数。</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li>
<p><strong>添加边流</strong></p>
<ul>
<li>初始化：每个节点的流 = 1 + 其所有子边的流之和</li>
<li>根据父节点的值分配流</li>
</ul>
</li>
<li>
<p><strong>对于每个起始节点U，重复广度优先搜索过程</strong></p>
</li>
</ol>
<p><strong>详细计算规则：</strong></p>
<p>对于某条边 $(X, Y)$，其边介数的计算遵循以下规则：</p>
<ul>
<li>如果从A到Y只有一条最短路径经过X，则该边获得完整的流</li>
<li>如果从A到Y有多条最短路径（通过不同的父节点），则按照各父节点的最短路径数量比例分配流</li>
</ul>
<p><strong>具体案例：</strong></p>
<p><a href="https://postimg.cc/8FSN9rXp"><img alt="image.png" loading="lazy" src="https://i.postimg.cc/bvGrGxQt/image.png"></a></p>
<p>以节点为K为例：</p>
<ul>
<li>K对于A而言是<strong>叶子节点</strong>，所以他的流为1（根据算法规则：子节点的流为0），</li>
<li>共有2条最短路径可被分配，根据I，J各有三条最短路径，为3：3，即1：1，因此每条边分配 $\frac{1}{2}$</li>
</ul>
<p>以节点I为例：</p>
<ul>
<li>A-I的最短路径总和算1，外加经过I到K的0.5，所以I的流为1.5</li>
<li>I有1.5可被分配，按照2:1的比例划分（因为A到F有2条最短路径，到G有1条最短路径）</li>
<li>故边$V_{F,I}$得到的流为1，边$V_{G,I}$得到的流为0.5</li>
</ul>
<p>以此自下而上故能得到所有边的边介数</p>
<h4 id="5-练习题">5. 练习题<a hidden class="anchor" aria-hidden="true" href="#5-练习题">#</a></h4>
<p>**题目：**给定下图所示的网络结构，请：</p>
<p><a href="https://postimg.cc/CnnNb94Z"><img alt="image.png" loading="lazy" src="https://i.postimg.cc/Y0bsBHGx/image.png"></a></p>
<p>根据第四小点，很快就能确定每条边的边介数</p>
<p><strong>步骤1：构建最短路径树</strong></p>
<p>从起始节点B开始，使用BFS构建到所有其他节点的最短路径树，并标记每个节点的层次：</p>
<ul>
<li>第0层：起始节点B</li>
<li>第1层：与B直接相连的节点（A，C，F）</li>
<li>第2层：距离B为2的节点（D，E，I）</li>
<li>第3层：距离B为3的节点（G，H，K）</li>
<li>第4层：距离B为4的节点（J）</li>
</ul>
<p><strong>步骤2：计算最短路径数量</strong></p>
<p>计算从起始节点B到网络中其他每个节点的最短路径数量。定义节点B到节点I的最短路径数量的方法为$N(i)$，故</p>
<ul>
<li>第0层：起始节点B</li>
<li>第1层：与B直接相连的节点$N(A) = 1$,$N(C) = 1$,$N(F) = 1$</li>
<li>第2层：距离B为2的节点$N(D) = N(A)=1$,$N(E) = N(A)=1$,$N(I)=N(F) = 1$</li>
<li>第3层：距离B为3的节点$N(G) = N(D)+N(I)=2$,$N(H) = N(D)+N(E)=2$,$N(K)=N(I) = 1$</li>
<li>第4层：距离B为4的节点$N(J) = N(G)+N(H)+N(K) = 5$​</li>
</ul>
<p><strong>步骤3：自底向上计算边介数</strong></p>
<p>每个节点的流 = 1 + 其所有子边的流之和，根据父节点的值分配流，</p>
<ul>
<li>
<p>第4层：距离B为4的节点（J），J为叶子节点，所以J的流为1，故分配边流</p>
<p>$V_{H,J}=V_{K,J}=V_{G,J} = \frac{1}{3}$</p>
</li>
<li>
<p>第3层：距离B为3的节点（G，H，K）,计算各自的流：$G = H = K = 1+\frac{1}{3}=\frac{4}{3}$</p>
</li>
</ul>
<hr>
<h3 id="三模块度modularity">三、模块度（Modularity）<a hidden class="anchor" aria-hidden="true" href="#三模块度modularity">#</a></h3>
<p><strong>定义：</strong>
模块度Q用于衡量网络社区划分的质量。</p>
<p><strong>公式：</strong></p>
<pre tabindex="0"><code>Q = (1/2m) Σ[Aᵢⱼ - (kᵢkⱼ/2m)]δ(cᵢ,cⱼ)
</code></pre><p>其中：</p>
<ul>
<li>m：边的总数</li>
<li>Aᵢⱼ：邻接矩阵</li>
<li>kᵢ：节点i的度</li>
<li>δ(cᵢ,cⱼ)：节点i和j是否在同一社区</li>
</ul>
<p><strong>特性：</strong></p>
<ul>
<li>Q值范围：[-0.5, 1]</li>
<li>Q &gt; 0.3通常表示有明显的社区结构</li>
<li>模块度最大化是NP困难问题</li>
</ul>
<h3 id="四louvain方法">四、Louvain方法<a hidden class="anchor" aria-hidden="true" href="#四louvain方法">#</a></h3>
<p>Louvain算法是一种基于模块度优化的快速社区发现算法。</p>
<p><strong>算法步骤：</strong></p>
<p><strong>第一阶段（模块度优化）：</strong></p>
<ol>
<li>初始化：每个节点为一个独立社区</li>
<li>遍历每个节点：
<ul>
<li>尝试将该节点移动到邻居节点所在的社区</li>
<li>计算模块度增益ΔQ</li>
<li>选择使ΔQ最大且为正的移动</li>
</ul>
</li>
<li>重复步骤2直到模块度不再增加</li>
</ol>
<p><strong>第二阶段（网络聚合）：</strong></p>
<ol>
<li>将同一社区的所有节点合并成一个超级节点</li>
<li>社区间的边权重等于原节点间边权重之和</li>
<li>对新网络重复第一阶段</li>
</ol>
<p><strong>重复两个阶段直到模块度不再显著增加。</strong></p>
<p><strong>优势：</strong></p>
<ul>
<li>时间复杂度：O(n log n)</li>
<li>能处理大规模网络（百万级节点）</li>
<li>能发现层次化社区结构</li>
<li>实现简单，效果好</li>
</ul>
<p><strong>应用案例：</strong></p>
<ul>
<li>社交网络社区检测</li>
<li>生物网络模块识别</li>
<li>知识图谱聚类</li>
</ul>
<hr>
<h2 id="第九讲-子模函数及其应用">第九讲 子模函数及其应用<a hidden class="anchor" aria-hidden="true" href="#第九讲-子模函数及其应用">#</a></h2>
<h3 id="一应用背景">一、应用背景<a hidden class="anchor" aria-hidden="true" href="#一应用背景">#</a></h3>
<p>子模函数在组合优化中有广泛应用，许多实际问题都具有子模性质。</p>
<p><strong>典型应用场景：</strong></p>
<ul>
<li>信息传播最大化</li>
<li>传感器布置优化</li>
<li>文档摘要</li>
<li>特征选择</li>
<li>图像分割</li>
</ul>
<h3 id="二子模函数submodular-function">二、子模函数（Submodular Function）<a hidden class="anchor" aria-hidden="true" href="#二子模函数submodular-function">#</a></h3>
<p><strong>定义：</strong>
集合函数f: 2^V → ℝ 是子模的，如果对于任意A ⊆ B ⊆ V 和 x ∉ B，有：</p>
<pre tabindex="0"><code>f(A ∪ {x}) - f(A) ≥ f(B ∪ {x}) - f(B)
</code></pre><p><strong>直观理解：</strong>
边际收益递减（Diminishing Returns）：向小集合添加元素的收益不小于向大集合添加相同元素的收益。</p>
<p><strong>常见子模函数：</strong></p>
<ol>
<li><strong>覆盖函数</strong>：f(S) = |∪ₛ∈S Cₛ|</li>
<li><strong>截断函数</strong>：f(S) = min(|S|, k)</li>
<li><strong>图割函数</strong></li>
<li><strong>熵函数</strong></li>
</ol>
<p><strong>性质：</strong></p>
<ul>
<li>子模函数的非负线性组合仍是子模的</li>
<li>子模函数的最小化可以在多项式时间内精确求解</li>
<li>子模函数的最大化是NP困难的，但存在近似算法</li>
</ul>
<h3 id="三集合覆盖问题set-cover-problem">三、集合覆盖问题（Set Cover Problem）<a hidden class="anchor" aria-hidden="true" href="#三集合覆盖问题set-cover-problem">#</a></h3>
<p><strong>问题定义：</strong>
给定全集U和若干子集S₁, S₂, &hellip;, Sₙ ⊆ U，找到最少数量的子集使其并集等于U。</p>
<p><strong>形式化：</strong></p>
<pre tabindex="0"><code>最小化：|S|
约束条件：∪ₛ∈S s = U
</code></pre><p><strong>复杂性：</strong></p>
<ul>
<li>NP困难问题</li>
<li>不存在常数因子近似算法（除非P=NP）</li>
</ul>
<p><strong>贪心算法：</strong></p>
<ol>
<li>初始化：S = ∅, R = U（未覆盖元素）</li>
<li>循环直到R = ∅：
<ul>
<li>选择覆盖R中最多元素的集合s</li>
<li>S = S ∪ {s}</li>
<li>R = R \ s</li>
</ul>
</li>
<li>返回S</li>
</ol>
<p><strong>性能保证：</strong></p>
<ul>
<li>贪心算法的近似比：O(ln n)</li>
<li>这是可达到的最好近似比（在P≠NP假设下）</li>
</ul>
<p><strong>子模性与贪心算法：</strong>
集合覆盖函数f(S) = |∪ₛ∈S s|是子模的，对于单调子模函数最大化：</p>
<ul>
<li>贪心算法保证(1 - 1/e)近似比</li>
<li>这个界是紧的</li>
</ul>
<p><strong>实际应用：</strong></p>
<ul>
<li><strong>设施选址</strong>：用最少的设施覆盖所有需求点</li>
<li><strong>无线网络覆盖</strong>：最小化基站数量</li>
<li><strong>测试用例选择</strong>：用最少的测试覆盖所有代码路径</li>
<li><strong>特征选择</strong>：选择最少的特征保持分类性能</li>
</ul>
<p><strong>高级话题：</strong></p>
<ul>
<li>加权集合覆盖</li>
<li>多目标集合覆盖</li>
<li>在线集合覆盖</li>
<li>分布式集合覆盖算法</li>
</ul>
<hr>
<h2 id="课程总结">课程总结<a hidden class="anchor" aria-hidden="true" href="#课程总结">#</a></h2>
<p>本课程系统地介绍了数学基础算法的核心内容，涵盖了从理论到实践的多个重要主题：</p>
<p><strong>基础理论部分（第1-2讲）：</strong></p>
<ul>
<li><strong>算法分析</strong>为评估算法效率提供了数学工具，相似度搜索和高维空间技术是现代大数据应用的基础</li>
<li><strong>尾不等式</strong>提供了随机算法性能的概率保证，是设计和分析概率算法的重要理论基础</li>
</ul>
<p><strong>数据流处理（第3-4讲）：</strong></p>
<ul>
<li><strong>数据流算法</strong>解决了在有限空间内处理海量数据的问题，频繁元素检测和滑动窗口模型在实时系统中应用广泛</li>
<li><strong>分布式数据流</strong>扩展到多节点场景，聚集查询和top-k监控为大规模分布式系统提供了实用解决方案</li>
</ul>
<p><strong>核心算法技术（第5-7讲）：</strong></p>
<ul>
<li><strong>哈希技术</strong>为大规模数据的快速检索和去重提供了基础工具，布隆过滤器和LSH在实际应用中具有重要价值</li>
<li><strong>线性规划与整数规划</strong>是运筹优化的核心方法，单纯形算法、分支界定法和切平面法为求解复杂优化问题提供了理论基础</li>
<li><strong>内存计算</strong>代表了大数据处理的技术趋势，通过合理利用单机大内存和分布式架构可以显著提升计算性能</li>
</ul>
<p><strong>图算法与优化（第8-9讲）：</strong></p>
<ul>
<li><strong>社区发现</strong>算法帮助我们理解复杂网络的结构特征，Louvain方法在实践中表现出色</li>
<li><strong>子模优化</strong>为许多实际问题提供了理论保证的近似算法，贪心策略在子模函数优化中具有良好的性能保证</li>
</ul>
<p><strong>核心思想总结：</strong></p>
<ol>
<li><strong>近似与权衡</strong>：在精确性和效率之间寻找平衡</li>
<li><strong>概率与随机化</strong>：利用随机化技术突破确定性算法的局限</li>
<li><strong>分布式思维</strong>：将算法扩展到大规模分布式环境</li>
<li><strong>理论保证</strong>：为实际算法提供可证明的性能边界</li>
</ol>
<p>这些算法和技术在实际应用中经常需要结合使用，深入理解其数学基础对于解决复杂的工程问题至关重要。掌握这些方法不仅能提升算法设计能力，更能在面对实际问题时选择合适的解决方案，在效率、精度和资源消耗之间做出明智的权衡。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
      <li><a href="http://localhost:1313/tags/%E5%93%88%E5%B8%8C/">哈希</a></li>
      <li><a href="http://localhost:1313/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">算法分析</a></li>
      <li><a href="http://localhost:1313/tags/%E5%B0%BE%E4%B8%8D%E7%AD%89%E5%BC%8F/">尾不等式</a></li>
      <li><a href="http://localhost:1313/tags/%E6%95%B0%E6%8D%AE%E6%B5%81/">数据流</a></li>
    </ul>
  </footer><div id="tw-comment"></div>
<script>
    
    const getStoredTheme = () => localStorage.getItem("pref-theme") === "light" ? "nord_light" : "dark_dimmed";
    const setGiscusTheme = () => {
        const sendMessage = (message) => {
            const iframe = document.querySelector('iframe.giscus-frame');
            if (iframe) {
                iframe.contentWindow.postMessage({giscus: message}, 'https://giscus.app');
            }
        }
        sendMessage({setConfig: {theme: getStoredTheme()}})
    }

    document.addEventListener("DOMContentLoaded", () => {
        const giscusAttributes = {
            "src": "https://giscus.app/client.js",
            "data-repo": "minjieblog\/minjieblog.github.io",
            "data-repo-id": "R_kgDOQjMm6A",
            "data-category": "Announcements",
            "data-category-id": "DIC_kwDOQjMm6M4Czb4B",
            "data-mapping": "pathname",
            "data-strict": "0",
            "data-reactions-enabled": "1",
            "data-emit-metadata": "0",
            "data-input-position": "bottom",
            "data-theme": getStoredTheme(),
            "data-lang": "zh-CN",
            "data-loading": "lazy",
            "crossorigin": "anonymous",
        };

        
        const giscusScript = document.createElement("script");
        Object.entries(giscusAttributes).forEach(
                ([key, value]) => giscusScript.setAttribute(key, value));
        document.querySelector("#tw-comment").appendChild(giscusScript);

        
        const themeSwitcher = document.querySelector("#theme-toggle");
        if (themeSwitcher) {
            themeSwitcher.addEventListener("click", setGiscusTheme);
        }
        const themeFloatSwitcher = document.querySelector("#theme-toggle-float");
        if (themeFloatSwitcher) {
            themeFloatSwitcher.addEventListener("click", setGiscusTheme);
        }
    });
</script>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://minjieblog.github.io/">©2025 Minjie&rsquo;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
