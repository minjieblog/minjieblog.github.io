[{"content":" 论文基本信息 标题: xRWA: A Cross-Chain Framework for Interoperability of Real-World Assets 作者: Yihao Guo, Haoming Zhu, Minghui Xu, Xiuzhen Cheng, Bin Xiao 机构: 香港理工大学计算系, 山东大学计算机科学与技术学院 发表: arXiv预印本 (2025年9月) 领域: 区块链互操作性、真实世界资产、去中心化身份 arXiv: 2509.12957v2 [cs.CR] 代码: GitHub - xRWA 核心问题 RWA市场现状 市场规模: 2025年上半年从86亿增至230亿美元(+260%) 未来预测: Citibank估计2030年达到4万亿美元 典型资产: 政府债券、大宗商品、房地产、稳定币 跨链部署的两大挑战 Q1: 冗余认证 (Redundant Authentication) 单链场景: RWA只需在本地账本认证一次 跨链困境: 每次转移到新链都要完全重新认证 理想方案: 在链A认证后,链B应通过证明直接识别 Q2: 低效操作 (Inefficient Operations) 单链瓶颈: Bitcoin ~7 TPS, Ethereum ~15 TPS (Visa可达数千TPS) 跨链放大: HTLC原子交换需要4个独立链上操作 现有通道: 每次结算都要关闭并重开通道,增加成本和延迟 解决方案概览 xRWA三层架构 ┌─────────────────────────────────────────────────────┐ │ Layer 3: 跨链交互 (Cross-Chain Interaction) │ │ - 跨链通道支持无需关闭的结算 │ │ - 基于HTLC的原子性保证 │ └─────────────────────────────────────────────────────┘ ↓ ┌─────────────────────────────────────────────────────┐ │ Layer 2: 跨链认证 (Cross-Chain Authentication) │ │ - SPV证明避免重复认证 │ │ - Merkle路径 + 轻客户端验证 │ └─────────────────────────────────────────────────────┘ ↓ ┌─────────────────────────────────────────────────────┐ │ Layer 1: 识别与代币化 (Identification \u0026amp; Token) │ │ - DID + VC构建RWA复合凭证 (RWA-CC) │ │ - 四模块设计:资产/身份/合规/托管 │ └─────────────────────────────────────────────────────┘ 技术细节 1. RWA复合凭证 (RWA-CC) 四大核心模块 Asset (资产模块)\n{ \u0026#34;assetId\u0026#34;: \u0026#34;did:ion:EiAa...asset123\u0026#34;, \u0026#34;assetType\u0026#34;: \u0026#34;RealEstate\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Residential\u0026#34;, \u0026#34;classDid\u0026#34;: \u0026#34;did:web:issuer.example.org:class:RE-RESIDENCE\u0026#34;, \u0026#34;tokenBinding\u0026#34;: { \u0026#34;standard\u0026#34;: \u0026#34;ERC-721\u0026#34;, \u0026#34;chain\u0026#34;: \u0026#34;eip155:1\u0026#34;, \u0026#34;contract\u0026#34;: \u0026#34;0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D\u0026#34;, \u0026#34;tokenId\u0026#34;: \u0026#34;1234\u0026#34; } } Identity (身份模块)\nidentifiers[]: 官方注册信息(登记方案、ID值、管辖区) taxonomies[]: 标准化分类码(如UNSPSC) spatialFootprint: GeoJSON格式的地理位置 documents[]: 契约、证书等加密哈希链接 attributes[]: 结构化事实(如面积120平米) Compliance (合规模块)\n{ \u0026#34;licenseId\u0026#34;: \u0026#34;example-2025-8899\u0026#34;, \u0026#34;sellableRegions\u0026#34;: [\u0026#34;CN-11\u0026#34;, \u0026#34;US-CA\u0026#34;], \u0026#34;restrictions\u0026#34;: [\u0026#34;NoCrossBorderSale\u0026#34;], \u0026#34;effectiveFrom\u0026#34;: \u0026#34;2025-01-01\u0026#34;, \u0026#34;effectiveTo\u0026#34;: \u0026#34;2026-01-01\u0026#34;, \u0026#34;regulatorDid\u0026#34;: \u0026#34;did:web:regulator.gov\u0026#34; } Custody (托管模块)\ncustodianDid: 托管人DID location: 物理存放位置 policy: 安全标准(如ISO-27001) auditCycleDays: 审计频率(如30天) insurancePolicyRef: 保险单引用 独立状态管理 每个模块都有独立的 sStatus (状态追踪) 和 sProof (密码学证明),支持:\n模块级别的撤销/暂停 选择性披露(仅透露必要字段) 分级验证(不同验证者看到不同内容) 2. SPV跨链认证协议 算法流程 (Algorithm 1) Phase 1: 源链承诺 (C₁)\n# 发行方在交易tx中嵌入承诺 commitment = { \u0026#34;assetId\u0026#34;: did_a, \u0026#34;credDigest\u0026#34;: hash(cred), \u0026#34;tokenBinding\u0026#34;: {...}, \u0026#34;epoch\u0026#34;: current_epoch, \u0026#34;nonce\u0026#34;: random() } # tx被包含在区块B中,B的头部有Merkle根μ Phase 2: 生成SPV证明\nπ ← SPV.Prove(tx, B) # π = (p, μ) # p: Merkle路径(从tx到根的兄弟哈希序列) # μ: 区块头中的Merkle根 Phase 3: 目标链验证 (C₂)\nfunction verifyCrossChainAuth( bytes memory tx, bytes32[] memory merklePath, bytes32 merkleRoot ) public returns (bool) { // 1. 检查μ对应C₁的有效区块头(轻客户端规则) require(isValidHeader(merkleRoot, chainC1)); // 2. 用路径p重新计算,验证tx包含在μ下 bytes32 computedRoot = recomputePath(tx, merklePath); require(computedRoot == merkleRoot); // 3. 解析tx中的承诺,验证与披露的cred字段一致 Commitment memory c = parseCommitment(tx); require(c.credDigest == hash(disclosedCred)); require(checkIssuerDID(c.assetId)); require(checkRevocationStatus(c.assetId)); return true; } 关键优势 避免重复: C₁上的DID解析、签名检查、撤销查询只需一次 轻量验证: C₂只需验证紧凑的Merkle证明 对数复杂度: 验证时间 T_SPV ≈ 0.69 × log₂(n) + 0.23 μs 3. 无需关闭的跨链通道 传统HTLC问题 每次交互需要4个链上操作: C₁: Lock → Unlock (2 ops) C₂: Lock → Unlock (2 ops) 总计: 4n ops (n次交互) xRWA跨链通道设计 (Algorithm 2) Phase 1: 开启通道\n// 双方在各自链上部署合约并存入保证金 Π.Open: ξ₁ on C₁ ← deposit d_Alice ξ₂ on C₂ ← deposit d_Bob // 此时无哈希锁条件 Phase 2: 链下批量协商\n# 多轮链下状态更新 σ₁: Alice pays v₁ for RWA batch S₁ = {a₁, a₂} σ₂: Alice pays v₂ for RWA batch S₂ = {a₃} σ₃: Alice pays v₃ for RWA batch S₃ = {a₄, a₅, a₆} ... # 签名的最终聚合状态 σ_final = { \u0026#34;totalPayment\u0026#34;: v₁ + v₂ + v₃, \u0026#34;totalRWAs\u0026#34;: S₁ ∪ S₂ ∪ S₃, \u0026#34;signatures\u0026#34;: [sig_Alice, sig_Bob] } Phase 3: 单次链上结算\n// 双方提交最终状态并安装HTLC条件 Π.Lock(σ_final): ξ₁.lock(totalPayment, h(ρ), T₁) // 超时T₁ ξ₂.lock(totalRWAs, h(ρ), T₂) // 超时T₂ \u0026lt; T₁ // 原子性解锁 if Bob reveals ρ before T₂: Π.Unlock on ξ₂: deliver all RWAs to Alice Π.Unlock on ξ₁: release payment to Bob before T₁ else: Π.Refund on ξ₂: return RWAs to Bob at T₂ Π.Refund on ξ₁: return payment to Alice at T₁ Phase 4: 通道持续运行\n可选择继续新的 Π.Update 轮次 或调用 Π.Close 释放剩余保证金 Gas成本对比 方案 n次交互的Gas消耗 节省比例 HTLC 465,426 × n 基准 xRWA通道 917,253 (固定) \u0026gt;99% (n≥2时) 性能评估 实验环境 硬件: Intel i9-13980HX, 32GB RAM 系统: Windows 11 (24H2) 实现: Python 3.12.10 (VC/SPV), Solidity 0.8.30 (合约) 测试网: Remix VM (Prague) 1. VC凭证大小与延迟 资产类型 VC大小(KB) 签发延迟(ms) 验证延迟(ms) 车辆 7.11 8.22 ± 9.04 1.09 ± 1.27 房地产 8.05 8.35 0.81 黄金 6.95 7.82 0.99 艺术品 7.38 8.23 0.85 债券 7.09 8.08 1.01 基金 7.27 8.17 1.02 知识产权 7.10 8.21 0.93 平均 7.27 8.16 ± 9.04 0.96 ± 1.27 测试配置: 500凭证, 100迭代, 8工作线程\n2. SPV验证可扩展性 实验拟合对数模型:\nT_SPV(n) ≈ 0.69 × log₂(n) + 0.23 μs 区块交易数(n) 验证时间(μs) 2⁵ = 32 3.75 2⁷ = 128 5.12 2⁹ = 512 6.48 2¹¹ = 2,048 7.85 2¹³ = 8,192 9.27 结论: 即使区块增大256倍(32→8,192),验证时间仅增长2.5倍\n应用场景 1. 房地产代币化 传统流程:\n链A: 完成KYC/AML, 签发VC, 代币化 链B: 重复KYC/AML, 重新签发VC xRWA流程:\n链A: 完成一次认证,生成SPV证明 链B: 验证SPV证明(\u0026lt; 10μs),直接接受 2. 跨链稳定币结算 场景: Alice(持USDT在以太坊) ↔ Bob(持房产代币在Polygon)\n批量交易示例:\nRound 1: Alice买房产A,B (100 USDT) Round 2: Alice买房产C (50 USDT) Round 3: Alice买房产D,E,F (150 USDT) 成本对比:\nHTLC: 3轮 × 465,426 gas = 1,396,278 gas xRWA: 917,253 gas (节省34%) 3. DAO治理 身份绑定: 通过DID确保一人一票 隐私保护: VC选择性披露(仅证明资格,不暴露详情) 跨链投票: SPV同步多链投票结果 4. DeFi空投防女巫 问题: 传统方式易被多账户攻击 方案: RWA-CC的 identity 模块验证唯一性 效果: 确保每个真实用户仅领取一次 安全性分析 威胁模型 已考虑的攻击:\n重放攻击: nonce + epoch 防止同一证明重用 伪造SPV: 轻客户端验证区块头工作量证明 凭证伪造: VC的发行方签名 + 撤销列表检查 双花攻击: HTLC的 T₁ \u0026gt; T₂ 时间锁机制 假设:\n至少一条链是诚实的(51%算力/权益) DID发行方遵循W3C规范 用户妥善保管私钥 形式化证明(简略) 定理1 (认证一致性): 如果RWA在链C₁通过验证,则SPV证明在链C₂的验证结果一致(除非C₁被51%攻击)。\n定理2 (原子性): 跨链通道的结算要么双方都完成,要么都退款(除非网络永久分区)。\n相关工作对比 项目/研究 单链/跨链 身份管理 认证机制 结算效率 MakerDAO [8] 单链 ❌ 中心化预言机 标准 HSBC金代币 [1] 单链 ❌ KYC/AML 标准 Securitize [21] 单链 部分 合规平台 标准 Chen et al. [5] 单链 ❌ 安全分析 N/A Zhao et al. [29] 单链 DAO治理 L2 Rollup 高 xRWA (本文) 跨链 DID+VC SPV 极高 首创性:\n✅ 首个系统性解决RWA跨链问题的框架 ✅ 首次将SPV应用于RWA认证 ✅ 首个支持无需关闭的RWA跨链通道 总结 xRWA通过DID/VC身份层 + SPV认证层 + 无需关闭的通道层,构建了首个完整的RWA跨链框架。在万亿美元规模的RWA市场即将到来之际,该方案为:\n🏠 房地产代币的全球流通 💰 跨链稳定币的高效结算 🗳️ 去中心化组织的身份治理 🎁 DeFi空投的防女巫机制 提供了关键的技术基础设施。SPV的对数复杂度和通道的99%+ Gas节省证明了方案的实用性,值得进一步在主网环境测试和优化。\n[!IMPORTANT]\n\u0026ldquo;For 𝑛 cross-chain interactions, the cross-chain channel requires only 917,253 gas in total, while the HTLC scheme consumes 465,426 × 𝑛 gas.\u0026rdquo; — 性能评估章节\n个人思考 优势 模块化设计: RWA-CC四模块可独立更新/撤销,灵活性强 标准兼容: 完全遵循W3C DID/VC规范,生态友好 实用性强: 公开代码、测试网部署、详细Gas成本分析 潜在限制 轻客户端依赖: SPV需要维护源链的区块头,增加存储成本 预言机问题: 链下资产状态更新(如房产出售)仍需可信预言机 监管挑战: 跨境RWA流动可能触发复杂的法律合规 改进方向 零知识优化: 用zkSNARK压缩SPV证明大小 动态通道: 支持多方(\u0026gt;2)参与的跨链通道 AI审计: 自动检测RWA凭证中的异常模式 标签: #RWA #跨链互操作 #DID #可验证凭证 #SPV #区块链 #Web3金融\n","permalink":"http://localhost:1313/blockchain/xrwa-cross-chain-real-world-assets/","summary":"xRWA是首个专门针对真实世界资产(RWA)跨链场景设计的完整框架。通过整合去中心化身份标识(DID)、可验证凭证(VC)和简化支付验证(SPV),解决了RWA在多链部署中的冗余认证和低效结算问题。系统采用三层架构:资产识别与代币化、跨链认证协议、跨链交互通道。实验显示SPV验证复杂度为O(log n),跨链通道比HTLC节省超过99%的gas成本。该框架为RWA的万亿美元市场潜力提供了关键的跨链基础设施。","title":"xRWA: 真实世界资产的跨链互操作性框架"},{"content":"论文基本信息 标题: A Comparative Survey of Centralised and Decentralised Identity Management Systems: Analysing Scalability, Security, and Feasibility 作者: Aviral Goel, Yogachandran Rahulamathavan 机构: Loughborough University, Institute for Digital Technologies 发表期刊: Future Internet 2025, 17(1) 发表时间: 2024年12月24日 DOI: https://doi.org/10.3390/fi17010001 研究背景与动机 数字身份的重要性 在网络犯罪高发的时代，数字身份已成为关键资产：\n敏感信息保护：包含姓名、年龄、银行信息等个人数据 服务访问凭证：用于社交媒体、银行、购物等在线服务 安全防护需求：防止身份盗窃和未经授权的访问 身份认证技术演进历程 1990年代初期：简单的用户名+密码认证\n主要问题：用户在多个站点重复使用相同密码 安全隐患：密码管理效率低，容易发生安全漏洞 2000年代至今：引入复杂认证机制\n单点登录（SSO）：一次登录访问多个应用 多因素认证（MFA）：增加额外验证层 生物识别认证：指纹、人脸识别等 传统中心化系统面临的挑战 1. 单点故障风险（Single Point of Failure）\n中央服务器故障导致整个系统不可用 典型案例：2021年微软 Azure AD 故障持续数小时，影响全球服务 2. 隐私安全问题\n所有用户数据集中存储，成为攻击者的首要目标 典型案例：2021年 Facebook 数据泄露，5.33亿用户记录被盗 3. 可扩展性瓶颈\n用户数量增长导致中央服务器负载过高 需要持续投入硬件资源进行扩容 研究方法论 文献检索策略 主要数据库来源：\nGoogle Scholar（初步广泛检索） IEEE Xplore（技术论文） ACM Digital Library（计算机科学） SpringerLink（综合学术） 时间范围设定：2015-2024年\n确保技术相关性和时效性 覆盖区块链技术成熟期 核心检索词组合（e.g.）：\n(\u0026#34;decentralized identity management\u0026#34; OR \u0026#34;self-sovereign identity\u0026#34; OR \u0026#34;DID\u0026#34;) AND (\u0026#34;blockchain\u0026#34; OR \u0026#34;Hyperledger Indy\u0026#34; OR \u0026#34;Sovrin\u0026#34;) AND (\u0026#34;scalability\u0026#34; OR \u0026#34;security\u0026#34; OR \u0026#34;feasibility\u0026#34;) 筛选结果：经过系统筛选标题和摘要，最终纳入约90篇高质量论文，这些论文均衡地描述了去中心化和集中式 IdM 系统，重点关注它们各自的优势、挑战和未来潜力。\n评估维度框架 论文从5个关键维度对身份管理系统进行全面对比：\n可扩展性（Scalability）：系统处理用户数量增长的能力 可靠性（Reliability）：系统持续稳定运行的能力 安全性（Security）：防护数据泄露和网络攻击的能力 适应性（Adaptability）：与现有系统集成的灵活性 成本（Cost）：部署和维护的经济投入 中心化身份管理系统（CIMS） 核心架构设计 基本工作流程：\n用户 → 服务提供商(SP) → 身份提供商(IdP) ↓ 验证凭证 \u0026amp; 发放令牌 ↓ 授予服务访问权限 关键组件说明：\n身份提供商（IdP）：集中管理所有用户身份数据和凭证 服务提供商（SP）：用户实际交互的应用程序或服务 认证服务器：负责处理和验证用户的认证请求 单点登录（SSO）：允许用户一次认证后访问多个应用 主流中心化协议详解 1. LDAP（轻量级目录访问协议） 技术特征：\n基于目录的分层结构存储用户信息 采用客户端-服务器通信模型 广泛应用于 Microsoft Active Directory 等企业环境 认证工作流程：\n客户端发送 Bind 请求，包含 DN（Distinguished Name）和密码 服务器在目录信息树（DIT）中验证凭证 服务器搜索匹配的用户条目 返回认证成功或失败的结果 安全机制与问题：\n默认情况下以明文传输凭证（存在安全风险） 必须配置 SSL/TLS 加密以保护数据传输 配置复杂，需要专业知识进行规划和部署 性能指标：\n优化环境下可达 10,000 查询/秒 典型响应时间低于 200 毫秒 2. RADIUS（远程认证拨号用户服务） 协议特性：\n基于 UDP 协议通信 端口 1812：认证服务 端口 1813：计费服务 提供 AAA 服务（认证、授权、计费） 主要应用于 VPN、WLAN 等网络接入场景 数据包类型：\nCode 1：客户端访问请求 Code 2：认证成功响应 Code 3：访问拒绝响应 安全挑战：\nMD5 加密算法已被认为不够安全 容易遭受 DoS（拒绝服务）攻击 Request Authenticator 随机性不足可能产生安全漏洞 3. SAML（安全断言标记语言） 应用场景：\n企业级单点登录（SSO）解决方案 跨组织域的身份联合认证 完整工作流程：\n用户向服务提供商（SP）请求访问受保护资源 SP 生成 SAML 认证请求并重定向到身份提供商（IdP） IdP 验证用户身份并生成 SAML 断言（Assertion） 用户携带 SAML 断言返回 SP SP 验证断言的数字签名 验证通过后授予用户访问权限 安全保障措施：\n使用数字签名确保断言的完整性和真实性 通过 HTTPS 协议传输防止中间人攻击 实施会话管理机制防止会话劫持 系统局限性：\n配置过程复杂，部署周期较长 依赖中心化的 IdP（存在单点故障风险） 需要注意 XML 相关的安全漏洞 4. OAuth 2.0（开放授权标准） 核心设计优势：\n用户无需向第三方应用共享账号密码 使用时限令牌（Access Token）限制潜在滥用 被 Google、Facebook、Microsoft 等主流平台广泛采用 系统关键角色：\n资源所有者（Resource Owner）：拥有数据的用户 客户端（Client）：请求访问资源的第三方应用 授权服务器（Authorization Server）：负责颁发访问令牌 资源服务器（Resource Server）：存储和提供受保护数据 授权码模式流程：\n1. Client → Authorization Server: /authorize 请求 参数包括: response_type=code, client_id, redirect_uri, scope, state 2. 用户授权 → Authorization Server 返回授权码（Authorization Code） 3. Client → Authorization Server: /token 请求 使用授权码换取 Access Token 4. Client 使用 Access Token 访问资源服务器 5. 资源服务器验证 Token 合法性后返回数据 6. Token 过期后可使用 Refresh Token 获取新的 Access Token 常见安全漏洞：\n过度权限请求：应用请求超出功能需要的访问范围 缺乏用户控制：UI 设计诱导用户授予所有权限 令牌重放攻击：攻击者拦截并重复使用 OAuth 令牌 安全缓解措施：\n实施细粒度的权限控制机制 设置较短的令牌有效期（如1小时） 强制使用 HTTPS 防止令牌被拦截 检测到滥用时立即撤销相关令牌 中心化系统的优势与挑战 主要优势：\n部署简单，成本相对较低（中小企业初始投入 \u0026lt; $10,000） 集中化管理，便于统一实施安全策略 技术成熟稳定，供应商支持体系完善 具备良好的水平扩展能力（如 LDAP、OAuth） 面临挑战：\n单点故障风险：中央服务器故障影响整个系统 隐私问题：数据集中存储容易成为攻击目标 可扩展性受限：中央服务器性能成为瓶颈 灵活性不足：集成新技术和协议较为困难 去中心化身份管理系统（DIMS） 核心理念：自主身份（SSI） Self-Sovereign Identity 核心原则：\n用户完全拥有和控制自己的身份数据 不依赖任何中心化权威机构 支持选择性披露信息（Selective Disclosure） 数据存储在用户本地或分布式网络中 关键技术组件 1. 去中心化标识符（DID） 核心特点：\n全局唯一的身份标识符 基于密码学密钥对生成 公钥发布在区块链上供验证 私钥由用户安全保管，不可泄露 DID 文档内容：\n用户的公钥信息 可访问的服务端点 支持的身份验证方法 2. 可验证凭证（VC） 基本定义：数字化的身份证明文档，类似于电子版的护照或驾驶执照\n技术特征：\n由可信的颁发机构进行数字签名 存储在用户的数字钱包应用中 可通过加密技术验证真伪 支持零知识证明技术 3. 区块链与分布式账本技术（DLT） 系统作用：\n存储 DID 文档和凭证的哈希值 通过密码学保证数据不可篡改 提供透明的验证机制 消除对中心化服务器的依赖 主要共识机制：\n拜占庭容错（BFT）：用于 Hyperledger Indy、Sovrin 工作量证明（PoW）：用于 Bitcoin（Blockstack、ShoCard） 权益证明（PoS）：用于 Ethereum（uPort） 4. 零知识证明（ZKP） 核心能力：在不暴露具体数据的情况下向他人证明某个事实为真\n实际应用示例：\n证明\u0026quot;年满18岁\u0026quot;而不需要透露确切的出生日期 证明\u0026quot;账户余额大于1000美元\u0026quot;而不显示具体金额 证明\u0026quot;拥有某项资质\u0026quot;而不泄露其他无关信息 去中心化身份系统架构 系统层次结构：\n用户层（持有 DID + 私钥） ↓ 数字钱包层（存储可验证凭证 VC） ↓ 区块链网络层（存储 DID 文档 + 凭证证明） ↓ 验证方（验证 VC 的真实性和有效性） 完整认证流程：\n用户向验证方出示可验证凭证（VC） 验证方从区块链获取凭证颁发者的公钥 使用公钥验证凭证的数字签名有效性 检查凭证是否已被撤销 用户选择性披露必要的属性信息 验证通过后授予服务访问权限 主流去中心化身份平台深度分析 1. Hyperledger Indy 基本信息：\n许可型区块链（Permissioned Blockchain） 基于 Linux Foundation Hyperledger 项目 专为自主身份（SSI）设计 技术架构：\n验证者节点（Validators）：由受信任的管理员（Stewards）运营 共识算法：Plenum BFT（拜占庭容错） 多链设计： Domain TXs：存储域特定数据和交易元数据 Pool TXs：管理验证者配置和操作 Config TXs：存储网络参数和策略更新 核心特性：\n支持零知识证明（ZKP）技术 符合 GDPR 等隐私法规要求 支持动态配置修改能力 性能特点：\n写延迟始终低于读延迟 性能受验证者数量和交易速率影响 使用 Docker 容器化部署便于管理 局限性分析：\n可扩展性受 BFT 共识机制限制（计算开销较大） 添加新验证者需要投票过程，影响扩展速度 开源代码相对受限，部署过程较为复杂 最新进展：\nIndy Besu 项目引入模块化架构 兼容许可型和无许可型网络 显著提升交易吞吐量和灵活性 适用场景：\n企业级身份管理系统 政府数字身份基础设施 医疗健康记录管理平台 2. Sovrin Network 基本信息：\n基于 Hyperledger Indy 框架构建 拥有独立加密货币 SOV 用于激励验证者 具备完善的治理框架体系 四层架构设计：\nLayer 1: 账本层（Ledger Layer）\n存储 DID、凭证定义、撤销注册表 使用 RBFT（冗余拜占庭容错）共识机制 保证数据的保密性和完整性 Layer 2: 代理层（Agent Layer）\n管理点对点的安全连接 通过 DIDComm 协议进行加密通信 包括边缘代理（用户设备）和云代理（服务器） Layer 3: 治理层（Governance Layer）\nSovrin 治理框架（SGF）制定运营规则 确保符合法律、安全和隐私要求 所有参与者必须遵守统一标准 Layer 4: 应用层\n支持各类基于 Sovrin 的应用开发 系统优势：\nRBFT 机制提供高容错性（即使部分节点失效仍可运行） 代币激励机制促进生态系统发展 完善的治理框架确保系统可信度 局限性分析：\n依赖 Steward（受信任组织）运营节点，增加一定中心化风险 可扩展性和可移植性仍在早期发展阶段 复杂的治理机制对普通用户不够友好 3. Blockstack 基本信息：\n基于 Bitcoin 区块链构建 使用区块链名称系统（BNS）替代传统 DNS 配备去中心化存储系统 Gaia 核心组件详解：\nBNS（Blockchain Name System）\n将人类可读的名称绑定到公钥 名称注册采用两阶段流程： 预订阶段：生成哈希并记录到区块链 注册阶段：等待期后将名称正式绑定到区块链 VirtualChain（虚拟链）\n作为抽象层独立于底层区块链运行 提升系统速度和灵活性 降低直接操作区块链的复杂度 Atlas 网络\n点对点的数据索引和查找系统 处理 BNS 数据的传播和同步 Gaia 存储系统\n去中心化存储解决方案 数据使用用户私钥签名防止篡改 兼容 Dropbox、Amazon S3 等现有云服务 身份管理流程：\n用户注册过程：\n预订名称（生成加密哈希） 经过强制等待期 完成注册，名称加密绑定到公钥 身份认证过程：\n用户提交 Blockstack ID 提供私钥作为所有权证明 系统验证私钥与公钥是否匹配 密钥撤销与恢复：\n通过名称转移流程将 ID 所有权转移到新地址 密钥撤销后禁用该身份的所有后续操作 独特优势：\n动态定价机制：需求高的名称价格更高 跨链迁移能力：区块链故障时可转移身份到其他链 分叉恢复机制：通过共识哈希检测并纠正不一致状态 局限性分析：\n加密、解密、签名验证的开销影响实时性能 多层架构（区块链+P2P网络+存储）管理复杂 大规模部署需要专业技术人员支持 4. uPort 基本信息：\n基于 Ethereum 区块链平台 完全开源的身份解决方案 通过移动应用安全存储私钥 智能合约架构：\n用户创建身份时会生成两个关键智能合约：\n代理合约（Proxy Contract）\n作为持久化的唯一身份标识 与区块链网络上其他合约进行交互 在私钥和区块链之间添加抽象层 允许密钥恢复而不改变身份本身 控制器合约（Controller Contract）\n维护访问控制策略 允许用户向代理合约进行身份认证 即使私钥丢失也能保护身份完整性 密钥恢复机制：\n恢复法定人数合约（Recovery Quorum Contract）\n由一组受信任的个人（恢复代表）共同控制 当用户私钥丢失时协助恢复身份控制权 采用去中心化方式，无需依赖中心化权威机构 数据存储策略：\n链上数据：智能合约处理核心身份功能 链下数据： 存储在 IPFS 等去中心化存储平台 包括个人资料、证明文件、身份属性 通过注册合约加密链接到 uPort 身份 系统优势：\n用户完全控制自己的身份数据 人性化的密钥恢复机制 链上链下结合优化存储成本和效率 局限性分析：\n依赖 Ethereum 网络（受其可扩展性和交易费用限制） 链下存储方案需要信任所选择的存储服务 主要基于 Ethereum，跨链可移植性和互操作性受限 恶意节点可能追踪和关联 uPort ID 的活动记录，存在隐私风险 5. EverID 基本信息：\n基于许可型 Ethereum 区块链 非开源系统（闭源商业方案） 支持多货币跨境金融交易 技术特点：\n数字身份整合政府 ID、生物特征、第三方认证 数据存储在云端（用户无需移动设备也可使用） 利用生物识别技术创建唯一用户身份 核心组件：\nEverID Datagram：存储生物特征标识符数据 去中心化应用（DApp）：提供自助注册和身份管理功能 应用程序接口（API）：与其他服务进行安全集成 核心智能合约：管理身份创建、验证和交易流程 超级节点（Super Nodes）：存储 Datagram 的副本以提高可用性 局限性分析：\n数据最小化原则未完全实现：验证声明时需要披露所有信息 许可型区块链引入一定程度的中心化（访问受限于批准的参与者） 用户和交易规模增长可能导致： 运营成本持续增加 交易处理速度变慢 整体用户体验下降 6. ShoCard 基本信息：\n基于 Bitcoin 公有区块链 用户身份信息以加密哈希形式存储 第三方验证者通过区块链验证用户身份 核心设计理念：\n私人信息不存储在任何中央位置 用户可在不分散身份碎片的情况下证明账户所有权 使用加密哈希将用户标识符与可信凭证（护照、驾照等）关联 三阶段工作流程：\n阶段1: 引导（Bootstrapping）\nShoCard 移动应用生成加密密钥对 扫描用户的身份凭证（如护照） 凭证数据加密后作为签名哈希存储在 Bitcoin 交易中 生成唯一的 ShoCardID 作为区块链上的参考点 阶段2: 认证（Certification）\n用户与服务提供商进行交互 向用户身份添加经过验证的属性 属性被哈希处理、数字签名并存储在区块链上 阶段3: 验证（Validation）\n依赖方从区块链检索认证信息 验证数字签名的有效性 将数据与区块链记录进行对比 确认用户身份的真实性和有效性 系统优势：\n利用 Bitcoin 区块链的高安全性和全球接受度 无需中心化数据库存储敏感身份信息 用户完全控制自己的身份数据共享 局限性分析：\n依赖中央服务器处理部分功能，引入中心化风险 如果 ShoCard 公司停止运营，用户可能丧失数据访问权 缺乏全向标识符（Omnidirectional Identifiers），限制扩展到更广泛生态 Bitcoin 交易确认延迟（约10分钟）在实时验证场景下存在问题 7.小结 平台 底层区块链 共识机制 核心特色 主要优势 主要局限 Hyperledger Indy 自有许可型链 Plenum BFT SSI专用,支持ZKP 隐私保护强,符合GDPR 扩展性受限,部署复杂 Sovrin Network Hyperledger Indy RBFT 四层架构,SOV代币激励 治理完善,容错性高 依赖Steward,有中心化风险 Blockstack Bitcoin PoW BNS系统,Gaia去中心化存储 跨链迁移能力,动态定价 性能开销大,架构复杂 uPort Ethereum PoS/PoW 智能合约身份,移动优先 用户完全自控,恢复机制好 依赖Ethereum,交易费高 EverID 许可型Ethereum 许可型 生物识别,云端存储 生物识别方便,支持跨境金融 中心化,隐私保护较弱 ShoCard Bitcoin PoW 加密哈希,三阶段验证 Bitcoin安全性高,用户自控 确认慢(约10分钟),依赖中央服务器 中心化 vs 去中心化：全面对比分析 1. 可扩展性（Scalability） 中心化系统的表现 优势特点：\nLDAP 和 OAuth 经过数十年优化，支持灵活的水平和垂直扩展 LDAP 在优化环境下可处理 10,000 查询/秒，响应时间低于 200ms OAuth 能够高效处理大量基于令牌的访问请求 SAML 的联邦模型支持跨多个组织域的扩展 性能瓶颈：\n单点控制架构在系统规模增长时可能引入性能瓶颈 需要持续增加硬件资源以应对用户增长 去中心化系统的表现 核心挑战：可扩展性主要受共识机制的计算复杂度限制\n性能对比表：\n系统 共识机制 吞吐量（TPS） 关键特点 Ethereum (uPort) PoS 15-30 Layer-2 方案可提升至 1000-4000 TPS Bitcoin (Blockstack/ShoCard) PoW 约7 挖矿计算开销大，确认时间约10分钟 Hyperledger Indy (Sovrin) RBFT 约300 可容忍 33% 节点故障 LDAP (中心化) N/A 10,000+ 支持多主复制 最新技术进展：\nIndy Besu 项目：模块化架构，兼容许可型和无许可型网络，提升吞吐量 Ethereum Layer-2 解决方案（Optimistic Rollups、zkRollups）显著改善扩展性 2. 可靠性（Reliability） 中心化系统的可靠性保障 技术机制：\n多主复制（Multi-Master Replication）技术 备份服务器可在几秒钟内接管服务 LDAP 系统年度停机时间通常低于 1% 典型风险案例：\n2021年微软 Azure AD 故障：持续数小时，影响全球范围内的服务访问 去中心化系统的可靠性优势 核心优势：\n分布式网络架构：单个节点故障不影响整体系统运行 RBFT 共识机制：即使 33% 的节点出现故障仍可维持运行 无单点故障风险，系统韧性更强 技术权衡：\n节点添加或配置更新时可能出现临时的数据同步延迟 需要更复杂的协调机制确保网络一致性 3. 安全性（Security） 中心化系统的安全措施 主要防护机制：\nLDAP：使用 SSL/TLS 加密凭证传输过程 OAuth：强制 HTTPS 传输 + 时限令牌（TTL）机制 SAML：XML 加密技术 + 数字签名验证 重大安全事件：\n2021年 Facebook 数据泄露：5.33亿用户记录被窃取 主要攻击面：\n中央服务器一旦被攻破，所有用户数据面临风险 容易遭受暴力破解攻击和令牌重放攻击 去中心化系统的安全优势 先进安全技术：\n零知识证明（ZKP）：可以证明\u0026quot;年满18岁\u0026quot;而无需透露具体出生日期 选择性披露：用户仅分享验证所需的最少信息 区块链不可篡改性：数据一经写入区块链即无法修改 无中央数据库：消除单点大规模数据泄露风险 潜在安全风险：\nBFT 共识机制漏洞：恶意节点串通可能导致系统延迟或操纵 智能合约缺陷：代码漏洞可能导致未授权操作 密钥管理挑战：私钥丢失或被盗通常无法恢复（最大安全隐患） 高交易负载下延迟增加，可能间接影响安全性和性能 4. 适应性（Adaptability） 中心化系统的集成优势 技术成熟度：\n经过数十年的企业级应用实践 提供丰富的 API 库和集成工具 与 SSO、云服务平台可以无缝对接 显著减少系统部署时间和技术复杂度 适用场景：\n需要快速部署上线的企业项目 现有 IT 基础设施已经成熟的大型组织 去中心化系统的集成挑战 主要技术障碍：\n需要开发中间件桥接区块链操作与传统 IT 环境 Hyperledger Indy 集成企业数据库需要定制开发 API 公有链（uPort）受 Gas 费用和网络吞吐量限制 私有链（Sovrin、Indy）虽然提供更多控制权，但初始设置复杂 系统过渡要求：\n需要进行重大的基础设施升级改造 IT 团队必须重新培训以管理分布式系统 整体实施成本和周期显著增加 5. 成本（Cost） 中心化系统的成本结构 经济优势：\n中小企业初始部署成本通常低于 $10,000 运营成本主要包括基础设施维护和定期系统更新 开源工具和完善的供应商支持降低总拥有成本 LDAP 等系统的最小硬件需求减少经常性开支 适用对象：预算相对固定的中小型企业\n去中心化系统的成本结构 详细成本对比：\n成本项目 私有链（Sovrin/Indy） 公有链（uPort/Ethereum） 验证者节点部署 $5,000-$10,000/节点 不适用 整体系统部署 $10,000-$50,000 取决于网络活动量 运营成本 节点维护和管理费用 交易 Gas 费（高峰期 $1-$20/笔） 人力成本 员工再培训或聘请区块链专家 同左 专业支持 需要区块链技术专家 需要智能合约开发者 高频交易场景的成本影响：\n公有链的交易费用在高峰期可能急剧上升 不适合成本敏感且需要频繁身份验证的应用场景 适用对象：\n资源充足的大型组织 长期战略侧重去中心化控制和数据主权 重视隐私法规合规性（如 GDPR）的行业 研究结论 核心发现 本综述论文通过对中心化和去中心化身份管理系统的全面分析，揭示了两种范式各有优劣，不存在普适的最优解决方案。组织需要根据自身需求在可扩展性、成本效益、安全性和复杂度之间做出权衡决策。\n中心化系统的当前优势地位 为何仍是主流选择：\n成熟稳定：经过数十年实战验证，提供可靠的身份认证服务 易于部署：快速上线，无需大规模基础设施改造 成本可控：中小企业初始投入 \u0026lt; $10,000 规模处理：优化后可达 10,000+ TPS，支持水平扩展 安全增强：现代系统通过多因素认证（MFA）和加密会话提升防护能力 适用场景：\n内部企业应用和员工访问管理 需要快速部署的项目 预算和技术资源有限的中小企业 高性能要求场景（低延迟、高并发） 去中心化系统的创新价值 核心优势：\n用户数据主权：将身份控制权交还给用户，消除对中心化机构的依赖 隐私保护：零知识证明（ZKP）实现选择性披露，符合 GDPR 等严格法规 透明性：区块链不可篡改特性确保操作可追溯 高韧性：无单点故障风险，RBFT 共识可容忍 33% 节点故障 面临挑战：\n复杂架构：需要专业区块链工程师和长期学习曲线 高成本：初始部署 $10,000-$50,000，持续运营费用较高 性能瓶颈：共识机制限制吞吐量（BFT ~300 TPS, PoW ~7 TPS） 集成困难：与传统 IT 系统对接需要定制中间件 适用场景：\n高度监管行业（医疗、金融、政府） 数据主权和隐私要求极高的应用 Web3 原生应用（DApps、NFT、DeFi） 拥有专业团队和长期战略投资的大型组织 未来发展展望 1. 混合身份管理模式（Hybrid Approach） 核心理念：结合中心化系统的易用性与去中心化系统的安全性\n两种融合路径：\n路径A：中心化系统增强去中心化特性\n通过 API 集成区块链验证层 关键身份操作记录在链上（不可篡改审计） 用户可选择将身份哈希锚定到公有链 保留现有认证服务器处理日常登录 优势：最小化破坏性改造，逐步提升安全性和用户控制权\n路径B：去中心化系统集成中心化便利性\n区块链作为信任根（Root of Trust） 中心化服务处理高频低风险操作 提供传统 API 接口便于企业集成 可选的托管钱包服务降低使用门槛 优势：继承区块链安全性，改善用户体验和性能\n先行者案例：\nYoti - 智能身份验证平台\n用户友好的移动应用 + 区块链锚定身份 支持零知识属性共享（选择性披露） 被英国政府采用进行年龄验证 符合 GDPR 和 eIDAS 法规 EarthID - 去中心化身份生态\n基于区块链 DID 注册 + 中央索引服务 提供托管钱包和友好 Web 界面 无缝集成现有企业系统 支持教育、医疗、企业等多领域应用 2. 零知识证明（ZKP）与中心化系统的深度融合 技术价值：在不暴露敏感数据的情况下完成身份验证\n实际应用示例：\n银行贷款：证明\u0026quot;年收入 \u0026gt; $50,000\u0026quot;而不透露具体金额 年龄验证：证明\u0026quot;年满18岁\u0026quot;而不泄露确切出生日期 资质认证：证明\u0026quot;拥有某项资质\u0026quot;而不显示其他信息 实施路径：\n通过 API 网关集成 ZKP 验证模块 中央服务器无需存储原始敏感数据 用户在本地客户端生成 ZKP 证明 符合数据最小化原则（GDPR 要求） 3. 区块链可扩展性技术突破 Layer-2 扩展方案：\n技术方案 代表项目 TPS 提升 关键特点 Optimistic Rollup Optimism 1,000-4,000 继承以太坊安全性 ZK Rollup zkSync, StarkNet 2,000-20,000 数学证明，更强安全性 Sharding Ethereum 2.0 未来 100,000+ 分片技术，大规模扩展 Sharding（分片技术）：\n将网络划分为多个并行处理的分片 显著提升整体吞吐量 预计可达 100,000+ TPS 对身份管理的影响：\n降低交易成本：Gas 费降低 100-1000 倍 提升用户体验：交易确认从分钟级降至秒级 支持大规模采用：移除性能瓶颈，支撑全球性身份系统 个人思考 1. 论文的主要贡献 优点：\n✅ 系统性全面：覆盖 LDAP 到 Sovrin 的广泛技术光谱 ✅ 评估框架清晰：5 个维度对比（可扩展性、可靠性、安全性、适应性、成本） ✅ 实践指导价值：为组织选型提供具体的决策依据 ✅ 前沿性：纳入 2024 年最新研究成果 不足之处：\n⚠️ 性能数据来源不够透明：部分 TPS 数据缺乏实验环境细节 ⚠️ 混合模式探讨不够深入：仅简要提及 Yoti 和 EarthID，缺乏架构细节 ⚠️ 成本分析偏粗略：未考虑不同规模组织的具体成本差异 2. 技术发展的关键矛盾 性能 vs 去中心化的永恒权衡：\n区块链的\u0026quot;不可能三角\u0026quot;（Trilemma）始终存在：\n去中心化：节点分布越广，安全性越高 安全性：共识机制越复杂，攻击成本越高 可扩展性：吞吐量越高，对去中心化和安全性的妥协越大 思考：纯粹的去中心化身份系统短期内难以在性能上超越中心化方案，混合模式可能是更现实的过渡路径。\n3. 用户体验的挑战被低估 私钥管理的用户负担：\n普通用户难以理解\u0026quot;私钥丢失 = 身份永久丢失\u0026quot;的概念 助记词备份机制对非技术用户不友好 缺乏类似\u0026quot;忘记密码\u0026quot;的容错机制 解决方向：\n社交恢复机制（通过可信联系人恢复） 生物识别与私钥结合（如 Apple 的 Secure Enclave） 托管钱包服务（牺牲部分去中心化换取便利性） 个人观点：去中心化身份要真正普及，必须在用户体验上实现\u0026quot;隐形化\u0026quot;——用户享受好处而无需理解底层复杂性。\n4. 监管与创新的博弈 现实困境：\n去中心化身份挑战现有监管框架（如 KYC/AML） 完全匿名性与政府监管需求冲突 不同司法管辖区法规不一致 可能的平衡点：\n选择性披露 + 监管机构特权访问 零知识证明满足合规要求（证明合规而不泄露数据） 国际标准化组织推动跨国互认（如 W3C DID 标准） 5. Web3.0 身份的终极愿景 理想状态：\n用户拥有唯一的全球数字身份（跨平台、跨国界） 一次身份验证即可访问所有服务（真正的 SSO） 用户完全控制个人数据的访问权限 身份数据可移植，不被任何平台锁定 实现路径的现实考量：\n技术成熟度：需要 5-10 年持续优化 商业模式转变：互联网巨头依赖用户数据盈利，缺乏动力放弃控制权 用户教育：需要长期的认知普及和习惯培养 监管协调：全球范围内法规统一是巨大挑战 个人预测：去中心化身份将首先在特定垂直领域（医疗、教育、金融）取得突破，而非一蹴而就的全面替代。混合模式将在未来 5 年内成为主流，纯粹的去中心化可能需要等待下一代互联网基础设施的成熟。\n参考资料 原论文：Future Internet 2025, 17(1) Hyperledger Indy: https://www.hyperledger.org/use/hyperledger-indy Sovrin Network: https://sovrin.org/ uPort: https://www.uport.me/ Blockstack: https://www.stacks.co/ W3C DID 标准: https://www.w3.org/TR/did-core/ W3C Verifiable Credentials: https://www.w3.org/TR/vc-data-model/ Yoti: https://www.yoti.com/ EarthID: https://www.earthid.io/ ","permalink":"http://localhost:1313/blockchain/identity-management-systems-survey/","summary":"深度解读 Web3.0 身份认证领域的最新综述论文，对比分析中心化（LDAP、SAML、OAuth）与去中心化（Hyperledger Indy、Sovrin、uPort）身份管理系统的优劣势","title":"Web3.0 身份认证系统综述：中心化与去中心化方案对比分析"},{"content":"定江你能不能不要点我的名，啊啊啊 ","permalink":"http://localhost:1313/dase-course/mathematical-fundamentals-lecture/","summary":"黄老师上的课","title":"数学基础数学篇"},{"content":"第一讲 算法分析 一、算法简介 算法分析是计算机科学的基础，用于评估算法的效率和资源消耗。\n算法复杂度分析：\n时间复杂度：衡量算法执行时间随输入规模增长的趋势 空间复杂度：衡量算法所需存储空间随输入规模增长的趋势 渐近分析：O、Ω、Θ记号 常见复杂度类型：\nO(1)：常数时间 O(log n)：对数时间 O(n)：线性时间 O(n log n)：线性对数时间 O(n²)：平方时间 O(2ⁿ)：指数时间 算法设计范式：\n分治法（Divide and Conquer） 动态规划（Dynamic Programming） 贪心算法（Greedy Algorithm） 回溯法（Backtracking） 分支界定法（Branch and Bound） 二、相似度搜索 相似度搜索是在大规模数据中找到与查询对象相似的数据项。\n相似度度量：\n欧氏距离（Euclidean Distance）： d(x, y) = √(Σ(xᵢ - yᵢ)²) 曼哈顿距离（Manhattan Distance）： d(x, y) = Σ|xᵢ - yᵢ| 余弦相似度（Cosine Similarity）： sim(x, y) = (x·y) / (||x|| ||y||) Jaccard相似度： J(A, B) = |A ∩ B| / |A ∪ B| 应用场景：\n推荐系统 图像检索 文档相似度检测 近似最近邻搜索（ANN） 朴素方法的局限： 线性扫描的时间复杂度为O(n)，对于大规模数据集不可行。\n三、高维空间的相似性搜索 在高维空间中，传统的索引结构（如KD树）性能退化严重，这被称为\u0026quot;维度灾难\u0026quot;。\n维度灾难（Curse of Dimensionality）：\n数据点之间的距离趋于相等 数据点趋向于分布在空间的\u0026quot;表面\u0026quot; 索引结构的效率降低 解决方案：\n1. 降维技术：\n主成分分析（PCA） 随机投影 t-SNE 2. 近似算法：\n局部敏感哈希（LSH）：将相似的点以高概率映射到同一个桶 乘积量化（Product Quantization）：将向量空间分解为子空间 HNSW（Hierarchical Navigable Small World）：基于图的近似最近邻搜索 LSH的基本原理：\n使用哈希函数族h，满足：相似的对象碰撞概率高，不相似的对象碰撞概率低 通过多个哈希函数和多个哈希表提高召回率 查询时只需检查哈希到同一桶的候选点 第二讲 尾不等式 一、尾不等式分析概要 尾不等式用于界定随机变量偏离其期望值的概率，在算法分析和概率算法设计中具有重要作用。\n为什么需要尾不等式：\n期望值只描述了平均情况 需要了解\u0026quot;坏情况\u0026quot;发生的概率 为随机算法提供性能保证 应用领域：\n随机算法分析 负载均衡 哈希表性能分析 采样算法 二、三个常见的尾不等式 1. Markov不等式（马尔可夫不等式）：\n对于非负随机变量X和a \u0026gt; 0：\nP(X ≥ a) ≤ E[X] / a 特点：\n只需要知道期望 界比较松 适用于任何非负随机变量 2. Chebyshev不等式（切比雪夫不等式）：\n对于随机变量X，有：\nP(|X - E[X]| ≥ a) ≤ Var(X) / a² 特点：\n需要知道期望和方差 比Markov不等式更紧 不需要独立性假设 3. Chernoff界（切尔诺夫界）：\n对于独立的随机变量X₁, X₂, \u0026hellip;, Xₙ ∈ [0,1]，令X = ΣXᵢ，μ = E[X]：\nP(X ≥ (1+δ)μ) ≤ e^(-δ²μ/3) (0 \u0026lt; δ ≤ 1) P(X ≤ (1-δ)μ) ≤ e^(-δ²μ/2) (0 \u0026lt; δ ≤ 1) 特点：\n界最紧，指数级衰减 需要独立性假设 广泛应用于随机算法分析 三、计数问题 问题描述： 估计一个数据流中不同元素的个数（基数估计）。\n朴素方法的问题：\n存储所有元素需要O(n)空间 对于大规模数据流不可行 概率计数算法：\nFlajolet-Martin算法：\n使用哈希函数h将元素映射到[0, 2^L-1] 对每个元素计算其哈希值的尾部0的个数 记录观察到的最大尾部0个数R 估计值：2^R 原理：\n如果有n个不同元素，期望看到log₂(n)个尾部0 使用多个哈希函数取平均值提高精度 空间复杂度：O(log log n) HyperLogLog算法：\nFlajolet-Martin的改进版本 使用调和平均数代替算术平均数 精度更高，误差约为1.04/√m（m为桶数） 空间效率极高 第三讲 数据流 一、数据流模型 数据流模型描述了数据以流的形式到达，只能顺序访问一次或有限次的计算场景。\n数据流的特点：\n数据量巨大，无法全部存储 数据到达速度快，需要实时处理 只能进行一次或有限次扫描 需要在有限空间内近似计算 典型应用：\n网络流量监控 金融交易分析 社交媒体数据处理 IoT传感器数据 数据流算法的目标：\n使用亚线性（sublinear）空间 提供可证明的近似保证 单次扫描或少量扫描 二、频繁元素-确定性算法 问题定义： 找出数据流中出现频率超过某个阈值的元素（heavy hitters）。\nMisra-Gries算法：\n算法描述：\n维护最多k个计数器 对于每个到来的元素： 如果已有计数器，增加其计数 如果没有计数器且有空位，创建新计数器 如果没有空位，所有计数器减1，删除值为0的计数器 输出计数器中的元素 性能保证：\n空间复杂度：O(k) 如果元素出现次数 \u0026gt; n/k，一定会被找到 可能有假阳性，但可以通过二次扫描验证 应用：\n找出访问量最大的网页 检测网络中的大流量 识别热门话题 三、频繁元素-随机算法 Count-Min Sketch算法：\n数据结构：\nd × w 的二维计数器数组 d个独立的哈希函数h₁, h₂, \u0026hellip;, h_d 算法操作：\n更新（插入元素x）：\n对于 i = 1 到 d： count[i][hᵢ(x)] += 1 查询（估计元素x的频率）：\n返回 min{count[i][hᵢ(x)] : i = 1..d} 性能保证：\n空间复杂度：O(d × w) 误差界：ε·n (n为总元素数)，概率至少1-δ 选择w = ⌈e/ε⌉, d = ⌈ln(1/δ)⌉ 只会高估，不会低估 优势：\n空间效率高 支持点查询和范围查询 可以处理删除操作（使用带符号的计数） 四、滑动窗口模型 问题描述： 只关心最近W个元素的统计特性，更早的数据被丢弃。\n挑战：\n无法存储所有W个元素 需要及时更新统计信息 DGIM算法（用于计数）：\n基本思想：\n将窗口划分为桶（bucket） 每个桶代表一段连续的1 桶的大小是2的幂次 维护O(log W)个桶 桶的性质：\n每种大小的桶最多2个 桶按时间戳排序 最老的桶可能不完整 查询操作： 统计窗口内1的个数 ≈ 完整桶的大小之和 + 半个最老桶\n误差保证：\n相对误差：最多50% 可以通过增加每种大小桶的数量来降低误差 应用扩展：\n滑动窗口中的平均值 滑动窗口中的中位数（近似） 滑动窗口中的distinct计数 第四讲 分布式数据流 一、分布式数据流模型 在分布式环境中，数据流分散在多个节点上，需要协调多个节点进行计算。\n系统架构：\n多个监测节点：每个节点观察部分数据流 协调节点：汇总和处理来自监测节点的信息 通信约束：最小化节点间的通信量 挑战：\n数据分散性 通信开销 同步问题 节点故障 典型场景：\n分布式网络监控 多数据中心的日志分析 边缘计算 CDN流量统计 二、聚集查询 问题定义： 计算分布在多个节点上的数据的聚集函数（如SUM、COUNT、AVG）。\n基本方法：\n1. 连续聚集：\n每个节点维护本地的统计信息 周期性发送给协调节点 协调节点汇总计算全局结果 2. 快照聚集：\n在特定时刻获取全局快照 需要处理同步问题 使用逻辑时钟或物理时钟 优化技术：\n采样与估计：\n不发送所有数据，只发送样本 使用统计方法估计全局结果 权衡精度和通信开销 增量更新：\n只发送变化部分 减少冗余通信 适用于变化缓慢的数据 数据结构支持：\n使用Count-Min Sketch等概要结构 可以在协调节点合并 支持分布式查询 三、topk监控 问题定义： 实时监控分布式系统中全局的top-k元素（如最热门的k个商品、最活跃的k个用户）。\n挑战：\n全局top-k可能不在任何单个节点的局部top-k中 需要在精度和通信量之间平衡 数据分布可能高度倾斜 解决方案：\n1. 阈值算法：\n协调节点维护全局top-k的阈值θ 每个节点报告超过θ的元素 动态调整θ以平衡通信量 算法流程：\n初始化：θ = 0 循环： 1. 每个节点报告频率 \u0026gt; θ 的元素 2. 协调节点更新全局top-k 3. 计算新阈值θ（如第k大元素的频率） 4. 将θ广播给各节点 2. 采样方法：\n各节点以概率p采样元素 上传采样的数据到协调节点 基于采样数据估计全局top-k 3. 层次化监控：\n构建监控树 中间节点聚合子节点的信息 减少单点通信压力 性能优化：\n局部过滤：只上传可能进入全局top-k的元素 批量通信：积累一定数量的更新后批量发送 缓存机制：利用时间局部性减少通信 实际应用：\n实时热搜榜 分布式缓存的热点识别 网络安全中的异常检测 广告系统的CTR监控 第五讲 哈希 一、哈希函数和哈希表 哈希技术是一种通过哈希函数将数据映射到固定大小的表中的方法，实现快速的数据存储和检索。\n核心概念：\n哈希函数：将任意大小的数据映射到固定大小的值 哈希表：基于数组实现的数据结构，通过哈希函数计算索引位置 冲突处理：当不同的键映射到相同位置时的解决策略 链地址法（Chaining） 开放地址法（Open Addressing） 时间复杂度：\n平均情况：O(1) 查找、插入、删除 最坏情况：O(n)（当所有元素都冲突时） 二、布隆过滤器（Bloom Filter） 布隆过滤器是一种空间高效的概率型数据结构，用于判断一个元素是否在集合中。\n特点：\n可能产生假阳性（False Positive）：说存在但实际不存在 不会产生假阴性（False Negative）：说不存在就一定不存在 不支持删除操作（标准版本） 应用场景：\n网页URL去重 垃圾邮件过滤 缓存穿透防护 大数据去重 工作原理：\n使用k个不同的哈希函数 将元素映射到位数组的k个位置 查询时检查这k个位置是否都为1 三、最小哈希和LSH（Locality-Sensitive Hashing） 最小哈希（MinHash）： 用于估计两个集合的Jaccard相似度，常用于文档去重和相似度检测。\n局部敏感哈希（LSH）： 一种降维技术，使得相似的数据项以高概率被映射到相同的桶中。\n应用：\n近似最近邻搜索 图像相似度检测 文本去重 推荐系统 第六讲 线性规划与整数规划 一、线性规划：单纯形算法 线性规划问题标准形式：\n最大化/最小化：c^T x 约束条件：Ax ≤ b, x ≥ 0 单纯形算法（Simplex Method）：\n由George Dantzig于1947年提出 从可行域的一个顶点出发 沿着目标函数值改进的方向移动到相邻顶点 直到找到最优解或判定无界 算法步骤：\n将问题转换为标准形式 找到初始基本可行解 检验数判断是否达到最优 若未达到最优，选择入基变量和出基变量 进行基变换，更新解 重复步骤3-5直到最优 二、整数规划：问题定义 整数规划是线性规划的扩展，要求部分或全部变量取整数值。\n分类：\n纯整数规划：所有变量都必须是整数 混合整数规划（MIP）：部分变量是整数，部分是连续变量 0-1整数规划：变量只能取0或1 应用场景：\n资源分配 生产计划 网络设计 任务调度 三、整数规划：分支界定法（Branch and Bound） 基本思想： 将原问题分解为若干子问题，通过界定（bounding）技术减少搜索空间。\n算法流程：\n松弛：求解去掉整数约束的线性规划松弛问题 界定：用松弛问题的最优值作为上界（最大化问题） 分支：选择一个非整数变量进行分支 剪枝： 当前节点的界不如已知最优解时剪枝 松弛问题无可行解时剪枝 松弛问题的解满足整数约束时更新最优解 四、整数规划：切平面法（Cutting Plane Method） 核心思想： 通过添加线性约束（切平面）逐步逼近整数规划的可行域，直到得到整数最优解。\nGomory割平面：\n从单纯形表中推导出的割平面 切掉当前非整数最优解 不切掉任何整数可行解 算法步骤：\n求解线性规划松弛问题 若解为整数，则为最优解，算法结束 若解不为整数，生成割平面约束 将割平面加入原问题 重新求解并重复步骤2-4 第七讲 内存计算 一、海量内存概述 随着硬件技术的发展，单机内存容量已经可以达到TB级别，这为大数据处理带来了新的机遇。\n内存计算的优势：\n速度快：内存访问速度比磁盘快3-5个数量级 延迟低：避免了磁盘I/O的延迟 适合迭代计算：机器学习、图计算等需要多次迭代的场景 挑战：\n成本较高 数据持久化问题 容错机制 二、基于单机版内存增大优势 单机大内存的应用场景：\n内存数据库（如Redis, Memcached） 实时数据分析 高性能缓存系统 图数据处理 技术特点：\n简化系统架构，减少网络通信开销 提高数据处理的吞吐量 适合中等规模的数据集 优化策略：\n数据结构优化（压缩、列式存储） NUMA-aware内存分配 大页内存（Huge Pages）的使用 三、基于共享式内存和分布式内存结合架构优势 混合架构设计：\n共享式内存（Shared Memory）：\n多个处理器共享同一物理内存空间 通信开销低 编程相对简单 可扩展性受限 分布式内存（Distributed Memory）：\n每个节点有独立的内存空间 通过网络进行通信 可扩展性强 编程复杂度较高 结合架构的优势：\n弹性扩展：根据数据规模动态调整资源 负载均衡：合理分配计算任务 容错能力：数据副本和快照机制 性能优化：本地内存访问 + 跨节点通信 典型系统：\nApache Spark（基于RDD的内存计算框架） Apache Flink（流式和批处理统一计算） Alluxio（分布式内存文件系统） 四、总结 内存计算已成为大数据处理的重要技术方向：\n针对不同场景选择合适的架构 平衡性能、成本和可扩展性 结合持久化存储保证数据安全 关注新硬件技术（如持久化内存）的发展 第八讲 社区发现 社区发现是复杂网络分析中的重要问题，目标是找出网络中紧密连接的节点群组。\n一、图切割（Graph Partitioning） 1. 社区划分问题 给定无向图 $G = (V, E)$，其中：\n$V$ 表示所有的顶点（节点）集合 $E$ 表示所有的边集合 任务： 将所有顶点分成两个不相交的组：\n组 $A$：包含一部分节点 组 $B = V\\backslash A$：包含剩余的所有节点（即 $V$ 中除了 $A$ 之外的所有节点） 核心问题： 如何评判这个划分的好坏？\n2. 评判准则 一个良好的社区划分应该满足：\n最大化社区内部的连接数：同一个社区内的节点之间应该有尽可能多的边连接 最小化社区之间的连接数：不同社区之间的连接应该尽可能少 3. 割（Cut）的定义 为了量化划分的质量，我们引入\u0026quot;割\u0026quot;的概念。\n割(cut) 是指：只有一个端点在社区 $A$ 内，另一个端点在社区 $A$ 外的所有边的权重之和。\n数学表达式：\n$$cut(A) = \\sum_{i \\in A, j \\notin A} w_{ij}$$公式解释：\n$i \\in A$：节点 $i$ 在社区 $A$ 中 $j \\notin A$：节点 $j$ 不在社区 $A$ 中（即在社区 $B$ 中） $w_{ij}$：连接节点 $i$ 和节点 $j$ 的边的权重（如果是无权图，权重为1） $\\sum$：对所有满足条件的边进行求和 通俗理解： 割就是\u0026quot;跨越两个社区的边的总权重\u0026quot;，这个值越小，说明两个社区之间的连接越少，划分越好。\n求解方法： 存在多项式时间算法来求解最小割问题，特别是 Edmonds-Karp 算法，其时间复杂度为 $O(|V| \\cdot |E|^2)$。\n4. 最小割 (Minimum-cut) 目标： 找到一个划分 $(A, B)$，使得 $cut(A,B)$ 的值最小。\n$$\\arg\\min_{A,B} cut(A,B)$$公式解释：\n$\\arg\\min$：表示\u0026quot;使得后面的值最小的参数\u0026quot; 即找到使 $cut(A,B)$ 最小的划分方式 $(A, B)$ 最小割的局限性：\n虽然最小割能找到连接最少的划分，但存在明显的问题：\n只考虑簇间的联通性：只关心两个社区之间有多少连接 不考虑簇内的连通性：不关心每个社区内部的结构 可能产生不平衡的划分：例如，将一个孤立的节点分离出来，只需要切断很少的边，但这样的划分是没有意义的 举例说明： 假设有一个图，其中有一个节点只通过一条边连接到主图，那么最小割会将这个节点单独分离出来（只需切断1条边），但这样的划分显然不合理。\n5. 归一化切割 (Normalized-cut) 为了解决最小割的问题，我们引入归一化切割，它同时考虑了簇间的连通性和各簇的规模。\n体积（Volume）的定义： 首先需要定义社区 $A$ 的\u0026quot;体积\u0026quot; $vol(A)$：\n$$vol(A) = \\sum_{i \\in A} k_i$$其中 $k_i$ 是节点 $i$ 的度（degree），即连接到节点 $i$ 的所有边的权重之和。$vol(A)$ 表示至少有一个端点在社区 $A$ 中的所有边的总权重，反映了社区 $A$ 的\u0026quot;规模\u0026quot;或\u0026quot;密度\u0026quot;。\n归一化切割的定义：\n$$ncut(A,B) = \\frac{cut(A,B)}{vol(A)} + \\frac{cut(A,B)}{vol(B)}$$公式解释：\n第一项 $\\frac{cut(A,B)}{vol(A)}$：割的大小相对于社区 $A$ 的规模 第二项 $\\frac{cut(A,B)}{vol(B)}$：割的大小相对于社区 $B$ 的规模 两项相加：综合考虑两个社区的规模 为什么要归一化？ 通过除以各自的体积，我们将割的大小\u0026quot;标准化\u0026quot;了。这样如果一个社区很大（$vol$ 很大），即使割的值不变，归一化后的值也会变小，从而避免了将单个节点分离出来的情况（因为单个节点的 $vol$ 很小，归一化后的值会很大）。\n优势：\n使划分更加平衡，避免产生极小的社区 同时考虑了社区间的连接和社区的规模 挑战：\n计算归一化割是 NP-hard 问题 需要使用近似算法或启发式方法来高效地找到好的划分 6. 练习题详解 题目： 对于给定的图(红色节点和绿色节点)，分别计算最优切割和最小切割的 $ncut$ 值。\n题目分析： 从图中可以看到两种切割方式：\n最优切割（蓝色虚线）：在红色社区（左侧）和绿色社区（右侧）之间进行切割 最小切割（红色虚线）：将右下角单个绿色节点孤立出来 （1）最小切割的 $ncut$ 值计算\n划分方式：社区 $A$ 为右下角单个绿色节点，社区 $B$ 为其余所有节点。\n$cut(A,B) = 1$（只有1条边连接孤立节点） $vol(A) = 0$（节点完全孤立，内部没有边） $ncut_{\\text{min}} = \\frac{1}{0} + \\frac{1}{vol(B)} = +\\infty$ 这说明将单个节点完全孤立是一个极差的划分！\n（2）最优切割的 $ncut$ 值计算\n划分方式：社区 $A$ 为所有红色节点（左侧6个节点），社区 $B$ 为所有绿色节点（右侧10个节点）。\n$cut(A,B) = 2$（2条边跨越蓝色虚线） $vol(A) = 2 \\times 9 = 18$（红色区域内部9条边） $vol(B) = 2 \\times 15 = 30$（绿色区域内部15条边） $ncut_{\\text{optimal}} = \\frac{2}{30} + \\frac{2}{18} = \\frac{1}{15} + \\frac{1}{9} = \\frac{8}{45} \\approx 0.178$ 结果对比：\n切割方式 $cut(A,B)$ $vol(A)$ $vol(B)$ $ncut$ 值 最小切割 1 0 \u0026gt;0 $+\\infty$ 最优切割 2 18 30 0.178 结论：\n最小切割将单个节点孤立后，$vol(A) = 0$ 导致 $ncut$ 值趋向无穷大，这是最差的划分 最优切割虽然 $cut$ 值不是最小，但 $ncut$ 值很小，实现了平衡且合理的划分 归一化切割通过考虑社区规模，避免了不合理的极端划分，$ncut$ 值越小说明划分越好 二、边介数（Edge Betweenness） 1. 边介数的定义 边介数（Edge Betweenness）：通过该边的最短路径的数量。\n作用：\n用于衡量图中一条边的重要性或中心性 反映图中有多少条最短路径经过该边 重要性判断：\n若很多最短路径都经过该边，则该边对于保持图的高效连接性就非常重要 相反，如果仅少数最短路径经过该边，则该边的重要性就较低 应用价值：\n边介数有助于识别图中的关键连接，即这些连接一旦断裂会显著影响图中节点之间的通信效率。\n示例：\n在下图中，不同的边具有不同的边介数值：\n左侧的边：$b = 16$（有16条最短路径经过） 右侧的边：$b = 7.5$（有7.5条最短路径经过） 边介数越大，该边在网络中的重要性越高。\n2. Girvan-Newman方法（简称GN方法） GN方法定义：\nGirvan-Newman方法是一种基于边介数概念的层次聚类算法，适用于无向无权网络。\n算法流程：\n重复以下步骤直到没有边剩余：\n计算边介数：计算网络中所有边的边介数 移除边介数最高的边：找到边介数最大的边并将其从图中删除 重新计算：在每个步骤后，需要重新计算剩余边的边介数 输出结果：\n相连接的边构成社区 可输出网络的层次分解 重要提示： 在每个步骤，均需重新计算边介数，因为移除一条边会影响其他边的最短路径。\n3. GN方法案例分析 考虑下图所示的网络，应用GN方法进行社区划分：\nStep 1： 计算所有边的边介数，移除边介数最高的边（边7-8，边介数为49）\n结果：图被分成两个主要部分\nStep 2： 重新计算剩余边的边介数，继续移除边介数最高的边\n结果：进一步细分，形成更小的社区\nStep 3： 持续迭代，直到所有边都被移除\n结果：每个节点成为独立的社区\n最终输出：层次状的网络划分\n通过记录每次移除边的顺序，可以构建一个层次树（dendrogram），展示网络在不同粒度下的社区结构。\n4. 如何计算边介数 （1）基本方法：构建根节点到其余子节点的最短路径数量\n步骤1：构建最短路径树\n从起始节点（如节点A）开始，使用BFS构建到所有其他节点的最短路径树，并标记每个节点的层次：\n第0层：起始节点A 第1层：与A直接相连的节点（B, C, D, E） 第2层：距离A为2的节点（F, G, H） 第3层：距离A为3的节点（I, J） 第4层：距离A为4的节点（K） 步骤2：计算最短路径数量\n计算从起始节点A到网络中其他每个节点的最短路径数量。\n公式：\n从A到某个节点X的最短路径数量 = 所有能到达X的父节点的最短路径数量之和\n示例：\n从A到H的最短路径数量 = 从A到D的最短路径数量 + 从A到E的最短路径数量 从A到K的最短路径数量 = 从A到I的最短路径数量 + 从A到J的最短路径数量 （2）自底向上计算边介数：如果存在多条最短路径，则可按比例划分边介数。\n算法步骤：\n添加边流\n初始化：每个节点的流 = 1 + 其所有子边的流之和 根据父节点的值分配流 对于每个起始节点U，重复广度优先搜索过程\n详细计算规则：\n对于某条边 $(X, Y)$，其边介数的计算遵循以下规则：\n如果从A到Y只有一条最短路径经过X，则该边获得完整的流 如果从A到Y有多条最短路径（通过不同的父节点），则按照各父节点的最短路径数量比例分配流 具体案例：\n以节点为K为例：\nK对于A而言是叶子节点，所以他的流为1（根据算法规则：子节点的流为0）， 共有2条最短路径可被分配，根据I，J各有三条最短路径，为3：3，即1：1，因此每条边分配 $\\frac{1}{2}$ 以节点I为例：\nA-I的最短路径总和算1，外加经过I到K的0.5，所以I的流为1.5 I有1.5可被分配，按照2:1的比例划分（因为A到F有2条最短路径，到G有1条最短路径） 故边$V_{F,I}$得到的流为1，边$V_{G,I}$得到的流为0.5 以此自下而上故能得到所有边的边介数\n5. 练习题 **题目：**给定下图所示的网络结构，请：\n根据第四小点，很快就能确定每条边的边介数\n步骤1：构建最短路径树\n从起始节点B开始，使用BFS构建到所有其他节点的最短路径树，并标记每个节点的层次：\n第0层：起始节点B 第1层：与B直接相连的节点（A，C，F） 第2层：距离B为2的节点（D，E，I） 第3层：距离B为3的节点（G，H，K） 第4层：距离B为4的节点（J） 步骤2：计算最短路径数量\n计算从起始节点B到网络中其他每个节点的最短路径数量。定义节点B到节点I的最短路径数量的方法为$N(i)$，故\n第0层：起始节点B 第1层：与B直接相连的节点$N(A) = 1$,$N(C) = 1$,$N(F) = 1$ 第2层：距离B为2的节点$N(D) = N(A)=1$,$N(E) = N(A)=1$,$N(I)=N(F) = 1$ 第3层：距离B为3的节点$N(G) = N(D)+N(I)=2$,$N(H) = N(D)+N(E)=2$,$N(K)=N(I) = 1$ 第4层：距离B为4的节点$N(J) = N(G)+N(H)+N(K) = 5$​ 步骤3：自底向上计算边介数\n每个节点的流 = 1 + 其所有子边的流之和，根据父节点的值分配流，\n第4层：距离B为4的节点（J），J为叶子节点，所以J的流为1，故分配边流\n$V_{H,J}=V_{K,J}=V_{G,J} = \\frac{1}{3}$\n第3层：距离B为3的节点（G，H，K）,计算各自的流：$G = H = K = 1+\\frac{1}{3}=\\frac{4}{3}$\n三、模块度（Modularity） 定义： 模块度Q用于衡量网络社区划分的质量。\n公式：\nQ = (1/2m) Σ[Aᵢⱼ - (kᵢkⱼ/2m)]δ(cᵢ,cⱼ) 其中：\nm：边的总数 Aᵢⱼ：邻接矩阵 kᵢ：节点i的度 δ(cᵢ,cⱼ)：节点i和j是否在同一社区 特性：\nQ值范围：[-0.5, 1] Q \u0026gt; 0.3通常表示有明显的社区结构 模块度最大化是NP困难问题 四、Louvain方法 Louvain算法是一种基于模块度优化的快速社区发现算法。\n算法步骤：\n第一阶段（模块度优化）：\n初始化：每个节点为一个独立社区 遍历每个节点： 尝试将该节点移动到邻居节点所在的社区 计算模块度增益ΔQ 选择使ΔQ最大且为正的移动 重复步骤2直到模块度不再增加 第二阶段（网络聚合）：\n将同一社区的所有节点合并成一个超级节点 社区间的边权重等于原节点间边权重之和 对新网络重复第一阶段 重复两个阶段直到模块度不再显著增加。\n优势：\n时间复杂度：O(n log n) 能处理大规模网络（百万级节点） 能发现层次化社区结构 实现简单，效果好 应用案例：\n社交网络社区检测 生物网络模块识别 知识图谱聚类 第九讲 子模函数及其应用 一、应用背景 子模函数在组合优化中有广泛应用，许多实际问题都具有子模性质。\n典型应用场景：\n信息传播最大化 传感器布置优化 文档摘要 特征选择 图像分割 二、子模函数（Submodular Function） 定义： 集合函数f: 2^V → ℝ 是子模的，如果对于任意A ⊆ B ⊆ V 和 x ∉ B，有：\nf(A ∪ {x}) - f(A) ≥ f(B ∪ {x}) - f(B) 直观理解： 边际收益递减（Diminishing Returns）：向小集合添加元素的收益不小于向大集合添加相同元素的收益。\n常见子模函数：\n覆盖函数：f(S) = |∪ₛ∈S Cₛ| 截断函数：f(S) = min(|S|, k) 图割函数 熵函数 性质：\n子模函数的非负线性组合仍是子模的 子模函数的最小化可以在多项式时间内精确求解 子模函数的最大化是NP困难的，但存在近似算法 三、集合覆盖问题（Set Cover Problem） 问题定义： 给定全集U和若干子集S₁, S₂, \u0026hellip;, Sₙ ⊆ U，找到最少数量的子集使其并集等于U。\n形式化：\n最小化：|S| 约束条件：∪ₛ∈S s = U 复杂性：\nNP困难问题 不存在常数因子近似算法（除非P=NP） 贪心算法：\n初始化：S = ∅, R = U（未覆盖元素） 循环直到R = ∅： 选择覆盖R中最多元素的集合s S = S ∪ {s} R = R \\ s 返回S 性能保证：\n贪心算法的近似比：O(ln n) 这是可达到的最好近似比（在P≠NP假设下） 子模性与贪心算法： 集合覆盖函数f(S) = |∪ₛ∈S s|是子模的，对于单调子模函数最大化：\n贪心算法保证(1 - 1/e)近似比 这个界是紧的 实际应用：\n设施选址：用最少的设施覆盖所有需求点 无线网络覆盖：最小化基站数量 测试用例选择：用最少的测试覆盖所有代码路径 特征选择：选择最少的特征保持分类性能 高级话题：\n加权集合覆盖 多目标集合覆盖 在线集合覆盖 分布式集合覆盖算法 课程总结 本课程系统地介绍了数学基础算法的核心内容，涵盖了从理论到实践的多个重要主题：\n基础理论部分（第1-2讲）：\n算法分析为评估算法效率提供了数学工具，相似度搜索和高维空间技术是现代大数据应用的基础 尾不等式提供了随机算法性能的概率保证，是设计和分析概率算法的重要理论基础 数据流处理（第3-4讲）：\n数据流算法解决了在有限空间内处理海量数据的问题，频繁元素检测和滑动窗口模型在实时系统中应用广泛 分布式数据流扩展到多节点场景，聚集查询和top-k监控为大规模分布式系统提供了实用解决方案 核心算法技术（第5-7讲）：\n哈希技术为大规模数据的快速检索和去重提供了基础工具，布隆过滤器和LSH在实际应用中具有重要价值 线性规划与整数规划是运筹优化的核心方法，单纯形算法、分支界定法和切平面法为求解复杂优化问题提供了理论基础 内存计算代表了大数据处理的技术趋势，通过合理利用单机大内存和分布式架构可以显著提升计算性能 图算法与优化（第8-9讲）：\n社区发现算法帮助我们理解复杂网络的结构特征，Louvain方法在实践中表现出色 子模优化为许多实际问题提供了理论保证的近似算法，贪心策略在子模函数优化中具有良好的性能保证 核心思想总结：\n近似与权衡：在精确性和效率之间寻找平衡 概率与随机化：利用随机化技术突破确定性算法的局限 分布式思维：将算法扩展到大规模分布式环境 理论保证：为实际算法提供可证明的性能边界 这些算法和技术在实际应用中经常需要结合使用，深入理解其数学基础对于解决复杂的工程问题至关重要。掌握这些方法不仅能提升算法设计能力，更能在面对实际问题时选择合适的解决方案，在效率、精度和资源消耗之间做出明智的权衡。\n","permalink":"http://localhost:1313/dase-course/mathematical-algorithms-lecture/","summary":"本笔记涵盖数学基础算法篇的完整内容，包括算法分析与相似度搜索、尾不等式及其应用、数据流算法（频繁元素检测、滑动窗口模型）、分布式数据流处理、哈希技术（布隆过滤器、LSH）、线性规划与整数规划、内存计算架构、社区发现算法以及子模函数应用等核心理论与实践。","title":"数学基础算法篇"},{"content":"0.前言 功能概要 数据库设计 1. tb_blog (博客/探店笔记表) 功能: 存储用户发布的探店笔记内容\n字段 类型 说明 id bigint(20) 主键，自增 shop_id bigint(20) 关联的商户ID user_id bigint(20) 发布用户ID title varchar(255) 笔记标题 images varchar(2048) 图片路径，多张用逗号分隔，最多9张 content varchar(2048) 文字描述内容 liked int(8) 点赞数量 comments int(8) 评论数量 create_time timestamp 创建时间 update_time timestamp 更新时间 示例数据: 包含美食探店笔记，如\u0026quot;无尽浪漫的夜晚\u0026quot;、\u0026ldquo;人均30💰杭州港式茶餐厅\u0026quot;等\n2. tb_blog_comments (博客评论表) 功能: 存储博客的评论信息，支持多级评论\n字段 类型 说明 id bigint(20) 主键，自增 user_id bigint(20) 评论用户ID blog_id bigint(20) 关联的博客ID parent_id bigint(20) 父评论ID，一级评论为0 answer_id bigint(20) 回复的评论ID content varchar(255) 评论内容 liked int(8) 点赞数 status tinyint(1) 状态: 0正常, 1被举报, 2禁止查看 create_time timestamp 创建时间 update_time timestamp 更新时间 设计亮点: 通过parent_id和answer_id支持多层级的评论回复\n3. tb_follow (关注关系表) 功能: 记录用户之间的关注关系\n字段 类型 说明 id bigint(20) 主键，自增 user_id bigint(20) 用户ID follow_user_id bigint(20) 被关注的用户ID create_time timestamp 创建时间 用途: 实现社交功能，构建用户关系网络\n4. tb_shop (商铺表) 功能: 存储商铺的基本信息\n字段 类型 说明 id bigint(20) 主键，自增 name varchar(128) 商铺名称 type_id bigint(20) 商铺类型ID images varchar(1024) 商铺图片，多张用逗号分隔 area varchar(128) 商圈，如\u0026quot;陆家嘴\u0026rdquo; address varchar(255) 详细地址 x double 经度 y double 纬度 avg_price bigint(10) 人均价格（整数） sold int(10) 销量 comments int(10) 评论数量 score int(2) 评分(1-5分，乘10保存) open_hours varchar(32) 营业时间 create_time timestamp 创建时间 update_time timestamp 更新时间 示例商铺: 包含103茶餐厅、海底捞火锅、开乐迪KTV等14家商铺\n5. tb_shop_type (商铺类型表) 功能: 商铺分类管理\n字段 类型 说明 id bigint(20) 主键，自增 name varchar(32) 类型名称 icon varchar(255) 图标路径 sort int(3) 排序 create_time timestamp 创建时间 update_time timestamp 更新时间 分类: 美食、KTV、丽人美发、健身运动、按摩足疗、美容SPA、亲子游乐、酒吧、轰趴馆、美睫美甲\n6. tb_user (用户表) 功能: 存储用户基本信息\n字段 类型 说明 id bigint(20) 主键，自增 phone varchar(11) 手机号（唯一索引） password varchar(128) 加密密码 nick_name varchar(32) 昵称 icon varchar(255) 头像路径 create_time timestamp 创建时间 update_time timestamp 更新时间 安全设计: 密码加密存储，手机号唯一\n7. tb_user_info (用户详细信息表) 功能: 存储用户的扩展信息\n字段 类型 说明 user_id bigint(20) 主键，关联用户ID city varchar(64) 城市 introduce varchar(128) 个人介绍 fans int(8) 粉丝数 followee int(8) 关注数 gender tinyint(1) 性别: 0男, 1女 birthday date 生日 credits int(8) 积分 level tinyint(1) 会员等级(0-9) create_time timestamp 创建时间 update_time timestamp 更新时间 8. tb_voucher (代金券表) 功能: 管理商铺的优惠券信息\n字段 类型 说明 id bigint(20) 主键，自增 shop_id bigint(20) 商铺ID title varchar(255) 券标题 sub_title varchar(255) 副标题 rules varchar(1024) 使用规则 pay_value bigint(10) 支付金额（分） actual_value bigint(10) 抵扣金额（分） type tinyint(1) 类型: 0普通券, 1秒杀券 status tinyint(1) 状态: 1上架, 2下架, 3过期 create_time timestamp 创建时间 update_time timestamp 更新时间 9. tb_seckill_voucher (秒杀券表) 功能: 存储秒杀券的特殊信息\n字段 类型 说明 voucher_id bigint(20) 主键，关联券ID stock int(8) 库存数量 begin_time timestamp 生效时间 end_time timestamp 失效时间 create_time timestamp 创建时间 update_time timestamp 更新时间 特点: 与tb_voucher是一对一关系，专门处理秒杀场景\n10. tb_voucher_order (优惠券订单表) 功能: 记录用户购买优惠券的订单\n字段 类型 说明 id bigint(20) 主键（非自增） user_id bigint(20) 用户ID voucher_id bigint(20) 优惠券ID pay_type tinyint(1) 支付方式: 1余额, 2支付宝, 3微信 status tinyint(1) 订单状态: 1未支付, 2已支付, 3已核销, 4已取消, 5退款中, 6已退款 create_time timestamp 下单时间 pay_time timestamp 支付时间 use_time timestamp 核销时间 refund_time timestamp 退款时间 update_time timestamp 更新时间 设计亮点: 完整的订单状态流转，支持退款流程\n11. tb_sign (签到表) 功能: 记录用户的签到信息\n字段 类型 说明 id bigint(20) 主键，自增 user_id bigint(20) 用户ID year year 签到年份 month tinyint(2) 签到月份 date date 签到日期 is_backup tinyint(1) 是否补签 用途: 用户激励体系，支持补签功能\n1.短信登录 基于session实现登录 1.登录流程 2.代码实现 发送短信验证码\n@Slf4j @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements IUserService { @Override public Result sendcode(String phone, HttpSession session){ //1.校验手机号,utils的工具包 if(RegexUtils.isPhoneInvalid(phone)){ //2.如果不符合，返回错误信息 return Result.fail(\u0026#34;手机号格式错误！\u0026#34;); } //3.符合，生成验证码,一个java的工具包 String code = RandomUtil.randomNumbers(6); //4.保存验证码道session session.setAttribute(\u0026#34;code\u0026#34;,code); //5.发送验证码,需要调用第三方的短信平台，比如说阿里云 //TODO log.debug(\u0026#34;发送短信验证码成功，验证码：{}\u0026#34;,code); //返回ok return Result.ok(code); } } 短信验证码验证和登录\n@Override public Result login(LoginFormDTO loginForm, HttpSession session){ //1.校验手机号 String phone = loginForm.getPhone(); if(RegexUtils.isPhoneInvalid(phone)){ return Result.fail(\u0026#34;手机号格式错误！\u0026#34;); } //2.校验验证码 Object cacheCode = session.getAttribute(\u0026#34;code\u0026#34;); String code = loginForm.getCode(); if(cacheCode==null || !cacheCode.toString().equals(code)){ //3.不一致报错 return Result.fail(\u0026#34;验证码错误\u0026#34;); } //4.一致，根据手机号查询用户,select * from tb_user where phone = ? User user = query().eq(\u0026#34;phone\u0026#34;, phone).one(); //5.判断用户是否存在 if(user==null){ //6.不存在，创建用户并保存,只需要填充phone和nickname字段即可 user = createUserWithPhone(String phone); } //7.保存用户信息到session中 session.setAttribute(\u0026#34;user\u0026#34;,user); return Result.ok(); } private User createUserWithPhone(String phone){ //1.创建用户 User user = new User(); user.setPhone(phone); user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(10)); //2.保存用户 save(user); return user; } 校验登录状态\n/* 在utils中添加LoginInterceptor.java作为拦截器 */ public class LoginInterceptor implements HandlerInterceptor { //预拦截 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.获取session HttpSession session = request.getSession(); //2.获取session中的user Object user = session.getAttribute(\u0026#34;user\u0026#34;); //3.判断用户是否在存在 if(user==null){ //4.不存在，返回401状态码 response.setStatus(401); return false; } //5.存在，保存用户信息到ThreadLocal UserHolder.saveUser((UserDTO) user); //6.放行 return true; } //渲染之前的拦截 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { //移除用户 UserHolder.removeUser(); } } /* 在config中添加MvcConfig.java */ @Configuration public class MvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( \u0026#34;/user/code\u0026#34; , \u0026#34;/user/login\u0026#34; , \u0026#34;/blog/hot\u0026#34; , \u0026#34;/shop/**\u0026#34; , \u0026#34;/shop-type/**\u0026#34; , \u0026#34;/upload/**\u0026#34; , \u0026#34;/voucher/**\u0026#34; ); } } /* controller拿到用户登录的信息，通过这个ThreadLocal\t*/ @GetMapping(\u0026#34;/me\u0026#34;) public Result me(){ // 获取当前登录的用户并返回 UserDTO user = UserHolder.getUser(); return Result.ok(user); } 隐藏用户信息\n/* 1.需要在登录的时候，将传入session的user更改成userDTO 2.更改UserHolder中的所有的相关信息和拦截器调用信息为userDTO 3.更改me接口，return一个UserDTO信息 */ //登录时保存用户信息到session中 session.setAttribute(\u0026#34;user\u0026#34;, BeanUtil.copyProperties(user, UserDTO.class)); 集群的session共享问题 基于Redis实现共享session问题 1.Redis字段选择 设计key的要求\n唯一性 便携带 2.Redis实现验证码发送登录问题 3.Redis实现校验登录功能 4.代码实现 发送短信验证码\n@Resource private StringRedisTemplate stringRedisTemplate; @Override public Result sendcode(String phone, HttpSession session){ //1.校验手机号,utils的工具包 if(RegexUtils.isPhoneInvalid(phone)){ //2.如果不符合，返回错误信息 return Result.fail(\u0026#34;手机号格式错误！\u0026#34;); } //3.符合，生成验证码,一个java的工具包 String code = RandomUtil.randomNumbers(6); //4.保存验证码到redis stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY+phone,code,LOGIN_CODE_TTL, TimeUnit.MINUTES); //5.发送验证码,需要调用第三方的短信平台，比如说阿里云 log.debug(\u0026#34;发送短信验证码成功，验证码：{}\u0026#34;,code); //返回ok return Result.ok(code); } 短信验证码验证和登录\n@Override public Result login(LoginFormDTO loginForm, HttpSession session){ //1.校验手机号 String phone = loginForm.getPhone(); if(RegexUtils.isPhoneInvalid(phone)){ return Result.fail(\u0026#34;手机号格式错误！\u0026#34;); } //2.从redis中获取验证码并进行校验 String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY+phone); String code = loginForm.getCode(); if(cacheCode==null || !cacheCode.equals(code)){ //3.不一致报错 return Result.fail(\u0026#34;验证码错误\u0026#34;); } //4.一致，根据手机号查询用户,select * from tb_user where phone = ? User user = query().eq(\u0026#34;phone\u0026#34;, phone).one(); //5.判断用户是否存在 if(user==null){ //6.不存在，创建用户并保存,只需要填充phone和nickname字段即可 user = createUserWithPhone(phone); } //7.保存用户信息到redis //7.1随机生成token,作为登录令牌 String token = UUID.randomUUID().toString(); //7.2将user对象转为hash存储 UserDTO userDTO = BeanUtil.copyProperties(user,UserDTO.class); Map\u0026lt;String, Object\u0026gt; userMap = BeanUtil.beanToMap(userDTO,new HashMap\u0026lt;\u0026gt;(), //解决id字段是整型而不是字符串类型 CopyOptions.create().setIgnoreNullValue(true).setFieldValueEditor((fieldName,fieldValue)-\u0026gt;fieldValue.toString()) ); //7.3存储 String tokenKey = LOGIN_USER_KEY+token; stringRedisTemplate.opsForHash().putAll(tokenKey,userMap); //添加hash对象 stringRedisTemplate.expire(tokenKey,LOGIN_USER_TTL, TimeUnit.MINUTES); //8.返回token return Result.ok(token); 校验登录状态\n需要在MvcConfig中导入RedisTemplate 使用拦截器是为了解决redis像session一样只要有操作就会自动延长过期时间 private StringRedisTemplate stringRedisTemplate; public LoginInterceptor(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } //预拦截 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.获取请求头中的token String token = request.getHeader(\u0026#34;authorization\u0026#34;); if(StrUtil.isBlank(token)){ response.setStatus(401); return false; } //2.基于token获取redis中的用户 String key = RedisConstants.LOGIN_USER_KEY + token; Map\u0026lt;Object, Object\u0026gt; userMap = stringRedisTemplate.opsForHash().entries(key); //3.判断用户是否在存在 if(userMap.isEmpty()){ //4.不存在，返回401状态码 response.setStatus(401); return false; } //5.将查询到的hash数据转为UserDTO对象 UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap,new UserDTO(),false); //6.存在，保存用户信息到ThreadLocal UserHolder.saveUser(userDTO); //7.刷新token的有效期 stringRedisTemplate.expire(key,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES); //8.放行 return true; } /* 此时的MVCCONFIG需要更新 */ @Configuration public class MvcConfig implements WebMvcConfigurer { @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginInterceptor(stringRedisTemplate)) .excludePathPatterns( \u0026#34;/user/code\u0026#34; , \u0026#34;/user/login\u0026#34; , \u0026#34;/blog/hot\u0026#34; , \u0026#34;/shop/**\u0026#34; , \u0026#34;/shop-type/**\u0026#34; , \u0026#34;/upload/**\u0026#34; , \u0026#34;/voucher/**\u0026#34; ); } } 登录拦截器的优化\n如果用户访问的全都不是在拦截器的页面，token仍然会失效 //具体做法：拷贝一份新的RefreshTokenInterceptor，并重写一下LoginInterceptor @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.判断是否需要进行拦截（ThreadLocal中是否有用户） if(UserHolder.getUser() == null){ //没有，需要进行拦截 response.setStatus(401); //拦截 return false; } //有用户，进行放行操作 return true; } //需要更新一下MvcConfig @Configuration public class MvcConfig implements WebMvcConfigurer { @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( \u0026#34;/user/code\u0026#34; , \u0026#34;/user/login\u0026#34; , \u0026#34;/blog/hot\u0026#34; , \u0026#34;/shop/**\u0026#34; , \u0026#34;/shop-type/**\u0026#34; , \u0026#34;/upload/**\u0026#34; , \u0026#34;/voucher/**\u0026#34; ).order(1); registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(\u0026#34;/**\u0026#34;).order(0); } }\t2.商户查询缓存 什么是缓存 缓存的级别\n缓存的优缺点\n添加Redis缓存 1.添加商户查询缓存 代码实现\n@Service public class ShopServiceImpl extends ServiceImpl\u0026lt;ShopMapper, Shop\u0026gt; implements IShopService { @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result queryById(Long id) { String key = RedisConstants.CACHE_SHOP_KEY +id; //1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if(StrUtil.isNotBlank(shopJson)){ //3.存在，直接返回 Shop shop = JSONUtil.toBean(shopJson,Shop.class); return Result.ok(shop); } //4.不存在，根据id查询数据库 Shop shop = getById(id); //5.数据库不存在，返回错误 if(shop==null){ return Result.fail(\u0026#34;店铺不存在\u0026#34;); } //6.存在，将查询结果写入redis stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop)); //7.返回数据 return Result.ok(shop); } } 2.添加商铺类型查询业务 代码实现\n@Service public class ShopTypeServiceImpl extends ServiceImpl\u0026lt;ShopTypeMapper, ShopType\u0026gt; implements IShopTypeService { @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result queryTypeList() { String typeKey= RedisConstants.CACHE_TYPE_KEY; //1.从redis中查询 Long typeListSize = stringRedisTemplate.opsForList().size(typeKey); //2.redis存在数据 if (typeListSize!=null\u0026amp;\u0026amp;typeListSize!=0){ List\u0026lt;String\u0026gt; typeJsonList = stringRedisTemplate.opsForList().range(typeKey, 0, typeListSize-1); List\u0026lt;ShopType\u0026gt; typeList=new ArrayList\u0026lt;\u0026gt;(); for (String typeJson : typeJsonList) { typeList.add(JSONUtil.toBean(typeJson,ShopType.class)); } return Result.ok(typeList); } //3.redis不存在数据 查询数据库 List\u0026lt;ShopType\u0026gt; typeList = query().orderByAsc(\u0026#34;sort\u0026#34;).list(); //4.数据库中不存在相关数据 if (typeList==null){ //数据库不存在数据 return Result.fail(\u0026#34;发生错误\u0026#34;); } //转换 List\u0026lt;String\u0026gt; typeJsonList=new ArrayList\u0026lt;\u0026gt;(); for (ShopType shopType : typeList) { typeJsonList.add(JSONUtil.toJsonStr(shopType)); } //5.数据库存在数据 写入redis stringRedisTemplate.opsForList().rightPushAll(typeKey,typeJsonList); //6.返回数据 return Result.ok(typeList); } } 缓存更新策略 当数据库的数据发生修改时，需要及时更新redis中的值\n1.三种更新策略 2.主动更新策略 3.案例：实现商铺缓存和数据库的双写一致 需求\n代码实现\n@Override @Transactional public Result update(Shop shop) { Long id = shop.getId(); if(id==null){ return Result.fail(\u0026#34;店铺id不能为空\u0026#34;); } //1.更新数据库 updateById(shop); //2.删除缓存 stringRedisTemplate.delete(RedisConstants.CACHE_SHOP_KEY+shop.getId()); return Result.ok(); } 缓存穿透 问题详情\n缓存空对象*\npublic Shop queryWithPassThrough(Long id){ String key = RedisConstants.CACHE_SHOP_KEY +id; //1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if(StrUtil.isNotBlank(shopJson)){ //3.存在，直接返回 Shop shop = JSONUtil.toBean(shopJson,Shop.class); return Result.ok(shop); } //判断是否为空值，如果是“”，就不用返回数据库的查询了，如果是null,就需要进行数据库的查询（因为数据库没有查到会默认传一个“”，省略了查数据库的这一步） if(shopJson != null){ return Result.fail(\u0026#34;店铺信息不存在！\u0026#34;); } //4.不存在，根据id查询数据库 Shop shop = getById(id); //5.数据库不存在，返回错误 if(shop==null){ //将空值写入redis stringRedisTemplate.opsForValue().set(key,\u0026#34;\u0026#34;,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES); return Result.fail(\u0026#34;店铺不存在\u0026#34;); } //6.存在，将查询结果写入redis stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); //7.返回数据 return Result.ok(shop); } 缓存雪崩 缓存击穿 1.互斥锁 案例：\n解决办法:setnx\n代码实现\n@Override public Result queryById(Long id) { //缓存穿透 Shop shop = queryWithPassThrough(id); if(shop == null){ return Result.fail(\u0026#34;店铺查询失败\u0026#34;); } //返回数据 return Result.ok(shop); } //封装缓存穿透的代码——基于锁机制 public Shop queryWithPassThrough(Long id) { String key = RedisConstants.CACHE_SHOP_KEY +id; //1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在，isNotBlank方法会剔除掉null,\u0026#34;\u0026#34;的情况 if(StrUtil.isNotBlank(shopJson)){ //3.存在，直接返回 return JSONUtil.toBean(shopJson,Shop.class); } //4.实现缓存重建 //4.1 获取互斥锁 String lockKey = RedisConstants.LOCK_SHOP_KEY+id; Shop shop = null; try { boolean isLock = tryLock(lockKey); //4.2 判断是否获取成功 if(!isLock){ //4.3 获取失败，休眠 Thread.sleep(50); return queryWithPassThrough(id); //递归处理 } //4.4 成功，进行数据库的查询和缓存重建 shop = getById(id); //模拟重建的超时 Thread.sleep(200); //5.数据库不存在，返回错误 if(shop==null){ //将空值写入redis stringRedisTemplate.opsForValue().set(key,\u0026#34;\u0026#34;,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES); return null; } //6.存在，将查询结果写入redis stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); } catch (InterruptedException e) { throw new RuntimeException(e); }finally { //7.释放互斥锁 unlock(lockKey); } //8.返回数据 return shop; } //获取锁 private boolean tryLock(String key){ Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key,\u0026#34;1\u0026#34;,RedisConstants.LOCK_SHOP_TTL,TimeUnit.SECONDS); //如果flag的值为null，自动进行拆箱将包装类转换为基本数据类型时会抛出NullPointerException return BooleanUtil.isTrue(flag); } //删除锁 private boolean unlock(String key){ return stringRedisTemplate.delete(key); } 2.逻辑过期 案例\n代码实现\nprivate static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); //封装缓存穿透的代码——基于逻辑过期 public Shop queryWithLogicalExpire(Long id) { String key = RedisConstants.CACHE_SHOP_KEY +id; //1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if(StrUtil.isBlank(shopJson)){ //3.不存在，直接返回null return null; } //4.命中，需要把这个json对象反序列化 RedisData redisDate = JSONUtil.toBean(shopJson, RedisData.class); Shop shop = JSONUtil.toBean((JSONObject) redisDate.getData();, Shop.class); LocalDateTime expireTime = redisDate.getExpireTime(); //5，判断是否过期 if (expireTime.isAfter(LocalDateTime.now())) { //5.1 未过期，直接返回店铺信息 return shop; } //5.2 已过期，需要缓存重建 //6.缓存重建 //6.1 获取互斥锁 String localKey = RedisConstants.LOCK_SHOP_KEY + id; boolean isLock = tryLock(localKey); //6.2 判断是否获取锁成功 if(isLock){ //6.3 成功，开启独立线程，实现缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -\u0026gt; { try { //重建缓存 this.saveShopToRedis(id,20L); } catch (Exception e) { throw new RuntimeException(e); } finally { //释放锁 unlock(localKey); } }); } //6.4 返回过期的商铺信息 return shop; } public void saveShopToRedis(Long id,Long expireSeconds){ //1.查询店铺数据 Shop shop = getById(id); Thread.sleep(200); //2.封装逻辑过期时间 RedisData redisData = new RedisData(); redisData.setData(shop); redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds)); //3.写入Redis stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(redisData)); } 缓存封装工具 1.方法类型 2.代码封装 @Slf4j @Component public class CacheClient { private final StringRedisTemplate stringRedisTemplate; public CacheClient(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } public void set(String key, Object value, Long time, TimeUnit unit){ stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit); } public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit){ RedisData redisData = new RedisData(); redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time))); redisData.setData(value); stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData)); } public \u0026lt;R,ID\u0026gt; R queryWithPassThrough( String keyPrefix, ID id, Class\u0026lt;R\u0026gt; type, Function\u0026lt;ID,R\u0026gt; dbFallback, Long time, TimeUnit unit){ String key = keyPrefix +id; //1.从redis查询商铺缓存 String json = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if(StrUtil.isNotBlank(json)){ //3.存在，直接返回 return JSONUtil.toBean(json,type); } //判断是否为空值，如果是“”，就不用返回数据库的查询了，如果是null,就需要进行数据库的查询（因为数据库没有查到会默认传一个“”，省略了查数据库的这一步） if(json != null){ return null; } //4.不存在，根据id查询数据库 R r = dbFallback.apply(id); //5.数据库不存在，返回错误 if(r==null){ //将空值写入redis stringRedisTemplate.opsForValue().set(key,\u0026#34;\u0026#34;,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES); return null; } //6.存在，将查询结果写入redis this.stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(r),time,unit); //7.返回数据 return r; } private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); //封装缓存穿透的代码——基于逻辑过期 public \u0026lt;R,ID\u0026gt; R queryWithLogicalExpire( String prefix, ID id, Class\u0026lt;R\u0026gt; type, Function\u0026lt;ID,R\u0026gt; dbFallback, Long time, TimeUnit unit) { String key = prefix +id; //1.从redis查询商铺缓存 String json = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if(StrUtil.isBlank(json)){ //3.不存在，直接返回null return null; } //4.命中，需要把这个json对象反序列化 RedisData redisDate = JSONUtil.toBean(json, RedisData.class); R r = JSONUtil.toBean((JSONObject) redisDate.getData(), type); LocalDateTime expireTime = redisDate.getExpireTime(); //5，判断是否过期 if (expireTime.isAfter(LocalDateTime.now())) { //5.1 未过期，直接返回店铺信息 return r; } //5.2 已过期，需要缓存重建 //6.缓存重建 //6.1 获取互斥锁 String localKey = RedisConstants.LOCK_SHOP_KEY + id; boolean isLock = tryLock(localKey); //6.2 判断是否获取锁成功 if(isLock){ //6.3 成功，开启独立线程，实现缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -\u0026gt; { try { //查询数据库 R r1 = dbFallback.apply(id); //写入redis this.setWithLogicalExpire(key,r1,time,unit); } catch (Exception e) { throw new RuntimeException(e); } finally { //释放锁 unlock(localKey); } }); } //6.4 返回过期的商铺信息 return r; } //获取锁 private boolean tryLock(String key){ Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key,\u0026#34;1\u0026#34;,RedisConstants.LOCK_SHOP_TTL,TimeUnit.SECONDS); //如果flag的值为null，自动进行拆箱将包装类转换为基本数据类型时会抛出NullPointerException return BooleanUtil.isTrue(flag); } //删除锁 private boolean unlock(String key){ return stringRedisTemplate.delete(key); } } 3.实现样例 //缓存穿透 //Shop shop = cacheClient. //queryWithPassThrough(RedisConstants.CACHE_SHOP_KEY,id,Shop.class,this::getById, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES); //逻辑过期解决缓存击穿 Shop shop = cacheClient. queryWithLogicalExpire(RedisConstants.CACHE_SHOP_KEY,id,Shop.class,this::getById,20L,TimeUnit.SECONDS); 3.优惠券秒杀 全局唯一ID 1.问题来源 2.全局id生成器 3.代码实现 private static final long BEGIN_TIMESTAMP = 1735689600; //序列号位数 private static final int COUNT_BITS = 32; @Resource private StringRedisTemplate stringRedisTemplate; public long nextId(String keyPrefix){ //1.生成时间戳,当前时间-初始时间 LocalDateTime now = LocalDateTime.now(); long nowSecond = now.toEpochSecond(ZoneOffset.UTC); long timeStamp = nowSecond-BEGIN_TIMESTAMP; //2.生成序列号,为了防止序列号进行超标，所以引入了时间key String date = now.format(DateTimeFormatter.ofPattern(\u0026#34;yyyy:MM:dd\u0026#34;)); Long count = stringRedisTemplate.opsForValue().increment(\u0026#34;icr:\u0026#34; + keyPrefix + \u0026#34;:\u0026#34; + date); //3.借助位运算拼接并返回 return timeStamp \u0026lt;\u0026lt; COUNT_BITS | count; } 4.并发测试 @Test void testIdWorker() throws InterruptedException { // CountDownLatch：并发控制工具，这里初始计数为 300（对应 300 个并发任务） CountDownLatch latch = new CountDownLatch(300); // 定义一个并发任务 Runnable Runnable task = () -\u0026gt; { // 每个线程循环生成 100 个 ID for(int i=0;i\u0026lt;100;i++){ // 调用 RedisIdWorker 生成分布式唯一 ID，\u0026#34;order\u0026#34; 是业务前缀 long id = redisIdWorker.nextId(\u0026#34;order\u0026#34;); // 打印生成的 ID，方便观察是否有重复 System.out.println(\u0026#34;id = \u0026#34;+id); } //把 CountDownLatch 的计数器减 1 latch.countDown(); }; // 记录开始时间，用于统计生成 ID 的耗时 long begin = System.currentTimeMillis(); // 向线程池提交 300 个并发任务 for(int i=0;i\u0026lt;300;i++){ executorService.execute(task); } // 主线程阻塞，等待所有任务执行完成 latch.await(); // 记录结束时间 long end = System.currentTimeMillis(); // 输出从提交任务到当前时刻的耗时 System.out.println(\u0026#34;time:\u0026#34;+(end-begin)); } 实现优惠券秒杀下单 1.需求分析 2.添加优惠券(秒杀) 代码实现：\n@Override @Transactional public void addSeckillVoucher(Voucher voucher) { // 保存优惠券 save(voucher); // 保存秒杀信息 SeckillVoucher seckillVoucher = new SeckillVoucher(); seckillVoucher.setVoucherId(voucher.getId()); seckillVoucher.setStock(voucher.getStock()); seckillVoucher.setBeginTime(voucher.getBeginTime()); seckillVoucher.setEndTime(voucher.getEndTime()); seckillVoucherService.save(seckillVoucher); } post测试样例：http://localhost:8081/voucher/seckill\n{ \u0026#34;shopId\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;100元代金券\u0026#34;, \u0026#34;subTitle\u0026#34;: \u0026#34;新用户专享\u0026#34;, \u0026#34;rules\u0026#34;: \u0026#34;仅限堂食使用，不可叠加其他优惠\u0026#34;, \u0026#34;payValue\u0026#34;: 7000, \u0026#34;actualValue\u0026#34;: 10000, \u0026#34;type\u0026#34;: 1, \u0026#34;stock\u0026#34;: 100, \u0026#34;beginTime\u0026#34;: \u0026#34;2025-01-01T10:00:00\u0026#34;, \u0026#34;endTime\u0026#34;: \u0026#34;2030-01-07T23:59:59\u0026#34; } 3.秒杀下单 功能需求\n代码实现\n@Resource private ISeckillVoucherService seckillVoucherService; @Resource private RedisIdWorker redisIdWorker; @Override @Transactional public Result seckillVoucher(Long voucherId) { //1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); //2.判断秒杀是否开始 if(voucher.getBeginTime().isAfter(LocalDateTime.now())){ //尚未开始 return Result.fail(\u0026#34;秒杀尚未开始\u0026#34;); } //3.判断秒杀是否已经结束 if(voucher.getEndTime().isBefore(LocalDateTime.now())){ //已经结束 return Result.fail(\u0026#34;秒杀已经结束\u0026#34;); } //4.判断库存是否充足 if(voucher.getStock() \u0026lt; 1){ //库存不足 return Result.fail(\u0026#34;库存不足！\u0026#34;); } //5.扣减库存 boolean success = seckillVoucherService.update() .setSql(\u0026#34;stock = stock - 1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId).update(); if(!success){ return Result.fail(\u0026#34;库存不足！\u0026#34;); } //6.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); //6.1生成全局唯一的订单Id Long orderId = redisIdWorker.nextId(\u0026#34;order\u0026#34;); voucherOrder.setId(orderId); //6.2设置当前线程内的用户id voucherOrder.setUserId(UserHolder.getUser().getId()); //6.3设置代金券id voucherOrder.setVoucherId(voucherId); //6.4保存到数据库 save(voucherOrder); //7.返回订单 return Result.ok(orderId); } 超卖问题 1.问题来源 2.解决方案 3.乐观锁 版本号法\nCAS法\n4.代码实现 //5.扣减库存 boolean success = seckillVoucherService.update() .setSql(\u0026#34;stock = stock - 1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId).gt(\u0026#34;stock\u0026#34;,0).update(); 一人一单 1.解决方案 2.代码实现 pom.xml中添加依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 添加启动类\n@EnableAspectJAutoProxy(exposeProxy = true) 悲观锁解决一人一单\n@Override public Result seckillVoucher(Long voucherId) { //1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); //2.判断秒杀是否开始 if(voucher.getBeginTime().isAfter(LocalDateTime.now())){ //尚未开始 return Result.fail(\u0026#34;秒杀尚未开始\u0026#34;); } //3.判断秒杀是否已经结束 if(voucher.getEndTime().isBefore(LocalDateTime.now())){ //已经结束 return Result.fail(\u0026#34;秒杀已经结束\u0026#34;); } //4.判断库存是否充足 if(voucher.getStock() \u0026lt; 1){ //库存不足 return Result.fail(\u0026#34;库存不足！\u0026#34;); } Long userId = UserHolder.getUser().getId(); synchronized (userId.toString().intern()) { //获取代理对象，避免没提交到数据库就释放锁的安全问题 IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); } } @Transactional public Result createVoucherOrder(Long voucherId) { //5.一人一单 Long userId = UserHolder.getUser().getId(); //5.1查询订单 Long count = query().eq(\u0026#34;user_id\u0026#34;, userId).eq(\u0026#34;voucher_id\u0026#34;, voucherId).count(); //5.2判断是否存在 if(count \u0026gt; 0L){ //用户已经购买过了 return Result.fail(\u0026#34;用户已经购买过一次！\u0026#34;); } //6.扣减库存 boolean success = seckillVoucherService.update() .setSql(\u0026#34;stock = stock - 1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId).gt(\u0026#34;stock\u0026#34;,0).update(); if(!success){ return Result.fail(\u0026#34;库存不足！\u0026#34;); } //7.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); //7.1生成全局唯一的订单Id Long orderId = redisIdWorker.nextId(\u0026#34;order\u0026#34;); voucherOrder.setId(orderId); //7.2设置当前线程内的用户id voucherOrder.setUserId(UserHolder.getUser().getId()); //7.3设置代金券id voucherOrder.setVoucherId(voucherId); //7.4保存到数据库 save(voucherOrder); //8.返回订单 return Result.ok(orderId); } 分布式锁 1.集群模式下的并发安全问题（TODO） 添加集群\n配置反向代理\n重启nginx nginx.exe -s reload\n问题来源\n2.分布式锁原理 3.redis实现分布式锁 代码实现\npublic class SimpleRedisLock implements ILock{ private final String name; private final StringRedisTemplate stringRedisTemplate; public SimpleRedisLock(String name,StringRedisTemplate stringRedisTemplate){ this.name = name; this.stringRedisTemplate = stringRedisTemplate; } private static final String KEY_PREFIX = \u0026#34;lock:\u0026#34;; @Override public boolean tryLock(Long timeoutSec) { //获取线程标识 long threadId = Thread.currentThread().getId(); //获取锁 Boolean success = stringRedisTemplate.opsForValue(). setIfAbsent(KEY_PREFIX + name, threadId + \u0026#34;\u0026#34;, timeoutSec, TimeUnit.SECONDS); //防止拆箱为NULL return Boolean.TRUE.equals(success); } @Override public void unlock() { //释放锁 stringRedisTemplate.delete(KEY_PREFIX + name); } } 使用样例\n//创建锁对象 SimpleRedisLock lock = new SimpleRedisLock(\u0026#34;order:\u0026#34; + userId, stringRedisTemplate); //获取锁 boolean isLock = lock.tryLock(1200L); //判断锁是否获取成功 if(!isLock){ //获取锁失败或者重试 return Result.fail(\u0026#34;一个人不允许重复下单\u0026#34;); } try { //获取代理对象，避免没提交到数据库就释放锁的安全问题 IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); } catch (IllegalStateException e) { throw new RuntimeException(e); } finally { lock.unlock(); } 4.误删问题 问题来源：业务未完成超时释放锁 。导致线程2，3全都获取锁执行成功\n**解决办法：**判断获取锁的标识前后是否一致。\n代码实现\nprivate static final String KEY_PREFIX = \u0026#34;lock:\u0026#34;; private static final String ID_PREFIX = UUID.randomUUID().toString() + \u0026#39;-\u0026#39;; @Override public boolean tryLock(Long timeoutSec) { //获取线程标识 String threadId = ID_PREFIX+Thread.currentThread().getId(); //获取锁 Boolean success = stringRedisTemplate.opsForValue(). setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS); //防止拆箱为NULL return Boolean.TRUE.equals(success); } @Override public void unlock() { //获取线程标识 String threadId = ID_PREFIX + Thread.currentThread().getId(); //获取锁中的标识 String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name); if(threadId.equals(id)){ //释放锁 stringRedisTemplate.delete(KEY_PREFIX + name); } } 5.原子性问题 问题来源：判断锁标识和释放锁之间产生了阻塞问题，导致锁超时自动释放，导致线程2，3并发安全问题、导致于线程1，3的执行都成功\nLua语言\nLua语言的执行\nLua脚本:实现判断锁标识和释放锁的一致性\n-- 比较线程标识与锁中的线程标识是否一致 if(redis.call(\u0026#39;get\u0026#39;,KEYS[i]) == ARGV[i]) then -- 释放锁 del key return redis.call(\u0026#39;del\u0026#39;,KEYS[i]) end return 0 java调用这个lua脚本\nprivate static final DefaultRedisScript\u0026lt;Long\u0026gt; UNLOCK_SCRIPT; //初始化脚本 static { UNLOCK_SCRIPT = new DefaultRedisScript\u0026lt;\u0026gt;(); UNLOCK_SCRIPT.setLocation(new ClassPathResource(\u0026#34;unlock.lua\u0026#34;)); UNLOCK_SCRIPT.setResultType(Long.class); } @Override public void unlock() { //调用lua脚本 stringRedisTemplate.execute( UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX+name), ID_PREFIX+Thread.currentThread().getId() ); } 6.Redisson重构 问题来源\nRedis秒杀优化 Redis消息队列实现异步秒杀优化 4.达人探店 5.好友关注 6.附近商铺搜索 7.用户签到 8.UV统计 ","permalink":"http://localhost:1313/java-notes/hmdp/","summary":"黑马点评项目学习笔记，涵盖 Redis 缓存、分布式锁、消息队列等核心技术实践","title":"黑马点评项目笔记"},{"content":"第一题：线性回归梯度下降 题目： 对线性模型 $h_\\theta(x) = \\theta^\\top x$，给定训练集 $\\{(x^{(i)}, y^{(i)})\\}$，推导其向量形式的最小二乘损失梯度下降更新公式为：\n$$\\theta := \\theta + \\alpha \\sum_{i=1}^{n} (y^{(i)} - h_\\theta(x^{(i)})) x^{(i)}$$解：\n最小二乘损失函数为：\n$$J(\\theta) = \\frac{1}{2}\\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)})^2 = \\frac{1}{2}\\sum_{i=1}^{n}(\\theta^\\top x^{(i)} - y^{(i)})^2$$对 $\\theta$ 求梯度：\n$$\\begin{aligned} \\nabla_\\theta J(\\theta) \u0026= \\sum_{i=1}^{n}(\\theta^\\top x^{(i)} - y^{(i)}) \\cdot x^{(i)} \\\\ \u0026= \\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} \\end{aligned}$$梯度下降更新规则为 $\\theta := \\theta - \\alpha \\nabla_\\theta J(\\theta)$，因此：\n$$\\theta := \\theta - \\alpha \\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} = \\theta + \\alpha \\sum_{i=1}^{n}(y^{(i)} - h_\\theta(x^{(i)})) x^{(i)}$$ 第二题：交叉熵损失梯度 题目： Cross Entropy Loss 定义如下：\n$$l_{ce}((t_1,\\ldots,t_k),y) = -\\log\\left(\\frac{\\exp(t_y)}{\\sum_j \\exp(t_j)}\\right)$$令向量 $t = (t_1,t_2,\\ldots,t_k)$，推导 CEL 对任意 $t_i$ 求导为：\n$$\\frac{\\partial l_{ce}(t,y)}{\\partial t_i} = \\phi_i - \\mathbb{1}\\{y=i\\}$$解：\n记 $\\phi_i = \\frac{\\exp(t_i)}{\\sum_j \\exp(t_j)}$ 为 softmax 函数。\n首先简化损失函数：\n$$l_{ce}(t,y) = -\\log(\\phi_y) = -t_y + \\log\\left(\\sum_j \\exp(t_j)\\right)$$对 $t_i$ 求导：\n$$\\begin{aligned} \\frac{\\partial l_{ce}(t,y)}{\\partial t_i} \u0026= -\\frac{\\partial t_y}{\\partial t_i} + \\frac{\\partial}{\\partial t_i}\\log\\left(\\sum_j \\exp(t_j)\\right) \\\\ \u0026= -\\mathbb{1}\\{y=i\\} + \\frac{\\exp(t_i)}{\\sum_j \\exp(t_j)} \\\\ \u0026= \\phi_i - \\mathbb{1}\\{y=i\\} \\end{aligned}$$其中 $\\mathbb{1}\\{y=i\\}$ 是指示函数，当 $y=i$ 时为1，否则为0。\n第三题：高斯假设下的最大似然估计 题目： 证明在高斯差异假定下，对线性模型 $h_\\theta(x) = \\theta^\\top x$，最大化参数似然 $L(\\theta)$ 等价于最小化二乘损失 $\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2$。\n解：\n假设误差 $\\epsilon^{(i)} = y^{(i)} - \\theta^\\top x^{(i)}$ 服从独立同分布的高斯分布 $\\mathcal{N}(0, \\sigma^2)$，即：\n$$p(\\epsilon^{(i)}) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(\\epsilon^{(i)})^2}{2\\sigma^2}\\right)$$因此：\n$$p(y^{(i)} | x^{(i)}; \\theta) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right)$$似然函数为：\n$$\\begin{aligned} L(\\theta) \u0026= \\prod_{i=1}^{n} p(y^{(i)} | x^{(i)}; \\theta) \\\\ \u0026= \\prod_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right) \\end{aligned}$$对数似然为：\n$$\\begin{aligned} \\log L(\\theta) \u0026= \\sum_{i=1}^{n}\\left[\\log\\frac{1}{\\sqrt{2\\pi}\\sigma} - \\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right] \\\\ \u0026= n\\log\\frac{1}{\\sqrt{2\\pi}\\sigma} - \\frac{1}{2\\sigma^2}\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2 \\end{aligned}$$最大化 $\\log L(\\theta)$ 等价于最小化 $\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2$。\n第四题：Logistic回归的NLL损失 题目： 对Logistic回归模型 $h_\\theta(x) = g(\\theta^\\top x) = \\frac{1}{1+e^{-\\theta^\\top x}}$，推导其在单样本 $(x,y)$ 下的NLL（negative log likelihood）损失，以及损失对特定参数 $\\theta_j$ 的导数为 $(h_\\theta(x) - y)x_j$。\n提示：Logistic回归预测概率的统一形式为 $P(y|x;\\theta) = (h_\\theta(x))^y(1-h_\\theta(x))^{1-y}$\n解：\n根据提示，Logistic回归的概率模型为：\n$$P(y|x;\\theta) = (h_\\theta(x))^y(1-h_\\theta(x))^{1-y}$$其中 $y \\in \\{0,1\\}$，$h_\\theta(x) = g(\\theta^\\top x) = \\frac{1}{1+e^{-\\theta^\\top x}}$。\n对数似然为：\n$$\\log P(y|x;\\theta) = y\\log(h_\\theta(x)) + (1-y)\\log(1-h_\\theta(x))$$NLL损失为：\n$$\\text{NLL}(x,y;\\theta) = -\\log P(y|x;\\theta) = -y\\log(h_\\theta(x)) - (1-y)\\log(1-h_\\theta(x))$$对 $\\theta_j$ 求导。首先注意到：\n$$\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j} = h_\\theta(x)(1-h_\\theta(x)) \\cdot x_j$$这是因为 $g'(z) = g(z)(1-g(z))$。\n因此：\n$$\\begin{aligned} \\frac{\\partial \\text{NLL}}{\\partial \\theta_j} \u0026= -y\\frac{1}{h_\\theta(x)}\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j} - (1-y)\\frac{1}{1-h_\\theta(x)}\\left(-\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j}\\right) \\\\ \u0026= -y\\frac{1}{h_\\theta(x)} \\cdot h_\\theta(x)(1-h_\\theta(x))x_j + (1-y)\\frac{1}{1-h_\\theta(x)} \\cdot h_\\theta(x)(1-h_\\theta(x))x_j \\\\ \u0026= -y(1-h_\\theta(x))x_j + (1-y)h_\\theta(x)x_j \\\\ \u0026= (h_\\theta(x) - y)x_j \\end{aligned}$$ 第五题：Poisson分布的指数族形式 题目： 已知指数分布族定义如下：$p(y;\\eta) = b(y)\\exp(\\eta^\\top y - a(\\eta))$。推导Poisson分布的指数分布族形式，并构建Poisson分布对应的广义线性模型。其中，Poisson分布 $\\text{Pois}(\\lambda)$ 的概率密度函数如下：\n$$P(X=k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}$$解：\n将Poisson分布改写为指数族形式：\n$$\\begin{aligned} P(X=k) \u0026= \\frac{\\lambda^k e^{-\\lambda}}{k!} \\\\ \u0026= \\frac{1}{k!}\\exp(k\\log\\lambda - \\lambda) \\\\ \u0026= \\frac{1}{k!}\\exp(\\eta \\cdot k - e^\\eta) \\end{aligned}$$其中 $\\eta = \\log\\lambda$（自然参数），因此 $\\lambda = e^\\eta$。\n对应指数族形式：\n$b(y) = \\frac{1}{y!}$ $\\eta = \\log\\lambda$ $a(\\eta) = e^\\eta = \\lambda$ $y$ 的充分统计量就是 $y$ 本身 构建广义线性模型：\n假设 $y|x;\\theta \\sim \\text{Pois}(\\lambda)$ 自然参数 $\\eta = \\theta^\\top x$ 因为 $\\lambda = e^\\eta$，所以 $\\lambda = e^{\\theta^\\top x}$ 响应函数（期望）为：$h_\\theta(x) = \\mathbb{E}[y|x;\\theta] = \\lambda = e^{\\theta^\\top x}$ 这就是Poisson回归模型。\n第六题：Shapley值计算 题目： 计算以下3人团队的Shapley值 $\\phi_1$、$\\phi_2$、$\\phi_3$。\n给定：\n$C_{123} = 10000$，$C_0 = 0$ $C_{12} = 7500$，$C_{13} = 7500$，$C_{23} = 5000$ $C_1 = 5000$，$C_2 = 5000$，$C_3 = 0$ 解：\nShapley值的公式为：\n$$\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(|N|-|S|-1)!}{|N|!}[C(S \\cup \\{i\\}) - C(S)]$$对于3人团队，$|N| = 3$，计算每个玩家的边际贡献：\n玩家1的Shapley值：\n$$\\begin{aligned} \\phi_1 \u0026= \\frac{0!2!}{3!}[C_1 - C_0] + \\frac{1!1!}{3!}[C_{12} - C_2] + \\frac{1!1!}{3!}[C_{13} - C_3] + \\frac{2!0!}{3!}[C_{123} - C_{23}] \\\\ \u0026= \\frac{1}{3}[5000 - 0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[7500 - 0] + \\frac{1}{3}[10000 - 5000] \\\\ \u0026= \\frac{5000}{3} + \\frac{2500}{6} + \\frac{7500}{6} + \\frac{5000}{3} \\\\ \u0026= \\frac{10000}{3} + \\frac{10000}{6} = \\frac{20000 + 10000}{6} = 5000 \\end{aligned}$$玩家2的Shapley值：\n$$\\begin{aligned} \\phi_2 \u0026= \\frac{0!2!}{3!}[C_2 - C_0] + \\frac{1!1!}{3!}[C_{12} - C_1] + \\frac{1!1!}{3!}[C_{23} - C_3] + \\frac{2!0!}{3!}[C_{123} - C_{13}] \\\\ \u0026= \\frac{1}{3}[5000 - 0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[5000 - 0] + \\frac{1}{3}[10000 - 7500] \\\\ \u0026= \\frac{5000}{3} + \\frac{2500}{6} + \\frac{5000}{6} + \\frac{2500}{3} \\\\ \u0026= \\frac{15000 + 2500 + 5000 + 5000}{6} = \\frac{27500}{6} \\approx 4583.33 \\end{aligned}$$玩家3的Shapley值：\n由对称性或直接计算：\n$$\\phi_3 = 10000 - \\phi_1 - \\phi_2 = 10000 - 5000 - 4583.33 = 416.67$$或直接计算：\n$$\\begin{aligned} \\phi_3 \u0026= \\frac{1}{3}[0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[5000 - 5000] + \\frac{1}{3}[10000 - 7500] \\\\ \u0026= 0 + \\frac{2500}{6} + 0 + \\frac{2500}{3} = \\frac{5000}{6} \\approx 416.67 \\end{aligned}$$答案： $\\phi_1 = 5000$，$\\phi_2 \\approx 4583.33$，$\\phi_3 \\approx 416.67$\n第七题：协方差矩阵性质 题目： 基于协方差矩阵定义 $\\Sigma = \\text{Cov}(X)$ 证明：\n$\\Sigma$ 为对称矩阵； $\\Sigma$ 半正定，记 $\\Sigma \\geq 0$，即对任意向量 $z \\in \\mathbb{R}^d$ 有 $z^\\top \\Sigma z \\geq 0$。 解：\n设 $X \\in \\mathbb{R}^d$ 为随机向量，$\\mu = \\mathbb{E}[X]$，则：\n$$\\Sigma = \\text{Cov}(X) = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top]$$(1) 证明 $\\Sigma$ 为对称矩阵：\n$$\\Sigma^\\top = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top]^\\top = \\mathbb{E}[((X-\\mu)(X-\\mu)^\\top)^\\top] = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top] = \\Sigma$$因此 $\\Sigma$ 是对称矩阵。\n(2) 证明 $\\Sigma$ 半正定：\n对任意 $z \\in \\mathbb{R}^d$：\n$$\\begin{aligned} z^\\top \\Sigma z \u0026= z^\\top \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top] z \\\\ \u0026= \\mathbb{E}[z^\\top(X-\\mu)(X-\\mu)^\\top z] \\\\ \u0026= \\mathbb{E}[(z^\\top(X-\\mu))^2] \\\\ \u0026\\geq 0 \\end{aligned}$$最后一步是因为期望中的项是平方项，必然非负。因此 $\\Sigma$ 半正定。\n第八题：高斯判别分析的MLE 题目： 对高斯判别分析，已知各变量概率分布为：\n$$\\begin{aligned} p(y) \u0026= \\phi^y(1-\\phi)^{1-y} \\\\ p(x|y=0) \u0026= \\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}\\exp\\left(-\\frac{1}{2}(x-\\mu_0)^\\top\\Sigma^{-1}(x-\\mu_0)\\right) \\\\ p(x|y=1) \u0026= \\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}\\exp\\left(-\\frac{1}{2}(x-\\mu_1)^\\top\\Sigma^{-1}(x-\\mu_1)\\right) \\end{aligned}$$证明在极大似然估计下，参数 $\\phi$、$\\mu_0$、$\\mu_1$ 的形式为：\n$$\\begin{aligned} \\phi \u0026= \\frac{1}{n}\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\} \\\\ \\mu_0 \u0026= \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}} \\\\ \\mu_1 \u0026= \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}} \\end{aligned}$$解：\n对数似然函数为：\n$$\\log L = \\sum_{i=1}^{n}\\left[\\log p(y^{(i)}) + \\log p(x^{(i)}|y^{(i)})\\right]$$估计 $\\phi$：\n$$\\log L_\\phi = \\sum_{i=1}^{n}\\log p(y^{(i)}) = \\sum_{i=1}^{n}[y^{(i)}\\log\\phi + (1-y^{(i)})\\log(1-\\phi)]$$令 $\\frac{\\partial \\log L_\\phi}{\\partial \\phi} = 0$：\n$$\\sum_{i=1}^{n}\\left[\\frac{y^{(i)}}{\\phi} - \\frac{1-y^{(i)}}{1-\\phi}\\right] = 0$$解得：\n$$\\phi = \\frac{1}{n}\\sum_{i=1}^{n}y^{(i)} = \\frac{1}{n}\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}$$估计 $\\mu_0$：\n只考虑 $y=0$ 的样本：\n$$\\log L_{\\mu_0} = \\sum_{i:y^{(i)}=0}\\left[-\\frac{1}{2}(x^{(i)}-\\mu_0)^\\top\\Sigma^{-1}(x^{(i)}-\\mu_0) + \\text{const}\\right]$$令 $\\frac{\\partial \\log L_{\\mu_0}}{\\partial \\mu_0} = 0$：\n$$\\sum_{i:y^{(i)}=0}\\Sigma^{-1}(x^{(i)}-\\mu_0) = 0$$解得：\n$$\\mu_0 = \\frac{\\sum_{i:y^{(i)}=0}x^{(i)}}{\\sum_{i:y^{(i)}=0}1} = \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}}$$同理可得 $\\mu_1$ 的估计。\n第九题：GDA可转化为Logistic回归 题目： 证明GDA可转化为Logistic回归。提示：\n$p(y=1|x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=1)p(y=1) + p(x|y=0)p(y=0)}$ 可记 $r(x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)}$ 给出 $p(x|y=0)$, $p(x|y=1)$, $p(y=1)$ 的表达式 解：\n根据贝叶斯定理：\n$$p(y=1|x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=1)p(y=1) + p(x|y=0)p(y=0)} = \\frac{1}{1 + \\frac{p(x|y=0)p(y=0)}{p(x|y=1)p(y=1)}} = \\frac{1}{1 + \\frac{1}{r(x)}}$$其中：\n$$r(x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)}$$计算 $\\log r(x)$：\n$$\\begin{aligned} \\log r(x) \u0026= \\log p(x|y=1) + \\log p(y=1) - \\log p(x|y=0) - \\log p(y=0) \\\\ \u0026= -\\frac{1}{2}(x-\\mu_1)^\\top\\Sigma^{-1}(x-\\mu_1) + \\frac{1}{2}(x-\\mu_0)^\\top\\Sigma^{-1}(x-\\mu_0) + \\log\\frac{\\phi}{1-\\phi} \\end{aligned}$$展开：\n$$\\begin{aligned} \\log r(x) \u0026= -\\frac{1}{2}x^\\top\\Sigma^{-1}x + x^\\top\\Sigma^{-1}\\mu_1 - \\frac{1}{2}\\mu_1^\\top\\Sigma^{-1}\\mu_1 \\\\ \u0026\\quad + \\frac{1}{2}x^\\top\\Sigma^{-1}x - x^\\top\\Sigma^{-1}\\mu_0 + \\frac{1}{2}\\mu_0^\\top\\Sigma^{-1}\\mu_0 + \\log\\frac{\\phi}{1-\\phi} \\\\ \u0026= x^\\top\\Sigma^{-1}(\\mu_1 - \\mu_0) + \\frac{1}{2}(\\mu_0^\\top\\Sigma^{-1}\\mu_0 - \\mu_1^\\top\\Sigma^{-1}\\mu_1) + \\log\\frac{\\phi}{1-\\phi} \\\\ \u0026= \\theta^\\top x + \\theta_0 \\end{aligned}$$其中：\n$$\\theta = \\Sigma^{-1}(\\mu_1 - \\mu_0), \\quad \\theta_0 = \\frac{1}{2}(\\mu_0^\\top\\Sigma^{-1}\\mu_0 - \\mu_1^\\top\\Sigma^{-1}\\mu_1) + \\log\\frac{\\phi}{1-\\phi}$$因此：\n$$p(y=1|x) = \\frac{1}{1+e^{-\\theta^\\top x - \\theta_0}} = \\frac{1}{1+e^{-\\tilde{\\theta}^\\top \\tilde{x}}}$$这正是Logistic回归的形式（其中 $\\tilde{x}$ 包含截距项）。\n第十题：Kernel Method分析 题目： Kernel method中，若Kernel function $K(x,z) = (x^\\top z + c)^2$，推导对应的feature mapping $\\phi$，并讨论对于 $n$ 个样本一轮SGD，使用Kernel method和在feature map上的计算效率优化比。\n提示：\n基于feature map的参数更新方法为：$\\theta := \\theta + \\alpha\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top\\phi(x^{(i)}))\\phi(x^{(i)})$ Kernel method的参数更新方法为：$\\theta := \\theta + \\alpha(\\tilde{y} - K\\theta)$，其中 $K_j = K(x^{(i)}, x^{(j)})$ 解：\n推导feature mapping：\n对于 $x,z \\in \\mathbb{R}^d$，展开核函数：\n$$\\begin{aligned} K(x,z) \u0026= (x^\\top z + c)^2 \\\\ \u0026= (x_1z_1 + x_2z_2 + \\cdots + x_dz_d + c)^2 \\\\ \u0026= \\sum_{i=1}^{d}x_i^2z_i^2 + \\sum_{i \\neq j}2x_ix_jz_iz_j + 2c\\sum_{i=1}^{d}x_iz_i + c^2 \\end{aligned}$$因此，feature mapping为：\n$$\\phi(x) = (x_1^2, x_2^2, \\ldots, x_d^2, \\sqrt{2}x_1x_2, \\sqrt{2}x_1x_3, \\ldots, \\sqrt{2}x_{d-1}x_d, \\sqrt{2c}x_1, \\ldots, \\sqrt{2c}x_d, c)$$维度为：$d + \\binom{d}{2} + d + 1 = d + \\frac{d(d-1)}{2} + d + 1 = \\frac{d(d+3)}{2} + 1 = O(d^2)$\n计算效率比较：\nFeature map方法： 计算 $\\phi(x^{(i)})$：$O(d^2)$ 每个样本 内积 $\\theta^\\top\\phi(x^{(i)})$：$O(d^2)$ 更新 $\\theta$：$O(d^2)$ 总计：$O(nd^2)$ 每轮SGD Kernel method： 计算核矩阵 $K$：$O(n^2d)$（一次性预计算） 更新参数：$O(n^2)$（矩阵向量乘法） 总计：$O(n^2d + n^2) = O(n^2d)$ 每轮 效率比：\n$$\\frac{\\text{Feature map}}{\\text{Kernel method}} = \\frac{O(nd^2)}{O(n^2d)} = \\frac{d}{n}$$ 当 $n \\ll d$ 时（样本少，特征多），Kernel method更高效 当 $n \\gg d$ 时（样本多，特征少），Feature map方法更高效 第十一题：超平面的函数间隔和几何间隔 题目： 对超平面 $w^\\top x + b = 0$，样本 $x^{(i)}$ 到的函数间隔 $\\hat{\\gamma}^{(i)}$ 与几何间隔 $\\gamma^{(i)}$ 满足何关系？直接给出答案即可。\n解：\n函数间隔定义为：\n$$\\hat{\\gamma}^{(i)} = y^{(i)}(w^\\top x^{(i)} + b)$$几何间隔定义为：\n$\\gamma^{(i)} = \\frac{y^{(i)}(w^\\top x^{(i)} + b)}{|w|} = \\frac{\\hat{\\gamma}^{(i)}}{|w|}$\n关系：\n$\\gamma^{(i)} = \\frac{\\hat{\\gamma}^{(i)}}{|w|}$\n几何间隔是函数间隔除以权重向量的范数，表示点到超平面的真实距离。\n第十二题：SVM的Lagrange函数和对偶形式 题目： 已知SVM的优化目标为：\n$$ \\min_{w,b} \\quad \\frac{1}{2}\\|w\\|^2 \\qquad (1) $$$$ \\text{s.t.} \\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1, \\quad i=1,\\ldots,n $$请构造其Lagrange函数 $\\mathcal{L}(w,b,\\alpha)$。\n已知 $\\mathcal{L}(w,b,\\alpha)$ 满足Slater条件，因此强对偶成立，问题(1)最终可转化为 $\\max_{\\alpha;\\alpha_i\\geq 0}\\min_w \\mathcal{L}(w,b,\\alpha)$，证明该对偶形式问题可进一步转化为：\n$$ \\max_\\alpha W(\\alpha) = \\max_\\alpha \\left(\\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle\\right) \\qquad (2) $$约束条件：\n$$ \\alpha_i \\geq 0, \\quad i=1,\\ldots,n $$$$ \\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0 $$解：\n步骤1：构造Lagrange函数\n$\\mathcal{L}(w,b,\\alpha) = \\frac{1}{2}|w|^2 - \\sum_{i=1}^{n}\\alpha_i[y^{(i)}(w^\\top x^{(i)} + b) - 1]$\n其中 $\\alpha_i \\geq 0$ 为Lagrange乘子。\n步骤2：固定 $\\alpha$，对 $w$ 求导\n$\\frac{\\partial \\mathcal{L}}{\\partial w} = w - \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)} = 0$\n因此：\n$w = \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}$\n步骤3：固定 $\\alpha$，对 $b$ 求导\n$\\frac{\\partial \\mathcal{L}}{\\partial b} = -\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$\n因此：\n$\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$\n步骤4：代入Lagrange函数\n将 $w = \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}$ 代入 $\\mathcal{L}$：\n$\\begin{aligned} \\mathcal{L}(w,b,\\alpha) \u0026= \\frac{1}{2}w^\\top w - \\sum_{i=1}^{n}\\alpha_i y^{(i)} w^\\top x^{(i)} - b\\sum_{i=1}^{n}\\alpha_i y^{(i)} + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\frac{1}{2}\\left(\\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}\\right)^\\top\\left(\\sum_{j=1}^{n}\\alpha_j y^{(j)} x^{(j)}\\right) - \\sum_{i=1}^{n}\\alpha_i y^{(i)} \\left(\\sum_{j=1}^{n}\\alpha_j y^{(j)} x^{(j)}\\right)^\\top x^{(i)} + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle - \\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle \\end{aligned}$\n其中使用了 $\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$，所以 $b$ 项消失。\n因此对偶问题为：\n$\\max_\\alpha W(\\alpha) = \\max_\\alpha \\left(\\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle\\right)$\n约束条件为：\n$\\begin{aligned} \\alpha_i \u0026\\geq 0, \\quad i=1,\\ldots,n \\\\ \\sum_{i=1}^{n}\\alpha_i y^{(i)} \u0026= 0 \\end{aligned}$\n第十三题：线性不可分的SVM与L1正则 题目： 对线性不可分的训练集，SVM对应带L1正则的优化目标是什么？已知对线性可分情况的优化为：\n$$ \\min_{w,b} \\quad \\frac{1}{2}\\|w\\|^2 \\qquad (1) $$ $$ \\text{s.t.} \\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1, \\quad i=1,\\ldots,n $$解：\n对于线性不可分的情况，引入松弛变量 $\\xi_i \\geq 0$，允许某些样本违反间隔约束。\n带L1正则的软间隔SVM优化目标为：\n$\\begin{aligned} \\min_{w,b,\\xi} \u0026\\quad \\frac{1}{2}|w|^2 + C\\sum_{i=1}^{n}\\xi_i \\\\ \\text{s.t.} \u0026\\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1 - \\xi_i, \\quad i=1,\\ldots,n \\\\ \u0026\\quad \\xi_i \\geq 0, \\quad i=1,\\ldots,n \\end{aligned}$\n其中：\n$\\xi_i$ 是松弛变量，表示样本 $i$ 违反间隔的程度 $C \u003e 0$ 是惩罚参数，控制间隔最大化与违反程度之间的权衡 $C\\sum_{i=1}^{n}\\xi_i$ 是L1正则项（对松弛变量的惩罚） 这个目标函数平衡了两个目标：\n最大化间隔（通过最小化 $|w|^2$） 最小化分类错误（通过最小化 $\\sum\\xi_i$） 第十四题：SVM最优化问题分析 题目： 已知SVM的最终优化目标为：\n$W(\\alpha) = \\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle$\n假设此时正在优化 $\\alpha_1$ 与 $\\alpha_2$，并有 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$。请推导此时 $\\alpha_2$ 应当更新的值。\n解：\n简化目标函数：\n在固定其他 $\\alpha_i$ ($i \\geq 3$) 的情况下，目标函数关于 $\\alpha_1, \\alpha_2$ 可写为：\n$W(\\alpha_1, \\alpha_2) = \\alpha_1 + \\alpha_2 + W_0 - \\frac{1}{2}[K_{11}\\alpha_1^2 + K_{22}\\alpha_2^2 + 2K_{12}\\alpha_1\\alpha_2y^{(1)}y^{(2)}] + \\text{线性项}$\n其中 $K_{ij} = \\langle x^{(i)}, x^{(j)}\\rangle$，$W_0$ 是常数项。\n利用约束 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$：\n这个约束来自 $\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$，可以改写为：\n$\\alpha_1 y^{(1)} + \\alpha_2 y^{(2)} = -\\sum_{i=3}^{n}\\alpha_i y^{(i)} = \\zeta \\quad \\text{（常数）}$\n将 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$ 代入目标函数，得到关于 $\\alpha_2$ 的单变量优化问题。\n对 $\\alpha_2$ 求导并令其为0，经过复杂推导（涉及预测误差），得到 $\\alpha_2$ 的无约束最优解：\n$\\alpha_2^{\\text{new, unc}} = \\alpha_2^{\\text{old}} + \\frac{y^{(2)}(E_1 - E_2)}{\\eta}$\n其中：\n$E_i = f(x^{(i)}) - y^{(i)}$ 是预测误差 $\\eta = K_{11} + K_{22} - 2K_{12} = \\|x^{(1)} - x^{(2)}\\|^2$（特征空间距离） 考虑约束 $0 \\leq \\alpha_2 \\leq C$：\n根据约束 $\\alpha_1 y^{(1)} + \\alpha_2 y^{(2)} = \\zeta$：\n若 $y^{(1)} \\neq y^{(2)}$： $L = \\max(0, \\alpha_2^{\\text{old}} - \\alpha_1^{\\text{old}}), \\quad H = \\min(C, C + \\alpha_2^{\\text{old}} - \\alpha_1^{\\text{old}})$ 若 $y^{(1)} = y^{(2)}$： $L = \\max(0, \\alpha_1^{\\text{old}} + \\alpha_2^{\\text{old}} - C), \\quad H = \\min(C, \\alpha_1^{\\text{old}} + \\alpha_2^{\\text{old}})$ 最终更新公式：\n$\\alpha_2^{\\text{new}} = \\begin{cases} H \u0026 \\text{if } \\alpha_2^{\\text{new, unc}} \u003e H \\\\ \\alpha_2^{\\text{new, unc}} \u0026 \\text{if } L \\leq \\alpha_2^{\\text{new, unc}} \\leq H \\\\ L \u0026 \\text{if } \\alpha_2^{\\text{new, unc}} \u003c L \\end{cases}$\n然后通过约束更新 $\\alpha_1$：\n$\\alpha_1^{\\text{new}} = \\alpha_1^{\\text{old}} + y^{(1)}y^{(2)}(\\alpha_2^{\\text{old}} - \\alpha_2^{\\text{new}})$\n第十五题：信息增益比计算 题目： 计算给定数据集中四个特征的信息增益比。可保留log项，统一底数为2。\n解：\n首先计算数据集的熵。类别分布：否=6，是=9，总计15。\n$H(D) = -\\frac{6}{15}\\log_2\\frac{6}{15} - \\frac{9}{15}\\log_2\\frac{9}{15} = -0.4\\log_2(0.4) - 0.6\\log_2(0.6) = 0.971$\n特征1：年龄 青年(5个)：否=3，是=2，$H = 0.971$ 中年(5个)：否=1，是=4，$H = 0.722$ 老年(5个)：否=2，是=3，$H = 0.971$ 条件熵：\n$H(D|\\text{年龄}) = \\frac{5}{15}(0.971) + \\frac{5}{15}(0.722) + \\frac{5}{15}(0.971) = 0.888$\n信息增益：\n$\\text{Gain}(\\text{年龄}) = 0.971 - 0.888 = 0.083$\n特征熵（分裂信息）：\n$H_A(\\text{年龄}) = -3 \\times \\frac{5}{15}\\log_2\\frac{5}{15} = \\log_2 3 = 1.585$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{年龄}) = \\frac{0.083}{1.585} = 0.052 $$特征2：有工作 否(8个)：否=4，是=4，$H = 1.0$ 是(7个)：否=2，是=5，$H = 0.863$ 条件熵：$H(D|\\text{有工作}) = 0.936$\n信息增益：$\\text{Gain}(\\text{有工作}) = 0.035$\n特征熵：$H_A(\\text{有工作}) = 0.997$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{有工作}) = 0.035 $$特征3：有自己的房子 否(9个)：否=3，是=6，$H = 0.918$ 是(6个)：否=3，是=3，$H = 1.0$ 条件熵：$H(D|\\text{有房}) = 0.951$\n信息增益：$\\text{Gain}(\\text{有房}) = 0.020$\n特征熵：$H_A(\\text{有房}) = 0.971$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{有房}) = 0.021 $$特征4：信贷情况 一般(5个)：否=4，是=1，$H = 0.722$ 好(6个)：否=2，是=4，$H = 0.918$ 非常好(4个)：否=0，是=4，$H = 0$ 条件熵：$H(D|\\text{信贷}) = 0.608$\n信息增益：$\\text{Gain}(\\text{信贷}) = 0.363$\n特征熵：$H_A(\\text{信贷}) = 1.557$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{信贷}) = 0.233 $$总结（信息增益比排序） 信贷情况：0.233 ⭐（最佳分裂特征） 年龄：0.052 有工作：0.035 有自己的房子：0.021 应选择\u0026quot;信贷情况\u0026quot;作为根节点的分裂特征。\n第十六题：XGBoost损失函数二阶泰勒展开 题目： 已知XGBoost优化第t棵树时的损失函数为：\n$\\mathcal{L}^{(t)} = \\sum_{i=1}^{n}l(y_i, \\hat{y}*i^{(t-1)} + f_t(x_i)) + \\gamma T + \\frac{1}{2}\\lambda\\sum*{j=1}^{T}w_j^2$\n请推导 $l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i))$ 在 $l(y_i, \\hat{y}_i^{(t-1)})$ 处对于 $f_t(x_i)$ 的二阶泰勒展开。其中，一阶和二阶导数可使用：\n$g_i = \\frac{\\partial l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i}\\Big|*{\\hat{y}_i^{(t-1)}}, \\quad h_i = \\frac{\\partial^2 l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i^2}\\Big|*{\\hat{y}_i^{(t-1)}}$\n在此基础上，推导叶子节点 $j$ 对应的 $w_j^*$ 满足：\n$w_j^* = -\\frac{\\sum_{i \\in \\mathcal{I}*j}g_i}{\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda}$\n其中，$\\mathcal{I}_j = \\{i \\mid q(x_i) = j\\}$ 表示属于叶子节点 $j$ 的样本集合。\n解：\n二阶泰勒展开 在 $\\hat{y}_i^{(t-1)}$ 处对 $l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i))$ 关于 $f_t(x_i)$ 进行二阶泰勒展开：\n$\\begin{aligned} l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i)) \u0026\\approx l(y_i, \\hat{y}_i^{(t-1)}) + \\frac{\\partial l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i}\\Big|*{\\hat{y}_i^{(t-1)}} \\cdot f_t(x_i) \\\\ \u0026\\quad + \\frac{1}{2}\\frac{\\partial^2 l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i^2}\\Big|*{\\hat{y}_i^{(t-1)}} \\cdot f_t(x_i)^2 \\\\ \u0026= l(y_i, \\hat{y}_i^{(t-1)}) + g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2 \\end{aligned}$\n因此损失函数变为：\n$\\mathcal{L}^{(t)} \\approx \\sum_{i=1}^{n}[l(y_i, \\hat{y}*i^{(t-1)}) + g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2] + \\gamma T + \\frac{1}{2}\\lambda\\sum*{j=1}^{T}w_j^2$\n去掉常数项 $\\sum_{i=1}^{n}l(y_i, \\hat{y}_i^{(t-1)})$：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{i=1}^{n}[g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2] + \\gamma T + \\frac{1}{2}\\lambda\\sum_{j=1}^{T}w_j^2$\n推导叶子权重 $w_j^*$ 对于树模型，$f_t(x_i) = w_{q(x_i)}$，其中 $q(x_i)$ 表示样本 $i$ 落在的叶子节点。\n将样本按叶子节点分组：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{j=1}^{T}\\left[\\left(\\sum_{i \\in \\mathcal{I}*j}g_i\\right)w_j + \\frac{1}{2}\\left(\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda\\right)w_j^2\\right] + \\gamma T$\n记 $G_j = \\sum_{i \\in \\mathcal{I}*j}g_i$，$H_j = \\sum*{i \\in \\mathcal{I}_j}h_i$，则：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{j=1}^{T}\\left[G_j w_j + \\frac{1}{2}(H_j + \\lambda)w_j^2\\right] + \\gamma T$\n对 $w_j$ 求导并令其为0：\n$\\frac{\\partial \\tilde{\\mathcal{L}}^{(t)}}{\\partial w_j} = G_j + (H_j + \\lambda)w_j = 0$\n解得：\n$w_j^* = -\\frac{G_j}{H_j + \\lambda} = -\\frac{\\sum_{i \\in \\mathcal{I}*j}g_i}{\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda}$\n这就是叶子节点的最优权重。将其代入损失函数，得到：\n$\\tilde{\\mathcal{L}}^{(t)} = -\\frac{1}{2}\\sum_{j=1}^{T}\\frac{G_j^2}{H_j + \\lambda} + \\gamma T$\n这个公式用于评估树结构的质量，指导分裂决策。\n","permalink":"http://localhost:1313/dase-course/ml-exercise-set/","summary":"胡老师上的机器学习课程习题集解答汇总","title":"机器学习习题集"},{"content":"前言 四川麻将，又称成都麻将或血战麻将，是中国最流行的麻将玩法之一。与传统麻将相比，四川麻将节奏快、变化多，充满了刺激性和趣味性。本文将带你从零开始，系统学习四川麻将的规则和技巧。\n一、基础规则入门 1.1 牌面组成 四川麻将使用108张牌，包括：\n万子：一万到九万，各4张（36张） 条子：一条到九条，各4张（36张） 筒子：一筒到九筒，各4张（36张） 注意：四川麻将没有东南西北中发白这些字牌和花牌。\n1.2 基本概念 刻子：三张相同的牌（如：三张五万） 顺子：三张连续的同花色牌（如：三四五条） 对子：两张相同的牌（如：两张八筒） 杠：四张相同的牌\n1.3 胡牌基本型 标准胡牌牌型：3n+2 结构（n个刻子或顺子 + 1个对子）\n例如：\n一一一 + 二三四 + 五六七 + 八八八 + 九九（4组3张+1对） 1.4 游戏流程 定庄：掷骰子决定庄家 配牌：每人抓13张牌，庄家多抓一张（14张） 出牌：庄家先出一张牌，其他玩家依次摸牌、出牌 胡牌：谁先凑齐胡牌牌型谁获胜 血战到底：已胡牌的玩家退出，剩余玩家继续游戏，直到3人胡牌或流局 二、四川麻将特色规则 2.1 缺一门 四川麻将的核心规则：必须缺一门才能胡牌\n也就是说，你的手牌中只能有两种花色（万、条、筒三选二）。\n例如：\n✅ 可以胡：万子+条子（缺筒） ✅ 可以胡：万子+筒子（缺条） ❌ 不能胡：万子+条子+筒子（三门齐全） 2.2 杠牌规则 明杠：\n碰牌后，再摸到第四张，可以杠牌 别人打出的牌，自己有三张，可以直接杠 暗杠：\n自己摸到四张相同的牌，可以暗杠 杠牌后：\n摸一张牌 多算一番（底分×2） 杠后可以继续杠或胡牌 2.3 血战到底 这是四川麻将最大的特色：\n第一个人胡牌后不结束游戏 剩余三人继续打，直到有第二、第三个人胡牌 最后没胡的人要赔给所有胡牌的人 第一个胡牌的人可以继续胡（查叫） 2.4 查叫 游戏结束时，如果有人没胡牌：\n如果他已听牌（只差一张就能胡），他只赔给胡牌的人 如果他未听牌（没有听牌），他要加倍赔偿 三、番型与计分 3.1 基础番型 番型 番数 说明 平胡 1番 基础胡牌 自摸 1番 自己摸牌胡 根（杠） 1番 每杠一次+1番 对对胡 2番 全是刻子+对子，没有顺子 清一色 4番 全部是一种花色 龙七对 4番 七个对子 天胡 封顶 庄家起手就胡 地胡 封顶 闲家第一轮胡 3.2 计分方式 基础公式：底分 × 2^(番数)\n例如：\n底分1元，平胡（1番）= 1×2¹ = 2元 底分1元，清一色（4番）= 1×2⁴ = 16元 底分1元，清一色+对对胡（6番）= 1×2⁶ = 64元 封顶：很多地方设置封顶番数（如10番），防止输赢过大\n四、进阶技巧 4.1 定缺策略 游戏开始后，要快速决定缺哪一门：\n判断依据：\n数量最少的门：哪门牌少就缺哪门 孤张多的门：有很多不连续的孤张，这门不好组合 对子情况：如果某门有对子，考虑留下，可能组成刻子 例子：\n手牌：一万 三万 五万 六万 | 二条 七条 | 一筒 二筒 三筒 四筒 八筒 九筒 分析：万子4张分散，条子2张，筒子6张且有顺子潜力 建议：缺条子 4.2 听牌技巧 多面听优于单钓：\n单钓：只有一种牌能胡（如：等一张五万） 两面听：能胡两种牌（如：三四条，等二条或五条） 多面听：能胡多种牌（如：卡张、边张、对子等组合） 例子：\n手牌：一万 二万 | 三万 四万 | 五万 六万 | 七万 八万 | 九万 拆牌选择： - 打九万：听二万和五万（两面） - 打一万：听三万和六万和九万（多面） 建议打一万，听牌面更多 4.3 防守策略 观察舍牌：\n对手打出的牌反映他要什么、不要什么 如果对手大量打某一门，可能在做清一色 如果对手突然不打某种牌，可能在攒那个牌 生张和熟张：\n生张：桌面上没出现过的牌，危险度较高 熟张：已经有人打过的牌，相对安全 听牌信号：\n出牌犹豫 打牌速度突然变化 开始打生张或中张 4.4 做大牌策略 什么时候做大牌：\n起手牌型好（比如某门很多，可以做清一色） 当前领先或持平，可以冒险 对手没有明显听牌迹象 做大牌风险：\n听牌较慢，容易被别人截胡 如果未听牌查叫，要加倍赔偿 建议新手以稳为主，先保证听牌 4.5 心理战术 诱敌出牌：\n故意打出中张，引诱对手出你需要的牌 注意节奏，不要过于明显 藏牌意图：\n不要急于碰牌或杠牌，暴露自己的牌型 暗刻比明刻更有迷惑性 施压策略：\n快速出牌，给对手压力 适当沉默，让对手摸不清你的意图 五、常见错误与避免 5.1 新手常犯错误 忘记缺门：手牌三门齐全还以为能胡 盲目做大牌：不顾牌型强行做清一色，最后未听牌 不会算番：不知道自己多少番，糊里糊涂胡牌 乱碰乱杠：过早暴露牌型，让对手防范 不看舍牌：只顾自己手牌，不观察对手 5.2 进阶常犯错误 过度防守：太在意对手，错失自己的听牌机会 贪大求全：总想胡大牌，反而听牌慢 不会放弃：明知牌型不好还死撑，最后查叫 心态失衡：连续点炮后急躁，决策失误 六、实战案例分析 案例1：定缺选择 起手牌：\n二万 四万 六万 八万 九万 一条 二条 三条 五筒 六筒 七筒 八筒 分析：\n万子：5张但分散，不易组合 条子：3张成顺，很好 筒子：4张有两个顺子潜力 决策：缺万子，保留条筒两门\n案例2：听牌选择 当前牌型：\n二万 三万 四万 | 五万 六万 七万 | 一条 二条 三条 | 五筒 六筒 | 八筒 八筒 选择1：打五筒或六筒，听七筒（单钓） 选择2：打八筒，听四筒或七筒（两面）\n决策：选择2更优，两面听更容易胡牌\n案例3：要不要做清一色 当前牌型（已缺条）：\n一万 二万 三万 四万 五万 六万 | 二筒 五筒 七筒 | 八筒 八筒 分析：\n距离清一色还差3张筒子替换万子 如果做清一色，需要拆掉现有的顺子 当前可以快速听牌（1-2轮） 决策：不做清一色，保证快速听牌，除非后续摸牌特别好\n七、练习建议 7.1 新手阶段 熟悉规则：先玩小局，熟悉缺门、血战等规则 记住番型：至少记住基础番型和分数 多观察：看别人怎么打，学习经验 求稳为主：不要急于做大牌，先学会稳定胡牌 7.2 进阶阶段 提高速度：加快判断和决策速度 学习算牌：记住哪些牌出过，推测剩余牌 心理博弈：学会观察对手，做出针对性策略 复盘总结：每局结束后思考得失 7.3 推荐练习方式 线上平台：在手机或电脑上玩四川麻将游戏，方便练习 观战学习：看高手直播或录像，学习思路 实战练习：找朋友线下对局，积累实战经验 理论学习：阅读麻将书籍或教程，系统提升 八、总结 四川麻将规则简单但策略丰富，从新手到高手需要：\n扎实的基本功：熟练掌握规则和番型 灵活的战术：根据牌型和局势调整策略 敏锐的观察力：读懂对手意图，做出正确判断 稳定的心态：胜不骄败不馁，理性决策 记住：麻将三分靠运气，七分靠技术。多练习、多思考，你一定能成为四川麻将高手！\n祝你好运，胡牌多多！🀄\n","permalink":"http://localhost:1313/game-guide/sichuan-mahjong-guide/","summary":"四川麻将完全攻略：从基础规则到高阶技巧，涵盖缺一门、血战到底、番型计分、定缺策略、听牌技巧、防守要点和实战案例分析。无论你是零基础\n新手还是想提升的进阶玩家，这篇指南都能帮你系统掌握四川麻将的精髓，快速从入门到精通","title":"四川麻将指南"},{"content":"Windows PowerShell 常用指令 文件和目录操作 列出目录内容\nGet-ChildItem / ls - 列出当前目录内容 ls -Force - 显示隐藏文件 ls -Recurse - 递归列出所有子目录 ls | Sort-Object Length -Descending - 按文件大小排序 切换目录\nSet-Location \u0026lt;路径\u0026gt; / cd - 切换目录 cd ~ - 返回用户主目录 cd .. - 返回上级目录 cd - - 返回上一个目录 创建文件和目录\nNew-Item -ItemType Directory \u0026lt;名称\u0026gt; / mkdir - 创建目录 New-Item -ItemType File \u0026lt;名称\u0026gt; / ni - 创建文件 复制、移动和删除\nCopy-Item \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; 复制文件\nMove-Item \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; / mv - 移动/重命名文件\nRemove-Item \u0026lt;路径\u0026gt; 删除文件\n查看文件\nGet-Content \u0026lt;文件\u0026gt; / cat - 查看文件内容 Get-Content \u0026lt;文件\u0026gt; -Tail 10 - 查看最后 10 行 Get-Content \u0026lt;文件\u0026gt; -Wait - 实时查看文件更新（类似 tail -f） Test-Path \u0026lt;路径\u0026gt; - 检查路径是否存在 以默认方式打开文件或目录\nstart filename打开当前目录下的指定文件 code filename使用vscode打开 code .使用vscode打开当前目录 文本处理和搜索 Select-String \u0026lt;模式\u0026gt; \u0026lt;文件\u0026gt; - 在文件中搜索文本（类似 grep） Select-String \u0026quot;error\u0026quot; *.log - 在所有 log 文件中搜索 ls -Recurse | Select-String \u0026quot;TODO\u0026quot; - 递归搜索 Out-File \u0026lt;文件\u0026gt; - 输出重定向到文件 Tee-Object \u0026lt;文件\u0026gt; - 同时输出到控制台和文件 系统信息和管理 进程管理\nGet-Process / ps - 查看进程列表 Get-Process | Sort-Object CPU -Descending | Select-Object -First 5 - CPU 占用最高的 5 个进程 Stop-Process -Name \u0026lt;进程名\u0026gt; - 结束进程 服务管理\nGet-Service - 查看服务列表 Get-Service | Where-Object {$_.Status -eq \u0026quot;Running\u0026quot;} - 只显示运行中的服务 Start-Service \u0026lt;服务名\u0026gt; - 启动服务 Stop-Service \u0026lt;服务名\u0026gt; - 停止服务 系统信息\nGet-ComputerInfo - 查看计算机信息 Get-NetIPAddress - 查看网络配置 Get-Disk - 查看磁盘信息 Get-Volume - 查看卷信息 systeminfo - 显示详细系统信息 环境变量 $env:PATH - 查看 PATH 环境变量 $env:变量名 = \u0026quot;值\u0026quot; - 设置临时环境变量 [Environment]::SetEnvironmentVariable(\u0026quot;变量名\u0026quot;, \u0026quot;值\u0026quot;, \u0026quot;User\u0026quot;) - 永久设置 网络操作 Test-Connection \u0026lt;主机\u0026gt; / ping - 测试网络连接 Invoke-WebRequest \u0026lt;URL\u0026gt; / curl - 发送 HTTP 请求 Invoke-WebRequest -Uri \u0026lt;URL\u0026gt; -OutFile \u0026lt;文件\u0026gt; - 下载文件 Get-NetTCPConnection - 查看 TCP 连接 ipconfig - 查看 IP 配置 ipconfig /flushdns - 刷新 DNS 缓存 实用命令 Clear-Host / cls - 清屏 Get-History / history - 查看命令历史 Get-Help \u0026lt;命令\u0026gt; - 获取帮助 Get-Help \u0026lt;命令\u0026gt; -Examples - 查看使用示例 Get-Command - 列出所有可用命令 Get-Command *process* - 搜索包含 process 的命令 Get-Alias - 查看所有别名 Measure-Object - 统计对象 Start-Process \u0026lt;程序\u0026gt; - 启动程序 Get-Location / pwd - 显示当前路径 Linux Terminal 常用指令 文件和目录操作 列出目录\nls - 列出目录内容 ls -l - 长格式显示（详细信息） ls -a - 显示隐藏文件 ls -lh - 人性化显示文件大小 ls -lt - 按修改时间排序 ls -lS - 按文件大小排序 ls -R - 递归列出所有子目录 切换目录\ncd \u0026lt;路径\u0026gt; - 切换目录 cd / cd ~ - 返回主目录 cd .. - 返回上级目录 cd - - 返回上一个目录 pwd - 显示当前完整路径 创建\nmkdir \u0026lt;目录名\u0026gt; - 创建目录 mkdir -p a/b/c - 递归创建多级目录 touch \u0026lt;文件名\u0026gt; - 创建空文件或更新时间戳 复制、移动和删除\ncp \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 复制文件 cp -r \u0026lt;源目录\u0026gt; \u0026lt;目标\u0026gt; - 递归复制目录 cp -i \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 交互式复制（覆盖前询问） mv \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 移动/重命名文件 rm \u0026lt;文件\u0026gt; - 删除文件 rm -r \u0026lt;目录\u0026gt; - 递归删除目录 rm -f \u0026lt;文件\u0026gt; - 强制删除 rm -rf \u0026lt;目录\u0026gt; - 强制递归删除（危险！） rm -i \u0026lt;文件\u0026gt; - 交互式删除（推荐） 链接\nln -s \u0026lt;源\u0026gt; \u0026lt;链接名\u0026gt; - 创建符号链接 readlink -f \u0026lt;链接\u0026gt; - 查看链接目标 文件查看和编辑 查看文件\ncat \u0026lt;文件\u0026gt; - 显示文件内容 cat -n \u0026lt;文件\u0026gt; - 显示行号 less \u0026lt;文件\u0026gt; - 分页查看（可前后翻页） more \u0026lt;文件\u0026gt; - 分页查看（只能向前） head \u0026lt;文件\u0026gt; - 查看文件开头 head -n 20 \u0026lt;文件\u0026gt; - 查看前 20 行 tail \u0026lt;文件\u0026gt; - 查看文件末尾 tail -n 20 \u0026lt;文件\u0026gt; - 查看最后 20 行 tail -f \u0026lt;文件\u0026gt; - 实时查看文件更新 tail -f \u0026lt;文件\u0026gt; | grep \u0026quot;error\u0026quot; - 实时过滤查看 编辑文件\nnano \u0026lt;文件\u0026gt; - 简单文本编辑器 vim \u0026lt;文件\u0026gt; / vi \u0026lt;文件\u0026gt; - 强大的文本编辑器 统计文件\nwc \u0026lt;文件\u0026gt; - 统计文件 wc -l \u0026lt;文件\u0026gt; - 统计行数 wc -w \u0026lt;文件\u0026gt; - 统计单词数 wc -c \u0026lt;文件\u0026gt; - 统计字节数 文件搜索和查找 find 命令\nfind \u0026lt;路径\u0026gt; -name \u0026lt;名称\u0026gt; - 按名称查找 find . -name \u0026quot;*.txt\u0026quot; - 查找所有 txt 文件 find . -type f -name \u0026quot;*.log\u0026quot; - 查找文件（不含目录） find . -type d -name \u0026quot;node_modules\u0026quot; - 查找目录 find . -mtime -7 - 查找 7 天内修改的文件 find . -size +100M - 查找大于 100MB 的文件 find . -name \u0026quot;*.tmp\u0026quot; -delete - 查找并删除 grep 命令\ngrep \u0026lt;模式\u0026gt; \u0026lt;文件\u0026gt; - 搜索文本 grep -r \u0026quot;TODO\u0026quot; . - 递归搜索当前目录 grep -i \u0026quot;error\u0026quot; log.txt - 忽略大小写 grep -n \u0026quot;function\u0026quot; code.js - 显示行号 grep -v \u0026quot;debug\u0026quot; log.txt - 反向匹配（不包含） grep -E \u0026quot;error|warning\u0026quot; log.txt - 使用正则表达式 grep -c \u0026quot;error\u0026quot; log.txt - 统计匹配行数 其他查找工具\nlocate \u0026lt;文件名\u0026gt; - 快速查找文件 updatedb - 更新 locate 数据库 which \u0026lt;命令\u0026gt; - 查找命令位置 whereis \u0026lt;程序\u0026gt; - 查找程序位置 文件权限 chmod \u0026lt;权限\u0026gt; \u0026lt;文件\u0026gt; - 修改文件权限 chmod 755 script.sh - 数字方式（rwxr-xr-x） chmod +x script.sh - 添加执行权限 chmod -R 644 directory/ - 递归修改 chown \u0026lt;用户\u0026gt;:\u0026lt;组\u0026gt; \u0026lt;文件\u0026gt; - 修改所有者 chgrp \u0026lt;组\u0026gt; \u0026lt;文件\u0026gt; - 修改所属组 umask - 查看或设置默认权限掩码 进程管理 查看进程\nps - 查看进程 ps aux - 查看所有进程详细信息 ps -ef - 另一种格式 ps aux | grep \u0026lt;进程名\u0026gt; - 搜索特定进程 top - 实时查看系统资源（按 q 退出） htop - 增强版 top 管理进程\nkill \u0026lt;PID\u0026gt; - 结束进程 kill -9 \u0026lt;PID\u0026gt; - 强制结束 killall \u0026lt;进程名\u0026gt; - 按名称结束进程 pkill \u0026lt;进程名\u0026gt; - 按模式匹配结束 bg - 将任务放到后台 fg - 将后台任务调到前台 jobs - 查看后台任务 nohup \u0026lt;命令\u0026gt; \u0026amp; - 后台运行，不受终端关闭影响 磁盘和存储 df -h - 查看磁盘使用情况 du -sh \u0026lt;目录\u0026gt; - 查看目录大小 du -h --max-depth=1 - 查看各子目录大小 du -sh * | sort -h - 按大小排序 free -h - 查看内存使用 lsblk - 列出块设备 mount - 挂载文件系统 umount - 卸载文件系统 系统信息 uname -a - 完整系统信息 uname -r - 内核版本 hostname - 主机名 whoami - 当前用户 id - 用户 ID 和组 ID uptime - 系统运行时间和负载 date - 系统时间 cal - 日历 lsb_release -a - Linux 发行版信息（Ubuntu/Debian） cat /etc/os-release - 系统版本信息 网络操作 连接测试\nping \u0026lt;地址\u0026gt; - 测试网络连接 ping -c 4 google.com - 发送 4 个包后停止 traceroute \u0026lt;地址\u0026gt; - 追踪路由路径 文件传输\ncurl \u0026lt;URL\u0026gt; - 发送 HTTP 请求 curl -O \u0026lt;URL\u0026gt; - 下载文件（保持原文件名） curl -o \u0026lt;文件名\u0026gt; \u0026lt;URL\u0026gt; - 下载并重命名 curl -I \u0026lt;URL\u0026gt; - 只获取 HTTP 头 curl -X POST -d \u0026quot;data\u0026quot; \u0026lt;URL\u0026gt; - 发送 POST 请求 wget \u0026lt;URL\u0026gt; - 下载文件 wget -c \u0026lt;URL\u0026gt; - 断点续传 远程连接\nssh \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt; - SSH 连接 ssh -p \u0026lt;端口\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt; - 指定端口 scp \u0026lt;源\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt;:\u0026lt;目标\u0026gt; - 安全复制文件 scp -r \u0026lt;目录\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt;:\u0026lt;目标\u0026gt; - 复制目录 网络信息\nnetstat -tuln - 查看网络端口（传统） ss -tuln - 查看网络端口（现代） ip addr / ifconfig - 查看网络接口 nslookup \u0026lt;域名\u0026gt; - DNS 查询 dig \u0026lt;域名\u0026gt; - DNS 详细查询 压缩和解压 tar 格式\ntar -czf \u0026lt;文件.tar.gz\u0026gt; \u0026lt;目录\u0026gt; - 压缩为 tar.gz tar -xzf \u0026lt;文件.tar.gz\u0026gt; - 解压 tar.gz tar -xzf \u0026lt;文件.tar.gz\u0026gt; -C \u0026lt;目标目录\u0026gt; - 解压到指定目录 tar -tvf \u0026lt;文件.tar.gz\u0026gt; - 查看压缩包内容 zip 格式\nzip -r \u0026lt;文件.zip\u0026gt; \u0026lt;目录\u0026gt; - 创建 zip 压缩包 unzip \u0026lt;文件.zip\u0026gt; - 解压 zip unzip \u0026lt;文件.zip\u0026gt; -d \u0026lt;目标目录\u0026gt; - 解压到指定目录 gzip 格式\ngzip \u0026lt;文件\u0026gt; - 压缩为 .gz gunzip \u0026lt;文件.gz\u0026gt; - 解压 .gz 文本处理工具 sed（流编辑器）\nsed 's/old/new/g' file.txt - 替换文本 sed -i 's/old/new/g' file.txt - 直接修改文件 awk（文本处理）\nawk '{print $1}' file.txt - 打印第一列 awk -F',' '{print $2}' file.csv - 指定分隔符 排序和去重\nsort \u0026lt;文件\u0026gt; - 排序 sort -r \u0026lt;文件\u0026gt; - 反向排序 sort -n \u0026lt;文件\u0026gt; - 按数字排序 uniq \u0026lt;文件\u0026gt; - 去除重复行 sort file.txt | uniq - 配合使用 uniq -c \u0026lt;文件\u0026gt; - 统计重复次数 其他工具\ncut -d',' -f1,3 file.csv - 按分隔符提取列 tr 'a-z' 'A-Z' \u0026lt; file.txt - 字符转换 系统管理 用户管理\nsudo \u0026lt;命令\u0026gt; - 以管理员权限执行 su - 切换用户 su - - 切换到 root passwd - 修改密码 useradd \u0026lt;用户名\u0026gt; - 创建用户 userdel \u0026lt;用户名\u0026gt; - 删除用户 usermod -aG \u0026lt;组\u0026gt; \u0026lt;用户\u0026gt; - 添加用户到组 服务管理（systemd）\nsystemctl start \u0026lt;服务\u0026gt; - 启动服务 systemctl stop \u0026lt;服务\u0026gt; - 停止服务 systemctl restart \u0026lt;服务\u0026gt; - 重启服务 systemctl status \u0026lt;服务\u0026gt; - 查看状态 systemctl enable \u0026lt;服务\u0026gt; - 设置开机启动 journalctl -u \u0026lt;服务\u0026gt; - 查看服务日志 实用快捷键 Ctrl + C - 终止当前命令 Ctrl + Z - 暂停当前命令 Ctrl + D - 退出终端 Ctrl + L - 清屏 Ctrl + A - 光标移到行首 Ctrl + E - 光标移到行尾 Ctrl + U - 删除光标前的内容 Ctrl + K - 删除光标后的内容 Ctrl + R - 搜索命令历史 Tab - 自动补全 !! - 执行上一条命令 !$ - 上一条命令的最后一个参数 其他实用命令 clear - 清屏 history - 查看命令历史 history | grep \u0026lt;关键词\u0026gt; - 搜索历史命令 echo \u0026lt;文本\u0026gt; - 输出文本 echo \u0026quot;text\u0026quot; \u0026gt; file.txt - 覆盖写入 echo \u0026quot;text\u0026quot; \u0026gt;\u0026gt; file.txt - 追加写入 alias \u0026lt;别名\u0026gt;='\u0026lt;命令\u0026gt;' - 创建别名 watch \u0026lt;命令\u0026gt; - 定期执行命令 watch -n 2 df -h - 每 2 秒更新 xargs - 将标准输入转换为命令参数 tee \u0026lt;文件\u0026gt; - 同时输出到文件和标准输出 Git 常用指令 初始化和配置 初始化仓库\ngit init - 初始化新仓库 git clone \u0026lt;URL\u0026gt; - 克隆远程仓库 git clone \u0026lt;URL\u0026gt; \u0026lt;目录名\u0026gt; - 克隆到指定目录 git clone --depth 1 \u0026lt;URL\u0026gt; - 浅克隆（只克隆最新提交） git clone -b \u0026lt;分支名\u0026gt; \u0026lt;URL\u0026gt; - 克隆指定分支 配置 Git\ngit config --global user.name \u0026quot;\u0026lt;名字\u0026gt;\u0026quot; - 设置用户名 git config --global user.email \u0026quot;\u0026lt;邮箱\u0026gt;\u0026quot; - 设置邮箱 git config --list - 查看所有配置 git config --global core.editor \u0026quot;vim\u0026quot; - 设置编辑器 git config --global alias.st status - 设置别名 基本操作 查看状态\ngit status - 查看工作区状态 git status -s - 简短格式 添加和提交\ngit add \u0026lt;文件\u0026gt; - 添加文件到暂存区 git add . - 添加所有修改 git add -A - 添加所有变化（包括删除） git add -p - 交互式添加 git commit -m \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 提交 git commit -am \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 添加并提交已跟踪文件 git commit --amend - 修改最后一次提交 git commit --amend --no-edit - 修改提交但不改消息 推送和拉取\ngit push - 推送到远程 git push origin \u0026lt;分支名\u0026gt; - 推送指定分支 git push -u origin \u0026lt;分支名\u0026gt; - 推送并设置上游 git push --force / git push -f - 强制推送（危险！） git push --tags - 推送标签 git pull - 拉取并合并 git pull --rebase - 使用 rebase 方式拉取 git fetch - 获取但不合并 git fetch --all - 获取所有远程分支 git fetch --prune - 获取并清理已删除的远程分支 分支操作 查看分支\ngit branch - 查看本地分支 git branch -a - 查看所有分支（包括远程） git branch -r - 只查看远程分支 git branch -v - 查看分支及最后一次提交 创建和切换分支\ngit branch \u0026lt;分支名\u0026gt; - 创建分支 git checkout \u0026lt;分支名\u0026gt; - 切换分支 git checkout -b \u0026lt;分支名\u0026gt; - 创建并切换 git checkout -b \u0026lt;分支名\u0026gt; origin/\u0026lt;分支名\u0026gt; - 从远程分支创建 git switch \u0026lt;分支名\u0026gt; - 切换分支（新语法） git switch -c \u0026lt;分支名\u0026gt; - 创建并切换（新语法） 合并和删除分支\ngit merge \u0026lt;分支名\u0026gt; - 合并分支 git merge --no-ff \u0026lt;分支名\u0026gt; - 非快进合并 git merge --squash \u0026lt;分支名\u0026gt; - 压缩合并 git branch -d \u0026lt;分支名\u0026gt; - 删除已合并分支 git branch -D \u0026lt;分支名\u0026gt; - 强制删除分支 git branch -m \u0026lt;旧名\u0026gt; \u0026lt;新名\u0026gt; - 重命名分支 git push origin --delete \u0026lt;分支名\u0026gt; - 删除远程分支 查看历史 日志查看\ngit log - 查看提交历史 git log --oneline - 每个提交一行 git log --graph - 图形化显示 git log --oneline --graph --all - 图形化显示所有分支 git log -p - 显示详细差异 git log --author=\u0026quot;\u0026lt;作者\u0026gt;\u0026quot; - 按作者筛选 git log --since=\u0026quot;2 weeks ago\u0026quot; - 按时间筛选 git log --grep=\u0026quot;\u0026lt;关键词\u0026gt;\u0026quot; - 搜索提交消息 git log \u0026lt;文件\u0026gt; - 查看文件历史 git log --stat - 显示文件统计 差异比较\ngit diff - 查看未暂存的更改 git diff --staged / git diff --cached - 查看已暂存的更改 git diff \u0026lt;分支1\u0026gt; \u0026lt;分支2\u0026gt; - 比较分支 git diff \u0026lt;提交1\u0026gt; \u0026lt;提交2\u0026gt; - 比较提交 git diff HEAD - 比较工作区和最新提交 其他查看命令\ngit show \u0026lt;提交\u0026gt; - 查看提交详情 git show HEAD - 查看最新提交 git blame \u0026lt;文件\u0026gt; - 查看每行的修改者 git shortlog - 按作者分组显示 撤销和回退 撤销修改\ngit restore \u0026lt;文件\u0026gt; - 撤销工作区修改（新语法） git restore --staged \u0026lt;文件\u0026gt; - 取消暂存（新语法） git checkout -- \u0026lt;文件\u0026gt; - 撤销修改（旧语法） 重置提交\ngit reset \u0026lt;文件\u0026gt; - 取消暂存 git reset HEAD~ - 撤销最后一次提交，保留更改 git reset --soft HEAD~ - 撤销提交，更改在暂存区 git reset --hard HEAD~ - 撤销提交并丢弃更改（危险！） git reset --hard \u0026lt;提交\u0026gt; - 重置到指定提交 回退操作\ngit revert \u0026lt;提交\u0026gt; - 创建新提交来撤销 git revert HEAD - 撤销最新提交 git clean -fd - 删除未跟踪的文件 git clean -n - 预览将要删除的文件 暂存操作（Stash） git stash - 暂存当前更改 git stash save \u0026quot;描述\u0026quot; - 暂存并添加描述 git stash list - 查看暂存列表 git stash pop - 恢复并删除最新暂存 git stash apply - 恢复但不删除暂存 git stash apply stash@{0} - 恢复指定暂存 git stash drop - 删除最新暂存 git stash drop stash@{0} - 删除指定暂存 git stash clear - 清空所有暂存 git stash show - 查看暂存内容 远程仓库 查看远程\ngit remote - 查看远程仓库 git remote -v - 查看详细信息 管理远程\ngit remote add \u0026lt;名称\u0026gt; \u0026lt;URL\u0026gt; - 添加远程仓库 git remote add origin \u0026lt;URL\u0026gt; - 添加 origin git remote remove \u0026lt;名称\u0026gt; - 删除远程仓库 git remote rename \u0026lt;旧名\u0026gt; \u0026lt;新名\u0026gt; - 重命名 git remote set-url \u0026lt;名称\u0026gt; \u0026lt;新URL\u0026gt; - 修改 URL git remote show \u0026lt;名称\u0026gt; - 查看详细信息 git remote prune origin - 清理已删除的远程分支引用 标签操作 git tag - 查看所有标签 git tag \u0026lt;标签名\u0026gt; - 创建轻量标签 git tag -a \u0026lt;标签名\u0026gt; -m \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 创建带注释的标签 git tag -d \u0026lt;标签名\u0026gt; - 删除本地标签 git push origin \u0026lt;标签名\u0026gt; - 推送标签 git push origin --tags - 推送所有标签 git push origin :refs/tags/\u0026lt;标签名\u0026gt; - 删除远程标签 高级操作 变基（Rebase）\ngit rebase \u0026lt;分支\u0026gt; - 变基到指定分支 git rebase -i HEAD~3 - 交互式变基最近 3 个提交 git rebase --continue - 解决冲突后继续 git rebase --abort - 取消变基 其他高级命令\ngit cherry-pick \u0026lt;提交\u0026gt; - 将指定提交应用到当前分支 git reflog - 查看引用日志（恢复丢失的提交） git bisect start - 开始二分查找问题提交 git submodule add \u0026lt;URL\u0026gt; - 添加子模块 git submodule update --init - 初始化并更新子模块 .gitignore 配置 New-Item -ItemType File .gitignore创建 .gitignore 文件来忽略不需要跟踪的文件：\n# 忽略日志文件 *.log # 忽略 node_modules 目录 node_modules/ # 忽略环境变量文件 .env .env.local # 忽略构建输出 dist/ build/ # 忽略操作系统文件 .DS_Store Thumbs.db # 忽略 IDE 配置 .vscode/ .idea/ GitHub CLI 常用指令 认证 gh auth login - 登录 GitHub 账号 gh auth status - 查看认证状态 gh auth logout - 登出 gh auth refresh - 刷新令牌 gh config set editor vim - 设置编辑器 仓库操作 创建和克隆\ngh repo create - 创建仓库 gh repo create \u0026lt;名称\u0026gt; - 创建指定名称的仓库 gh repo create --public - 创建公开仓库 gh repo create --private - 创建私有仓库 gh repo create --clone - 创建并克隆 gh repo clone \u0026lt;仓库\u0026gt; - 克隆仓库 gh repo clone owner/repo - 克隆指定仓库 查看和管理\ngh repo view - 查看仓库信息 gh repo view --web - 在浏览器中打开 gh repo list - 列出仓库 gh repo list \u0026lt;用户名\u0026gt; - 列出指定用户的仓库 gh repo list --limit 50 - 限制显示数量 gh repo fork - Fork 仓库 gh repo fork --clone - Fork 并克隆 gh repo delete \u0026lt;仓库\u0026gt; - 删除仓库 gh repo rename \u0026lt;新名称\u0026gt; - 重命名仓库 or gh repo rename owner/repo 新名字 gh repo sync - 同步 fork Pull Request 创建 PR\ngh pr create - 创建 PR gh pr create --title \u0026quot;标题\u0026quot; --body \u0026quot;描述\u0026quot; - 指定标题和描述 gh pr create --web - 在浏览器中创建 gh pr create --draft - 创建草稿 PR 查看 PR\ngh pr list - 列出 PR gh pr list --state open - 只显示开放的 gh pr list --author \u0026lt;用户名\u0026gt; - 按作者筛选 gh pr list --label \u0026lt;标签\u0026gt; - 按标签筛选 gh pr view \u0026lt;编号\u0026gt; - 查看详情 gh pr view \u0026lt;编号\u0026gt; --web - 在浏览器中查看 gh pr view \u0026lt;编号\u0026gt; --comments - 查看评论 操作 PR\ngh pr checkout \u0026lt;编号\u0026gt; - 检出 PR 分支 gh pr diff \u0026lt;编号\u0026gt; - 查看差异 gh pr merge \u0026lt;编号\u0026gt; - 合并 PR gh pr merge \u0026lt;编号\u0026gt; --squash - 压缩合并 gh pr merge \u0026lt;编号\u0026gt; --rebase - 变基合并 gh pr close \u0026lt;编号\u0026gt; - 关闭 PR gh pr reopen \u0026lt;编号\u0026gt; - 重新打开 gh pr ready \u0026lt;编号\u0026gt; - 标记为准备好 审查 PR\ngh pr review \u0026lt;编号\u0026gt; - 审查 PR gh pr review \u0026lt;编号\u0026gt; --approve - 批准 gh pr review \u0026lt;编号\u0026gt; --request-changes - 请求更改 gh pr review \u0026lt;编号\u0026gt; --comment - 添加评论 gh pr checks \u0026lt;编号\u0026gt; - 查看 CI/CD 状态 Issue 创建 Issue\ngh issue create - 创建 Issue gh issue create --title \u0026quot;标题\u0026quot; --body \u0026quot;描述\u0026quot; - 指定内容 gh issue create --web - 在浏览器中创建 gh issue create --label \u0026quot;bug,help wanted\u0026quot; - 添加标签 查看 Issue\ngh issue list - 列出 Issues gh issue list --state open - 只显示开放的 gh issue list --assignee \u0026lt;用户名\u0026gt; - 按指派人筛选 gh issue list --label \u0026lt;标签\u0026gt; - 按标签筛选 gh issue list --author \u0026lt;用户名\u0026gt; - 按作者筛选 gh issue view \u0026lt;编号\u0026gt; - 查看详情 gh issue view \u0026lt;编号\u0026gt; --web - 在浏览器中查看 操作 Issue\ngh issue close \u0026lt;编号\u0026gt; - 关闭 Issue gh issue close \u0026lt;编号\u0026gt; --comment \u0026quot;已修复\u0026quot; - 关闭并评论 gh issue reopen \u0026lt;编号\u0026gt; - 重新打开 gh issue edit \u0026lt;编号\u0026gt; - 编辑 Issue gh issue edit \u0026lt;编号\u0026gt; --add-label \u0026quot;bug\u0026quot; - 添加标签 gh issue comment \u0026lt;编号\u0026gt; - 添加评论 gh issue status - 查看状态 Gist gh gist create \u0026lt;文件\u0026gt; - 创建 Gist gh gist create --public \u0026lt;文件\u0026gt; - 创建公开 Gist gh gist create --desc \u0026quot;描述\u0026quot; \u0026lt;文件\u0026gt; - 添加描述 gh gist list - 列出 Gists gh gist view \u0026lt;ID\u0026gt; - 查看 Gist gh gist view \u0026lt;ID\u0026gt; --web - 在浏览器中查看 gh gist edit \u0026lt;ID\u0026gt; - 编辑 Gist gh gist delete \u0026lt;ID\u0026gt; - 删除 Gist gh gist clone \u0026lt;ID\u0026gt; - 克隆到本地 Release 创建和查看\ngh release create \u0026lt;标签\u0026gt; - 创建 Release gh release create v1.0.0 --title \u0026quot;版本 1.0.0\u0026quot; --notes \u0026quot;说明\u0026quot; - 指定内容 gh release create v1.0.0 *.zip - 附加文件 gh release create v1.0.0 --draft - 创建草稿 gh release list - 列出所有 Releases gh release view \u0026lt;标签\u0026gt; - 查看详情 gh release view \u0026lt;标签\u0026gt; --web - 在浏览器中查看 下载和管理\ngh release download \u0026lt;标签\u0026gt; - 下载资源 gh release download \u0026lt;标签\u0026gt; --pattern \u0026quot;*.zip\u0026quot; - 下载匹配文件 gh release delete \u0026lt;标签\u0026gt; - 删除 Release gh release upload \u0026lt;标签\u0026gt; \u0026lt;文件\u0026gt; - 上传文件 GitHub Actions 工作流管理\ngh workflow list - 列出工作流 gh workflow view \u0026lt;工作流\u0026gt; - 查看详情 gh workflow view \u0026lt;工作流\u0026gt; --web - 在浏览器中查看 gh workflow run \u0026lt;工作流\u0026gt; - 触发工作流 gh workflow run \u0026lt;工作流\u0026gt; --ref \u0026lt;分支\u0026gt; - 在指定分支运行 运行管理\ngh run list - 列出运行记录 gh run list --workflow \u0026lt;工作流名\u0026gt; - 按工作流筛选 gh run view \u0026lt;运行ID\u0026gt; - 查看详情 gh run view \u0026lt;运行ID\u0026gt; --log - 查看日志 gh run watch \u0026lt;运行ID\u0026gt; - 实时查看状态 gh run rerun \u0026lt;运行ID\u0026gt; - 重新运行 gh run cancel \u0026lt;运行ID\u0026gt; - 取消运行 其他功能 浏览和搜索\ngh browse - 在浏览器中打开仓库 gh browse \u0026lt;文件\u0026gt; - 打开指定文件 gh browse --settings - 打开设置 gh search repos \u0026lt;关键词\u0026gt; - 搜索仓库 gh search repos --stars \u0026quot;\u0026gt;1000\u0026quot; - 按星标搜索 gh search repos --language python - 按语言搜索 gh search issues \u0026lt;关键词\u0026gt; - 搜索 Issues gh search prs \u0026lt;关键词\u0026gt; - 搜索 PRs API 和扩展\ngh api \u0026lt;端点\u0026gt; - 调用 GitHub API gh api user - 获取用户信息 gh alias set \u0026lt;别名\u0026gt; \u0026lt;命令\u0026gt; - 创建别名 gh extension install \u0026lt;扩展\u0026gt; - 安装扩展 gh extension list - 列出扩展 标签和项目\ngh label list - 列出标签 gh label create \u0026lt;名称\u0026gt; - 创建标签 gh project list - 列出项目 gh project view \u0026lt;编号\u0026gt; - 查看项目 ","permalink":"http://localhost:1313/doc-intro/command-reference/","summary":"详细的命令行指令参考手册，包含 Windows PowerShell、Linux Terminal、Git 和 GitHub CLI 的常用命令及实用技巧","title":"常用命令行指令参考"},{"content":"一、数据库操作 1.1 创建和删除数据库 -- 创建数据库 CREATE DATABASE database_name; CREATE DATABASE IF NOT EXISTS database_name CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; -- 删除数据库 DROP DATABASE database_name; DROP DATABASE IF EXISTS database_name; -- 查看所有数据库 SHOW DATABASES; -- 选择数据库 USE database_name; -- 查看当前数据库 SELECT DATABASE(); 二、数据表操作 2.1 创建表 -- 基础创建表 CREATE TABLE users ( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(50) NOT NULL UNIQUE, email VARCHAR(100), age INT DEFAULT 0, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ); -- 创建表时指定引擎和字符集 CREATE TABLE products ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(100) NOT NULL, price DECIMAL(10, 2), stock INT DEFAULT 0 ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; -- 从查询结果创建表 CREATE TABLE users_backup AS SELECT * FROM users; 2.2 修改表结构 -- 添加列 ALTER TABLE users ADD COLUMN phone VARCHAR(20); ALTER TABLE users ADD COLUMN address TEXT AFTER email; -- 修改列 ALTER TABLE users MODIFY COLUMN age TINYINT; ALTER TABLE users CHANGE COLUMN username user_name VARCHAR(60); -- 删除列 ALTER TABLE users DROP COLUMN phone; -- 重命名表 RENAME TABLE users TO members; ALTER TABLE members RENAME TO users; -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键 ALTER TABLE users DROP PRIMARY KEY; -- 添加索引 ALTER TABLE users ADD INDEX idx_username (username); ALTER TABLE users ADD UNIQUE INDEX idx_email (email); -- 删除索引 ALTER TABLE users DROP INDEX idx_username; 2.3 查看表信息 -- 查看所有表 SHOW TABLES; -- 查看表结构 DESC users; DESCRIBE users; SHOW COLUMNS FROM users; -- 查看创建表的语句 SHOW CREATE TABLE users; -- 查看表状态 SHOW TABLE STATUS LIKE \u0026#39;users\u0026#39;; 2.4 删除和清空表 -- 删除表 DROP TABLE users; DROP TABLE IF EXISTS users; -- 清空表数据（保留结构） TRUNCATE TABLE users; DELETE FROM users; -- 与 TRUNCATE 的区别是可以回滚 三、数据操作（CRUD） 3.1 插入数据（INSERT） -- 插入单条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;, 25); -- 插入多条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;李四\u0026#39;, \u0026#39;lisi@example.com\u0026#39;, 28), (\u0026#39;王五\u0026#39;, \u0026#39;wangwu@example.com\u0026#39;, 30); -- 插入所有列（可省略列名） INSERT INTO users VALUES (NULL, \u0026#39;赵六\u0026#39;, \u0026#39;zhaoliu@example.com\u0026#39;, 22, NOW(), NOW()); -- 插入或更新（存在则更新） INSERT INTO users (id, username, email) VALUES (1, \u0026#39;张三\u0026#39;, \u0026#39;new@example.com\u0026#39;) ON DUPLICATE KEY UPDATE email = \u0026#39;new@example.com\u0026#39;; -- 忽略重复插入错误 INSERT IGNORE INTO users (username, email) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;); -- 从其他表插入数据 INSERT INTO users_backup SELECT * FROM users WHERE age \u0026gt; 25; 3.2 查询数据（SELECT） 基础查询 -- 查询所有列 SELECT * FROM users; -- 查询指定列 SELECT username, email FROM users; -- 使用别名 SELECT username AS name, email AS mail FROM users; -- 去重查询 SELECT DISTINCT age FROM users; -- 限制结果数量 SELECT * FROM users LIMIT 10; SELECT * FROM users LIMIT 10, 20; -- 跳过前10条，取20条 SELECT * FROM users LIMIT 20 OFFSET 10; -- 同上 WHERE 条件查询 -- 基本条件 SELECT * FROM users WHERE age \u0026gt; 25; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users WHERE email IS NULL; SELECT * FROM users WHERE email IS NOT NULL; -- 多条件组合 SELECT * FROM users WHERE age \u0026gt; 20 AND age \u0026lt; 30; SELECT * FROM users WHERE age BETWEEN 20 AND 30; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39; OR username = \u0026#39;李四\u0026#39;; SELECT * FROM users WHERE username IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;); SELECT * FROM users WHERE username NOT IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;); -- 模糊查询 SELECT * FROM users WHERE username LIKE \u0026#39;张%\u0026#39;; -- 以\u0026#34;张\u0026#34;开头 SELECT * FROM users WHERE username LIKE \u0026#39;%三\u0026#39;; -- 以\u0026#34;三\u0026#34;结尾 SELECT * FROM users WHERE username LIKE \u0026#39;%张%\u0026#39;; -- 包含\u0026#34;张\u0026#34; SELECT * FROM users WHERE username LIKE \u0026#39;张_\u0026#39;; -- 张+一个字符 SELECT * FROM users WHERE username NOT LIKE \u0026#39;张%\u0026#39;; 排序和分组 -- 排序 SELECT * FROM users ORDER BY age ASC; -- 升序（默认） SELECT * FROM users ORDER BY age DESC; -- 降序 SELECT * FROM users ORDER BY age DESC, username ASC; -- 多列排序 -- 分组 SELECT age, COUNT(*) as count FROM users GROUP BY age; SELECT age, AVG(age) as avg_age FROM users GROUP BY age; -- HAVING 过滤分组结果 SELECT age, COUNT(*) as count FROM users GROUP BY age HAVING count \u0026gt; 5; 聚合函数 -- 计数 SELECT COUNT(*) FROM users; SELECT COUNT(DISTINCT age) FROM users; -- 求和、平均、最大、最小 SELECT SUM(age) FROM users; SELECT AVG(age) FROM users; SELECT MAX(age) FROM users; SELECT MIN(age) FROM users; -- 多个聚合函数 SELECT COUNT(*) as total, AVG(age) as avg_age, MAX(age) as max_age FROM users; 连接查询（JOIN） -- 内连接（INNER JOIN） SELECT users.username, orders.order_no FROM users INNER JOIN orders ON users.id = orders.user_id; -- 左连接（LEFT JOIN） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id; -- 右连接（RIGHT JOIN） SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 全连接（FULL JOIN，MySQL不直接支持，需要用UNION） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id UNION SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 自连接 SELECT a.username, b.username as friend FROM users a INNER JOIN users b ON a.friend_id = b.id; -- 多表连接 SELECT u.username, o.order_no, p.product_name FROM users u INNER JOIN orders o ON u.id = o.user_id INNER JOIN order_items oi ON o.id = oi.order_id INNER JOIN products p ON oi.product_id = p.id; 子查询 -- WHERE 子查询 SELECT * FROM users WHERE id IN (SELECT user_id FROM orders WHERE amount \u0026gt; 1000); -- FROM 子查询 SELECT avg_age FROM (SELECT AVG(age) as avg_age FROM users GROUP BY city) as subquery; -- EXISTS 子查询 SELECT * FROM users WHERE EXISTS (SELECT 1 FROM orders WHERE orders.user_id = users.id); -- 标量子查询 SELECT username, (SELECT COUNT(*) FROM orders WHERE user_id = users.id) as order_count FROM users; 联合查询（UNION） -- UNION（去重） SELECT username FROM users WHERE age \u0026gt; 30 UNION SELECT username FROM admins WHERE age \u0026gt; 30; -- UNION ALL（不去重，性能更好） SELECT username FROM users WHERE age \u0026gt; 30 UNION ALL SELECT username FROM admins WHERE age \u0026gt; 30; 3.3 更新数据（UPDATE） -- 更新单列 UPDATE users SET age = 26 WHERE username = \u0026#39;张三\u0026#39;; -- 更新多列 UPDATE users SET age = 26, email = \u0026#39;new@example.com\u0026#39; WHERE username = \u0026#39;张三\u0026#39;; -- 批量更新 UPDATE users SET age = age + 1 WHERE age \u0026lt; 30; -- 使用表达式更新 UPDATE users SET updated_at = NOW() WHERE id = 1; -- 基于其他表更新 UPDATE users u INNER JOIN orders o ON u.id = o.user_id SET u.total_orders = u.total_orders + 1 WHERE o.created_at \u0026gt; \u0026#39;2024-01-01\u0026#39;; -- 条件更新（CASE） UPDATE users SET level = CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END; 3.4 删除数据（DELETE） -- 删除指定数据 DELETE FROM users WHERE id = 1; -- 批量删除 DELETE FROM users WHERE age \u0026lt; 18; -- 删除所有数据 DELETE FROM users; -- 基于其他表删除 DELETE u FROM users u INNER JOIN orders o ON u.id = o.user_id WHERE o.status = \u0026#39;cancelled\u0026#39;; 四、索引管理 4.1 创建索引 -- 普通索引 CREATE INDEX idx_username ON users(username); -- 唯一索引 CREATE UNIQUE INDEX idx_email ON users(email); -- 复合索引 CREATE INDEX idx_name_age ON users(username, age); -- 全文索引 CREATE FULLTEXT INDEX idx_content ON articles(content); -- 在创建表时添加索引 CREATE TABLE users ( id INT PRIMARY KEY, username VARCHAR(50), email VARCHAR(100), INDEX idx_username (username), UNIQUE INDEX idx_email (email) ); 4.2 查看和删除索引 -- 查看索引 SHOW INDEX FROM users; -- 删除索引 DROP INDEX idx_username ON users; ALTER TABLE users DROP INDEX idx_username; 五、约束管理 5.1 主键约束 -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键（需要先删除 AUTO_INCREMENT 属性） ALTER TABLE users MODIFY id INT; ALTER TABLE users DROP PRIMARY KEY; 5.2 外键约束 -- 添加外键 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id); -- 添加外键时设置级联操作 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE; -- 删除外键 ALTER TABLE orders DROP FOREIGN KEY fk_user_id; 5.3 其他约束 -- 唯一约束 ALTER TABLE users ADD UNIQUE (email); -- 非空约束 ALTER TABLE users MODIFY username VARCHAR(50) NOT NULL; -- 检查约束（MySQL 8.0.16+） ALTER TABLE users ADD CONSTRAINT chk_age CHECK (age \u0026gt;= 0 AND age \u0026lt;= 150); -- 默认值约束 ALTER TABLE users ALTER COLUMN status SET DEFAULT \u0026#39;active\u0026#39;; 六、视图 -- 创建视图 CREATE VIEW active_users AS SELECT id, username, email FROM users WHERE status = \u0026#39;active\u0026#39;; -- 创建或替换视图 CREATE OR REPLACE VIEW active_users AS SELECT id, username, email, age FROM users WHERE status = \u0026#39;active\u0026#39;; -- 查询视图 SELECT * FROM active_users; -- 查看视图定义 SHOW CREATE VIEW active_users; -- 删除视图 DROP VIEW active_users; DROP VIEW IF EXISTS active_users; 七、事务处理 -- 开启事务 START TRANSACTION; -- 或 BEGIN; -- 提交事务 COMMIT; -- 回滚事务 ROLLBACK; -- 设置保存点 SAVEPOINT sp1; ROLLBACK TO sp1; -- 完整示例 START TRANSACTION; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; COMMIT; -- 设置自动提交 SET autocommit = 0; -- 关闭自动提交 SET autocommit = 1; -- 开启自动提交 八、存储过程和函数 8.1 存储过程 -- 创建存储过程 DELIMITER // CREATE PROCEDURE GetUserById(IN userId INT) BEGIN SELECT * FROM users WHERE id = userId; END // DELIMITER ; -- 调用存储过程 CALL GetUserById(1); -- 带输出参数的存储过程 DELIMITER // CREATE PROCEDURE GetUserCount(OUT total INT) BEGIN SELECT COUNT(*) INTO total FROM users; END // DELIMITER ; CALL GetUserCount(@count); SELECT @count; -- 删除存储过程 DROP PROCEDURE IF EXISTS GetUserById; -- 查看存储过程 SHOW PROCEDURE STATUS; SHOW CREATE PROCEDURE GetUserById; 8.2 函数 -- 创建函数 DELIMITER // CREATE FUNCTION GetUserAge(userId INT) RETURNS INT BEGIN DECLARE userAge INT; SELECT age INTO userAge FROM users WHERE id = userId; RETURN userAge; END // DELIMITER ; -- 使用函数 SELECT GetUserAge(1); -- 删除函数 DROP FUNCTION IF EXISTS GetUserAge; 九、触发器 -- 创建 BEFORE INSERT 触发器 DELIMITER // CREATE TRIGGER before_user_insert BEFORE INSERT ON users FOR EACH ROW BEGIN SET NEW.created_at = NOW(); END // DELIMITER ; -- 创建 AFTER UPDATE 触发器 DELIMITER // CREATE TRIGGER after_user_update AFTER UPDATE ON users FOR EACH ROW BEGIN INSERT INTO user_logs (user_id, action, created_at) VALUES (OLD.id, \u0026#39;update\u0026#39;, NOW()); END // DELIMITER ; -- 查看触发器 SHOW TRIGGERS; -- 删除触发器 DROP TRIGGER IF EXISTS before_user_insert; 十、用户和权限管理 -- 创建用户 CREATE USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; CREATE USER \u0026#39;username\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; -- 允许任何主机 -- 授予权限 GRANT ALL PRIVILEGES ON database_name.* TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; GRANT SELECT, INSERT, UPDATE ON database_name.table_name TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 刷新权限 FLUSH PRIVILEGES; -- 查看用户权限 SHOW GRANTS FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 撤销权限 REVOKE INSERT, UPDATE ON database_name.* FROM \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 修改密码 ALTER USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;new_password\u0026#39;; SET PASSWORD FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; = PASSWORD(\u0026#39;new_password\u0026#39;); -- 删除用户 DROP USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; 十一、备份和恢复 -- 使用 mysqldump 备份（在命令行执行） mysqldump -u username -p database_name \u0026gt; backup.sql mysqldump -u username -p database_name table_name \u0026gt; table_backup.sql mysqldump -u username -p --all-databases \u0026gt; all_databases.sql -- 恢复数据库（在命令行执行） mysql -u username -p database_name \u0026lt; backup.sql -- 导出为 CSV SELECT * FROM users INTO OUTFILE \u0026#39;/tmp/users.csv\u0026#39; FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; -- 从 CSV 导入 LOAD DATA INFILE \u0026#39;/tmp/users.csv\u0026#39; INTO TABLE users FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; 十二、性能优化相关 12.1 EXPLAIN 分析查询 -- 分析查询执行计划 EXPLAIN SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; -- 详细分析 EXPLAIN EXTENDED SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SHOW WARNINGS; -- JSON 格式 EXPLAIN FORMAT=JSON SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; 12.2 查询优化 -- 使用索引提示 SELECT * FROM users USE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users FORCE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users IGNORE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; -- 优化 COUNT SELECT COUNT(1) FROM users; -- 比 COUNT(*) 快一点 -- 分页优化（避免大 OFFSET） SELECT * FROM users WHERE id \u0026gt; 10000 ORDER BY id LIMIT 20; 12.3 查看状态和变量 -- 查看数据库状态 SHOW STATUS; SHOW STATUS LIKE \u0026#39;Threads%\u0026#39;; -- 查看系统变量 SHOW VARIABLES; SHOW VARIABLES LIKE \u0026#39;max_connections\u0026#39;; -- 查看进程列表 SHOW PROCESSLIST; SHOW FULL PROCESSLIST; -- 杀死进程 KILL process_id; 十三、常用字符串和日期函数 13.1 字符串函数 -- 字符串连接 SELECT CONCAT(\u0026#39;Hello\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;World\u0026#39;); SELECT CONCAT_WS(\u0026#39;-\u0026#39;, \u0026#39;2024\u0026#39;, \u0026#39;12\u0026#39;, \u0026#39;10\u0026#39;); -- 字符串长度 SELECT LENGTH(\u0026#39;Hello\u0026#39;), CHAR_LENGTH(\u0026#39;你好\u0026#39;); -- 大小写转换 SELECT UPPER(\u0026#39;hello\u0026#39;), LOWER(\u0026#39;HELLO\u0026#39;); -- 截取字符串 SELECT SUBSTRING(\u0026#39;Hello World\u0026#39;, 1, 5); SELECT LEFT(\u0026#39;Hello World\u0026#39;, 5), RIGHT(\u0026#39;Hello World\u0026#39;, 5); -- 替换和删除 SELECT REPLACE(\u0026#39;Hello World\u0026#39;, \u0026#39;World\u0026#39;, \u0026#39;MySQL\u0026#39;); SELECT TRIM(\u0026#39; Hello \u0026#39;), LTRIM(\u0026#39; Hello\u0026#39;), RTRIM(\u0026#39;Hello \u0026#39;); -- 查找位置 SELECT POSITION(\u0026#39;World\u0026#39; IN \u0026#39;Hello World\u0026#39;); SELECT LOCATE(\u0026#39;World\u0026#39;, \u0026#39;Hello World\u0026#39;); 13.2 日期时间函数 -- 获取当前时间 SELECT NOW(), CURDATE(), CURTIME(); SELECT CURRENT_TIMESTAMP(), CURRENT_DATE(), CURRENT_TIME(); -- 日期格式化 SELECT DATE_FORMAT(NOW(), \u0026#39;%Y-%m-%d %H:%i:%s\u0026#39;); SELECT DATE_FORMAT(NOW(), \u0026#39;%Y年%m月%d日\u0026#39;); -- 日期计算 SELECT date_add(\u0026#39;2023-01-01\u0026#39;, interval 1 day) 输出 \u0026#39;2023-01-02\u0026#39; SELECT date_sub(\u0026#39;2023-01-01\u0026#39;, interval 1 day) 输出 \u0026#39;2022-12-31\u0026#39; SELECT datediff(\u0026#39;2023-02-01\u0026#39;, \u0026#39;2023-01-01\u0026#39;) 输出31 -- 提取日期部分 SELECT YEAR(NOW()), MONTH(NOW()), DAY(NOW()); SELECT HOUR(NOW()), MINUTE(NOW()), SECOND(NOW()); -- 时间戳转换 SELECT UNIX_TIMESTAMP(NOW()); SELECT FROM_UNIXTIME(1702195200); 13.3 数学和其他函数 -- 数学函数 SELECT ROUND(3.14159, 2), CEIL(3.2), FLOOR(3.8); SELECT ABS(-5), MOD(10, 3), POWER(2, 3); SELECT RAND(), RAND()*100; -- 条件函数 SELECT IF(age \u0026gt; 18, \u0026#39;成年\u0026#39;, \u0026#39;未成年\u0026#39;) FROM users; SELECT IFNULL(email, \u0026#39;无邮箱\u0026#39;) FROM users; SELECT COALESCE(NULL, NULL, \u0026#39;default\u0026#39;, \u0026#39;value\u0026#39;); -- CASE 表达式 SELECT username, CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END as age_group FROM users; 十四、JSON 操作（MySQL 5.7+） -- 创建 JSON 列 CREATE TABLE products ( id INT PRIMARY KEY, name VARCHAR(100), attributes JSON ); -- 插入 JSON 数据 INSERT INTO products VALUES (1, \u0026#39;iPhone\u0026#39;, \u0026#39;{\u0026#34;color\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;storage\u0026#34;: \u0026#34;128GB\u0026#34;}\u0026#39;); -- 查询 JSON 数据 SELECT JSON_EXTRACT(attributes, \u0026#39;$.color\u0026#39;) as color FROM products; SELECT attributes-\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; SELECT attributes-\u0026gt;\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; -- 去除引号 -- 修改 JSON 数据 UPDATE products SET attributes = JSON_SET(attributes, \u0026#39;$.color\u0026#39;, \u0026#39;white\u0026#39;) WHERE id = 1; UPDATE products SET attributes = JSON_INSERT(attributes, \u0026#39;$.price\u0026#39;, 999) WHERE id = 1; UPDATE products SET attributes = JSON_REMOVE(attributes, \u0026#39;$.storage\u0026#39;) WHERE id = 1; -- JSON 数组操作 SELECT JSON_ARRAY(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;); SELECT JSON_CONTAINS(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;, \u0026#39;\u0026#34;a\u0026#34;\u0026#39;); SELECT JSON_LENGTH(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;); 十五、窗口函数（MySQL 8.0+） -- ROW_NUMBER：行号 SELECT username, age, ROW_NUMBER() OVER (ORDER BY age DESC) as row_num FROM users; -- RANK：排名（有并列，跳号） SELECT username, score, RANK() OVER (ORDER BY score DESC) as rank FROM students; -- DENSE_RANK：密集排名（有并列，不跳号） SELECT username, score, DENSE_RANK() OVER (ORDER BY score DESC) as rank FROM students; -- 分组窗口 SELECT department, username, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank FROM employees; -- 累计求和 SELECT username, amount, SUM(amount) OVER (ORDER BY created_at) as running_total FROM transactions; -- LAG 和 LEAD：访问上下行 SELECT username, salary, LAG(salary, 1) OVER (ORDER BY id) as prev_salary, LEAD(salary, 1) OVER (ORDER BY id) as next_salary FROM employees; 十六、常见问题和技巧 16.1 查找重复数据 -- 查找重复的用户名 SELECT username, COUNT(*) as count FROM users GROUP BY username HAVING count \u0026gt; 1; -- 删除重复数据（保留ID最小的） DELETE u1 FROM users u1 INNER JOIN users u2 WHERE u1.id \u0026gt; u2.id AND u1.username = u2.username; 16.2 随机获取数据 -- 随机获取一条数据 SELECT * FROM users ORDER BY RAND() LIMIT 1; -- 更高效的随机（大表适用） SELECT * FROM users WHERE id \u0026gt;= (SELECT FLOOR(MAX(id) * RAND()) FROM users) LIMIT 1; 16.3 行转列 -- 使用 CASE WHEN SELECT name, SUM(CASE WHEN subject = \u0026#39;语文\u0026#39; THEN score ELSE 0 END) as chinese, SUM(CASE WHEN subject = \u0026#39;数学\u0026#39; THEN score ELSE 0 END) as math FROM scores GROUP BY name; 16.4 列转行 -- 使用 UNION ALL SELECT name, \u0026#39;语文\u0026#39; as subject, chinese as score FROM scores UNION ALL SELECT name, \u0026#39;数学\u0026#39; as subject, math as score FROM scores; 十七、常用管理命令 -- 查看 MySQL 版本 SELECT VERSION(); -- 查看当前用户 SELECT USER(), CURRENT_USER(); -- 查看数据库大小 SELECT table_schema AS \u0026#39;Database\u0026#39;, ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables GROUP BY table_schema; -- 查看表大小 SELECT table_name AS \u0026#39;Table\u0026#39;, ROUND(((data_length + index_length) / 1024 / 1024), 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables WHERE table_schema = \u0026#39;database_name\u0026#39; ORDER BY (data_length + index_length) DESC; -- 修复表 REPAIR TABLE users; -- 优化表 OPTIMIZE TABLE users; -- 分析表 ANALYZE TABLE users; -- 检查表 CHECK TABLE users; 总结 这份笔记涵盖了 MySQL 从基础到进阶的大部分常用操作，当然也适合在刷题中补充，包括：\n数据库和表的管理 完整的 CRUD 操作 索引和约束 视图、事务、存储过程 用户权限管理 性能优化技巧 常用函数和 JSON、窗口函数！ ","permalink":"http://localhost:1313/database/mysql-cheatsheet/","summary":"MySQL 常用语句全面速查手册，涵盖从基础 CRUD 到高级特性（索引、事务、存储过程、窗口函数等）的所有常用操作，适合快速查阅和刷题使用","title":"MySQL 语句速查笔记"},{"content":"论文基本信息 标题: Linking Souls to Humans: Blockchain Accounts with Credible Anonymity for Web 3.0 Decentralized Identity 作者: Taotao Wang, Zibin Lin, Shengli Zhang, Long Shi, Qing Yang, Boris Düdder 会议: WWW \u0026lsquo;25 (ACM Web Conference 2025) 时间: 2025年4月28日-5月2日，悉尼 机构: 深圳大学、南京理工大学、哥本哈根大学 研究背景 数字身份的三个发展阶段 数字身份系统经历了三个演进阶段，分别对应互联网的三个时代：\n阶段 身份类型 对应时代 特点 问题 1 中心化身份 Web 1.0 用户创建，应用提供商管理 多账户管理复杂，数据泄露风险 2 联盟身份 Web 2.0 少数大型提供商管理，可跨应用使用 数据霸权，用户数据集中在少数巨头手中 3 去中心化身份 Web 3.0 用户自主创建和管理（自主权身份） 完全匿名导致无法追溯真实社交关系 Web 3.0的核心价值 Web 3.0的革命性转变在于：\n用户拥有数据主权 数据不被应用提供商占有 需要去中心化身份系统支撑 当前区块链账户系统的问题 区块链账户系统是Web 3.0去中心化身份的理想原型，但存在以下问题：\n完全匿名的缺陷： 用户可以无需认证创建多个账户 无法准确记录真实用户之间的社交关系和互动 用户与区块链身份之间的映射关系模糊 Soulbound Token的局限性： Vitalik Buterin提出的\u0026quot;灵魂\u0026quot;（Soul）概念和\u0026quot;灵魂绑定代币\u0026quot;（Soulbound Token） 用户仍可创建多个\u0026quot;灵魂\u0026quot;账户来抹除、转移或隐藏关系 无法真实反映人类社会中的真实关系 研究方案：zkBID 核心目标 zkBID（Zero-Knowledge Blockchain-account-based Web 3.0 decentralized IDentity）旨在实现：\n一对一映射：将灵魂（区块链账户）与人类（用户）建立一对一关联 去中心化：无需第三方中心化机构参与 隐私保护：隐藏身份与账户之间的绑定关系（即匿名） 可信性：每个账户在区块链上的信用与对应的真实用户一对一映射 关键技术 zkBID采用三大核心技术：\n零知识证明（zkSNARK） 可链接环签名（Linkable Ring Signature） 区块链智能合约（Smart Contracts） 技术预备知识 1. 可验证凭证（Verifiable Credentials, VC） 由W3C提出的去中心化标识符（DID）体系中的关键组件。\n三个主要角色：\n颁发者（Issuer）：签发凭证 持有者（Holder）：拥有凭证 验证者（Verifier）：验证凭证 VC的数据结构（JSON对象）：\n{ \u0026#34;metadata\u0026#34;: \u0026#34;包含颁发者DID、颁发日期、声明类型\u0026#34;, \u0026#34;claims\u0026#34;: \u0026#34;关于持有者的断言，包括持有者DID\u0026#34;, \u0026#34;proofs\u0026#34;: \u0026#34;颁发者的数字签名\u0026#34; } 2. 人格凭证（Personhood Credentials, PHC） 定义：证明用户是真人而非AI的数字凭证\n运作流程：\n注册流程 用户向PHC颁发者证明自己是真人 → 颁发者签发PHC\n使用流程 第三方服务可要求用户出示PHC作为授权过程的一部分\n验证方法（颁发者确保用户是真人的三种主要方式）：\n现有身份文件 基于政府签发的身份证件 利用现有可信来源 生物识别信息 测量持久且唯一的人体特征（掌纹、虹膜、指纹） 确保是真人且限制每人只注册一次 信任网络（Web of Trust） 通过社交图谱分析区分真人和机器 检测用户是否曾获得过凭证 在zkBID中的应用：\nPHC以VC形式作为每个人类用户的身份凭证 3. zkSNARK算法 全称：Zero-knowledge Succinct Non-interactive Argument of Knowledge\n优势：\n简洁性（Succinct）：证明大小仅几个字节，验证时间短 非交互性（Non-interactive）：证明者和验证者无需同步通信 工作原理：\n使用算术电路表示，包含基本运算：加、减、乘、除\nF-算术电路：\n输入：$x \\in \\mathbb{F}^n$ 辅助输入（见证）：$w \\in \\mathbb{F}^h$ 输出：$C(x, w) \\in \\mathbb{F}^l$ 三个算法组件：\n密钥生成（KEYGEN）\n(PK, VK) ← KEYGEN(1^λ, C) 输入：安全参数λ和电路C 输出：证明密钥PK和验证密钥VK 证明生成（PROVE）\nπ ← PROVE(PK, x, W) 输入：PK、公开输入x、私密见证W 输出：证明π 证明验证（VERIFY）\n1/0 ← VERIFY(VK, x, π) 输入：VK、公开输入x、证明π 输出：接受（1）或拒绝（0） zkBID采用的算法：Groth16\n原因：验证速度快，证明紧凑 适用于大规模应用和大型区块链网络 4. 可链接环签名（Linkable Ring Signature） 基本环签名：\n验证者可以确认签名由预定义集合中的某个成员创建 但无法确定具体是哪个成员 可链接环签名的额外特性：\n允许验证者确定两个签名是否由同一签名者生成 四个算法组件：\n密钥生成（GEN）\n(pk, sk) ← GEN(1^k) 签名生成（SIG）\nσ ← SIG(1^k, 1^n, m, L, sk) 输入：安全参数k、环大小n、消息m、公钥环L、私钥sk 输出：签名σ 签名验证（VER）\n1/0 ← VER(1^k, 1^n, m, L, σ) 可链接性检查（LINK）\n1/0 ← LINK(1^k, 1^n, m1, m2, σ1, σ2, L1, L2) 判断两个签名是否由同一签名者生成 关键属性：\n签名者模糊性（Signer Ambiguity）： 攻击者正确猜测真实签名者的概率不超过 1/(n-t) 其中n是环大小，t是攻击者拥有的私钥数量 可链接性（Linkability）： 同一签名者（相同私钥）签名的两条消息可被验证为关联 zkBID采用的算法：MLSAGS（Multilayered Linkable Spontaneous Anonymous Group Signature）\n原因：实现可链接性的技术复杂度较低，适合在智能合约上实现 密钥图像（Key Image）机制：\ny₀ ← sk * Hₚ(pk) y₀对于给定的(sk, pk)对是唯一的 所有由同一签名者产生的签名都带有相同的密钥图像 即使环中的公钥改变，签名仍可链接 zkBID系统设计 整体架构 映射关系图 真实用户 → PHC（人格凭证）→ PHC哈希 → 种子公钥 → 灵魂账户 关系说明：\n实线：可见的一对一关系 虚线：不可见但可验证的关系 箭头：单向计算关系 核心设计理念 隐私保护： PHC的具体内容不上链，只存储零知识证明 灵魂账户与种子公钥的关联不可见 可信匿名： 账户是匿名的（无法追踪到真实身份） 账户是可信的（确实与真实用户一对一绑定） 完全去中心化： 所有数据由用户生成 通过区块链上的智能合约验证 IVAC流程（Identity Verification and Account Certification） zkBID通过三个子流程生成具有可信匿名性的灵魂账户：\n[用户] → [注册信息生成] → [用户身份验证] → [灵魂账户认证] → [灵魂账户] ↓ ↓ ↓ 零知识证明 智能合约验证 可链接环签名 详细设计 阶段1：注册信息生成 目标：生成隐私保护的注册信息，不泄露PHC的具体内容\nPHC格式设计 zkBID中的PHC采用VC格式，包含三个关键字段：\n{ \u0026#34;credentialSubject\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_holder\u0026#34; // 持有者公钥 }, \u0026#34;proof\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_issuer\u0026#34;, // 颁发者公钥 \u0026#34;signature\u0026#34;: \u0026#34;sig_issuer\u0026#34; // 颁发者签名 } } 零知识证明生成流程 Protocol 1: PHC的ZK证明生成\n输入： - hash_PHC：PHC的哈希值 - sig_holder：持有者的签名 - pk_issuer：颁发者的公钥 - PHC：完整的PHC数据 设置： (PK, VK) ← zkSNARK.KEYGEN(1^λ, C) 生成证明： 1. 公开输入 x ← (hash_PHC, sig_holder, pk_issuer) 2. 私密见证 W ← PHC 3. π ← zkSNARK.PROVE(PK, x, W) 输出：π（零知识证明） 算术电路验证逻辑 graph TD A[私密输入: PHC] --\u0026gt; B[计算PHC的哈希] C[公开输入: hash_PHC] --\u0026gt; B B --\u0026gt; D{哈希值是否相等?} A --\u0026gt; E[提取pk_holder] F[公开输入: sig_holder] --\u0026gt; G[验证sig_holder] E --\u0026gt; G G --\u0026gt; H{签名是否有效?} A --\u0026gt; I[提取sig_issuer] J[公开输入: pk_issuer] --\u0026gt; K[验证sig_issuer] I --\u0026gt; K K --\u0026gt; L{签名是否有效?} D --\u0026gt; M[AND] H --\u0026gt; M L --\u0026gt; M M --\u0026gt; N{输出TRUE/FALSE} 验证步骤：\n验证哈希正确性： 计算PHC的哈希 检查是否等于公开输入中的hash_PHC 确保hash_PHC确实从PHC计算得出 验证所有权： 从PHC中提取持有者公钥pk_holder 用pk_holder验证sig_holder 证明用户拥有PHC 验证PHC有效性： 从PHC中提取颁发者签名sig_issuer 用pk_issuer验证sig_issuer 证明PHC由可信颁发者签发 输出：\n如果所有检查通过：输出TRUE和证明π π证明的声明：\u0026ldquo;PHC哈希正确，持有者拥有PHC，PHC由颁发者签发\u0026rdquo; 关键：不泄露PHC的具体内容 阶段2：用户身份验证 目标：\n验证用户的真人身份（通过验证ZK证明） 防止重复注册（检查PHC哈希未被使用） 智能合约流程 Protocol 2: 用户身份验证智能合约\n输入： - π：零知识证明 - hash_PHC：PHC哈希 - sig_holder：持有者签名 - pk_seed：种子公钥 执行步骤： 1. pk_issuer ← GetIssuerPK() // 获取预定义的颁发者公钥 2. validation ← zkSNARK.VERIFY(VK, hash_PHC, pk_issuer, π) 3. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 4. stored ← Traverse(hash_PHC) // 检查是否已注册 5. if stored ≠ 0: return \u0026#34;已经注册\u0026#34; 6. Store(hash_PHC, pk_seed) // 存储为键值对 7. return \u0026#34;认证成功\u0026#34; 用户操作步骤 生成种子密钥对：\n(pk_seed, sk_seed) ← MLSAGS.GEN(1^k) 构造交易：\n数据字段包含：π, hash_PHC, sig_holder, pk_issuer, pk_seed 发送到身份验证合约地址 合约验证：\n验证颁发者公钥匹配 验证零知识证明 检查PHC哈希未被使用 链上记录：\n存储键值对：(hash_PHC, pk_seed) hash_PHC用于防止重复注册 pk_seed作为用户在下一阶段创建灵魂账户的凭证 安全保证：\nPHC的具体内容不上链 仍能验证PHC的所有权和有效性 防止同一PHC多次注册 阶段3：灵魂账户认证 目标：认证灵魂账户与合法种子公钥的一对一关联\n整体流程 生成灵魂账户（普通以太坊账户） 建立关联（使用可链接环签名） 链上验证（智能合约验证签名） 可链接环签名的生成和验证 graph LR A[用户端] --\u0026gt; B[签名生成] B --\u0026gt; C[智能合约] C --\u0026gt; D[签名验证] E[输入] --\u0026gt; B E --\u0026gt; |选择的L-1个种子公钥| B E --\u0026gt; |用户的种子公钥pk_seed| B E --\u0026gt; |用户的种子私钥sk_seed| B E --\u0026gt; |灵魂账户地址addr_soul| B E --\u0026gt; |密钥图像y₀| B B --\u0026gt; |签名σ| C F[公钥环L] --\u0026gt; C G[addr_soul] --\u0026gt; C D --\u0026gt; H{验证结果} H --\u0026gt; |True| I[认证成功] H --\u0026gt; |False| J[认证失败] 详细步骤 步骤1：生成灵魂账户\n(addr_soul, pk_soul, sk_soul) = 生成以太坊账户 步骤2：构造公钥环\n从已注册的种子公钥中选择L-1个 加上用户自己的pk_seed 形成大小为L的公钥环 步骤3：计算密钥图像\ny₀ ← sk_seed * Hₚ(pk_seed) y₀对于给定的(sk_seed, pk_seed)是唯一的 用于防止重复注册 步骤4：生成可链接环签名\nσ ← MLSAGS.SIG(1^k, 1^n, addr_soul, L, sk_seed) 消息m = addr_soul（要签名的是灵魂账户地址） 签名格式：σ = (y₀, \u0026hellip;) y₀作为签名的一部分 步骤5：智能合约验证\nProtocol 3: 灵魂账户认证智能合约\n输入： - σ：可链接环签名 - L：公钥环 - addr_soul：灵魂账户地址 执行步骤： 1. validation ← LRS.VER(1^k, 1^n, addr_soul, L, σ) 2. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 3. stored ← Traverse(σ.y₀) // 检查密钥图像是否已使用 4. if stored ≠ 0: return \u0026#34;已经认证\u0026#34; 5. Store(σ.y₀, addr_soul) // 存储密钥图像和灵魂账户 6. return \u0026#34;认证成功\u0026#34; 隐私保护机制 关键特性：\n签名者模糊性： 签名可以被验证为有效 但无法确定环L中哪个公钥是真正的签名者 攻击者猜对的概率：1/(n-t)，其中n是环大小，t是攻击者拥有的私钥数 一对一保证： 密钥图像y₀唯一对应一个种子密钥对 同一种子密钥对只能生成一个有效签名 确保一个PHC只能关联一个灵魂账户 可验证的匿名性： 任何人都可以验证灵魂账户与某个合法种子公钥关联 但无法确定具体是哪个种子公钥 实现\u0026quot;可信匿名\u0026quot; 链上数据 存储内容：\n(σ.y₀, addr_soul) 键值对 可见信息：\n所有种子公钥（从阶段2） 所有灵魂账户地址 所有密钥图像 不可见关联：\n哪个种子公钥对应哪个灵魂账户 哪个PHC哈希对应哪个灵魂账户 哪个真实用户对应哪个灵魂账户 安全性分析 安全前提条件 计算对手受限：攻击者为多项式时间的计算对手 验证者诚实：智能合约不会接受虚假验证请求 PHC唯一性：每个用户只能从颁发者获得一个PHC 安全目标 zkBID需要满足三个核心安全属性：\n安全属性 定义 目标 身份唯一性 防止重复注册 一个用户不能注册多个灵魂账户 不可伪造性 防止身份伪造 攻击者不能冒充诚实用户认证灵魂账户 匿名性 保护身份隐私 攻击者无法检测用户身份(PHC)与灵魂账户的关联 威胁模型与防御 1. 女巫攻击（Sybil Attack） 攻击场景： 攻击者已拥有一个灵魂账户，试图获取新的灵魂账户\n攻击方法：\n方法A：使用相同PHC关联新的种子公钥 → 用新种子公钥认证新灵魂账户\n方法B：直接使用已用过的种子公钥认证新灵魂账户\n防御分析：\n方法A的防御：\n在用户身份验证合约中： 1. 合约检查hash_PHC是否已存储 2. 由于哈希函数的抗碰撞性，每个PHC只能生成一个唯一哈希 3. zkSNARK的可靠性保证：攻击者通过伪造哈希成功的概率可忽略不计 4. 因此无法用同一PHC注册两个种子账户 方法B的防御：\n在灵魂账户认证合约中： 1. 合约检查密钥图像y₀是否已使用 2. 由于可链接环签名的可链接性，同一种子私钥无法构造两个不同y₀的有效签名 3. 因此无法用同一种子密钥对认证两个灵魂账户 结论：无法使用相同PHC或种子公钥注册两个灵魂账户\n2. 链接攻击（Linkage Attack） 攻击场景： 攻击者试图通过破解环签名的真实签名者，建立用户身份（PHC哈希）与灵魂账户的链接\n攻击方法： 分析链上存储的环签名，推断哪个种子公钥是真正的签名者\n防御分析：\n基于可链接环签名的签名者模糊性： - 假设环大小为n - 攻击者拥有t个私钥 - 攻击者正确识别真实签名者的概率 = 1/(n-t) 示例： - 环大小 n = 100 - 攻击者拥有 t = 10 个私钥 - 成功概率 = 1/90 ≈ 1.1% 结论：攻击者无法有效建立身份与账户的链接 环大小的影响：\n环越大 → 匿名性越强 但签名生成和验证成本增加 需要在匿名性和效率之间权衡 3. 伪造攻击（Forgery Attack） 攻击场景： 攻击者试图冒充诚实用户获取灵魂账户\n攻击方法：\n方法A：伪造holder签名生成有效zkSNARK证明\n攻击者获得诚实用户的PHC ↓ 伪造sig_holder ↓ 生成通过验证的zkSNARK证明 ↓ 注册种子公钥 ↓ 认证灵魂账户 方法B：伪造种子账户的环签名\n已注册的种子公钥公开可见 ↓ 伪造某个诚实用户的环签名sig_seed ↓ 认证新的灵魂账户 防御分析：\n方法A的防御：\n依赖两个密码学保证： 1. EdDSA算法的不可伪造性 → 攻击者无法伪造任何诚实用户的sig_holder 2. zkSNARK的可靠性 → 没有有效签名，无法创建有效的zkSNARK证明 结论：攻击者无法通过伪造签名获得种子公钥 方法B的防御：\n依赖可链接环签名的不可伪造性： - 攻击者无法伪造任何已注册种子账户的有效签名 - 即使种子公钥公开可见 结论：攻击者无法冒充诚实用户认证灵魂账户 总结：zkBID协议能够抵御伪造攻击\n安全性总结表 攻击类型 攻击目标 依赖的安全属性 防御结果 女巫攻击-方法A 重复注册PHC 哈希抗碰撞性 + zkSNARK可靠性 ✅ 安全 女巫攻击-方法B 重复使用种子密钥 可链接环签名的可链接性 ✅ 安全 链接攻击 破坏匿名性 可链接环签名的签名者模糊性 ✅ 安全 伪造攻击-方法A 伪造身份验证 EdDSA不可伪造性 + zkSNARK可靠性 ✅ 安全 伪造攻击-方法B 伪造账户认证 可链接环签名不可伪造性 ✅ 安全 实验评估 实验环境 测试网络配置 区块链测试网络：\n平台：阿里云 节点数：6个以太坊全节点 共识协议：工作量证明（PoW） 客户端：Go-Ethereum 网络拓扑：全连接（每个节点有独立IP） 用户节点：\n1个用户节点连接到1个以太坊节点 运行用户端功能 硬件配置（所有节点）：\n操作系统：Ubuntu 20.04 CPU：Intel(R) Core(TM) i7-10700 @ 2.90GHz 内存：48GB RAM 实现技术栈 智能合约：\n语言：Solidity 部署：以太坊测试网络 zkSNARK：\n算法：Groth16 平台：Circom 2 功能：Setup和证明生成 可链接环签名：\n算法：MLSAGS 用户端实现：Python（密钥生成、签名算法） 合约实现：Solidity（签名验证） 性能评估指标 指标 说明 重要性 ZK证明生成时间 Groth16证明算法的执行时间 影响用户体验 ZK证明大小 证明所占字节数 影响链上存储 ZK证明验证成本 智能合约验证所需Gas 影响使用成本 算术电路大小 R1CS约束数量 影响系统复杂度 MLSAGS签名生成时间 环签名生成的执行时间 影响用户体验 MLSAGS签名验证成本 智能合约验证所需Gas 影响使用成本 实验结果 1. Groth16性能测试 测试方案：\n使用单个算术电路验证多个PHC批次 测试不同批次大小下的性能表现 图表 6(a)：电路大小和证明大小 PHC批次大小 R1CS约束数量 ZK证明大小 1 ~19,000 192 Bytes 2 ~38,000 192 Bytes 4 ~76,000 192 Bytes 8 ~152,000 192 Bytes 16 ~304,000 192 Bytes 32 ~608,000 192 Bytes 64 ~1,216,000 192 Bytes 128 ~2,432,000 192 Bytes 关键发现：\n✨ 证明大小恒定：无论批次大小如何，证明始终为192字节 这是Groth16的核心优势：简洁性（Succinctness） 电路大小随批次线性增长 图表 6(b)：证明生成时间和验证成本 证明生成时间：\nPHC批次大小 生成时间 (ms) 增长趋势 1 ~2,000 基准 2 ~4,000 2x 4 ~8,000 4x 8 ~16,000 8x 16 ~32,000 16x 32 ~64,000 32x 证明验证成本（Gas）：\nPHC批次大小 验证Gas消耗 单个PHC平均Gas 1 215.7K 215.7K 2 247.2K 123.6K 4 310.2K 77.6K 8 436.2K 54.5K 16 688.2K 43.0K 32 1,040.0K 32.5K 关键发现：\n📈 线性增长：生成时间和验证成本都与批次大小呈线性关系\n💰\n批处理优势\n：批次大小为32时，单个PHC的Gas消耗仅为32.5K\n相比单独验证（215.7K），节省约85% 效率提升约7倍 ⚠️ 部署限制：批次大小≥64时，验证合约因以太坊合约大小限制无法部署\n最佳实践建议：\n推荐批次大小：16-32个PHC - 在合约大小限制内 - 获得显著的Gas优化 - 用户体验可接受 2. MLSAGS性能测试 测试方案：\n测试不同环大小L下的签名生成和验证性能 环大小影响匿名性和性能的权衡 图表 6(c)：MLSAGS性能指标 签名生成时间：\n环大小 L 生成时间 (ms) 增量时间 1 ~40 - 2 ~80 +40ms 4 ~160 +40ms 8 ~320 +40ms 16 ~640 +40ms 32 ~1,280 +40ms 64 ~2,560 +40ms 128 ~5,120 +40ms 签名验证成本（Gas）：\n环大小 L 验证Gas消耗 增量Gas 1 ~57K - 2 ~114K +57K 4 ~228K +57K 8 ~456K +57K 16 ~912K +57K 32 ~1,824K +57K 64 ~3,648K +57K 128 ~7,296K +57K 关键发现：\n📏\n完美线性关系\n：\n每增加1个公钥，生成时间增加约40ms 每增加1个公钥，验证Gas增加约57K ⚖️\n匿名性vs效率权衡\n：\n环越大 → 匿名性越强（攻击者猜中概率 = 1/L） 环越大 → 成本越高（时间和Gas） 匿名性分析：\n环大小 L 攻击者成功率 匿名性等级 Gas成本 10 10% 较弱 570K 50 2% 中等 2,850K 100 1% 强 5,700K 1000 0.1% 非常强 57,000K 实际应用建议：\n小规模应用（\u0026lt; 1000用户）： 环大小：10-20 匿名性：10%-5%攻击成功率 Gas成本：570K-1,140K（可接受） 中等规模应用（1000-10000用户）： 环大小：50-100 匿名性：2%-1%攻击成功率 Gas成本：2,850K-5,700K（需要优化） 大规模应用（\u0026gt; 10000用户）： 环大小：100+ 匿名性：\u0026lt; 1%攻击成功率 Gas成本：\u0026gt; 5,700K（需要Layer 2或批处理） 性能优化建议 1. 对于zkSNARK部分 批处理策略：\n低频场景（个人注册）： - 批次大小：1-4 - 适用：个人用户单次注册 - 优点：即时处理 - 缺点：Gas成本较高（215K-310K） 高频场景（批量注册）： - 批次大小：16-32 - 适用：组织批量入职、大规模注册活动 - 优点：Gas效率提升7倍 - 缺点：需要等待批次凑齐 2. 对于MLSAGS部分 环大小配置：\n# 根据用户总数动态调整 def calculate_ring_size(total_users, target_anonymity=0.01): \u0026#34;\u0026#34;\u0026#34; total_users: 系统总用户数 target_anonymity: 目标攻击成功率（如0.01 = 1%） \u0026#34;\u0026#34;\u0026#34; # 环大小不超过总用户数 ring_size = min(int(1 / target_anonymity), total_users) # 考虑Gas成本限制（假设单笔交易Gas上限为8M） max_affordable_ring = 8_000_000 / 57_000 # ≈ 140 return min(ring_size, max_affordable_ring) # 示例 calculate_ring_size(1000, 0.01) # 返回 100 calculate_ring_size(10000, 0.01) # 返回 100（受成本限制） calculate_ring_size(50, 0.01) # 返回 50（受用户数限制） 分层匿名策略：\nVIP用户/高价值账户： - 使用较大环（100+） - 提供更强匿名性 - 愿意支付更高Gas 普通用户： - 使用中等环（20-50） - 平衡匿名性和成本 - 实际应用最常见 测试/低价值账户： - 使用小环（10-20） - 基本匿名性 - 成本最低 实验结论 zkSNARK的优势： ✅ 证明大小恒定（192字节）：不受批次影响 ✅ 批处理优化显著：32个PHC可节省85% Gas ✅ 验证快速：链上验证成本可接受 MLSAGS的特性： ✅ 性能可预测：完美线性关系 ⚠️ 需要权衡：匿名性与成本呈正比 ✅ 灵活配置：可根据场景调整环大小 系统可行性： ✅ 在实际以太坊网络上完全可行 ✅ 通过参数优化可适应不同规模 ✅ 性能瓶颈明确且可优化 相关工作对比 现有方案分析 论文对比了8个相关的区块链身份方案：\n方案 年份 主要技术 应用场景 TradeMap [12] 2019 ZKP 符合FINMA的匿名KYC平台 Pauwels et al. [14] 2022 zkSNARK DeFi协议的KYC系统 Aydar et al. [3] 2019 Blockchain 数字身份验证框架 Singh et al. [18] 2020 Credential Protocol 保护个人属性的身份系统 Abraham et al. [1] 2020 SSI Model 支持凭证撤销的自主身份 ZEBRA [15] 2022 zkSNARK 链上匿名凭证验证 Zhang et al. [26] 2024 ZKP 能源交易身份认证 Kim et al. [10] 2023 SBT + DID 元宇宙的KYC系统 设计目标对比 方案 DG1 技术灵活性 DG2 身份匿名性 DG3 身份可信性 DG4 隐私存储 TradeMap [12] ✅ ❌ ❌ ❌ Pauwels [14] ✅ ❌ ✅ ✅ Aydar [3] ❌ ✅ ❌ ❌ Singh [18] ❌ ✅ ✅ ✅ Abraham [1] ✅ ✅ ❌ ❌ ZEBRA [15] ❌ ✅ ❌ ❌ Zhang [26] ✅ ❌ ✅ ❌ Kim [10] ❌ ✅ ❌ ❌ zkBID ✅ ✅ ✅ ✅ 设计目标说明：\nDG1 - 技术灵活性：不局限于特定的ZKP算法或区块链平台 DG2 - 身份匿名性：无法从链上活动推断用户真实身份 DG3 - 身份可信性：每个身份可信地连接到真实世界用户 DG4 - 隐私存储：身份文档保密存储，不公开可见 zkBID的独特优势 1. 唯一全面满足所有设计目标 其他方案的局限： ├─ TradeMap: 只关注合规性，缺乏匿名性和可信映射 ├─ Pauwels: DeFi场景，但身份匿名性不足 ├─ Aydar/Singh: 技术灵活性差，绑定特定实现 ├─ Abraham/ZEBRA: 缺乏与真实用户的可信绑定 ├─ Zhang: 特定场景（能源交易），匿名性不足 └─ Kim: 元宇宙场景，技术灵活性和可信性不足 zkBID的创新： ✅ 同时实现匿名性和可信性（看似矛盾的目标） ✅ 完全去中心化（无需可信第三方） ✅ 技术灵活（可替换ZKP算法和环签名方案） ✅ 隐私保护（身份信息不上链） 2. 技术组合的创新性 现有方案的技术使用：\n大多只使用zkSNARK进行凭证验证 少数使用环签名，但未实现身份-账户绑定 没有方案同时使用zkSNARK + 可链接环签名 zkBID的技术创新：\nzkSNARK（阶段1-2）： 目的：验证PHC有效性 优势：不泄露PHC内容 创新：批处理优化 可链接环签名（阶段3）： 目的：建立身份-账户映射 优势：保持匿名性的同时确保一对一 创新：使用密钥图像防止重复绑定 组合效果： = 可验证的身份 + 不可追踪的账户绑定 = 可信匿名（Credible Anonymity） 3. 实际应用价值 传统KYC系统的问题：\n中心化KYC： ❌ 隐私泄露风险 ❌ 数据被服务商控制 ❌ 跨平台不互通 区块链匿名账户： ❌ 无法防止女巫攻击 ❌ 信誉系统难以建立 ❌ 监管合规困难 zkBID的解决方案：\n对用户： ✅ 保护隐私（身份信息不泄露） ✅ 自主控制（无需信任中心化机构） ✅ 一次认证，多处使用 对平台： ✅ 防止女巫攻击（一人一账户） ✅ 建立信誉系统（账户可信） ✅ 满足监管要求（有认证机制） 对监管： ✅ 可验证的身份（PHC由可信机构签发） ✅ 可追责性（必要时可追踪） ✅ 隐私保护合规 应用场景 1. 去中心化社交网络 问题：\nTwitter/X上的机器人和假账户泛滥 难以区分真人和AI生成的内容 水军和虚假舆论操纵 zkBID解决方案：\n用户注册： 1. 用政府ID获取PHC 2. 通过zkBID认证获得灵魂账户 3. 使用灵魂账户在社交网络发布内容 效果： ✅ 每个账户对应一个真人 ✅ 保持用户匿名性 ✅ 机器人和假账户显著减少 ✅ 信誉系统可以建立在灵魂账户上 2. DAO治理 问题：\n一人多账户操纵投票 女巫攻击破坏治理公平性 难以验证投票者资格 zkBID解决方案：\n治理流程： 1. DAO成员通过zkBID认证 2. 每个灵魂账户 = 一个真实成员 3. 投票时保持匿名 4. 防止多重投票 效果： ✅ 一人一票（真正的民主） ✅ 投票匿名（防止胁迫和贿赂） ✅ 可验证（确保只有成员投票） ✅ 信誉加权（可基于历史贡献） 3. DeFi空投和激励 问题：\n空投被羊毛党多账户瓜分 难以识别真实用户 激励机制被滥用 zkBID解决方案：\n空投流程： 1. 要求使用zkBID认证的灵魂账户 2. 每个灵魂账户只能领取一次 3. 基于链上行为的信誉评分 效果： ✅ 公平分配（每人一份） ✅ 防止女巫攻击 ✅ 识别真实活跃用户 ✅ 建立长期激励机制 4. Web3游戏和元宇宙 问题：\n工作室多开刷金币 游戏经济被破坏 难以建立公平竞技环境 zkBID解决方案：\n游戏应用： 1. 玩家使用灵魂账户登录 2. 游戏内资产绑定到灵魂账户 3. 排行榜和竞技只认可灵魂账户 效果： ✅ 一人一号（公平竞争） ✅ 资产真实归属 ✅ 游戏经济稳定 ✅ 社交关系可信 5. 去中心化信用系统 问题：\n传统信用系统中心化 跨平台信用不互通 隐私泄露风险 zkBID解决方案：\n信用体系： 1. 灵魂账户作为信用载体 2. 链上行为建立信用历史 3. 跨DApp信用互认 4. 保护用户隐私 效果： ✅ 去中心化信用（不被单一机构控制） ✅ 可移植性（跨平台使用） ✅ 隐私保护（匿名但可信） ✅ 防止信用欺诈（一人一信用档案） 局限性与未来工作 当前局限性 1. 性能限制 Gas成本：\n当前状态： - 单次PHC验证：215.7K Gas - 环大小100的签名验证：5,700K Gas - 在以太坊主网上成本较高 影响： ❌ 大规模应用成本高 ❌ 限制了环大小（影响匿名性） 可能的解决方案：\nLayer 2方案（如Optimism、Arbitrum） 侧链部署 批处理优化 2. PHC依赖 当前状态：\n依赖可信的PHC颁发机构： - 政府机构 - 大型科技公司 - 其他可信第三方 问题： ❌ PHC系统尚未广泛部署 ❌ 不同颁发者的互操作性 ❌ 颁发者可能成为中心化风险点 3. 隐私权衡 匿名性级别：\n环大小的限制： - 小环（\u0026lt;20）：匿名性较弱 - 大环（100+）：成本高昂 - 实际应用中需要权衡 4. 撤销机制 当前缺失：\n无法撤销已认证的灵魂账户： ❌ 如果PHC被吊销怎么办？ ❌ 如果用户想注销怎么办？ ❌ 如果发现欺诈怎么办？ 需要设计： - 灵活的撤销机制 - 保持匿名性的撤销 - 防止滥用撤销权 未来研究方向 1. 性能优化 方向A：递归证明：\n使用递归zkSNARK： - 将多个证明聚合成一个 - 减少链上验证成本 - 提高批处理效率 预期效果： - Gas成本降低50%+ - 支持更大批次 方向B：量子抗性：\n替换为抗量子密码算法： - 格基密码学 - 哈希基签名 - 为后量子时代做准备 2. PHC生态系统 多颁发者互操作：\n标准化PHC格式： - 统一的VC模板 - 跨颁发者互认 - 去中心化颁发者网络 目标： - 减少单点故障 - 提高可用性 - 增强去中心化 去中心化PHC颁发：\n探索无需中心化颁发者的方案： - 基于生物识别的去中心化验证 - 社交图谱验证 - 组合多种验证方式 3. 隐私增强 方向A：动态环：\n允许用户动态选择环大小： - 根据交易重要性调整 - 重要交易用大环 - 普通交易用小环 效果： - 灵活性提高 - 成本优化 方向B：分层匿名：\n不同隐私级别的灵魂账户： - 公开级：最小匿名性，低成本 - 标准级：中等匿名性，中等成本 - 隐私级：高匿名性，高成本 4. 跨链支持 多链部署：\n扩展到其他区块链： - Polkadot/Cosmos生态 - 高性能链（Solana、Aptos） - 专用隐私链（Zcash、Monero概念） 跨链身份： - 一个PHC，多链认证 - 统一的身份层 5. 撤销和恢复机制 优雅的撤销：\n设计保护隐私的撤销： - 使用累加器（Accumulator） - 撤销列表不泄露身份 - 高效的撤销验证 恢复机制： - PHC过期后的更新流程 - 密钥丢失的恢复方案 - 保持连续性的信誉迁移 6. 合规和监管 可选的透明性：\n为监管场景设计： - 选择性披露机制 - 紧急情况下的去匿名化 - 法院命令的执行 平衡： - 保护普通用户隐私 - 满足反洗钱（AML）要求 - 支持合法调查 关键takeaways 技术创新 可信匿名的突破： 首次在区块链上实现\u0026quot;可信\u0026quot;+\u0026ldquo;匿名\u0026quot;的结合 通过零知识证明保护隐私 通过可链接环签名确保一对一映射 完全去中心化： 无需可信第三方参与验证 所有逻辑在智能合约中执行 用户完全控制自己的身份 实用性验证： 在真实以太坊测试网络上实现 性能指标明确可测 成本可接受且可优化 理论贡献 身份模型创新：\n传统模型：身份 → 账户（可见映射） zkBID模型：身份 → [ZK层] → 种子 → [环签名层] → 账户 创新点： - 两层隐私保护 - 可验证但不可追踪 - 数学上可证明的安全性 密码学组合：\nzkSNARK + 可链接环签名的首次组合应用 各取所长，弥补对方不足 为未来类似系统提供范式 实践意义 Web3基础设施： 为Web3提供关键的身份层 解决匿名性与可信性的矛盾 使去中心化应用更实用 防止AI冒充： 在AI时代区分人类和机器 PHC作为\u0026quot;数字人格证\u0026rdquo; 保护在线空间的人类性 新经济模式： 支持基于信誉的去中心化经济 公平的激励分配机制 可持续的社区治理 结论 zkBID是一个创新的Web 3.0去中心化身份方案，成功解决了区块链账户系统中匿名性与可信性的矛盾。\n核心成就 ✅ 技术突破：\n零知识证明保护身份隐私 可链接环签名确保一对一映射 完全去中心化的验证机制 ✅ 安全保证：\n抵御女巫攻击 抵御链接攻击 抵御伪造攻击 ✅ 实用验证：\n以太坊测试网络成功部署 性能指标满足实际应用需求 成本可通过参数优化控制 未来展望 zkBID为Web3去中心化身份提供了一个可行的解决方案，但仍有改进空间：\n继续优化性能和成本 推动PHC生态系统发展 探索跨链和多链支持 完善撤销和恢复机制 平衡隐私保护 ","permalink":"http://localhost:1313/blockchain/linking-souls-to-humans/","summary":"zkBID通过零知识证明和可链接环签名技术，首次实现了区块链账户的\u0026quot;可信匿名\u0026quot;：每个账户与真实用户一对一绑定（可信），但外界无法追踪具体对应关系（匿名）。系统采用三阶段IVAC流程，将人格凭证(PHC)通过零知识证明验证后绑定到种子公钥，再用环签名将种子公钥关联到灵魂账户。实验显示批处理可将验证成本降低85%，环大小灵活可调以平衡匿名性与效率。该方案为Web3提供了关键身份基础设施，可有效防止女巫攻击，支持去中心化社交、DAO治理、DeFi空投等场景。","title":"zkBID: 区块链账户与Web 3.0去中心化身份"},{"content":"📚 Part 1: Java 集合使用手册 0.String - 不可变字符串 // 初始化 String s = \u0026#34;hello\u0026#34;; String s2 = new String(\u0026#34;world\u0026#34;); String s3 = String.valueOf(123); // 数字转字符串 // 基本属性 int len = s.length(); // 长度 boolean empty = s.isEmpty(); // 是否为空 char ch = s.charAt(0); // 获取字符 // 查找 int index = s.indexOf(\u0026#34;ll\u0026#34;); // 查找子串位置 int lastIndex = s.lastIndexOf(\u0026#34;l\u0026#34;); // 最后出现位置 boolean contains = s.contains(\u0026#34;el\u0026#34;); // 是否包含 // 截取 String sub = s.substring(1, 4); // [1, 4) 截取 String sub2 = s.substring(2); // 从索引2到结尾 // 替换 String replaced = s.replace(\u0026#34;l\u0026#34;, \u0026#34;L\u0026#34;); // 替换所有 String replaced2 = s.replaceFirst(\u0026#34;l\u0026#34;, \u0026#34;L\u0026#34;); // 替换第一个 String replaced3 = s.replaceAll(\u0026#34;[aeiou]\u0026#34;, \u0026#34;*\u0026#34;); // 正则替换 // 分割 String[] parts = \u0026#34;a,b,c\u0026#34;.split(\u0026#34;,\u0026#34;); // 按分隔符分割 String[] parts2 = \u0026#34;a b c\u0026#34;.split(\u0026#34;\\\\s+\u0026#34;); // 按空格分割 // 拼接 String joined = String.join(\u0026#34;,\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); // \u0026#34;a,b,c\u0026#34; String concat = s.concat(\u0026#34; world\u0026#34;); // 拼接 // 大小写 String upper = s.toUpperCase(); String lower = s.toUpperCase().toLowerCase(); // 去空格 String trimmed = \u0026#34; hello \u0026#34;.trim(); // 去两端空格 String stripped = \u0026#34; hello \u0026#34;.strip(); // Java 11+ // 比较 boolean equals = s.equals(\u0026#34;hello\u0026#34;); boolean equalsIgnoreCase = s.equalsIgnoreCase(\u0026#34;HELLO\u0026#34;); int compare = s.compareTo(\u0026#34;world\u0026#34;); // 字典序比较 // 判断 boolean startsWith = s.startsWith(\u0026#34;he\u0026#34;); boolean endsWith = s.endsWith(\u0026#34;lo\u0026#34;); // 转换 char[] chars = s.toCharArray(); // 转字符数组 byte[] bytes = s.getBytes(); // 转字节数组 StringBuilder - 可变字符串 使用场景：单线程环境下需要频繁修改字符串\n// 初始化 StringBuilder sb = new StringBuilder(); StringBuilder sb2 = new StringBuilder(\u0026#34;hello\u0026#34;); StringBuilder sb3 = new StringBuilder(100); // 指定初始容量 // 添加（拼接） sb.append(\u0026#34;hello\u0026#34;); // 尾部添加 sb.append(123); // 添加数字 sb.append(\u0026#39;!\u0026#39;); // 添加字符 sb.insert(0, \u0026#34;start \u0026#34;); // 指定位置插入 // 删除 sb.delete(0, 5); // 删除 [0, 5) sb.deleteCharAt(0); // 删除指定位置 sb.setLength(0); // 清空（重置长度为0） // 修改 sb.replace(0, 5, \u0026#34;world\u0026#34;); // 替换 [0, 5) sb.setCharAt(0, \u0026#39;H\u0026#39;); // 修改指定位置字符 // 反转 sb.reverse(); // 查询 int len = sb.length(); char ch = sb.charAt(0); String sub = sb.substring(0, 5); // 转换为 String String result = sb.toString(); // 常见应用：循环拼接字符串 StringBuilder result = new StringBuilder(); for (int i = 0; i \u0026lt; 1000; i++) { result.append(i).append(\u0026#34;,\u0026#34;); } // 比用 String + 拼接快得多！ StringBuffer - 可变字符串 使用场景：多线程环境下需要频繁修改字符串\n// API 与 StringBuilder 完全相同 StringBuffer sb = new StringBuffer(); sb.append(\u0026#34;hello\u0026#34;); sb.append(\u0026#34; world\u0026#34;); String result = sb.toString(); // 区别：StringBuffer 的方法都是 synchronized 的 // 多线程安全，但性能比 StringBuilder 差 常用字符串操作技巧 // 1. 字符串转数字 int num = Integer.parseInt(\u0026#34;123\u0026#34;); long l = Long.parseLong(\u0026#34;123\u0026#34;); double d = Double.parseDouble(\u0026#34;3.14\u0026#34;); // 2. 数字转字符串 String s1 = String.valueOf(123); String s2 = Integer.toString(123); String s3 = \u0026#34;\u0026#34; + 123; // 不推荐 // 3. 字符串数组拼接 String[] arr = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; String joined = String.join(\u0026#34;,\u0026#34;, arr); // \u0026#34;a,b,c\u0026#34; // 4. 重复字符串（Java 11+） String repeated = \u0026#34;ab\u0026#34;.repeat(3); // \u0026#34;ababab\u0026#34; // 5. 判断空字符串 if (s != null \u0026amp;\u0026amp; !s.isEmpty()) { } if (s != null \u0026amp;\u0026amp; !s.isBlank()) { } // Java 11+，忽略空白字符 // 6. 字符串格式化 String formatted = String.format(\u0026#34;Hello %s, you are %d years old\u0026#34;, \u0026#34;Alice\u0026#34;, 25); 1. List - 列表 ArrayList - 动态数组 // 初始化 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); List\u0026lt;Integer\u0026gt; list3 = new ArrayList\u0026lt;\u0026gt;(100); // 指定初始容量 // 增 list.add(1); // 尾部添加 list.add(0, 10); // 指定位置添加 list.addAll(Arrays.asList(2,3,4)); // 批量添加 // 删 list.remove(0); // 删除指定索引 list.remove(Integer.valueOf(1)); // 删除指定元素 list.clear(); // 清空 // 改 list.set(0, 100); // 修改指定位置 // 查 int val = list.get(0); // 获取元素 int size = list.size(); // 获取大小 boolean empty = list.isEmpty(); // 是否为空 boolean contains = list.contains(1); // 是否包含 int index = list.indexOf(1); // 查找索引 // 遍历 for (int num : list) { System.out.println(num); } // 或使用迭代器 Iterator\u0026lt;Integer\u0026gt; it = list.iterator(); while (it.hasNext()) { System.out.println(it.next()); } LinkedList - 双向链表 LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 头部操作 list.addFirst(1); list.removeFirst(); int first = list.getFirst(); // 尾部操作 list.addLast(2); list.removeLast(); int last = list.getLast(); // 作为队列使用 list.offer(3); // 入队 int head = list.poll(); // 出队 // 作为栈使用 list.push(4); // 入栈 int top = list.pop(); // 出栈 2. Set - 集合 HashSet - 无序不重复 // 初始化 Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); // 增 set.add(1); set.addAll(Arrays.asList(2, 3, 4)); // 删 set.remove(1); set.clear(); // 查 boolean contains = set.contains(1); int size = set.size(); boolean empty = set.isEmpty(); // 遍历 for (int num : set) { System.out.println(num); } TreeSet - 有序集合（红黑树） TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 基本操作同 HashSet set.add(3); set.add(1); set.add(2); System.out.println(set); // [1, 2, 3] 自动排序 // 特有方法 int first = set.first(); // 最小元素 int last = set.last(); // 最大元素 int lower = set.lower(2); // 小于 2 的最大元素 int higher = set.higher(2); // 大于 2 的最小元素 int floor = set.floor(2); // ≤ 2 的最大元素 int ceiling = set.ceiling(2); // ≥ 2 的最小元素 // 子集操作 SortedSet\u0026lt;Integer\u0026gt; subset = set.subSet(1, 3); // [1, 3) SortedSet\u0026lt;Integer\u0026gt; headSet = set.headSet(2); // \u0026lt; 2 SortedSet\u0026lt;Integer\u0026gt; tailSet = set.tailSet(2); // \u0026gt;= 2 LinkedHashSet - 保持插入顺序 Set\u0026lt;Integer\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); set.add(3); set.add(1); set.add(2); System.out.println(set); // [3, 1, 2] 保持插入顺序 3. Map - 映射 HashMap - 键值对 // 初始化 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 增/改 map.put(\u0026#34;apple\u0026#34;, 1); map.put(\u0026#34;banana\u0026#34;, 2); map.putIfAbsent(\u0026#34;apple\u0026#34;, 10); // 键不存在时才添加 // 删 map.remove(\u0026#34;apple\u0026#34;); map.clear(); // 查 int val = map.get(\u0026#34;apple\u0026#34;); int valOrDefault = map.getOrDefault(\u0026#34;orange\u0026#34;, 0); boolean hasKey = map.containsKey(\u0026#34;apple\u0026#34;); boolean hasValue = map.containsValue(1); int size = map.size(); // 遍历键值对 for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { String key = entry.getKey(); int value = entry.getValue(); } // 遍历键 for (String key : map.keySet()) { System.out.println(key); } // 遍历值 for (int value : map.values()) { System.out.println(value); } // Java 8+ 新方法 map.computeIfAbsent(\u0026#34;cherry\u0026#34;, k -\u0026gt; 3); map.merge(\u0026#34;apple\u0026#34;, 1, Integer::sum); // 累加 TreeMap - 有序映射（红黑树） TreeMap\u0026lt;Integer, String\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); map.put(3, \u0026#34;c\u0026#34;); map.put(1, \u0026#34;a\u0026#34;); map.put(2, \u0026#34;b\u0026#34;); // 基本操作同 HashMap // 特有方法 int firstKey = map.firstKey(); int lastKey = map.lastKey(); Map.Entry\u0026lt;Integer, String\u0026gt; firstEntry = map.firstEntry(); Map.Entry\u0026lt;Integer, String\u0026gt; lastEntry = map.lastEntry(); int lowerKey = map.lowerKey(2); // \u0026lt; 2 的最大键 int higherKey = map.higherKey(2); // \u0026gt; 2 的最小键 int floorKey = map.floorKey(2); // \u0026lt;= 2 的最大键 int ceilingKey = map.ceilingKey(2); // \u0026gt;= 2 的最小键 LinkedHashMap - 保持插入顺序 Map\u0026lt;String, Integer\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;c\u0026#34;, 3); map.put(\u0026#34;a\u0026#34;, 1); map.put(\u0026#34;b\u0026#34;, 2); // 遍历时保持插入顺序: c, a, b 4. Queue - 队列 普通队列 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 入队 queue.offer(1); queue.add(2); // 队列满时抛异常 // 出队 int head = queue.poll(); // 空时返回 null int head2 = queue.remove(); // 空时抛异常 // 查看队首 int peek = queue.peek(); // 空时返回 null int peek2 = queue.element(); // 空时抛异常 PriorityQueue - 优先队列（堆） // 小根堆（默认） PriorityQueue\u0026lt;Integer\u0026gt; minHeap = new PriorityQueue\u0026lt;\u0026gt;(); // 大根堆 PriorityQueue\u0026lt;Integer\u0026gt; maxHeap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); // 自定义对象 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); minHeap.offer(3); minHeap.offer(1); minHeap.offer(2); while (!minHeap.isEmpty()) { System.out.println(minHeap.poll()); // 1, 2, 3 } Deque - 双端队列 Deque\u0026lt;Integer\u0026gt; deque = new ArrayDeque\u0026lt;\u0026gt;(); // 头部操作 deque.offerFirst(1); deque.pollFirst(); deque.peekFirst(); // 尾部操作 deque.offerLast(2); deque.pollLast(); deque.peekLast(); // 作为栈使用 deque.push(3); int top = deque.pop(); 5. Stack - 栈 Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(1); // 入栈 int top = stack.pop(); // 出栈 int peek = stack.peek(); // 查看栈顶 boolean empty = stack.isEmpty(); int size = stack.size(); // 推荐使用 Deque 代替 Stack Deque\u0026lt;Integer\u0026gt; stack2 = new ArrayDeque\u0026lt;\u0026gt;(); 🧮 Part 2: 算法模板 1. 树的遍历 二叉树定义 class TreeNode { int val; // 节点值 TreeNode left; // 左子节点 TreeNode right; // 右子节点 TreeNode(int val) { this.val = val; } } DFS - 深度优先遍历 前序遍历（根-左-右） // 递归版本 - 最简洁直观 void preorder(TreeNode root) { if (root == null) return; // 递归终止条件：空节点 System.out.println(root.val); // 1. 先访问根节点 preorder(root.left); // 2. 再遍历左子树 preorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 使用栈模拟递归 List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); // 根节点入栈 while (!stack.isEmpty()) { TreeNode node = stack.pop(); // 弹出栈顶节点 res.add(node.val); // 访问该节点 // 关键：先压右子节点，再压左子节点 // 这样出栈时左子节点先出（栈是后进先出） if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); } return res; } 中序遍历（左-根-右） // 递归版本 void inorder(TreeNode root) { if (root == null) return; // 递归终止条件 inorder(root.left); // 1. 先遍历左子树 System.out.println(root.val); // 2. 再访问根节点 inorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 一直向左走到底 List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode curr = root; while (curr != null || !stack.isEmpty()) { // 第一步：一直向左走到底，沿途节点入栈 while (curr != null) { stack.push(curr); curr = curr.left; } // 第二步：弹出栈顶（当前最左节点），访问它 curr = stack.pop(); res.add(curr.val); // 第三步：转向右子树 curr = curr.right; } return res; } 后序遍历（左-右-根） // 递归版本 void postorder(TreeNode root) { if (root == null) return; // 递归终止条件 postorder(root.left); // 1. 先遍历左子树 postorder(root.right); // 2. 再遍历右子树 System.out.println(root.val); // 3. 最后访问根节点 } // 迭代版本 - 巧妙方法：前序遍历变形 + 反转 // 思路：前序是\u0026#34;根左右\u0026#34;，改成\u0026#34;根右左\u0026#34;，反转后得到\u0026#34;左右根\u0026#34; List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); res.add(node.val); // 添加到结果（根右左顺序） // 注意：这里先左后右，出栈时就是先右后左 if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); } Collections.reverse(res); // 反转得到左右根 return res; } BFS - 层序遍历 // 按层遍历二叉树，每层的节点放在一个列表中 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); // 根节点入队 while (!queue.isEmpty()) { int size = queue.size(); // 当前层的节点数（重要！） List\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); // 遍历当前层的所有节点 for (int i = 0; i \u0026lt; size; i++) { TreeNode node = queue.poll(); // 出队 level.add(node.val); // 记录节点值 // 将下一层的节点入队 if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } res.add(level); // 保存当前层结果 } return res; } 线段树（Segment Tree） /** * 线段树：用于高效处理区间查询和单点修改 * 时间复杂度：构建 O(n)，查询 O(log n)，更新 O(log n) */ class SegmentTree { private int[] tree; // 线段树数组 private int n; // 原数组大小 public SegmentTree(int[] nums) { n = nums.length; tree = new int[4 * n]; // 线段树最多需要 4n 空间 build(nums, 0, 0, n - 1); } // 构建线段树：递归构建 // node: 当前节点在 tree 中的索引 // start, end: 当前节点代表的区间 [start, end] private void build(int[] nums, int node, int start, int end) { if (start == end) { // 叶子节点：直接存储原数组的值 tree[node] = nums[start]; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; // 左子节点索引 int rightNode = 2 * node + 2; // 右子节点索引 // 递归构建左右子树 build(nums, leftNode, start, mid); build(nums, rightNode, mid + 1, end); // 当前节点的值 = 左子树 + 右子树（区间和） tree[node] = tree[leftNode] + tree[rightNode]; } // 区间查询：查询区间 [l, r] 的和 public int query(int l, int r) { return query(0, 0, n - 1, l, r); } private int query(int node, int start, int end, int l, int r) { // 情况1：当前区间与查询区间完全不相交 if (l \u0026gt; end || r \u0026lt; start) return 0; // 情况2：当前区间完全包含在查询区间内 if (l \u0026lt;= start \u0026amp;\u0026amp; end \u0026lt;= r) return tree[node]; // 情况3：部分相交，需要递归查询左右子树 int mid = start + (end - start) / 2; int leftSum = query(2 * node + 1, start, mid, l, r); int rightSum = query(2 * node + 2, mid + 1, end, l, r); return leftSum + rightSum; } // 单点更新：将 index 位置的值更新为 val public void update(int index, int val) { update(0, 0, n - 1, index, val); } private void update(int node, int start, int end, int index, int val) { if (start == end) { // 找到叶子节点，更新值 tree[node] = val; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; int rightNode = 2 * node + 2; // 判断 index 在左子树还是右子树 if (index \u0026lt;= mid) { update(leftNode, start, mid, index, val); } else { update(rightNode, mid + 1, end, index, val); } // 更新完子树后，更新当前节点 tree[node] = tree[leftNode] + tree[rightNode]; } } 2. 图算法 图的表示 // 方式1：邻接表（适合稀疏图） Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; graph = new HashMap\u0026lt;\u0026gt;(); // 或使用 ArrayList List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); // 方式2：邻接矩阵（适合密集图） int[][] graph = new int[n][n]; // graph[i][j] 表示 i 到 j 的边权 DFS - 图的深度优先遍历 // 递归实现 DFS void dfs(int node, Set\u0026lt;Integer\u0026gt; visited, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { visited.add(node); // 标记当前节点已访问 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { // 如果邻居未访问 dfs(neighbor, visited, graph); // 递归访问邻居 } } } // 使用示例 Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); dfs(0, visited, graph); // 从节点 0 开始 DFS BFS - 图的广度优先遍历 // 使用队列实现 BFS void bfs(int start, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(start); // 起始节点入队 visited.add(start); // 标记已访问 while (!queue.isEmpty()) { int node = queue.poll(); // 出队 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { queue.offer(neighbor); // 邻居入队 visited.add(neighbor); // 标记已访问 } } } } 拓扑排序（Kahn 算法） /** * 拓扑排序：将有向无环图(DAG)转换为线性序列 * 应用：课程安排、任务调度等 * 核心思想：不断移除入度为0的节点 */ List\u0026lt;Integer\u0026gt; topologicalSort(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] inDegree = new int[n]; // 记录每个节点的入度 for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } // 构建图并计算入度 for (int[] edge : edges) { graph.get(edge[0]).add(edge[1]); // edge[0] -\u0026gt; edge[1] inDegree[edge[1]]++; // edge[1] 的入度+1 } // 将所有入度为0的节点入队 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (inDegree[i] == 0) { queue.offer(i); } } List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); while (!queue.isEmpty()) { int node = queue.poll(); res.add(node); // 将节点加入结果 // 删除该节点的所有出边 for (int neighbor : graph.get(node)) { inDegree[neighbor]--; // 邻居的入度-1 if (inDegree[neighbor] == 0) { // 入度变为0，入队 queue.offer(neighbor); } } } // 如果所有节点都被访问，说明无环，返回结果；否则返回空 return res.size() == n ? res : new ArrayList\u0026lt;\u0026gt;(); } Dijkstra 最短路径算法 /** * Dijkstra算法：单源最短路径（不能有负权边） * 时间复杂度：O(E log V)，E是边数，V是顶点数 * 核心思想：贪心，每次选择距离最小的未访问节点 */ int[] dijkstra(int n, int[][] edges, int start) { // 构建邻接表: {neighbor, weight} List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // edge = [from, to, weight] graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); } // dist[i] 表示从 start 到 i 的最短距离 int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 优先队列: {distance, node}，按距离从小到大排序 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); pq.offer(new int[]{0, start}); while (!pq.isEmpty()) { int[] curr = pq.poll(); int d = curr[0], node = curr[1]; // 如果当前距离大于已知最短距离，跳过 if (d \u0026gt; dist[node]) continue; // 遍历所有邻居，尝试松弛操作 for (int[] neighbor : graph.get(node)) { int next = neighbor[0], weight = neighbor[1]; int newDist = d + weight; // 如果找到更短的路径，更新距离 if (newDist \u0026lt; dist[next]) { dist[next] = newDist; pq.offer(new int[]{newDist, next}); } } } return dist; } Bellman-Ford 算法（可处理负权边） /** * Bellman-Ford算法：单源最短路径，可处理负权边 * 时间复杂度：O(V * E) * 可以检测负环 */ int[] bellmanFord(int n, int[][] edges, int start) { int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 松弛操作：最多进行 n-1 次 // 原理：最短路径最多包含 n-1 条边 for (int i = 0; i \u0026lt; n - 1; i++) { for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; // 松弛操作：如果经过 u 到 v 更短，则更新 if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { dist[v] = dist[u] + w; } } } // 第 n 次松弛：如果还能更新，说明存在负环 for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { return null; // 存在负环 } } return dist; } Floyd-Warshall 全源最短路径 /** * Floyd-Warshall算法：计算所有点对之间的最短路径 * 时间复杂度：O(V³) * 核心思想：动态规划，逐步加入中间节点 */ int[][] floydWarshall(int n, int[][] edges) { int[][] dist = new int[n][n]; // 初始化距离矩阵 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(dist[i], Integer.MAX_VALUE / 2); // 除以2防止溢出 dist[i][i] = 0; // 自己到自己距离为0 } // 填入边的权重 for (int[] edge : edges) { dist[edge[0]][edge[1]] = edge[2]; } // 动态规划：k 是中间节点 // dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) for (int k = 0; k \u0026lt; n; k++) { // 枚举中间节点 for (int i = 0; i \u0026lt; n; i++) { // 枚举起点 for (int j = 0; j \u0026lt; n; j++) { // 枚举终点 // 如果经过 k 中转更短，则更新 dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]); } } } return dist; } Prim 最小生成树 /** * Prim算法：构建最小生成树 * 时间复杂度：O(E log V) * 核心思想：从一个节点开始，逐步扩展，每次选最小边 */ int prim(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // 无向图：添加双向边 graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); graph.get(edge[1]).add(new int[]{edge[0], edge[2]}); } boolean[] visited = new boolean[n]; // 优先队列：{node, weight}，按权重从小到大 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[1] - b[1]); pq.offer(new int[]{0, 0}); // 从节点0开始，权重0 int totalWeight = 0; // 最小生成树的总权重 int edgeCount = 0; // 已添加的边数 while (!pq.isEmpty() \u0026amp;\u0026amp; edgeCount \u0026lt; n) { int[] curr = pq.poll(); int node = curr[0], weight = curr[1]; if (visited[node]) continue; // 已访问，跳过 visited[node] = true; totalWeight += weight; // 加入最小生成树 edgeCount++; // 将邻居节点的边加入优先队列 for (int[] neighbor : graph.get(node)) { if (!visited[neighbor[0]]) { pq.offer(neighbor); } } } // 如果所有节点都连通，返回总权重；否则返回-1 return edgeCount == n ? totalWeight : -1; } Kruskal 最小生成树（并查集） /** * 并查集：用于判断连通性和合并集合 */ class UnionFind { int[] parent; // parent[i] 表示 i 的父节点 int[] rank; // rank[i] 表示以 i 为根的树的高度 public UnionFind(int n) { parent = new int[n]; rank = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; // 初始时每个节点的父节点是自己 } } // 查找：找到 x 所在集合的代表元素（路径压缩） public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); // 路径压缩：直接连到根节点 } return parent[x]; } // 合并：将 x 和 y 所在的集合合并（按秩合并） public boolean union(int x, int y) { int rootX = find(x), rootY = find(y); if (rootX == rootY) return false; // 已经在同一集合 // 按秩合并：将矮树挂到高树上 if (rank[rootX] \u0026lt; rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] \u0026gt; rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; // 高度相同，随便挂，高度+1 } return true; } } /** * Kruskal算法：构建最小生成树 * 时间复杂度：O(E log E) * 核心思想：按边权从小到大排序，用并查集避免成环 */ int kruskal(int n, int[][] edges) { // 按边权从小到大排序 Arrays.sort(edges, (a, b) -\u0026gt; a[2] - b[2]); UnionFind uf = new UnionFind(n); int totalWeight = 0; int edgeCount = 0; for (int[] edge : edges) { // 如果两个节点不在同一集合，添加这条边 if (uf.union(edge[0], edge[1])) { totalWeight += edge[2]; edgeCount++; if (edgeCount == n - 1) break; // 最小生成树有 n-1 条边 } } return edgeCount == n - 1 ? totalWeight : -1; } 3. 回溯算法 组合问题 /** * 组合问题：从 n 个数中选 k 个数的所有组合 * 例如：n=4, k=2 -\u0026gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), 1, n, k); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int start, int n, int k) { // 递归终止条件：已选择 k 个数 if (path.size() == k) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 注意：要复制一份 return; } // 从 start 开始枚举，避免重复 for (int i = start; i \u0026lt;= n; i++) { path.add(i); // 做选择 backtrack(res, path, i + 1, n, k); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } 全排列 /** * 全排列问题：给定数组，返回所有可能的排列 * 例如：[1,2,3] -\u0026gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, new boolean[nums.length]); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, boolean[] used) { // 递归终止条件：所有数字都已使用 if (path.size() == nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } // 枚举所有数字 for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) continue; // 已使用过，跳过 path.add(nums[i]); // 做选择 used[i] = true; // 标记已使用 backtrack(res, path, nums, used); // 递归 used[i] = false; // 撤销标记（回溯） path.remove(path.size() - 1); // 撤销选择（回溯） } } 子集问题 /** * 子集问题：返回数组的所有子集（幂集） * 例如：[1,2,3] -\u0026gt; [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, int start) { // 每个状态都是一个子集 res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 枚举后续元素 for (int i = start; i \u0026lt; nums.length; i++) { path.add(nums[i]); // 做选择 backtrack(res, path, nums, i + 1); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } N 皇后问题 /** * N皇后问题：在 n×n 的棋盘上放置 n 个皇后，使它们互不攻击 * 规则：任意两个皇后不能在同一行、同一列、同一对角线 */ List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); char[][] board = new char[n][n]; // 初始化棋盘：\u0026#39;.\u0026#39; 表示空位 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(board[i], \u0026#39;.\u0026#39;); } backtrack(res, board, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res, char[][] board, int row) { // 递归终止条件：所有行都放置完成 if (row == board.length) { res.add(construct(board)); // 将棋盘转换为字符串列表 return; } // 尝试在当前行的每一列放置皇后 for (int col = 0; col \u0026lt; board.length; col++) { if (!isValid(board, row, col)) continue; // 不合法，跳过 board[row][col] = \u0026#39;Q\u0026#39;; // 放置皇后 backtrack(res, board, row + 1); // 递归下一行 board[row][col] = \u0026#39;.\u0026#39;; // 撤销放置（回溯） } } // 检查在 (row, col) 位置放置皇后是否合法 boolean isValid(char[][] board, int row, int col) { int n = board.length; // 检查列：同一列不能有其他皇后 for (int i = 0; i \u0026lt; row; i++) { if (board[i][col] == \u0026#39;Q\u0026#39;) return false; } // 检查左上对角线 for (int i = row - 1, j = col - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } // 检查右上对角线 for (int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } return true; } // 将棋盘转换为字符串列表 List\u0026lt;String\u0026gt; construct(char[][] board) { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for (char[] row : board) { res.add(new String(row)); } return res; } 4. 动态规划 0-1 背包问题 /** * 0-1背包：每个物品只能选一次 * weights[i]: 第i个物品的重量 * values[i]: 第i个物品的价值 * capacity: 背包容量 * 返回：最大价值 */ int knapsack(int[] weights, int[] values, int capacity) { int n = weights.length; // dp[i][w] 表示前 i 个物品，背包容量为 w 时的最大价值 int[][] dp = new int[n + 1][capacity + 1]; for (int i = 1; i \u0026lt;= n; i++) { for (int w = 0; w \u0026lt;= capacity; w++) { // 如果当前物品的重量 \u0026lt;= 背包容量 if (weights[i - 1] \u0026lt;= w) { // 选择：max(不拿, 拿) dp[i][w] = Math.max( dp[i - 1][w], // 不拿第i个物品 dp[i - 1][w - weights[i - 1]] + values[i - 1] // 拿第i个物品 ); } else { // 放不下，只能不拿 dp[i][w] = dp[i - 1][w]; } } } return dp[n][capacity]; } /** * 0-1背包 - 空间优化版本 * 时间复杂度：O(n * capacity) * 空间复杂度：O(capacity) */ int knapsackOptimized(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：必须从后往前遍历，避免重复使用同一物品 for (int w = capacity; w \u0026gt;= weights[i]; w--) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 完全背包问题 /** * 完全背包：每个物品可以选无限次 * 与0-1背包的区别：内层循环从前往后遍历 */ int completeKnapsack(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：从前往后遍历，允许重复使用物品 for (int w = weights[i]; w \u0026lt;= capacity; w++) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 最长公共子序列（LCS） /** * 最长公共子序列：找两个字符串的最长公共子序列长度 * 子序列：不要求连续 * 例如：\u0026#34;abcde\u0026#34; 和 \u0026#34;ace\u0026#34; 的LCS是 \u0026#34;ace\u0026#34;，长度为3 */ int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); // dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的LCS长度 int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (text1.charAt(i - 1) == text2.charAt(j - 1)) { // 字符相同：LCS长度+1 dp[i][j] = dp[i - 1][j - 1] + 1; } else { // 字符不同：取两种情况的最大值 dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; } 最长递增子序列（LIS） /** * 最长递增子序列 - O(n²) 动态规划解法 * dp[i] 表示以 nums[i] 结尾的最长递增子序列长度 */ int lengthOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; Arrays.fill(dp, 1); // 初始每个元素自己构成长度为1的子序列 int maxLen = 1; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { // 如果 nums[i] 可以接在 nums[j] 后面 if (nums[i] \u0026gt; nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } maxLen = Math.max(maxLen, dp[i]); } return maxLen; } /** * 最长递增子序列 - O(n log n) 二分解法 * tails[i] 表示长度为 i+1 的递增子序列的最小尾部元素 */ int lengthOfLISBinary(int[] nums) { List\u0026lt;Integer\u0026gt; tails = new ArrayList\u0026lt;\u0026gt;(); for (int num : nums) { // 二分查找：找到第一个 \u0026gt;= num 的位置 int left = 0, right = tails.size(); while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (tails.get(mid) \u0026lt; num) { left = mid + 1; } else { right = mid; } } // 如果 num 比所有元素都大，追加到末尾 if (left == tails.size()) { tails.add(num); } else { // 否则替换找到的位置 tails.set(left, num); } } return tails.size(); } 编辑距离 /** * 编辑距离：将 word1 转换为 word2 的最少操作次数 * 操作：插入、删除、替换 * 例如：\u0026#34;horse\u0026#34; -\u0026gt; \u0026#34;ros\u0026#34; 需要3步（删除h、删除r、替换s） */ int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); // dp[i][j] 表示 word1[0..i-1] 转换为 word2[0..j-1] 的最少操作数 int[][] dp = new int[m + 1][n + 1]; // 边界条件：一个字符串为空 for (int i = 0; i \u0026lt;= m; i++) dp[i][0] = i; // word1 -\u0026gt; 空串：删除i个字符 for (int j = 0; j \u0026lt;= n; j++) dp[0][j] = j; // 空串 -\u0026gt; word2：插入j个字符 for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { // 字符相同：不需要操作 dp[i][j] = dp[i - 1][j - 1]; } else { // 字符不同：三种操作取最小 dp[i][j] = Math.min( Math.min( dp[i - 1][j], // 删除 word1[i-1] dp[i][j - 1] // 插入 word2[j-1] ), dp[i - 1][j - 1] // 替换 word1[i-1] 为 word2[j-1] ) + 1; } } } return dp[m][n]; } 股票买卖问题 只能买卖一次\n/** * 买卖股票的最佳时机 I：只能买卖一次 * 贪心思想：记录最低价格，计算每天卖出的最大利润 */ int maxProfit(int[] prices) { int minPrice = Integer.MAX_VALUE; // 记录目前为止的最低价格 int maxProfit = 0; // 记录最大利润 for (int price : prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; } 可以买卖多次\n/** * 买卖股票的最佳时机 II：可以买卖多次 * 贪心思想：只要今天价格比昨天高，就在昨天买今天卖 */ int maxProfitMultiple(int[] prices) { int profit = 0; for (int i = 1; i \u0026lt; prices.length; i++) { // 如果今天价格更高，累加差价 if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } 最多买卖 k 次\n/** * 买卖股票的最佳时机 III/IV：最多买卖 k 次 * dp[i][j] 表示第 i 次交易后，第 j 天的最大利润 */ int maxProfitK(int k, int[] prices) { if (prices.length == 0) return 0; int n = prices.length; // 如果 k \u0026gt;= n/2，相当于无限次交易 if (k \u0026gt;= n / 2) { int profit = 0; for (int i = 1; i \u0026lt; n; i++) { if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } int[][] dp = new int[k + 1][n]; for (int i = 1; i \u0026lt;= k; i++) { int maxDiff = -prices[0]; // 第 i-1 次交易后买入的最大收益 for (int j = 1; j \u0026lt; n; j++) { // 不操作 vs 卖出 dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff); // 更新买入的最大收益 maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]); } } return dp[k][n - 1]; } 打家劫舍 /** * 打家劫舍 I：线性排列的房屋 * 不能抢相邻的房屋 * dp[i] = max(dp[i-1], dp[i-2] + nums[i]) */ int rob(int[] nums) { if (nums.length == 0) return 0; if (nums.length == 1) return nums[0]; int prev2 = 0, prev1 = 0; // prev2: dp[i-2], prev1: dp[i-1] for (int num : nums) { int temp = prev1; // 不抢 vs 抢 prev1 = Math.max(prev1, prev2 + num); prev2 = temp; } return prev1; } /** * 打家劫舍 II：环形排列的房屋 * 第一个和最后一个房屋相邻 * 思路：分两种情况，取最大值 * 1. 抢第一个房屋，不抢最后一个 * 2. 不抢第一个房屋，抢最后一个 */ int robCircular(int[] nums) { if (nums.length == 1) return nums[0]; return Math.max( robRange(nums, 0, nums.length - 2), robRange(nums, 1, nums.length - 1) ); } int robRange(int[] nums, int start, int end) { int prev2 = 0, prev1 = 0; for (int i = start; i \u0026lt;= end; i++) { int temp = prev1; prev1 = Math.max(prev1, prev2 + nums[i]); prev2 = temp; } return prev1; } 分割等和子集 /** * 分割等和子集：判断是否能将数组分成两个和相等的子集 * 本质：0-1背包问题，目标是找到和为 sum/2 的子集 */ boolean canPartition(int[] nums) { int sum = 0; for (int num : nums) sum += num; if (sum % 2 != 0) return false; // 和为奇数，不可能分割 int target = sum / 2; // dp[j] 表示能否凑出和为 j boolean[] dp = new boolean[target + 1]; dp[0] = true; // 和为0总是可以（不选任何数） for (int num : nums) { // 从后往前遍历，避免重复使用 for (int j = target; j \u0026gt;= num; j--) { dp[j] = dp[j] || dp[j - num]; // 不选 num 或 选 num } } return dp[target]; } 零钱兑换 /** * 零钱兑换 I：最少硬币数 * dp[i] 表示凑出金额 i 所需的最少硬币数 */ int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); // 初始化为不可能的大值 dp[0] = 0; // 凑出0元需要0个硬币 for (int i = 1; i \u0026lt;= amount; i++) { for (int coin : coins) { if (i \u0026gt;= coin) { // 选择使用当前硬币 dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } } return dp[amount] \u0026gt; amount ? -1 : dp[amount]; } /** * 零钱兑换 II：组成方案数 * dp[i] 表示凑出金额 i 的方案数 */ int change(int amount, int[] coins) { int[] dp = new int[amount + 1]; dp[0] = 1; // 凑出0元有1种方案（不选） // 外层遍历硬币，内层遍历金额（避免重复计数） for (int coin : coins) { for (int i = coin; i \u0026lt;= amount; i++) { dp[i] += dp[i - coin]; } } return dp[amount]; } 5. 双指针 对撞指针 // 两数之和（有序数组） int[] twoSum(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[left] + nums[right]; if (sum == target) { return new int[]{left, right}; } else if (sum \u0026lt; target) { left++; } else { right--; } } return new int[]{-1, -1}; } // 三数之和 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length - 2; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { res.add(Arrays.asList(nums[i], nums[left], nums[right])); while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; left++; right--; } else if (sum \u0026lt; 0) { left++; } else { right--; } } } return res; } 快慢指针 // 链表中点 ListNode findMiddle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } // 环形链表 boolean hasCycle(ListNode head) { if (head == null) return false; ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) return true; } return false; } // 找环的入口 ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { slow = head; while (slow != fast) { slow = slow.next; fast = fast.next; } return slow; } } return null; } 6. 单调栈 // 下一个更大元素 int[] nextGreaterElement(int[] nums) { int n = nums.length; int[] res = new int[n]; Arrays.fill(res, -1); Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; nums[stack.peek()] \u0026lt; nums[i]) { int idx = stack.pop(); res[idx] = nums[i]; } stack.push(i); } return res; } // 每日温度 int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] res = new int[n]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[stack.peek()] \u0026lt; temperatures[i]) { int idx = stack.pop(); res[idx] = i - idx; } stack.push(i); } return res; } // 柱状图中最大的矩形 int largestRectangleArea(int[] heights) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(-1); int maxArea = 0; for (int i = 0; i \u0026lt; heights.length; i++) { while (stack.peek() != -1 \u0026amp;\u0026amp; heights[stack.peek()] \u0026gt;= heights[i]) { int h = heights[stack.pop()]; int w = i - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } stack.push(i); } while (stack.peek() != -1) { int h = heights[stack.pop()]; int w = heights.length - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } return maxArea; } 7. 前缀和 // 一维前缀和 class PrefixSum { private int[] preSum; public PrefixSum(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 0; i \u0026lt; nums.length; i++) { preSum[i + 1] = preSum[i] + nums[i]; } } // 查询区间 [left, right] 的和 public int query(int left, int right) { return preSum[right + 1] - preSum[left]; } } // 二维前缀和 class MatrixPrefixSum { private int[][] preSum; public MatrixPrefixSum(int[][] matrix) { int m = matrix.length, n = matrix[0].length; preSum = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } // 查询子矩阵 [row1, col1] 到 [row2, col2] 的和 public int query(int row1, int col1, int row2, int col2) { return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]; } } 📌 总结 这份文档涵盖了：\nJava 集合框架：List、Set、Map、Queue、Stack 的完整使用方法 树算法：DFS、BFS、线段树 图算法：遍历、最短路径、最小生成树 经典算法：回溯、动态规划、二分查找、滑动窗口、双指针、单调栈、前缀和 建议配合 LeetCode 刷题使用，遇到问题时可以快速查阅对应的模板代码。\n持续更新中\u0026hellip; 🚀\n","permalink":"http://localhost:1313/java-notes/algorithm-with-java/","summary":"详细介绍java集合的使用,以及在刷算法题中需要使用到的一些板子","title":"算法刷题必备：Java集合与算法模板"},{"content":"一、Hugo 常用指令 1.1 创建新站点 # 创建一个新的 Hugo 站点 hugo new site mysite # 进入站点目录 cd mysite 1.2 创建新文章 # 在 content/posts 目录下创建新文章 hugo new posts/my-first-post.md # 在 content 目录下创建文章 hugo new about.md # 创建在特定子目录 hugo new blog/2024/new-post.md 1.3 本地预览 # 启动本地开发服务器（默认 http://localhost:1313） hugo server # 启动并显示草稿文章 hugo server -D # 启动并显示草稿、未来日期和过期的文章 hugo server -DEF # 指定端口 hugo server --port 8080 # 实时重载并打开浏览器 hugo server -D --navigateToChanged 1.4 主题管理 # 添加主题（使用 Git submodule） git submodule add https://github.com/username/theme-name.git themes/theme-name # 更新主题 git submodule update --remote --merge # 删除主题 git submodule deinit -f themes/theme-name rm -rf .git/modules/themes/theme-name git rm -f themes/theme-name 1.5 其他常用指令 # 查看 Hugo 版本 hugo version # 查看帮助 hugo help # 查看配置信息 hugo config # 列出所有内容 hugo list all # 列出草稿 hugo list drafts 二、Markdown Front Matter 配置 2.1 完整配置示例 --- # 基本信息 title: \u0026#34;我的第一篇文章\u0026#34; date: 2025-12-06T15:04:05+08:00 lastmod: 2025-12-07T10:00:00+08:00 draft: false # 作者信息 author: \u0026#34;Minjie\u0026#34; authorLink: \u0026#34;https://github.com/Minjie2003\u0026#34; # 分类和标签 categories: [\u0026#34;技术\u0026#34;] tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;, \u0026#34;博客\u0026#34;] series: [\u0026#34;Hugo教程\u0026#34;] # 摘要和描述 summary: \u0026#34;这是一篇关于 Hugo 和 Markdown 的完整指南\u0026#34; description: \u0026#34;详细介绍 Hugo 的使用方法和 Markdown 配置\u0026#34; # 特色图片 image: \u0026#34;/images/featured.jpg\u0026#34; cover: image: \u0026#34;/images/cover.jpg\u0026#34; alt: \u0026#34;封面图片描述\u0026#34; caption: \u0026#34;图片说明文字\u0026#34; # SEO 相关 keywords: [\u0026#34;Hugo\u0026#34;, \u0026#34;静态博客\u0026#34;, \u0026#34;Markdown\u0026#34;] slug: \u0026#34;hugo-markdown-guide\u0026#34; url: \u0026#34;/posts/hugo-guide/\u0026#34; # 显示控制 toc: true # 显示目录 comments: true # 允许评论 showToc: true # 显示目录 TocOpen: false # 默认展开目录 hidemeta: false # 隐藏元信息 disableShare: false # 禁用分享按钮 hideSummary: false # 隐藏摘要 ShowReadingTime: true # 显示阅读时间 ShowBreadCrumbs: true # 显示面包屑导航 ShowPostNavLinks: true # 显示文章导航链接 # 权重（用于排序） weight: 1 # 外部链接 externalLink: \u0026#34;https://example.com\u0026#34; # 是否在首页显示 showhome: true --- 2.2 常用字段说明 字段 说明 示例 title 文章标题 \u0026quot;我的文章\u0026quot; date 发布日期 2025-12-06 或 2025-12-06T15:04:05+08:00 draft 是否为草稿 true / false tags 标签（数组） [\u0026quot;Hugo\u0026quot;, \u0026quot;博客\u0026quot;] categories 分类（数组） [\u0026quot;技术\u0026quot;, \u0026quot;教程\u0026quot;] summary 文章摘要 \u0026quot;这是摘要\u0026quot; description SEO 描述 \u0026quot;页面描述\u0026quot; slug URL 友好名称 \u0026quot;my-post\u0026quot; url 自定义完整 URL \u0026quot;/posts/my-post/\u0026quot; weight 排序权重 1 (数字越小越靠前) toc 是否显示目录 true / false 三、Hugo Shortcodes（短代码） 3.1 内置 Shortcodes # 显示图片 {{\u0026lt; figure src=\u0026#34;/images/photo.jpg\u0026#34; title=\u0026#34;图片标题\u0026#34; \u0026gt;}} # 高亮文本 {{\u0026lt; highlight python \u0026gt;}} def hello(): print(\u0026#34;Hello!\u0026#34;) {{\u0026lt; /highlight \u0026gt;}} # YouTube 视频 {{\u0026lt; youtube VIDEO_ID \u0026gt;}} # X (Twitter) 推文（新版） {{\u0026lt; x user=\u0026#34;USERNAME\u0026#34; id=\u0026#34;TWEET_ID\u0026#34; \u0026gt;}} # GitHub Gist（已废弃，建议直接嵌入代码） # 可以使用 highlight 或直接用代码块替代 # 参数传递（需要在 Front Matter 中定义参数） {{\u0026lt; param \u0026#34;description\u0026#34; \u0026gt;}} 3.2 自定义 Shortcode 示例 在 layouts/shortcodes/note.html 创建：\n\u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; 使用时：\n{{\u0026lt; note \u0026gt;}} 这是一个提示框 {{\u0026lt; /note \u0026gt;}} 四、Markdown 基本语法 4.1 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 4.2 文本样式 **粗体文字** *斜体文字* ***粗斜体*** ~~删除线~~ `行内代码` 4.3 列表 # 无序列表 - 项目 1 - 项目 2 - 子项目 2.1 - 子项目 2.2 # 有序列表 1. 第一项 2. 第二项 1. 子项 2.1 2. 子项 2.2 4.4 链接和图片 # 链接 [链接文字](https://example.com) [带标题的链接](https://example.com \u0026#34;鼠标悬停显示\u0026#34;) # 图片 ![图片描述](/images/photo.jpg) ![图片](https://example.com/image.jpg \u0026#34;图片标题\u0026#34;) 4.5 引用 \u0026gt; 这是一段引用文字 \u0026gt; 可以多行 \u0026gt;\u0026gt; 嵌套引用 4.6 代码块 ```python def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) ``` ```javascript console.log(\u0026#34;Hello, World!\u0026#34;); ``` 4.7 表格 | 列1 | 列2 | 列3 | |-----|-----|-----| | 数据1 | 数据2 | 数据3 | | 数据4 | 数据5 | 数据6 | # 对齐方式 | 左对齐 | 居中 | 右对齐 | |:-------|:----:|-------:| | 内容 | 内容 | 内容 | 4.8 分隔线 --- *** ___ 4.9 任务列表 - [x] 已完成的任务 - [ ] 未完成的任务 - [ ] 另一个任务 五、实用技巧 5.1 文章模板 在 archetypes/default.md 创建默认模板：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true tags: [] categories: [] summary: \u0026#34;\u0026#34; --- ## 简介 内容开始... 5.2 多语言配置 在 Front Matter 中：\n--- title: \u0026#34;English Title\u0026#34; title.zh: \u0026#34;中文标题\u0026#34; --- 5.3 自定义 URL 结构 在 hugo.toml 中：\n[permalinks] posts = \u0026#34;/:year/:month/:slug/\u0026#34; 5.4 草稿快速发布 # 将草稿改为发布状态 sed -i \u0026#39;s/draft: true/draft: false/\u0026#39; content/posts/my-post.md ","permalink":"http://localhost:1313/doc-intro/hugo-readme/","summary":"详细介绍 Hugo 常用指令、Markdown Front Matter 配置、基本语法和实用技巧的完整指南","title":"Hugo 常用指令与 Markdown 配置指南"},{"content":"👋 嗨，我是 Minjie 很高兴你能来到这里！这是我在互联网上的一个小角落，用来记录代码、想法和生活的点滴。\n🧑‍💻 关于我 我是一名在读研究生，研究方向包括区块链，web3.0，数据库管理等。当然，目前更加专注于 Java 后端开发。相比起\u0026quot;全栈工程师\u0026quot;这样的标签，我更喜欢把自己定义为一个对计算机技术充满好奇心的探索者。\n📖 这个博客写什么 这里主要记录我在技术道路上的成长轨迹，你可能会看到：\n技术笔记 - Java 后端开发的实践经验、框架使用心得、踩过的坑和解决方案\n项目复盘 - 从需求分析到上线部署，记录项目中的思考和收获\n学习记录 - 新技术的探索、算法题的思路、计算机基础知识的整理\n随笔杂谈 - 偶尔也会写写读书笔记、游戏感想，或者对技术趋势的一些思考\n我希望这里不仅是我个人的知识库,也能给同样在技术路上摸索的你带来一些启发或共鸣。\n🎯 技术栈 \u0026amp; 兴趣方向 后端开发：Java、Spring Boot、MyBatis、MySQL、Redis - 这是我的主战场\n折腾爱好：除了后端，我还喜欢写点爬虫玩玩，做些自动化小工具来解决日常遇到的重复性工作。总觉得能用代码解决的事情，就不该浪费时间手动操作。有时候为了实现一个自动化脚本，花的时间可能比手动做还多，但那种\u0026quot;一劳永逸\u0026quot;的快感真的很上头。\n探索中：对各种能提高效率的技术和工具都充满兴趣，正在不断拓展技术边界\u0026hellip;\n🎮 代码之外 游戏时光：Steam 上收藏了不少游戏，也会玩玩王者、原神这些。\n音乐陪伴：写代码的时候总要听点什么。古典音乐能让思路更清晰，ACG 音乐带来满满的回忆，偶尔也会跟着流行音乐哼哼唱唱。喜欢洗澡的时候k歌······当然，也是个半吊子吉他选手\n运动爱好：除了敲键盘，也喜欢出去动一动。篮球、羽毛球、乒乓球都有涉猎，虽然都不算精通，但也能过上两招。过去打篮球多一点，现在更想尝试羽毛球。\n历史爱好者：对历史有种莫名的着迷，喜欢看历史书籍、纪录片。主要包括近现代欧洲历史，唐史，春秋战国。\n💬 来聊聊？ 如果你也对后端开发感兴趣，或者想交流技术、分享项目经验，甚至只是想推荐个好玩的游戏或好听的歌，都欢迎联系我：\n📧 邮箱：zhongnagisa01@gmail.com 🐙 GitHub：Minjie2003 \u0026ldquo;流水不争先，争的是滔滔不绝\u0026rdquo;\n感谢你的访问，希望我们能在这里有更多交流！✨\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于我"}]