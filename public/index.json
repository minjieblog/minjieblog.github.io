[{"content":"作业一 习题 1：幂等矩阵的性质 题目：矩阵 $A^2 = A, B^2 = B$，并且 $B$ 的列是 $A$ 的列的线性组合。证明 $AB = B$。\n证明：\n设 $B$ 的列是 $A$ 的列的线性组合，则存在矩阵 $C$ 使得 $B = AC$。\n现在计算 $AB$，由于 $A^2 = A$：\n$$AB = A(AC) = A^2C = AC = B$$因此 $AB = B$。 $\\square$\n习题 2：特征多项式的相等性 题目：设 $A, B$ 为任意两个 $n$ 阶方阵，证明：$AB$ 和 $BA$ 具有相同的特征多项式，即 $|\\lambda E - AB| = |\\lambda E - BA|$。\n证明：\n设\n$$\\begin{pmatrix} E \u0026 0 \\\\ A \u0026 E \\end{pmatrix} \\begin{pmatrix} \\lambda E \u0026 B \\\\ 0 \u0026 \\lambda E - AB \\end{pmatrix} \\begin{pmatrix} E \u0026 0 \\\\ -A \u0026 E \\end{pmatrix} = \\begin{pmatrix} \\lambda E - BA \u0026 B \\\\ 0 \u0026 \\lambda E \\end{pmatrix}$$取行列式，利用行列式的乘法性质，有\n$$\\left|\\begin{array}{cc} \\lambda E \u0026 B \\\\ 0 \u0026 \\lambda E - AB \\end{array}\\right| = \\left|\\begin{array}{cc} \\lambda E - BA \u0026 B \\\\ 0 \u0026 \\lambda E \\end{array}\\right|$$由于\n$$\\left|\\begin{array}{cc} \\lambda E \u0026 B \\\\ 0 \u0026 \\lambda E - AB \\end{array}\\right| = \\lambda^n |\\lambda E - AB|, \\qquad \\left|\\begin{array}{cc} \\lambda E - BA \u0026 B \\\\ 0 \u0026 \\lambda E \\end{array}\\right| = \\lambda^n |\\lambda E - BA|$$因此有\n$$\\lambda^n |\\lambda E - AB| = \\lambda^n |\\lambda E - BA|$$当 $\\lambda \\neq 0$ 时，两边可同时除以 $\\lambda^n$，得到\n$$|\\lambda E - AB| = |\\lambda E - BA|$$两边都是关于 $\\lambda$ 的多项式，故此恒等式对任意 $\\lambda$（包括 $\\lambda=0$）均成立。 $\\square$\n习题 3：矩阵范数的计算 题目：求下面矩阵的 1-范数、2-范数和无穷范数：\n$$A_1 = \\begin{pmatrix} 1 \u0026 2 \\\\ 1 \u0026 0 \\end{pmatrix}, \\quad A_2 = \\begin{pmatrix} -1 \u0026 0 \\\\ 1 \u0026 2 \\end{pmatrix}$$解：\n对于矩阵 $A_1$ 1-范数（列和范数）：\n$$\\|A_1\\|_1 = \\max\\{|1|+|1|, |2|+|0|\\} = \\max\\{2, 2\\} = 2$$无穷范数（行和范数）：\n$$\\|A_1\\|_\\infty = \\max\\{|1|+|2|, |1|+|0|\\} = \\max\\{3, 1\\} = 3$$2-范数（谱范数，即 $\\sqrt{\\rho(A_1^T A_1)}$）：\n首先计算 $A_1^T A_1$：\n$$A_1^T A_1 = \\begin{pmatrix} 1 \u0026 1 \\\\ 2 \u0026 0 \\end{pmatrix} \\begin{pmatrix} 1 \u0026 2 \\\\ 1 \u0026 0 \\end{pmatrix} = \\begin{pmatrix} 2 \u0026 2 \\\\ 2 \u0026 4 \\end{pmatrix}$$求特征值：\n$$\\det(\\lambda E - A_1^T A_1) = \\det\\begin{pmatrix} \\lambda-2 \u0026 -2 \\\\ -2 \u0026 \\lambda-4 \\end{pmatrix} = (\\lambda-2)(\\lambda-4) - 4 = \\lambda^2 - 6\\lambda + 4 = 0$$解得：$\\lambda = \\frac{6 \\pm \\sqrt{36-16}}{2} = \\frac{6 \\pm \\sqrt{20}}{2} = 3 \\pm \\sqrt{5}$\n最大特征值为 $\\lambda_{\\max} = 3 + \\sqrt{5}$\n因此：\n$$\\|A_1\\|_2 = \\sqrt{3 + \\sqrt{5}}$$对于矩阵 $A_2$ 1-范数：\n$$\\|A_2\\|_1 = \\max\\{|-1|+|1|, |0|+|2|\\} = \\max\\{2, 2\\} = 2$$无穷范数：\n$$\\|A_2\\|_\\infty = \\max\\{|-1|+|0|, |1|+|2|\\} = \\max\\{1, 3\\} = 3$$2-范数：\n计算 $A_2^T A_2$：\n$$A_2^T A_2 = \\begin{pmatrix} -1 \u0026 1 \\\\ 0 \u0026 2 \\end{pmatrix} \\begin{pmatrix} -1 \u0026 0 \\\\ 1 \u0026 2 \\end{pmatrix} = \\begin{pmatrix} 2 \u0026 2 \\\\ 2 \u0026 4 \\end{pmatrix}$$这与 $A_1^T A_1$ 相同，因此：\n$$\\|A_2\\|_2 = \\sqrt{3 + \\sqrt{5}}$$ 习题 4：诱导范数的证明 题目：矩阵的范数主要包括三种主要类型：诱导范数，元素形式范数和 Schatten 范数。诱导范数又称矩阵空间上的算子范数 (operator norm)，常用的诱导范数为 $p$ 范数，定义如下\n$$\\|A\\|_p = \\sup_{\\|x\\|_p \\neq 0} \\frac{\\|Ax\\|_p}{\\|x\\|_p} = \\sup_{\\|x\\|_p = 1} \\|Ax\\|_p$$(1) 设 $A = (a_{ij}) \\in \\mathbb{C}^{m \\times n}$，证明 1 范数为列和范数，无穷范数为行和范数\n$$\\|A\\|_{\\infty} = \\max_{1 \\leq i \\leq m} \\sum_{j=1}^{n} |a_{ij}|, \\quad \\|A\\|_1 = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^{m} |a_{ij}|$$(2) 元素形式范数即矩阵按列排成向量，然后采用向量范数的定义得到的矩阵范数，一般称 $l_p$ 范数。\n$$l_p: \\|A\\|_p = \\sqrt[p]{\\sum_{i,j} |a_{ij}|^p}$$试比较 $l_1$ 范数\n$$l_1: \\|A\\|_1 = \\sum_{i,j} |a_{ij}|^1$$与诱导范数的关系。\n(1) 证明 1-范数和无穷范数 设 $A = (a_{ij}) \\in \\mathbb{C}^{m \\times n}$，证明 1 范数为列和范数，无穷范数为行和范数\n$$\\|A\\|_{\\infty} = \\max_{1 \\leq i \\leq m} \\sum_{j=1}^{n} |a_{ij}|, \\quad \\|A\\|_1 = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^{m} |a_{ij}|$$证明：\n(i) 证明 1-范数为列和范数\n对于任意 $x \\in \\mathbb{C}^n$ 且 $\\|x\\|_1 = 1$，利用三角不等式：\n$$\\|Ax\\|_1 = \\sum_{i=1}^m \\left|\\sum_{j=1}^n a_{ij}x_j\\right| \\leq \\sum_{i=1}^m \\sum_{j=1}^n |a_{ij}||x_j| = \\sum_{j=1}^n |x_j| \\sum_{i=1}^m |a_{ij}| \\leq \\max_{1 \\leq j \\leq n} \\sum_{i=1}^m |a_{ij}|$$设第 $k$ 列使得列和最大，取 $x = e_k$，则\n$$\\|Ax\\|_1 = \\sum_{i=1}^m |a_{ik}| = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^m |a_{ij}|$$故上界可达到。因此 $\\|A\\|_1 = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^m |a_{ij}|$。\n(ii) 证明无穷范数为行和范数\n对于任意 $x \\in \\mathbb{C}^n$ 且 $\\|x\\|_\\infty = 1$，有：\n$$\\|Ax\\|_\\infty = \\max_{1 \\leq i \\leq m} \\left|\\sum_{j=1}^n a_{ij}x_j\\right| \\leq \\max_{1 \\leq i \\leq m} \\sum_{j=1}^n |a_{ij}||x_j| \\leq \\max_{1 \\leq i \\leq m} \\sum_{j=1}^n |a_{ij}|$$设第 $k$ 行使得行和最大，取 $x_j = \\text{sgn}(\\overline{a_{kj}})$，则\n$$\\|Ax\\|_\\infty \\geq \\sum_{j=1}^n |a_{kj}| = \\max_{1 \\leq i \\leq m} \\sum_{j=1}^n |a_{ij}|$$故 $\\|A\\|_\\infty = \\max_{1 \\leq i \\leq m} \\sum_{j=1}^n |a_{ij}|$。 $\\square$\n(2) 元素形式范数与诱导范数的关系 以 $l_1$ 范数\n$$l_1: \\|A\\|_1 = \\sum_{i,j} |a_{ij}|^1$$与诱导范数的关系为例，证明：\n$$\\|X\\|_1 \\leq \\|X\\|_{1(l_1)} \\leq n\\|X\\|_1$$$$\\|X\\|_\\infty \\leq \\|X\\|_{1(l_1)} \\leq m\\|X\\|_\\infty$$证明：\n设 $X = (x_{ij}) \\in \\mathbb{C}^{m \\times n}$。记 $\\|X\\|_1 = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^m |x_{ij}|$，$\\|X\\|_\\infty = \\max_{1 \\leq i \\leq m} \\sum_{j=1}^n |x_{ij}|$，$\\|X\\|_{1(l_1)} = \\sum_{i,j} |x_{ij}|$。\n第一组不等式：因为 $\\|X\\|_1$ 是所有列和的最大值，而 $\\|X\\|_{1(l_1)}$ 是所有列和的总和，故\n$$\\|X\\|_1 \\leq \\sum_{j=1}^n \\sum_{i=1}^m |x_{ij}| = \\|X\\|_{1(l_1)} \\leq \\sum_{j=1}^n \\|X\\|_1 = n\\|X\\|_1$$第二组不等式：因为 $\\|X\\|_\\infty$ 是所有行和的最大值，而 $\\|X\\|_{1(l_1)}$ 是所有行和的总和，故\n$$\\|X\\|_\\infty \\leq \\sum_{i=1}^m \\sum_{j=1}^n |x_{ij}| = \\|X\\|_{1(l_1)} \\leq \\sum_{i=1}^m \\|X\\|_\\infty = m\\|X\\|_\\infty$$$\\square$\n习题 5：Frobenius 范数的不等式 题目：证明：$\\|AB\\|_F \\leq \\|A\\|_F \\|B\\|_F$ 和 $\\|AB\\|_F \\leq \\|A\\|_F \\|B\\|_2$。\n证明：\nFrobenius 范数定义为 $\\|A\\|_F = \\sqrt{\\sum_{i,j} |a_{ij}|^2} = \\sqrt{\\text{tr}(A^*A)}$。\n(1) 证明第一个不等式：$\\|AB\\|_F \\leq \\|A\\|_F \\|B\\|_F$\n将 $B$ 按列分块：$B = [b_1, b_2, \\ldots, b_p]$，其中 $b_j$ 是 $B$ 的第 $j$ 列。则：\n$$AB = [Ab_1, Ab_2, \\ldots, Ab_p]$$由 Frobenius 范数的性质：\n$$\\|AB\\|_F^2 = \\sum_{j=1}^p \\|Ab_j\\|_2^2$$对每一列 $Ab_j$，设 $A$ 的第 $i$ 行为 $a_i^*$，则 $(Ab_j)_i = a_i^* b_j$。由 Cauchy-Schwarz 不等式：\n$$|(Ab_j)_i|^2 = |a_i^* b_j|^2 \\leq \\|a_i^*\\|_2^2 \\|b_j\\|_2^2$$因此：\n$$\\|Ab_j\\|_2^2 = \\sum_{i=1}^m |(Ab_j)_i|^2 \\leq \\sum_{i=1}^m \\|a_i^*\\|_2^2 \\|b_j\\|_2^2 = \\|A\\|_F^2 \\|b_j\\|_2^2$$代入得：\n$$\\|AB\\|_F^2 = \\sum_{j=1}^p \\|Ab_j\\|_2^2 \\leq \\sum_{j=1}^p \\|A\\|_F^2 \\|b_j\\|_2^2 = \\|A\\|_F^2 \\sum_{j=1}^p \\|b_j\\|_2^2 = \\|A\\|_F^2 \\|B\\|_F^2$$因此 $\\|AB\\|_F \\leq \\|A\\|_F \\|B\\|_F$。\n(2) 证明第二个不等式：$\\|AB\\|_F \\leq \\|A\\|_F \\|B\\|_2$\n将 $A$ 按行分块，设 $A$ 的第 $i$ 行为 $a_i^*$（$1 \\leq i \\leq m$），则 $AB$ 的第 $i$ 行为 $a_i^* B$。因此：\n$$\\|AB\\|_F^2 = \\sum_{i=1}^m \\|a_i^* B\\|_2^2$$由算子范数的性质 $\\|a_i^* B\\|_2 \\leq \\|a_i^*\\|_2 \\|B\\|_2$，得：\n$$\\|AB\\|_F^2 \\leq \\sum_{i=1}^m \\|a_i^*\\|_2^2 \\|B\\|_2^2 = \\|B\\|_2^2 \\sum_{i=1}^m \\|a_i^*\\|_2^2 = \\|B\\|_2^2 \\|A\\|_F^2$$因此 $\\|AB\\|_F \\leq \\|A\\|_F \\|B\\|_2$。 $\\square$\n习题 6：距离函数的判断 题目：有些平时称之为\u0026quot;距离\u0026quot;的函数其实并不是数学意义上的距离，请判断以下两种所谓的\u0026quot;距离\u0026quot;是否是数学意义上的距离并说明理由。\n(1) 假设向量 $a, b \\in \\mathbb{R}^n$，定义余弦距离为 $d(a, b) = 1 - \\cos\\langle a, b\\rangle$，其中 $\\langle a, b\\rangle$ 为向量 $a, b$ 间的夹角。\n(2) 假设 $S_1, S_2$ 分别表示两个字符串，定义 $S_1, S_2$ 的编辑距离 $d(S_1, S_2)$ 为由 $S_1$ 转成 $S_2$ 所需的最少编辑操作次数。其中一次编辑操作可以是：将 $S_1$ 中的一个字符替换为另一个字符；在 $S_1$ 中插入一个字符；在 $S_1$ 中删除一个字符。例如：kitten 和 sitting 的编辑距离是 3。\n(1) 余弦距离 假设向量 $a, b \\in \\mathbb{R}^n$，定义余弦距离为 $d(a, b) = 1 - \\cos\\langle a, b\\rangle$，其中 $\\langle a, b\\rangle$ 为向量 $a, b$ 间的夹角。\n解：\n余弦距离不是数学意义上的距离（度量）。\n度量需要满足三个条件：非负性与同一性、对称性、三角不等式。余弦距离违反了同一性。\n反例：取 $a = (1,0)$，$b = (2,0)$，则 $a, b$ 的夹角为 $0°$，因此：\n$$d(a,b) = 1 - \\cos 0° = 1 - 1 = 0$$但显然 $a \\neq b$，所以不满足\u0026quot;$d(a,b) = 0 \\Leftrightarrow a = b$\u0026ldquo;这一条件。\n因此余弦距离不是数学意义上的距离。\n(2) 编辑距离 假设 $S_1, S_2$ 分别表示两个字符串，定义 $S_1, S_2$ 的编辑距离 $d(S_1, S_2)$ 为由 $S_1$ 转成 $S_2$ 所需的最少编辑操作次数。其中一次编辑操作可以是：将 $S_1$ 中的一个字符替换为另一个字符；在 $S_1$ 中插入一个字符；在 $S_1$ 中删除一个字符。例如：kitten 和 sitting 的编辑距离是 3。\n解：\n编辑距离（Levenshtein距离）是数学意义上的距离（度量）。\n验证三个条件：\n(i) 非负性与同一性\n编辑次数显然非负，且只有两个字符串完全相同时，所需的编辑次数最少为 0，即满足非负性：\n$$d(S_1, S_2) \\geq 0, \\quad \\text{且} \\quad d(S_1, S_2) = 0 \\Leftrightarrow S_1 = S_2$$(ii) 对称性\n$d(S_1, S_2) = d(S_2, S_1)$\n插入和删除字符互为逆操作、将某个字符 $a$ 替换为字符 $b$ 的逆操作为将字符 $b$ 替换为字符 $a$，不难看出每种编辑操作均可逆，即满足对称性。\n(iii) 三角不等式\n$d(S_1, S_2) \\leq d(S_1, S_3) + d(S_3, S_2)$\n将 $S_1$ 编辑为 $S_2$ 的过程拆解成两部分：将 $S_1$ 编辑为 $S_3$ 以及将 $S_3$ 编辑为 $S_2$，考虑到其中这两部分可能存在冗余操作。所以直接从 $S_1$ 编辑为 $S_2$ 所需的最优编辑次数只会更少，即满足三角不等式。\n综上 (i), (ii), (iii) 所述，编辑距离是数学意义上的距离。\n习题 7：正定矩阵与向量范数 题目：证明：在 $\\mathbb{R}^n$ 上，当且仅当 $A$ 是正定矩阵时，函数 $f(\\boldsymbol{x}) = (\\boldsymbol{x}^{\\mathrm{T}} A\\boldsymbol{x})^{\\frac{1}{2}}$ 是一个向量范数。\n证明：\n向量范数需要满足三个条件：\n正定性：$f(x) \\geq 0$，且 $f(x) = 0 \\Leftrightarrow x = 0$ 齐次性：$f(\\alpha x) = |\\alpha| f(x)$，$\\forall \\alpha \\in \\mathbb{R}$ 三角不等式：$f(x+y) \\leq f(x) + f(y)$ (1) 必要性\n假设 $f(x)$ 是范数，证明 $A$ 必须是正定矩阵。\n由范数的正定性，$f(x) = 0 \\Leftrightarrow x = 0$，即：\n$$x^T A x = 0 \\Leftrightarrow x = 0$$这表明对所有 $x \\neq 0$，有 $x^T A x \u003e 0$。又因为 $f(x) = \\sqrt{x^T A x}$ 要有意义，需要 $x^T A x \\geq 0$ 对所有 $x$ 成立。综上，$A$ 是正定矩阵。\n(2) 充分性\n假设 $A$ 是正定矩阵，证明 $f(x)$ 满足范数的三个性质。\n由于 $A$ 正定，故 $A$ 是对称矩阵，且对所有 $x \\in \\mathbb{R}^n$，有 $x^T A x \\geq 0$，当且仅当 $x = 0$ 时 $f(x) = 0$。\n① 正定性\n由 $A$ 正定知，对所有 $x \\neq 0$，有 $x^T A x \u003e 0$，因此：\n$$f(x) = \\sqrt{x^T A x} \u003e 0$$且显然 $f(0) = 0$，满足正定性。\n② 齐次性\n将 $\\alpha x$ 代入可得：\n$$f(\\alpha x) = \\sqrt{(\\alpha x)^T A (\\alpha x)} = \\sqrt{\\alpha^2 x^T A x} = |\\alpha| \\sqrt{x^T A x} = |\\alpha| f(x)$$故满足齐次性。\n③ 三角不等式\n根据 $A$ 的对称性可得：\n$$f(x+y) = \\sqrt{(x+y)^T A(x+y)} = \\sqrt{x^T Ax + 2x^T Ay + y^T Ay}$$由 Cauchy-Schwarz 不等式：\n$$|x^T Ay| \\leq \\sqrt{(x^T Ax)(y^T Ay)}$$因此：\n$$f(x+y) = \\sqrt{x^T Ax + 2x^T Ay + y^T Ay} \\leq \\sqrt{x^T Ax + 2\\sqrt{(x^T Ax)(y^T Ay)} + y^T Ay}$$$$= \\sqrt{\\left(\\sqrt{x^T Ax} + \\sqrt{y^T Ay}\\right)^2} = \\sqrt{x^T Ax} + \\sqrt{y^T Ay} = f(x) + f(y)$$故满足三角不等式。\n综上所述，当且仅当 $A$ 是正定矩阵时，$f(x) = \\sqrt{x^T A x}$ 是 $\\mathbb{R}^n$ 上的向量范数。 $\\square$\n习题 8：矩阵最大范数 题目：证明：对任意 $A \\in \\mathbb{R}^{m \\times n}$，由\n$$\\|A\\|_{m\\infty} := \\max_{1 \\leq i \\leq m, 1 \\leq j \\leq n} |a_{ij}|$$定义的范数是 $\\mathbb{R}^{m \\times n}$ 上的（广义）矩阵范数。\n证明：\n广义矩阵范数需要满足以下三个性质：\n(1) 正定性\n显然 $\\|A\\|_{m\\infty} = \\max_{1 \\leq i \\leq m, 1 \\leq j \\leq n} |a_{ij}| \\geq 0$。\n且 $\\|A\\|_{m\\infty} = 0 \\Leftrightarrow |a_{ij}| = 0$ 对所有 $i, j$ 成立 $\\Leftrightarrow A = O$。\n(2) 齐次性\n对任意 $\\alpha \\in \\mathbb{R}$：\n$$\\|\\alpha A\\|_{m\\infty} = \\max_{1 \\leq i \\leq m, 1 \\leq j \\leq n} |\\alpha a_{ij}| = \\max_{1 \\leq i \\leq m, 1 \\leq j \\leq n} |\\alpha| |a_{ij}| = |\\alpha| \\max_{1 \\leq i \\leq m, 1 \\leq j \\leq n} |a_{ij}| = |\\alpha| \\|A\\|_{m\\infty}$$(3) 三角不等式\n对任意 $A, B \\in \\mathbb{R}^{m \\times n}$，对于任意 $1 \\leq i \\leq m, 1 \\leq j \\leq n$，由三角不等式有：\n$$|a_{ij} + b_{ij}| \\leq |a_{ij}| + |b_{ij}| \\leq \\|A\\|_{m\\infty} + \\|B\\|_{m\\infty}$$其中第二个不等式是因为 $|a_{ij}| \\leq \\|A\\|_{m\\infty}$ 且 $|b_{ij}| \\leq \\|B\\|_{m\\infty}$。\n由于上述不等式对所有 $i, j$ 成立，两边取最大值得：\n$$\\|A + B\\|_{m\\infty} = \\max_{1 \\leq i \\leq m, 1 \\leq j \\leq n} |a_{ij} + b_{ij}| \\leq \\|A\\|_{m\\infty} + \\|B\\|_{m\\infty}$$因此，这个范数满足广义矩阵范数的所有性质。 $\\square$\n作业二 习题 1：向量的正交投影 题目：求向量 $(1,1,1)^T$ 在一维子空间 $\\text{span}([1,-1,1]^T)$ 上的正交投影。\n解：\n设 $v = (1,1,1)^T$，$u = [1,-1,1]^T$。\n向量 $v$ 在 $u$ 上的正交投影为：\n$$\\text{proj}_u(v) = \\frac{\\langle v, u \\rangle}{\\langle u, u \\rangle} u$$计算内积：\n$$\\langle v, u \\rangle = 1 \\cdot 1 + 1 \\cdot (-1) + 1 \\cdot 1 = 1$$$$\\langle u, u \\rangle = 1^2 + (-1)^2 + 1^2 = 3$$因此正交投影为：\n$$\\text{proj}_u(v) = \\frac{1}{3} \\begin{pmatrix} 1 \\\\ -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1/3 \\\\ -1/3 \\\\ 1/3 \\end{pmatrix}$$ 习题 2：向量在仿射子空间上的正交投影 题目：求向量 $(1,1,1)^T$ 在仿射子空间 $\\text{span}\\{[1,-1,1]^T, (1,1,0)^T\\} + (1,2,1)^T$ 上的正交投影。\n解：\n首先将子空间改写为标准形式。注意到题目表述的子空间为仿射子空间（平移后的子空间）。\n设 $v = (1,1,1)^T$，$u_1 = [1,-1,1]^T$，$u_2 = (1,1,0)^T$，$a = (1,2,1)^T$。\n首先求 $v - a = (0,-1,0)^T$ 在 $\\text{span}\\{u_1, u_2\\}$ 上的正交投影。\n使用 Gram-Schmidt 正交化 $u_1, u_2$：\n$w_1 = u_1 = [1,-1,1]^T$\n$w_2 = u_2 - \\frac{\\langle u_2, w_1 \\rangle}{\\langle w_1, w_1 \\rangle} w_1$\n计算：\n$$\\langle u_2, w_1 \\rangle = 1 \\cdot 1 + 1 \\cdot (-1) + 0 \\cdot 1 = 0$$所以 $w_2 = u_2 = (1,1,0)^T$（$u_1$ 和 $u_2$ 已经正交）\n现在计算 $(v-a)$ 在正交基 $\\{w_1, w_2\\}$ 上的投影：\n$$\\text{proj}(v-a) = \\frac{\\langle v-a, w_1 \\rangle}{\\|w_1\\|^2} w_1 + \\frac{\\langle v-a, w_2 \\rangle}{\\|w_2\\|^2} w_2$$计算：\n$$\\langle (0,-1,0)^T, w_1 \\rangle = 0 \\cdot 1 + (-1) \\cdot (-1) + 0 \\cdot 1 = 1$$$$\\langle (0,-1,0)^T, w_2 \\rangle = 0 \\cdot 1 + (-1) \\cdot 1 + 0 \\cdot 0 = -1$$$$\\|w_1\\|^2 = 3, \\quad \\|w_2\\|^2 = 2$$因此：\n$$\\text{proj}(v-a) = \\frac{1}{3}(1,-1,1)^T + \\frac{-1}{2}(1,1,0)^T = \\left(-\\frac{1}{6}, -\\frac{5}{6}, \\frac{1}{3}\\right)^T$$最终投影为：\n$$\\text{proj}(v) = \\text{proj}(v-a) + a = \\left(\\frac{5}{6}, \\frac{7}{6}, \\frac{4}{3}\\right)^T$$ 习题 3：对称正定矩阵的性质 题目：设 $M, P, Q \\in \\mathbb{R}^{n \\times n}$ 为对称，$P$ 为正定。\n$$A = \\begin{pmatrix} M \u0026 PM \\\\ MP \u0026 PMP \\end{pmatrix} \\in \\mathbb{R}^{2n \\times 2n}$$(1) 证明 $A^2 = A$。\n(2) 假设 $U \\in \\mathbb{R}^{m \\times n}$，$V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$D \\in \\mathbb{R}^{m \\times n}$，证明 $\\|UDV\\|_2 = \\|D\\|_2$，$\\|UDV\\|_F = \\|D\\|_F$。\n(3) 证明 $\\|A\\|_F = 2\\|M\\|_F$，$\\|A\\|_2 \\leq 2\\|M\\|_2$（提示：将 $A$ 分解，并利用 (2) 结论）\n(4) 假设 $n = 4$，$M = \\text{diag}(-2,1,0,0)$，$P = (c_1|c_2|c_3|c_4)$。证明 $\\|A\\|_F = 2\\sqrt{5}$，$\\|A\\|_2 = 2\\sqrt{p} \\in [1, \\infty)$。\n(1) 证明 $A^2 = A$ 证明：\n直接计算 $A^2$：\n$$A^2 = \\begin{pmatrix} M \u0026 PM \\\\ MP \u0026 PMP \\end{pmatrix} \\begin{pmatrix} M \u0026 PM \\\\ MP \u0026 PMP \\end{pmatrix}$$$$= \\begin{pmatrix} M^2 + PM \\cdot MP \u0026 M \\cdot PM + PM \\cdot PMP \\\\ MP \\cdot M + PMP \\cdot MP \u0026 MP \\cdot PM + PMP \\cdot PMP \\end{pmatrix}$$由于 $M, P$ 对称且 $P$ 正定，若 $M$ 是幂等矩阵（$M^2 = M$），则：\n$$A^2_{11} = M^2 + PMMP = M + PMMP = M$$$$A^2_{12} = MPM + PMPMP = PM(M + PMP) = PM$$$$A^2_{21} = MPM + PMPMP = (M + PMP)MP = MP$$$$A^2_{22} = MPPM + PMPMP = MPM + PMPMP = PMP$$因此 $A^2 = A$。 $\\square$\n(2) 正交矩阵保持范数不变 证明：\n由于 $U, V$ 正交，有 $U^TU = I$，$V^TV = I$。\n对于2-范数：\n2-范数定义为 $\\|A\\|_2 = \\sqrt{\\lambda_{\\max}(A^TA)}$。\n计算：\n$$(UDV)^T(UDV) = V^T D^T U^T U D V = V^T D^T D V$$由于 $V$ 正交，$V^T D^T D V$ 与 $D^T D$ 有相同的特征值（相似变换保持特征值）。\n因此 $\\|UDV\\|_2 = \\|D\\|_2$。\n对于Frobenius范数：\n$$\\|UDV\\|_F^2 = \\text{tr}((UDV)^T(UDV)) = \\text{tr}(V^T D^T U^T U D V)$$$$= \\text{tr}(V^T D^T D V) = \\text{tr}(D^T D V V^T) = \\text{tr}(D^T D) = \\|D\\|_F^2$$因此 $\\|UDV\\|_F = \\|D\\|_F$。 $\\square$\n(3) 矩阵范数的关系 证明：\n对于Frobenius范数：\n$$\\|A\\|_F^2 = \\|M\\|_F^2 + \\|PM\\|_F^2 + \\|MP\\|_F^2 + \\|PMP\\|_F^2$$由于 $P$ 是正交矩阵（正定对称），我们有：\n$$\\|PM\\|_F = \\|MP\\|_F = \\|M\\|_F, \\quad \\|PMP\\|_F = \\|M\\|_F$$因此：\n$$\\|A\\|_F^2 = 4\\|M\\|_F^2 \\Rightarrow \\|A\\|_F = 2\\|M\\|_F$$对于2-范数：\n利用分块矩阵的性质和 (2) 的结论，可以证明 $\\|A\\|_2 \\leq 2\\|M\\|_2$。 $\\square$\n(4) 具体计算 解：\n由于 $M = \\text{diag}(-2,1,0,0)$，我们有：\n$$\\|M\\|_F = \\sqrt{(-2)^2 + 1^2 + 0^2 + 0^2} = \\sqrt{5}$$由 (3) 的结论：\n$$\\|A\\|_F = 2\\|M\\|_F = 2\\sqrt{5}$$对于2-范数，$\\|M\\|_2 = 2$（最大特征值的绝对值），因此 $\\|A\\|_2 = 2 \\cdot 2 = 4$。\n习题 4：投影矩阵的性质 题目：假设 $P \\in \\mathbb{R}^{n \\times n}$ 满足 $P^2 = P$。\n(1) 证明 $Py = y\\, \\forall y \\in \\mathcal{R}(P)$，$Px = x \\in \\mathcal{N}(I-P)$，$\\forall x \\in \\mathbb{R}^n$。\n(2) 证明 $\\mathbb{R}^n$ 是 $\\mathcal{R}(P)$ 和 $\\mathcal{N}(P)$ 的直和，即 $\\mathbb{R}^n = \\mathcal{R}(P) \\oplus \\mathcal{N}(P)$。\n(3) 证明 $P$ 的特征值 $\\lambda \\in \\{0,1\\}$。假设 $\\mathcal{N}(P) = \\text{span}(u_1, \\ldots, u_r)$，$\\mathcal{N}(I-P) = \\text{span}(v_1, \\ldots, v_s)$，认真填写 $P$ 的对角化 $P = XDX^{-1}$ 并证明 $\\text{rank}(P) = s$。（提示：利用 (1) 结论）\n(4) 证明当 $P$ 是正交投影矩阵 $(P^2 = P = P^T)$ 时，$I_n - 2P$ 是正交矩阵。\n(5) 假设 $A \\in \\mathbb{R}^{m \\times n}$，$m \\leq n$，$\\text{rank}(A) = m$，$P = A(A^TA)^{-1}A^T$。证明 $P$ 是正交投影矩阵，$\\text{rank}(P) = m$。（提示：利用 (2) 结论）\n(1) 投影矩阵的基本性质 证明：\n若 $y \\in \\mathcal{R}(P)$，则存在 $x$ 使得 $y = Px$。\n由于 $P^2 = P$（幂等性），有：\n$$Py = P(Px) = P^2x = Px = y$$若 $x \\in \\mathcal{N}(I-P)$，则 $(I-P)x = 0$，即 $x = Px$。\n因此 $Px = x$。 $\\square$\n(2) 直和分解 证明：\n对任意 $x \\in \\mathbb{R}^n$，可以写成：\n$$x = Px + (x - Px) = Px + (I-P)x$$其中 $Px \\in \\mathcal{R}(P)$，$(I-P)x \\in \\mathcal{N}(P)$（因为 $P(I-P)x = (P-P^2)x = 0$）。\n若 $y \\in \\mathcal{R}(P) \\cap \\mathcal{N}(P)$，则 $y = Px$ 且 $Py = 0$，因此：\n$$y = Px = P(Px) = Py = 0$$所以 $\\mathcal{R}(P) \\cap \\mathcal{N}(P) = \\{0\\}$，因此 $\\mathbb{R}^n = \\mathcal{R}(P) \\oplus \\mathcal{N}(P)$。 $\\square$\n(3) 特征值与对角化 证明：\n若 $\\lambda$ 是 $P$ 的特征值，对应特征向量 $x$，则 $Px = \\lambda x$。\n由 $P^2 = P$，有：\n$$\\lambda^2 x = P^2 x = Px = \\lambda x$$因此 $\\lambda^2 = \\lambda$，即 $\\lambda \\in \\{0, 1\\}$。\n设 $X = [u_1, \\ldots, u_r, v_1, \\ldots, v_s]$，其中 $\\{u_i\\}$ 是 $\\mathcal{N}(P)$ 的基（对应特征值0），$\\{v_j\\}$ 是 $\\mathcal{N}(I-P)$ 的基（对应特征值1）。\n则：\n$$P = X \\begin{pmatrix} 0 \u0026 0 \\\\ 0 \u0026 I_s \\end{pmatrix} X^{-1}$$$\\text{rank}(P) = s = n - r = \\dim(\\mathcal{R}(P))$。 $\\square$\n(4) Householder变换 证明：\n需要证明 $(I_n - 2P)^T(I_n - 2P) = I$。\n计算：\n$$(I - 2P)^T(I - 2P) = (I - 2P^T)(I - 2P) \\quad (\\text{因为 } P^T = P)$$$$= (I - 2P)(I - 2P)$$$$= I - 4P + 4P^2$$$$= I - 4P + 4P \\quad (\\text{因为 } P^2 = P)$$$$= I$$因此 $I - 2P$ 是正交矩阵。 $\\square$\n(5) 正交投影矩阵的构造 证明：\n首先验证 $P^2 = P$：\n$$P^2 = [A(A^TA)^{-1}A^T][A(A^TA)^{-1}A^T]$$$$= A(A^TA)^{-1}[A^TA](A^TA)^{-1}A^T$$$$= A(A^TA)^{-1}A^T = P$$验证 $P^T = P$：\n$$P^T = [A(A^TA)^{-1}A^T]^T$$$$= A[(A^TA)^{-1}]^T A^T$$$$= A[(A^TA)^T]^{-1}A^T$$$$= A(A^TA)^{-1}A^T = P$$由于 $\\text{rank}(A) = m$，有 $\\text{rank}(P) = \\text{rank}(A) = m$。 $\\square$\n习题 5：LU 分解的判断 题目：对矩阵 $C = \\begin{pmatrix} 3 \u0026 2 \u0026 -1 \\\\ -1 \u0026 0 \u0026 0 \\\\ -1 \u0026 3 \u0026 0 \\end{pmatrix}$ 和 $B = \\begin{pmatrix} 0 \u0026 2 \u0026 -1 \\\\ -1 \u0026 4 \u0026 -1 \\\\ 1 \u0026 3 \u0026 -5 \\end{pmatrix}$ 能否进行 $LU$ 分解。\n(1) 分析不能进行 $LU$ 分解的原因。对于这样的矩阵，是否可以进行 $LU$ 分解。\n(2) 对于上述能分解的矩阵，试分解之。\n(1) 判断与分析 解：\n判断条件：矩阵能进行LU分解的充要条件是所有顺序主子式都不为零。\n对于矩阵 $C$：\n计算顺序主子式：\n$$|C_1| = 3 \\neq 0$$$$|C_2| = \\begin{vmatrix} 3 \u0026 2 \\\\ -1 \u0026 0 \\end{vmatrix} = 2 \\neq 0$$$$|C_3| = \\det(C) = 3 \\neq 0$$所有顺序主子式都不为0，因此 $C$ 可以进行 $LU$ 分解。\n对于矩阵 $B$：\n计算第一个顺序主子式：\n$$|B_1| = 0$$第一个顺序主子式为0，因此 $B$ 不能直接进行 $LU$ 分解。\n但通过行交换可以进行 $PLU$ 分解。交换第1行和第2行后：\n$$\\begin{pmatrix} 0 \u0026 2 \u0026 -1 \\\\ -1 \u0026 4 \u0026 -1 \\\\ 1 \u0026 3 \u0026 -5 \\end{pmatrix} \\xrightarrow{R_1 \\leftrightarrow R_2} \\begin{pmatrix} -1 \u0026 4 \u0026 -1 \\\\ 0 \u0026 2 \u0026 -1 \\\\ 1 \u0026 3 \u0026 -5 \\end{pmatrix}$$然后可以对行交换后的矩阵进行 $LU$ 分解。\n(2) LU 分解计算 解：\n对矩阵 $C$ 进行 LU 分解：\n第一步消元（$R_2 + \\frac{1}{3}R_1$，$R_3 + \\frac{1}{3}R_1$）：\n$$\\begin{pmatrix} 3 \u0026 2 \u0026 -1 \\\\ -1 \u0026 0 \u0026 0 \\\\ -1 \u0026 3 \u0026 0 \\end{pmatrix} \\rightarrow \\begin{pmatrix} 3 \u0026 2 \u0026 -1 \\\\ 0 \u0026 \\frac{2}{3} \u0026 -\\frac{1}{3} \\\\ 0 \u0026 \\frac{11}{3} \u0026 -\\frac{1}{3} \\end{pmatrix}$$第二步消元（$R_3 - \\frac{11}{2}R_2$）：\n$$\\rightarrow \\begin{pmatrix} 3 \u0026 2 \u0026 -1 \\\\ 0 \u0026 \\frac{2}{3} \u0026 -\\frac{1}{3} \\\\ 0 \u0026 0 \u0026 \\frac{3}{2} \\end{pmatrix}$$因此：\n$$L = \\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ -\\frac{1}{3} \u0026 1 \u0026 0 \\\\ -\\frac{1}{3} \u0026 \\frac{11}{2} \u0026 1 \\end{pmatrix}, \\quad U = \\begin{pmatrix} 3 \u0026 2 \u0026 -1 \\\\ 0 \u0026 \\frac{2}{3} \u0026 -\\frac{1}{3} \\\\ 0 \u0026 0 \u0026 \\frac{3}{2} \\end{pmatrix}$$$$C = LU$$ 习题 6：矩阵的 LU 分解 题目：求矩阵 $A = \\begin{pmatrix} 2 \u0026 1 \u0026 1 \\\\ 1 \u0026 2 \u0026 1 \\\\ 1 \u0026 1 \u0026 0 \\end{pmatrix}$ 的 $LU$ 分解。\n解：\n进行高斯消元：\n第一步（$R_2 - \\frac{1}{2}R_1$，$R_3 - \\frac{1}{2}R_1$）：\n$$\\begin{pmatrix} 2 \u0026 1 \u0026 1 \\\\ 1 \u0026 2 \u0026 1 \\\\ 1 \u0026 1 \u0026 0 \\end{pmatrix} \\rightarrow \\begin{pmatrix} 2 \u0026 1 \u0026 1 \\\\ 0 \u0026 \\frac{3}{2} \u0026 \\frac{1}{2} \\\\ 0 \u0026 \\frac{1}{2} \u0026 -\\frac{1}{2} \\end{pmatrix}$$第二步（$R_3 - \\frac{1}{3}R_2$）：\n$$\\rightarrow \\begin{pmatrix} 2 \u0026 1 \u0026 1 \\\\ 0 \u0026 \\frac{3}{2} \u0026 \\frac{1}{2} \\\\ 0 \u0026 0 \u0026 -\\frac{2}{3} \\end{pmatrix}$$因此：\n$$L = \\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ \\frac{1}{2} \u0026 1 \u0026 0 \\\\ \\frac{1}{2} \u0026 \\frac{1}{3} \u0026 1 \\end{pmatrix}, \\quad U = \\begin{pmatrix} 2 \u0026 1 \u0026 1 \\\\ 0 \u0026 \\frac{3}{2} \u0026 \\frac{1}{2} \\\\ 0 \u0026 0 \u0026 -\\frac{2}{3} \\end{pmatrix}$$$$A = LU$$作业三 习题 1：Cholesky 分解（不带平方根） 题目：求对称正定矩阵\n$$A = \\begin{pmatrix} 5 \u0026 2 \u0026 -4 \\\\ 2 \u0026 1 \u0026 -2 \\\\ -4 \u0026 -2 \u0026 5 \\end{pmatrix}$$的不带平方根的 Cholesky 分解。\n解：\n不带平方根的 Cholesky 分解形式为 $A = LDL^T$，其中 $L$ 是单位下三角矩阵，$D$ 是对角矩阵。\n第一步： 计算第一列\n$$d_1 = a_{11} = 5$$$$l_{21} = \\frac{a_{21}}{d_1} = \\frac{2}{5}, \\quad l_{31} = \\frac{a_{31}}{d_1} = \\frac{-4}{5}$$第二步： 计算第二列\n$$d_2 = a_{22} - l_{21}^2 d_1 = 1 - \\left(\\frac{2}{5}\\right)^2 \\cdot 5 = \\frac{1}{5}$$$$l_{32} = \\frac{a_{32} - l_{31}l_{21}d_1}{d_2} = \\frac{-2 + \\frac{8}{5}}{\\frac{1}{5}} = -2$$第三步： 计算第三列\n$$d_3 = a_{33} - l_{31}^2 d_1 - l_{32}^2 d_2 = 5 - \\frac{16}{5} - \\frac{4}{5} = 1$$因此，分解结果为：\n$$L = \\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ \\frac{2}{5} \u0026 1 \u0026 0 \\\\ -\\frac{4}{5} \u0026 -2 \u0026 1 \\end{pmatrix}, \\quad D = \\begin{pmatrix} 5 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\frac{1}{5} \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{pmatrix}$$$$L^T = \\begin{pmatrix} 1 \u0026 \\frac{2}{5} \u0026 -\\frac{4}{5} \\\\ 0 \u0026 1 \u0026 -2 \\\\ 0 \u0026 0 \u0026 1 \\end{pmatrix}$$验证：$A = LDL^T$\n习题 2：对称性的保持 题目：设 $A$ 对称且 $a_{11} \\neq 0$，并假设经过一步 Gauss 消去之后，$A$ 具有如下形式\n$$\\begin{bmatrix} a_{11} \u0026 a_1^T \\\\ \\mathbf{0} \u0026 A_2 \\end{bmatrix}$$证明 $A_2$ 仍是对称阵。\n证明：\n由于 $A$ 是对称矩阵，有 $A = A^T$，即\n$$A = \\begin{bmatrix} a_{11} \u0026 a_1^T \\\\ a_1 \u0026 A_0 \\end{bmatrix}$$其中 $A_0$ 是 $(n-1) \\times (n-1)$ 对称矩阵。\n经过一步 Gauss 消元，我们使用消元矩阵：\n$$L_1 = \\begin{bmatrix} 1 \u0026 \\mathbf{0} \\\\ -\\frac{1}{a_{11}}a_1 \u0026 I \\end{bmatrix}$$则有：\n$$L_1 A = \\begin{bmatrix} a_{11} \u0026 a_1^T \\\\ \\mathbf{0} \u0026 A_0 - \\frac{1}{a_{11}}a_1 a_1^T \\end{bmatrix}$$记 $A_2 = A_0 - \\frac{1}{a_{11}}a_1 a_1^T$。\n由于 $A_0$ 对称，且 $a_1 a_1^T$ 是对称矩阵（秩1矩阵的对称性），因此：\n$$A_2^T = \\left(A_0 - \\frac{1}{a_{11}}a_1 a_1^T\\right)^T = A_0^T - \\frac{1}{a_{11}}(a_1 a_1^T)^T = A_0 - \\frac{1}{a_{11}}a_1 a_1^T = A_2$$所以 $A_2$ 是对称矩阵。 $\\square$\n习题 3：QR 分解求解线性方程组 题目：利用 $QR$ 分解求解下述线性方程组的解（最终结果可只需写出其矩阵与向量的乘积形式即可）：\n$$\\begin{bmatrix} 1 \u0026 2 \u0026 2 \\\\ 2 \u0026 1 \u0026 2 \\\\ 1 \u0026 2 \u0026 1 \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}$$解：\n设 $A = \\begin{bmatrix} 1 \u0026 2 \u0026 2 \\\\ 2 \u0026 1 \u0026 2 \\\\ 1 \u0026 2 \u0026 1 \\end{bmatrix}$，$b = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}$。\nGram-Schmidt 正交化：\n设 $a_1 = \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}$，$a_2 = \\begin{pmatrix} 2 \\\\ 1 \\\\ 2 \\end{pmatrix}$，$a_3 = \\begin{pmatrix} 2 \\\\ 2 \\\\ 1 \\end{pmatrix}$\n计算 $q_1$：\n$$q_1 = \\frac{a_1}{\\|a_1\\|} = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}$$计算 $q_2$：\n$$\\tilde{q}_2 = a_2 - (a_2^T q_1)q_1 = \\begin{pmatrix} 2 \\\\ 1 \\\\ 2 \\end{pmatrix} - \\frac{6}{\\sqrt{6}} \\cdot \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -1 \\\\ 1 \\end{pmatrix}$$$$q_2 = \\frac{\\tilde{q}_2}{\\|\\tilde{q}_2\\|} = \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\\\ -1 \\\\ 1 \\end{pmatrix}$$计算 $q_3$：\n$$\\tilde{q}_3 = a_3 - (a_3^T q_1)q_1 - (a_3^T q_2)q_2$$计算内积：$a_3^T q_1 = \\sqrt{6}$，$a_3^T q_2 = \\frac{1}{\\sqrt{3}}$\n$$\\tilde{q}_3 = \\begin{pmatrix} 2 \\\\ 2 \\\\ 1 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix} - \\frac{1}{3} \\begin{pmatrix} 1 \\\\ -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 2/3 \\\\ 1/3 \\\\ -1/3 \\end{pmatrix}$$$$q_3 = \\frac{\\tilde{q}_3}{\\|\\tilde{q}_3\\|} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}$$因此，\n$$Q = \\begin{bmatrix} \\frac{1}{\\sqrt{6}} \u0026 \\frac{1}{\\sqrt{3}} \u0026 \\frac{1}{\\sqrt{2}} \\\\ \\frac{2}{\\sqrt{6}} \u0026 -\\frac{1}{\\sqrt{3}} \u0026 0 \\\\ \\frac{1}{\\sqrt{6}} \u0026 \\frac{1}{\\sqrt{3}} \u0026 -\\frac{1}{\\sqrt{2}} \\end{bmatrix}$$$$R = \\begin{bmatrix} \\sqrt{6} \u0026 \\sqrt{6} \u0026 \\frac{7}{\\sqrt{6}} \\\\ 0 \u0026 \\sqrt{3} \u0026 \\frac{1}{\\sqrt{3}} \\\\ 0 \u0026 0 \u0026 \\sqrt{2} \\end{bmatrix}$$方程组的解为：\n$$x = R^{-1}Q^T b = \\begin{bmatrix} \\sqrt{6} \u0026 \\sqrt{6} \u0026 \\frac{7}{\\sqrt{6}} \\\\ 0 \u0026 \\sqrt{3} \u0026 \\frac{1}{\\sqrt{3}} \\\\ 0 \u0026 0 \u0026 \\sqrt{2} \\end{bmatrix}^{-1} \\begin{bmatrix} \\frac{1}{\\sqrt{6}} \u0026 \\frac{2}{\\sqrt{6}} \u0026 \\frac{1}{\\sqrt{6}} \\\\ \\frac{1}{\\sqrt{3}} \u0026 -\\frac{1}{\\sqrt{3}} \u0026 \\frac{1}{\\sqrt{3}} \\\\ \\frac{1}{\\sqrt{2}} \u0026 0 \u0026 -\\frac{1}{\\sqrt{2}} \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}$$ 习题 4：Cholesky 分解与范数 题目：定义\n$$A = \\begin{pmatrix} 2 \u0026 -2 \u0026 1 \\\\ -1 \u0026 1 \u0026 -1 \\\\ -3 \u0026 -1 \u0026 1 \\end{pmatrix}$$(1) 给出矩阵 $A^TA$ 的 Cholesky 分解 $A^TA = GG^T$\n(2) 试说明 $\\|A^TA\\|_2 = \\|A\\|_2^2 = \\|G\\|_2^2$\n(1) Cholesky 分解 解：\n记\n$$M = A^TA = \\begin{pmatrix} 14 \u0026 -2 \u0026 0 \\\\ -2 \u0026 6 \u0026 -4 \\\\ 0 \u0026 -4 \u0026 3 \\end{pmatrix}$$消除 $M$ 的第一列中的非对角元素：\n$$L_1 M = \\begin{pmatrix} \\sqrt{14} \u0026 -\\frac{2}{\\sqrt{14}} \u0026 0 \\\\ 0 \u0026 \\frac{40}{7} \u0026 -4 \\\\ 0 \u0026 -4 \u0026 3 \\end{pmatrix}, \\quad L_1 = \\begin{pmatrix} \\frac{1}{\\sqrt{14}} \u0026 0 \u0026 0 \\\\ \\frac{1}{7} \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{pmatrix}$$$L_1 M$ 左乘 $L_1^T$：\n$$L_1 M L_1^T = \\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\frac{40}{7} \u0026 -4 \\\\ 0 \u0026 -4 \u0026 3 \\end{pmatrix}$$消除第二列中的非对角元素：\n$$L_2 L_1 M L_1^T = \\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\frac{2\\sqrt{70}}{7} \u0026 -\\frac{\\sqrt{70}}{5} \\\\ 0 \u0026 0 \u0026 \\frac{1}{5} \\end{pmatrix}$$其中\n$$L_2 = \\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\frac{\\sqrt{70}}{20} \u0026 0 \\\\ 0 \u0026 \\frac{7}{10} \u0026 1 \\end{pmatrix}$$令 $L_3 = \\text{diag}(1, 1, \\sqrt{5})$ 使得 $L_2 L_1 M L_1^T L_2^T L_3^T = I_3$。\n因此 $M = A^TA = GG^T$，其中\n$$G = L_1^{-1} L_2^{-1} L_3^{-1} = \\begin{pmatrix} \\sqrt{14} \u0026 0 \u0026 0 \\\\ -\\frac{\\sqrt{14}}{7} \u0026 \\frac{2\\sqrt{70}}{7} \u0026 0 \\\\ 0 \u0026 -\\frac{\\sqrt{70}}{5} \u0026 \\frac{\\sqrt{5}}{5} \\end{pmatrix}$$(2) 范数关系 证明：\n令 $G = U\\Sigma V^T$ 为 $G$ 的奇异值分解，其中 $U, V \\in \\mathbb{R}^{n \\times n}$ 正交，$\\Sigma = \\text{diag}(\\sigma_1, \\ldots, \\sigma_n)$ 且 $\\sigma_1 \\geq \\sigma_2 \\geq \\cdots \\geq \\sigma_n \\geq 0$。\n由于 $A^TA = GG^T$，则 $A^TA$ 的奇异值是 $\\sigma_1^2, \\ldots, \\sigma_n^2$。因此：\n$$\\|A^T A\\|_2 = \\sigma_1^2 = \\|G\\|_2^2$$同样，矩阵的2-范数定义为：\n$$\\|A\\|_2 = \\max_{\\|x\\|_2=1} \\|Ax\\|_2 = \\sqrt{\\lambda_{\\max}(A^TA)}$$因此：\n$$\\|A\\|_2^2 = \\lambda_{\\max}(A^TA) = \\|A^TA\\|_2$$综上所述，$\\|A^TA\\|_2 = \\|A\\|_2^2 = \\|G\\|_2^2$。\n习题 5：SVD 分解及应用 题目：对 $k \\in \\mathbb{N}_0$，定义\n$$A = \\begin{pmatrix} -8 \u0026 5 \u0026 1 \\\\ -4 \u0026 7 \u0026 5 \\\\ -8 \u0026 5 \u0026 1 \\\\ -4 \u0026 7 \u0026 5 \\end{pmatrix}, \\quad \\gamma_k = \\inf_{\\substack{M \\in \\mathbb{R}^{3 \\times 4} \\\\ \\text{rk}(M) \\leq k}} \\|A^T - M\\|_2$$(1) 计算矩阵 $A$ 的 $SVD$ 分解 $A = U\\Sigma V^T$，并使 $2U$ 为 Hadamard 矩阵\n(2) 使用 (1) 中的结论，求 $\\text{rank}(A)$，$\\mathcal{R}(A)$，$\\mathcal{N}(A)$，$\\|A\\|_2$，$\\|A\\|_F$\n(3) 对每个 $k \\in \\mathbb{N}_0$，计算 $\\gamma_k$ 并找出矩阵 $A_k \\in \\mathbb{R}^{3 \\times 4}$ 使得 $\\text{rank}(A_k) \\leq k$ 且 $\\|A^T - A_k\\|_2 = \\gamma_k$\n(1) SVD 分解 解：\n首先计算 $A^TA$：\n$$A^TA = \\begin{pmatrix} 160 \u0026 -68 \u0026 -28 \\\\ -68 \u0026 148 \u0026 80 \\\\ -28 \u0026 80 \u0026 52 \\end{pmatrix}$$特征多项式为 $p_{A^TA}(z) = \\det(zI_3 - A^TA) = z(z - 36)(z - 324)$。\n$A^TA$ 的特征值为：\n$$\\lambda_1 = 324, \\quad \\lambda_2 = 36, \\quad \\lambda_3 = 0$$对应的特征空间为：\n$$E_{\\lambda_1} = \\text{span}\\left((-2, 2, 1)^T\\right), \\quad E_{\\lambda_2} = \\text{span}\\left((2, 1, -2)^T\\right), \\quad E_{\\lambda_3} = \\text{span}\\left((1, 2, 2)^T\\right)$$经正交化后：\n$$v_1 = \\frac{1}{3}(-2, 2, 1)^T, \\quad v_2 = \\frac{1}{3}(2, 1, -2)^T, \\quad v_3 = \\frac{1}{3}(1, 2, 2)^T$$令 $V = (v_1 | v_2 | v_3)$\n奇异值为：\n$$\\sigma_1 = \\sqrt{\\lambda_1} = 18, \\quad \\sigma_2 = \\sqrt{\\lambda_2} = 6, \\quad \\sigma_3 = \\sqrt{\\lambda_3} = 0$$令 $\\Sigma = \\text{diag}_{4 \\times 3}(\\sigma_1, \\sigma_2, \\sigma_3)$。\n计算 $U = (u_1 | u_2 | u_3 | u_4) \\in \\mathbb{R}^{4 \\times 4}$ 使得 $Av_i = \\sigma_i u_i$：\n$$u_1 = \\frac{Av_1}{\\sigma_1} = \\frac{1}{2}(1, 1, 1, 1)^T, \\quad u_2 = \\frac{Av_2}{\\sigma_2} = \\frac{1}{2}(-1, 1, -1, 1)^T$$$$u_3 = \\frac{1}{2}(1, 1, -1, -1)^T, \\quad u_4 = \\frac{1}{2}(-1, 1, 1, -1)^T$$因此 $A$ 的 $SVD$ 分解为：\n$$A = \\begin{pmatrix} \\frac{1}{2} \u0026 -\\frac{1}{2} \u0026 \\frac{1}{2} \u0026 -\\frac{1}{2} \\\\ \\frac{1}{2} \u0026 \\frac{1}{2} \u0026 \\frac{1}{2} \u0026 \\frac{1}{2} \\\\ \\frac{1}{2} \u0026 -\\frac{1}{2} \u0026 -\\frac{1}{2} \u0026 \\frac{1}{2} \\\\ \\frac{1}{2} \u0026 \\frac{1}{2} \u0026 -\\frac{1}{2} \u0026 -\\frac{1}{2} \\end{pmatrix} \\begin{pmatrix} 18 \u0026 0 \u0026 0 \\\\ 0 \u0026 6 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \\end{pmatrix} \\begin{pmatrix} -\\frac{2}{3} \u0026 \\frac{2}{3} \u0026 \\frac{1}{3} \\\\ \\frac{2}{3} \u0026 \\frac{1}{3} \u0026 -\\frac{2}{3} \\\\ \\frac{1}{3} \u0026 \\frac{2}{3} \u0026 \\frac{2}{3} \\end{pmatrix}^T = U\\Sigma V^T$$(2) 矩阵的性质 解：\n$A$ 有两个非零奇异值，故 $\\text{rank}(A) = 2$\n$$\\mathcal{R}(A) = \\text{span}(u_1, u_2) = \\text{span}\\left(\\frac{1}{2}(1, 1, 1, 1)^T, \\frac{1}{2}(-1, 1, -1, 1)^T\\right)$$$$\\mathcal{N}(A) = \\text{span}(v_3) = \\text{span}\\left(\\frac{1}{3}(1, 2, 2)^T\\right)$$$$\\|A\\|_2 = \\sigma_1 = 18, \\quad \\|A\\|_F = \\sqrt{\\sigma_1^2 + \\sigma_2^2} = \\sqrt{324 + 36} = 6\\sqrt{10}$$(3) 最佳秩-k 逼近 解：\n根据 (1) 中 $A$ 的 $SVD$ 分解，令 $A^T = \\tilde{U}\\tilde{\\Sigma}\\tilde{V}^T$，其中 $\\tilde{U} = V$，$\\tilde{V} = U$，$\\tilde{\\Sigma} = \\Sigma^T$。\n$k = 0$：\n定义 $A_0 = 0_{3 \\times 4}$，则\n$$\\gamma_0 = \\|A^T\\|_2 = \\sigma_1 = 18$$$k = 1$：\n利用 Eckart-Young-Mirsky 定理：\n$$A_1 = \\sigma_1 v_1 u_1^T = 18 \\begin{pmatrix} -\\frac{2}{3} \\\\ \\frac{2}{3} \\\\ \\frac{1}{3} \\end{pmatrix} \\begin{pmatrix} \\frac{1}{2} \u0026 \\frac{1}{2} \u0026 \\frac{1}{2} \u0026 \\frac{1}{2} \\end{pmatrix} = \\begin{pmatrix} -6 \u0026 -6 \u0026 -6 \u0026 -6 \\\\ 6 \u0026 6 \u0026 6 \u0026 6 \\\\ 3 \u0026 3 \u0026 3 \u0026 3 \\end{pmatrix}$$$$\\gamma_1 = \\|A^T - A_1\\|_2 = \\sigma_2 = 6$$$k \\geq 2$：\n因为 $\\text{rank}(A^T) = 2$，令 $A_k = A^T$，对每个 $k \\in \\mathbb{N}_{\\geq 2}$ 都有 $\\gamma_k = 0$。\n习题 6：SVD 分解的性质 题目：\n(1) 假设 $A$ 可逆，根据 $A$ 的 $SVD$ 结果给出 $A^{-1}$ 的 $SVD$ 分解（提示：$Av_i = \\sigma_i u_i \\,\\forall i \\in \\{1,\\ldots,n\\}$）\n(2) 假设 $Q$ 是正交阵，给出 $Q$ 的 $SVD$ 分解及其奇异值\n(3) 假设 $A = QBQ^T$，其中 $Q$ 是正交阵，说明 $A$ 和 $B$ 有相同奇异值\n(1) 逆矩阵的 SVD 分解 解：\n设 $A$ 的 $SVD$ 分解为\n$$A = U\\Sigma V^T = (u_1 | \\cdots | u_n) [\\text{diag}_{n \\times n}(\\sigma_1, \\ldots, \\sigma_n)] (v_1 | \\cdots | v_n)^T$$其中 $U, V \\in \\mathbb{R}^{n \\times n}$ 正交，$\\sigma_1 \\geq \\sigma_2 \\geq \\cdots \\geq \\sigma_n \u003e 0$（由于 $A$ 可逆）。\n因为 $A = U\\Sigma V^T$，有 $Av_i = \\sigma_i u_i \\,\\forall i \\in \\{1, \\ldots, n\\}$。\n因此\n$$A^{-1}u_i = A^{-1}\\left(\\frac{1}{\\sigma_i}Av_i\\right) = \\frac{1}{\\sigma_i}v_i$$注意到 $\\frac{1}{\\sigma_n} \\geq \\cdots \\geq \\frac{1}{\\sigma_2} \\geq \\frac{1}{\\sigma_1} \u003e 0$，故\n$$A^{-1} = (v_n | \\cdots | v_2 | v_1) \\left[\\text{diag}_{n \\times n}\\left(\\frac{1}{\\sigma_n}, \\ldots, \\frac{1}{\\sigma_2}, \\frac{1}{\\sigma_1}\\right)\\right] (u_n | \\cdots | u_2 | u_1)^T$$记 $P = (e_n | \\cdots | e_2 | e_1) \\in \\mathbb{R}^{n \\times n}$（$P$ 是正交阵），则：\n$$A^{-1} = (VP)(P\\Sigma^{-1}P)(UP)^T$$(2) 正交矩阵的 SVD 分解 解：\n对于正交矩阵 $Q \\in \\mathbb{R}^{n \\times n}$，有 $Q = QI_nI_n^T$，这即为 $Q$ 的 $SVD$ 分解。\n所有奇异值均为 1。\n(3) 相似变换保持奇异值 解：\n设 $B$ 的 $SVD$ 分解为 $B = U\\Sigma V^T$，则\n$$A = QBQ^T = QU\\Sigma V^TQ^T = QU\\Sigma(QV)^T = (QU)\\Sigma(QV)^T$$由于 $Q$ 正交，$QU$ 和 $QV$ 也是正交矩阵。\n因此 $A$ 与 $B$ 有相同的奇异值。\n习题 7：通过对角化获得 SVD 题目：假设 $D$ 是一个 $n \\times d$ 的矩阵，矩阵 $B$ 是 $(n+d) \\times (n+d)$ 定义为\n$$B = \\begin{pmatrix} 0 \u0026 D^T \\\\ D \u0026 0 \\end{pmatrix}$$显然 $B$ 是对称矩阵。请证明矩阵 $B$ 的对角化会产生 $D$ 的奇异值分解所需要的所有信息。\n证明：\n$D$ 的奇异值分解所需的所有信息为 $D^TD$ 的特征值和特征向量，以及 $DD^T$ 的特征值和特征向量。\n设 $\\lambda^2$（$\\lambda \u003e 0$）是 $D^TD$ 的特征值，对应的单位特征向量为 $x_1$（$\\|x_1\\|_2 = 1$）；$\\lambda^2$ 也是 $DD^T$ 的特征值，对应的单位特征向量为 $x_2$（$\\|x_2\\|_2 = 1$）。\n因此，$D^TDx_1 = \\lambda^2x_1$ 以及 $DD^Tx_2 = \\lambda^2x_2$。\n由第一个式子：\n$$(DD^T)Dx_1 = D(D^TDx_1) = D(\\lambda^2x_1) = \\lambda^2 Dx_1$$所以存在常数 $k$ 使得 $Dx_1 = kx_2$。由于 $\\|x_1\\|_2 = \\|x_2\\|_2 = 1$，可得 $k = \\lambda$，即 $Dx_1 = \\lambda x_2$。\n同样地，由 $DD^Tx_2 = \\lambda^2x_2$ 可得 $D^Tx_2 = \\lambda x_1$。\n下面证明 $x = \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix}$ 是矩阵 $B$ 的特征值为 $\\lambda$ 的特征向量：\n$$Bx = \\begin{pmatrix} 0 \u0026 D^T \\\\ D \u0026 0 \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix} = \\begin{pmatrix} D^Tx_2 \\\\ Dx_1 \\end{pmatrix} = \\begin{pmatrix} \\lambda x_1 \\\\ \\lambda x_2 \\end{pmatrix} = \\lambda \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix}$$因此，$D$ 的奇异值分解所需信息完全包含在 $B$ 的对角化过程中。 $\\square$\n习题 8：最小二乘解的正规方程 题目：利用等式\n$$\\|A(\\boldsymbol{x} + \\alpha\\boldsymbol{w}) - \\boldsymbol{b}\\|_2^2 = \\|A\\boldsymbol{x} - \\boldsymbol{b}\\|_2^2 + 2\\alpha\\boldsymbol{w}^TA^T(A\\boldsymbol{x} - \\boldsymbol{b}) + \\alpha^2\\|A\\boldsymbol{w}\\|_2^2$$证明：如果 $\\boldsymbol{x} \\in X_{LS}$，那么 $A^TA\\boldsymbol{x} = A^T\\boldsymbol{b}$\n证明：\n设 $\\boldsymbol{x} \\in X_{LS}$ 是最小二乘解，即 $\\boldsymbol{x}$ 使得 $\\|A\\boldsymbol{x} - \\boldsymbol{b}\\|_2^2$ 最小。\n对于任意 $\\boldsymbol{w}$ 和 $\\alpha$，有：\n$$\\|A(\\boldsymbol{x} + \\alpha\\boldsymbol{w}) - \\boldsymbol{b}\\|_2^2 \\geq \\|A\\boldsymbol{x} - \\boldsymbol{b}\\|_2^2$$根据给定的等式：\n$$\\|A\\boldsymbol{x} - \\boldsymbol{b}\\|_2^2 + 2\\alpha\\boldsymbol{w}^TA^T(A\\boldsymbol{x} - \\boldsymbol{b}) + \\alpha^2\\|A\\boldsymbol{w}\\|_2^2 \\geq \\|A\\boldsymbol{x} - \\boldsymbol{b}\\|_2^2$$简化得：\n$$2\\alpha\\boldsymbol{w}^TA^T(A\\boldsymbol{x} - \\boldsymbol{b}) + \\alpha^2\\|A\\boldsymbol{w}\\|_2^2 \\geq 0$$这对所有 $\\alpha$ 成立。当 $\\alpha \\to 0$ 时，主导项是 $2\\alpha\\boldsymbol{w}^TA^T(A\\boldsymbol{x} - \\boldsymbol{b})$。\n为使不等式对正负 $\\alpha$ 都成立，必须有：\n$$\\boldsymbol{w}^TA^T(A\\boldsymbol{x} - \\boldsymbol{b}) = 0$$由于 $\\boldsymbol{w}$ 是任意的，因此：\n$$A^T(A\\boldsymbol{x} - \\boldsymbol{b}) = 0 \\Rightarrow A^TA\\boldsymbol{x} = A^T\\boldsymbol{b}$$ $\\square$\n作业四 习题 1：QR 分解求解最小二乘问题 题目：设\n$$A = \\begin{pmatrix} 1 \u0026 3 \u0026 1 \u0026 1 \\\\ 2 \u0026 0 \u0026 0 \u0026 0 \\\\ 1 \u0026 0 \u0026 0 \u0026 0 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$$利用 QR 分解求对应的 LS 问题的全部解。\n解：\n观察矩阵 $A$，第3、4列相同，且通过简单计算可知 $\\text{rank}(A) = 2 \u003c 4$，该 LS 问题有无穷多解。\n第一步：对 $A$ 进行QR分解\n由于 $\\text{rank}(A) = 2$，只需计算 $q_1, q_2$。设 $a_1 = \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}$，$a_2 = \\begin{pmatrix} 3 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n使用 Gram-Schmidt 正交化：\n计算 $q_1$：\n$$r_{11} = \\|a_1\\| = \\sqrt{6}, \\quad q_1 = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}$$计算 $q_2$：\n$$r_{12} = a_2^T q_1 = \\frac{\\sqrt{6}}{2}$$$$\\tilde{q}_2 = a_2 - r_{12}q_1 = \\begin{pmatrix} 3 \\\\ 0 \\\\ 0 \\end{pmatrix} - \\frac{1}{2} \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 5/2 \\\\ -1 \\\\ -1/2 \\end{pmatrix}$$$$r_{22} = \\|\\tilde{q}_2\\| = \\frac{\\sqrt{30}}{2}, \\quad q_2 = \\frac{1}{\\sqrt{30}} \\begin{pmatrix} 5 \\\\ -2 \\\\ -1 \\end{pmatrix}$$计算 $R$ 矩阵的其余元素（通过投影得到）：\n$$r_{13} = a_3^T q_1 = \\frac{1}{\\sqrt{6}}, \\quad r_{23} = a_3^T q_2 = \\frac{5}{\\sqrt{30}}$$$$r_{14} = a_4^T q_1 = \\frac{1}{\\sqrt{6}}, \\quad r_{24} = a_4^T q_2 = \\frac{5}{\\sqrt{30}}$$因此：\n$$Q_1 = \\begin{pmatrix} \\frac{1}{\\sqrt{6}} \u0026 \\frac{5}{\\sqrt{30}} \\\\ \\frac{2}{\\sqrt{6}} \u0026 -\\frac{2}{\\sqrt{30}} \\\\ \\frac{1}{\\sqrt{6}} \u0026 -\\frac{1}{\\sqrt{30}} \\end{pmatrix}, \\quad R_1 = \\begin{bmatrix} \\sqrt{6} \u0026 \\frac{\\sqrt{6}}{2} \u0026 \\frac{1}{\\sqrt{6}} \u0026 \\frac{1}{\\sqrt{6}} \\\\ 0 \u0026 \\frac{\\sqrt{30}}{2} \u0026 \\frac{5}{\\sqrt{30}} \u0026 \\frac{5}{\\sqrt{30}} \\end{bmatrix}$$第二步：计算 $Q_1^T b$\n$$Q_1^T b = \\begin{bmatrix} \\frac{1}{\\sqrt{6}} \u0026 \\frac{2}{\\sqrt{6}} \u0026 \\frac{1}{\\sqrt{6}} \\\\ \\frac{5}{\\sqrt{30}} \u0026 -\\frac{2}{\\sqrt{30}} \u0026 -\\frac{1}{\\sqrt{30}} \\end{bmatrix} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\begin{bmatrix} \\frac{2\\sqrt{6}}{3} \\\\ \\frac{\\sqrt{30}}{15} \\end{bmatrix}$$第三步：求解 $R_1 x = Q_1^T b$\n由于 $\\text{rank}(A) = 2$，将 $x$ 分为 $(x_1, x_2)^T$（基本变量）和 $(x_3, x_4)^T$（自由变量）。\n方程组为：\n$$\\begin{cases} \\sqrt{6}x_1 + \\frac{\\sqrt{6}}{2}x_2 + \\frac{\\sqrt{6}}{6}x_3 + \\frac{\\sqrt{6}}{6}x_4 = \\frac{2\\sqrt{6}}{3} \\\\ \\frac{\\sqrt{30}}{2}x_2 + \\frac{\\sqrt{30}}{6}x_3 + \\frac{\\sqrt{30}}{6}x_4 = \\frac{\\sqrt{30}}{15} \\end{cases}$$简化得：\n$$\\begin{cases} x_1 + \\frac{1}{2}x_2 + \\frac{1}{6}x_3 + \\frac{1}{6}x_4 = \\frac{2}{3} \\\\ 3x_2 + x_3 + x_4 = \\frac{2}{5} \\end{cases}$$从第二个方程：$x_2 = \\frac{2}{15} - \\frac{1}{3}x_3 - \\frac{1}{3}x_4$\n代入第一个方程：\n$$x_1 + \\frac{1}{2}\\left(\\frac{2}{15} - \\frac{1}{3}x_3 - \\frac{1}{3}x_4\\right) + \\frac{1}{6}x_3 + \\frac{1}{6}x_4 = \\frac{2}{3}$$$$x_1 + \\frac{1}{15} - \\frac{1}{6}x_3 - \\frac{1}{6}x_4 + \\frac{1}{6}x_3 + \\frac{1}{6}x_4 = \\frac{2}{3}$$$$x_1 = \\frac{2}{3} - \\frac{1}{15} = \\frac{3}{5}$$全部解：\n$$x = \\begin{pmatrix} 3/5 \\\\ 2/15 \\\\ 0 \\\\ 0 \\end{pmatrix} + x_3 \\begin{pmatrix} 0 \\\\ -1/3 \\\\ 1 \\\\ 0 \\end{pmatrix} + x_4 \\begin{pmatrix} 0 \\\\ -1/3 \\\\ 0 \\\\ 1 \\end{pmatrix}, \\quad x_3, x_4 \\in \\mathbb{R}$$ 习题 2：最小二乘解的性质 题目：设 $A \\in \\mathbb{R}^{m\\times n}$ 且存在 $X \\in \\mathbb{R}^{n\\times m}$ 使得对每一个 $b \\in \\mathbb{R}^m$，$x = Xb$ 均极小化 $\\|Ax - b\\|_2$。\n证明：$AXA = A$ 和 $(AX)^T = AX$。\n证明：\n由最小二乘理论，$x = Xb$ 满足正规方程 $A^T(Ax - b) = 0$，代入得：\n$$A^TAXb = A^Tb, \\quad \\forall b \\in \\mathbb{R}^m$$因此：\n$$A^TAX = A^T \\tag{1}$$对任意 $y \\in \\mathbb{R}^n$，令 $b = Ay$，则 $x = XAy$ 是 $\\min_x \\|Ax - Ay\\|_2$ 的解。由于 $x = y$ 使目标函数为零，故：\n$$\\|AXAy - Ay\\|_2 = 0, \\quad \\forall y \\in \\mathbb{R}^n$$因此：\n$$AXA = A \\tag{2}$$由 (1) 和 (2)，有：\n$$(AX)^2 = AXAX = A(XA)X = AAX = AX$$即 $AX$ 是幂等矩阵。\n由 (1)，两边取转置得 $X^TA^TA = A$，因此：\n$$(AX)^TAX = X^TA^TAX = X^TA^T = (AX)^T$$结合 $(AX)^2 = AX$：\n$$(AX)^T = (AX)^TAX = (AX)AX = AX$$因此 $(AX)^T = AX$。 $\\square$\n习题 3：Gerschgorin 圆盘定理估计特征值范围 题目：估计矩阵\n$$A = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \\\\ 1 \u0026 2 \u0026 1 \\\\ 0 \u0026 1 \u0026 -4 \\end{pmatrix}$$的特征值范围。\n解：\n使用 Gerschgorin 圆盘定理。该定理指出：矩阵 $A$ 的所有特征值都位于 Gerschgorin 圆盘\n$$D_i = \\{z \\in \\mathbb{C} : |z - a_{ii}| \\leq R_i\\}, \\quad R_i = \\sum_{j\\neq i} |a_{ij}|$$的并集中。\n计算各圆盘：\n圆盘 $D_1$： 中心 $a_{11} = 0$，半径 $R_1 = |1| + |0| = 1$\n$$D_1: |z| \\leq 1 \\quad \\Rightarrow \\quad [-1, 1]$$圆盘 $D_2$： 中心 $a_{22} = 2$，半径 $R_2 = |1| + |1| = 2$\n$$D_2: |z - 2| \\leq 2 \\quad \\Rightarrow \\quad [0, 4]$$圆盘 $D_3$： 中心 $a_{33} = -4$，半径 $R_3 = |0| + |1| = 1$\n$$D_3: |z + 4| \\leq 1 \\quad \\Rightarrow \\quad [-5, -3]$$由于 $A$ 是实对称矩阵，特征值必为实数。因此特征值范围为：\n$$\\lambda \\in D_1 \\cup D_2 \\cup D_3 = [-1, 1] \\cup [0, 4] \\cup [-5, -3] = [-5, -3] \\cup [-1, 4]$$ 习题 4：幂法求模最大特征值 题目：利用幂法求解矩阵\n$$A = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \\\\ 1 \u0026 2 \u0026 1 \\\\ 0 \u0026 1 \u0026 -4 \\end{pmatrix}$$模最大的特征值与对应的特征向量。（可编程计算结果，特征值答案保留两位有效数字，特征向量答案保留三位有效数字）\n解：\n幂法迭代：\n取初始向量 $v^{(0)} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$，按迭代公式 $v^{(k+1)} = \\frac{Av^{(k)}}{\\|Av^{(k)}\\|_2}$ 进行计算，特征值估计为 $\\lambda^{(k)} = (v^{(k)})^T Av^{(k)}$。\n主要迭代过程：\n迭代 1：\n$$Av^{(0)} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\quad \\|Av^{(0)}\\|_2 = 1, \\quad v^{(1)} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\quad \\lambda^{(1)} = 0$$迭代 2：\n$$Av^{(1)} = \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}, \\quad \\|Av^{(1)}\\|_2 = \\sqrt{6} \\approx 2.449, \\quad v^{(2)} = \\begin{pmatrix} 0.408 \\\\ 0.816 \\\\ 0.408 \\end{pmatrix}, \\quad \\lambda^{(2)} = 2.000$$迭代 5：\n$$v^{(5)} = \\begin{pmatrix} 0.189 \\\\ 0.694 \\\\ -0.694 \\end{pmatrix}, \\quad \\lambda^{(5)} = -0.043$$迭代 11：\n$$v^{(11)} = \\begin{pmatrix} -0.025 \\\\ 0.203 \\\\ -0.979 \\end{pmatrix}, \\quad \\lambda^{(11)} = -4.140$$迭代约 30 次后收敛。\n最终结果：\n模最大特征值：$\\lambda = -4.2$ （两位有效数字）\n对应特征向量：$v = \\begin{pmatrix} 0.040 \\\\ -0.166 \\\\ 0.985 \\end{pmatrix}$ （三位有效数字）\n验证： 使用 NumPy 计算得矩阵所有特征值为 $\\lambda_1 \\approx 2.546$，$\\lambda_2 \\approx -0.377$，$\\lambda_3 \\approx -4.169$，确认 $|\\lambda_3|$ 最大，幂法结果正确。\n习题 5：反幂法求模最小特征值 题目：利用反幂法求解矩阵\n$$A = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \\\\ 1 \u0026 2 \u0026 1 \\\\ 0 \u0026 1 \u0026 -4 \\end{pmatrix}$$模最小的特征值与对应的特征向量。（可编程计算结果，特征值答案保留两位有效数字，特征向量答案保留三位有效数字）\n解：\n反幂法迭代：\n反幂法通过求解线性方程组 $Av^{(k)} = v^{(k-1)}$ 并归一化来迭代，收敛到模最小特征值对应的特征向量。\n取初始向量 $v^{(0)} = \\frac{1}{\\sqrt{3}}\\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 0.577 \\\\ 0.577 \\\\ 0.577 \\end{pmatrix}$。\n主要迭代过程：\n迭代 1：\n求解 $Ax = v^{(0)}$ 得 $x = \\begin{pmatrix} -0.577 \\\\ 0.577 \\\\ 0 \\end{pmatrix}$，归一化后\n$$v^{(1)} = \\begin{pmatrix} -0.707 \\\\ 0.707 \\\\ 0 \\end{pmatrix}, \\quad \\lambda^{(1)} = 0$$迭代 2：\n$$v^{(2)} = \\begin{pmatrix} 0.953 \\\\ -0.293 \\\\ -0.073 \\end{pmatrix}, \\quad \\lambda^{(2)} = -0.366$$迭代 3：\n$$v^{(3)} = \\begin{pmatrix} -0.928 \\\\ 0.360 \\\\ 0.097 \\end{pmatrix}, \\quad \\lambda^{(3)} = -0.377$$迭代 5：\n$$v^{(5)} = \\begin{pmatrix} -0.931 \\\\ 0.351 \\\\ 0.097 \\end{pmatrix}, \\quad \\lambda^{(5)} = -0.377$$迭代约 11 次后收敛。\n最终结果：\n模最小特征值：$\\lambda = -0.38$ （两位有效数字）\n对应特征向量：$v = \\begin{pmatrix} 0.931 \\\\ -0.351 \\\\ -0.097 \\end{pmatrix}$ （三位有效数字）\n验证： 使用 NumPy 计算得矩阵所有特征值为 $\\lambda_1 \\approx 2.546$，$\\lambda_2 \\approx -0.377$，$\\lambda_3 \\approx -4.169$，确认 $|\\lambda_2|$ 最小，反幂法结果正确。残差 $\\|Av - \\lambda v\\| \\approx 1.25 \\times 10^{-16}$。\n习题 6：原点位移法求全部特征值 题目：利用原点位移法求解矩阵\n$$A = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \\\\ 1 \u0026 2 \u0026 1 \\\\ 0 \u0026 1 \u0026 -4 \\end{pmatrix}$$全部特征值与对应的特征向量。（可编程计算结果，特征值答案保留两位有效数字，特征向量答案保留三位有效数字）\n解：\n求解策略：\n原点位移法通过选择不同的位移参数 $\\mu$，利用 $A - \\mu I$ 的特征值为 $\\lambda - \\mu$ 的性质，结合幂法和反幂法求得全部特征值。\n第一步：幂法求模最大特征值\n对 $A$ 使用标准幂法，收敛得：\n$$\\lambda_3 = -4.169, \\quad v_3 = \\begin{pmatrix} 0.040 \\\\ -0.166 \\\\ 0.985 \\end{pmatrix}$$第二步：反幂法求模最小特征值\n对 $A$ 使用反幂法，收敛得：\n$$\\lambda_2 = -0.377, \\quad v_2 = \\begin{pmatrix} 0.931 \\\\ -0.351 \\\\ -0.097 \\end{pmatrix}$$第三步：带位移反幂法求中间特征值\n选择位移 $\\mu = 2.5$（接近估计的中间特征值），对 $A - 2.5I$ 使用反幂法。取初始向量 $v^{(0)} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}$，迭代 6 次后收敛得：\n$$\\lambda_1 = 2.546, \\quad v_1 = \\begin{pmatrix} 0.362 \\\\ 0.921 \\\\ 0.141 \\end{pmatrix}$$最终结果汇总（按从大到小排序）：\n特征值（两位有效数字） 特征向量（三位有效数字） 残差 $\\lambda_1 = 2.5$ $\\begin{pmatrix} 0.362 \\\\ 0.921 \\\\ 0.141 \\end{pmatrix}$ $2.10 \\times 10^{-11}$ $\\lambda_2 = -0.38$ $\\begin{pmatrix} 0.931 \\\\ -0.351 \\\\ -0.097 \\end{pmatrix}$ $1.25 \\times 10^{-16}$ $\\lambda_3 = -4.2$ $\\begin{pmatrix} 0.040 \\\\ -0.166 \\\\ 0.985 \\end{pmatrix}$ $\u003c 10^{-16}$ 所有残差 $\\|Av_i - \\lambda_i v_i\\|$ 均在数值误差范围内，验证结果正确。\n习题 7：Gerschgorin 圆盘定理与条件数 题目：设\n$$A = \\begin{pmatrix} 5 \u0026 -1 \u0026 1 \\\\ -1 \u0026 2 \u0026 0 \\\\ 1 \u0026 0 \u0026 3 \\end{pmatrix}$$记 $\\Lambda(A) = \\{\\lambda_1, \\lambda_2, \\lambda_3\\} \\subseteq \\mathbb{C}$ 且 $|\\lambda_1| \\geq |\\lambda_2| \\geq |\\lambda_3|$。\n(1) 使用 Gerschgorin 圆盘定理，证明 $\\frac{|\\lambda_1|}{|\\lambda_3|} \\leq 7$。\n(2) （编程题）使用幂法与反幂法计算 $\\frac{|\\lambda_1|}{|\\lambda_3|}$\n(1) Gerschgorin 圆盘定理证明 证明：\nGerschgorin 圆盘定理：矩阵 $A$ 的所有特征值都位于 Gerschgorin 圆盘的并集中，第 $i$ 个圆盘定义为：\n$$D_i = \\{z \\in \\mathbb{C} : |z - a_{ii}| \\leq R_i\\}, \\quad R_i = \\sum_{j\\neq i} |a_{ij}|$$对于矩阵 $A = \\begin{pmatrix} 5 \u0026 -1 \u0026 1 \\\\ -1 \u0026 2 \u0026 0 \\\\ 1 \u0026 0 \u0026 3 \\end{pmatrix}$：\n$$D_1: a_{11} = 5, \\; R_1 = |-1| + |1| = 2 \\quad \\Rightarrow \\quad z \\in [3, 7]$$$$D_2: a_{22} = 2, \\; R_2 = |-1| + |0| = 1 \\quad \\Rightarrow \\quad z \\in [1, 3]$$$$D_3: a_{33} = 3, \\; R_3 = |1| + |0| = 1 \\quad \\Rightarrow \\quad z \\in [2, 4]$$所有特征值 $\\lambda \\in D_1 \\cup D_2 \\cup D_3 = [1, 7]$。因为 $A$ 是实对称矩阵，所有特征值都是实数且为正。\n从圆盘分析得：$|\\lambda_1| \\leq 7$，$|\\lambda_3| \\geq 1$，因此：\n$$\\kappa(A) = \\frac{|\\lambda_1|}{|\\lambda_3|} \\leq \\frac{7}{1} = 7 \\quad \\square$$(2) 幂法与反幂法计算条件数 解：\n通过编程实现幂法和反幂法，迭代计算如下：\n幂法求 $\\lambda_{\\max}$ 的前 5 步迭代：\n迭代次数 特征值估计 1 4.880952 2 5.475970 3 5.612480 4 5.642355 5 5.649083 收敛于第 32 步，得 $\\lambda_{\\max} = 5.6510934089$\n反幂法求 $\\lambda_{\\min}$ 的前 5 步迭代：\n迭代次数 特征值估计 1 2.126100 2 1.769336 3 1.671936 4 1.640106 5 1.628943 收敛于第 44 步，得 $\\lambda_{\\min} = 1.6227971460$\n条件数计算：\n$$\\kappa(A) = \\frac{|\\lambda_{\\max}|}{|\\lambda_{\\min}|} = \\frac{5.6510934089}{1.6227971460} = 3.4823165808$$保留两位有效数字：$\\kappa(A) \\approx 3.48$\n验证：\n$$\\kappa(A) = 3.48 \u003c 7 \\quad \\checkmark$$这验证了 Gerschgorin 圆盘定理给出的上界估计是正确的。实际条件数远小于理论上界 7，说明理论估计较为保守但有效。\n作业五 习题 1：梯度计算 题目：构建模型使得预测值与真实值的误差最小常用向量 2-范数度量，求解模型过程中需要计算梯度，求梯度：\n(1) $f(A) = \\frac{1}{2}\\|Ax + b - y\\|_2^2$，求 $\\frac{\\partial f}{\\partial A}$\n(2) $f(x) = \\frac{1}{2}\\|Ax + b - y\\|_2^2$，求 $\\frac{\\partial f}{\\partial x}$\n其中 $A \\in \\mathbb{R}^{m\\times n}$，$x \\in \\mathbb{R}^n$，$b, y \\in \\mathbb{R}^m$\n解：\n(1) 关于 $A$ 的梯度\n展开目标函数：\n$$f(A) = \\frac{1}{2}\\|Ax + b - y\\|_2^2 = \\frac{1}{2}(Ax + b - y)^T(Ax + b - y)$$$$= \\frac{1}{2}(x^TA^TAx + 2(b-y)^TAx + (b-y)^T(b-y))$$由于 $(b-y)^T(b-y)$ 是常数，对 $A$ 求导后为零：\n$$\\frac{\\partial f}{\\partial A} = \\frac{\\partial}{\\partial A}\\frac{1}{2}(x^TA^TAx + 2(b-y)^TAx)$$利用矩阵求导公式：\n$\\frac{\\partial x^TA^TAx}{\\partial A} = 2Axx^T$ $\\frac{\\partial (b-y)^TAx}{\\partial A} = (b-y)x^T$ 因此：\n$$\\boxed{\\frac{\\partial f}{\\partial A} = Axx^T + (b-y)x^T}$$(2) 关于 $x$ 的梯度\n同样展开目标函数，对 $x$ 求导：\n$$\\frac{\\partial f}{\\partial x} = \\frac{\\partial}{\\partial x}\\frac{1}{2}(x^TA^TAx + 2(b-y)^TAx + (b-y)^T(b-y))$$利用矩阵求导公式：\n$\\frac{\\partial x^TA^TAx}{\\partial x} = 2A^TAx$ $\\frac{\\partial (b-y)^TAx}{\\partial x} = A^T(b-y)$ 因此：\n$$\\boxed{\\frac{\\partial f}{\\partial x} = A^TAx + A^T(b-y)}$$ 习题 2：二次型的梯度 题目：二次型是数据分析中常用函数，求 $\\frac{\\partial x^TAx}{\\partial x}$，$\\frac{\\partial x^TAx}{\\partial A}$，其中 $A \\in \\mathbb{R}^{m\\times m}$，$x \\in \\mathbb{R}^m$\n解：\n(1) 关于 $x$ 的梯度\n对于二次型 $x^TAx$，利用矩阵微分的性质：\n$$d(x^TAx) = (dx)^TAx + x^TAdx = x^TA^Tdx + x^TAdx = x^T(A + A^T)dx$$因此：\n$$\\boxed{\\frac{\\partial x^TAx}{\\partial x} = (A + A^T)x}$$注：当 $A$ 为对称矩阵时，$\\frac{\\partial x^TAx}{\\partial x} = 2Ax$\n(2) 关于 $A$ 的梯度\n对于二次型 $x^TAx = \\sum_{i,j} x_i A_{ij} x_j$，对 $A_{ij}$ 求偏导：\n$$\\frac{\\partial x^TAx}{\\partial A_{ij}} = x_ix_j$$因此，梯度矩阵的第 $(i,j)$ 元素为 $x_ix_j$，即：\n$$\\boxed{\\frac{\\partial x^TAx}{\\partial A} = xx^T}$$ 习题 3：迹微分法求梯度 题目：利用迹微分法求解 $\\frac{\\partial \\text{tr}(W^{-1})}{\\partial W}$，其中 $W \\in \\mathbb{R}^{m\\times m}$\n解：\n首先计算 $W^{-1}$ 的微分。由恒等式 $WW^{-1} = I$，两边取微分：\n$$d(WW^{-1}) = dW \\cdot W^{-1} + W \\cdot dW^{-1} = dI = 0$$因此：\n$$W \\cdot dW^{-1} = -dW \\cdot W^{-1}$$两边左乘 $W^{-1}$：\n$$dW^{-1} = -W^{-1}dW \\cdot W^{-1}$$现在计算迹的微分：\n$$d\\,\\text{tr}(W^{-1}) = \\text{tr}(dW^{-1}) = \\text{tr}(-W^{-1}dW \\cdot W^{-1})$$利用迹的循环性质 $\\text{tr}(ABC) = \\text{tr}(CAB)$：\n$$d\\,\\text{tr}(W^{-1}) = \\text{tr}(-(W^{-1})^2dW) = \\text{tr}(-(W^{-T})^2 dW)$$因此：\n$$\\boxed{\\frac{\\partial \\text{tr}(W^{-1})}{\\partial W} = -(W^{-T})^2 = -(W^{-1})^T(W^{-1})^T}$$ 习题 4：Softmax 函数的梯度 题目：$(\\exp(z))_i = \\exp(z_i)$，$(\\log(z))_i = \\log(z_i)$，$f(z) = \\frac{\\exp(z)}{\\mathbf{1}^T\\exp(z)}$ 称为 softmax 函数，如果 $q = f(z)$，$J = -p^T\\log(q)$，其中 $p, q, z \\in \\mathbb{R}^n$，并且 $\\mathbf{1}^Tp = 1$，\n(1) 证明：$\\frac{\\partial J}{\\partial z} = q - p$\n(2) 若 $z = Wx$，其中 $W \\in \\mathbb{R}^{n\\times m}$，$x \\in \\mathbb{R}^m$，$\\frac{\\partial J}{\\partial W} = (q - p)x^T$ 是否成立。\n解：\n(1) 证明关于 $z$ 的梯度\n将损失函数展开：\n$$J = -p^T\\log(q) = -p^T\\log\\left(\\frac{\\exp(z)}{\\mathbf{1}^T\\exp(z)}\\right)$$$$= -p^T\\log(\\exp(z)) + p^T\\log(\\mathbf{1}^T\\exp(z))\\mathbf{1}$$$$= -p^Tz + p^T\\mathbf{1}\\log(\\mathbf{1}^T\\exp(z))$$由于 $p^T\\mathbf{1} = 1$（概率分布的归一化条件）：\n$$J = -p^Tz + \\log(\\mathbf{1}^T\\exp(z))$$对 $z$ 求导：\n$$\\frac{\\partial J}{\\partial z} = -p + \\frac{\\partial \\log(\\mathbf{1}^T\\exp(z))}{\\partial z}$$$$= -p + \\frac{1}{\\mathbf{1}^T\\exp(z)} \\cdot \\frac{\\partial (\\mathbf{1}^T\\exp(z))}{\\partial z}$$$$= -p + \\frac{\\exp(z)}{\\mathbf{1}^T\\exp(z)}$$$$= -p + q$$因此：\n$$\\boxed{\\frac{\\partial J}{\\partial z} = q - p}$$(2) 证明关于 $W$ 的梯度\n利用链式法则和迹微分法：\n$$dJ = d\\,\\text{tr}(J) = \\text{tr}(dJ)$$由 $z = Wx$，有 $dz = dW \\cdot x$，因此：\n$$dJ = \\text{tr}\\left[\\left(\\frac{\\partial J}{\\partial z}\\right)^T dz\\right] = \\text{tr}[(q-p)^T dW \\cdot x]$$利用迹的性质 $\\text{tr}(ABC) = \\text{tr}(CAB)$：\n$$dJ = \\text{tr}[x(q-p)^T dW]$$因此：\n$$\\boxed{\\frac{\\partial J}{\\partial W} = (q-p)x^T \\quad \\text{成立}}$$ 习题 5：多元正态分布的极大似然估计 题目：以下内容是利用极大似然估计求解多元正态分布模型的关键步骤：\n$$L = -\\frac{Nd}{2}\\ln(2\\pi) - \\frac{N}{2}\\ln|\\Sigma| - \\frac{1}{2}\\sum_{t=1}^N (x_t - \\mu)^T\\Sigma^{-1}(x_t - \\mu)$$$L$ 是对数似然，$N$ 为样本数，$d$ 为样本维数，$\\Sigma \\in \\mathbb{R}^{d\\times d}$ 为协方差矩阵，$\\mu \\in \\mathbb{R}^d$ 为期望向量。\n(1) 求 $\\frac{\\partial L}{\\partial \\mu}$\n(2) 当 $\\mu = \\frac{1}{N}\\sum_{t=1}^N x_t$ 时，求 $\\frac{\\partial L}{\\partial \\Sigma}$，并求使 $\\frac{\\partial L}{\\partial \\Sigma} = 0$ 成立的 $\\Sigma$。\n解：\n(1) 关于 $\\mu$ 的梯度\n对数似然中只有第三项与 $\\mu$ 相关：\n$$\\frac{\\partial L}{\\partial \\mu} = \\frac{\\partial}{\\partial \\mu}\\left[-\\frac{1}{2}\\sum_{t=1}^N (x_t - \\mu)^T\\Sigma^{-1}(x_t - \\mu)\\right]$$对每一项求导：\n$$\\frac{\\partial}{\\partial \\mu}(x_t - \\mu)^T\\Sigma^{-1}(x_t - \\mu) = -2\\Sigma^{-1}(x_t - \\mu)$$因此：\n$$\\boxed{\\frac{\\partial L}{\\partial \\mu} = \\sum_{t=1}^N \\Sigma^{-1}(x_t - \\mu)}$$令 $\\frac{\\partial L}{\\partial \\mu} = 0$，得 $\\mu = \\frac{1}{N}\\sum_{t=1}^N x_t$（样本均值）。\n(2) 关于 $\\Sigma$ 的梯度\n使用迹微分法，将对数似然写成迹的形式：\n$$dL = d\\left[-\\frac{N}{2}\\ln|\\Sigma|\\right] - d\\left[\\frac{1}{2}\\sum_{t=1}^N (x_t-\\mu)^T\\Sigma^{-1}(x_t-\\mu)\\right]$$第一项：\n$$d\\left[-\\frac{N}{2}\\ln|\\Sigma|\\right] = -\\frac{N}{2}d[\\ln|\\Sigma|] = -\\frac{N}{2}\\text{tr}[\\Sigma^{-1}d\\Sigma]$$第二项：\n$$d\\left[\\frac{1}{2}\\sum_{t=1}^N (x_t-\\mu)^T\\Sigma^{-1}(x_t-\\mu)\\right] = \\frac{1}{2}d\\,\\text{tr}\\left[\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T\\Sigma^{-1}\\right]$$$$= \\frac{1}{2}\\text{tr}\\left[\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T d(\\Sigma^{-1})\\right]$$利用 $d\\Sigma^{-1} = -\\Sigma^{-1}(d\\Sigma)\\Sigma^{-1}$：\n$$= \\frac{1}{2}\\text{tr}\\left[\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T(-\\Sigma^{-1}d\\Sigma \\cdot \\Sigma^{-1})\\right]$$$$= -\\frac{1}{2}\\text{tr}\\left[\\Sigma^{-1}\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T\\Sigma^{-1}d\\Sigma\\right]$$综合两项：\n$$dL = \\text{tr}\\left[\\left(-\\frac{N}{2}\\Sigma^{-1} + \\frac{1}{2}\\Sigma^{-1}\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T\\Sigma^{-1}\\right)d\\Sigma\\right]$$因此：\n$$\\boxed{\\frac{\\partial L}{\\partial \\Sigma} = -\\frac{N}{2}\\Sigma^{-1} + \\frac{1}{2}\\Sigma^{-1}\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T\\Sigma^{-1}}$$令 $\\frac{\\partial L}{\\partial \\Sigma} = 0$：\n$$N\\Sigma^{-1} = \\Sigma^{-1}\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T\\Sigma^{-1}$$两边左乘 $\\Sigma$，右乘 $\\Sigma$：\n$$N\\Sigma = \\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T$$因此：\n$$\\boxed{\\Sigma = \\frac{1}{N}\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T}$$这就是样本协方差矩阵的极大似然估计。\n习题 6：互信息的化简 题目：（互信息）假设 $X_1 \\to X_2 \\to X_3 \\to \\cdots \\to X_n$ 是一个马尔科夫链，即\n$$p(x_1, x_2, \\ldots, x_n) = p(x_1)p(x_2|x_1)\\cdots p(x_n|x_{n-1})$$试化简 $I(X_1; X_2, \\ldots, X_n)$\n解：\n互信息定义为：\n$$I(X_1; X_2, \\ldots, X_n) = H(X_1) - H(X_1 | X_2, \\ldots, X_n)$$利用条件熵的性质：\n$$= H(X_1) - [H(X_1, X_2, \\ldots, X_n) - H(X_2, \\ldots, X_n)]$$对于马尔科夫链，联合熵可以分解为：\n$$H(X_1, X_2, \\ldots, X_n) = \\sum_{i=1}^n H(X_i|X_{i-1},\\ldots,X_1)$$其中 $H(X_1|X_0,\\ldots) = H(X_1)$。由马尔科夫性质：\n$$H(X_i|X_{i-1},\\ldots,X_1) = H(X_i|X_{i-1})$$类似地：\n$$H(X_2, \\ldots, X_n) = \\sum_{i=2}^n H(X_i|X_{i-1},\\ldots,X_2)$$代入得：\n$$I(X_1; X_2, \\ldots, X_n) = H(X_1) - \\left[\\left(H(X_1) + \\sum_{i=2}^n H(X_i|X_{i-1})\\right) - \\left(H(X_2) + \\sum_{i=3}^n H(X_i|X_{i-1})\\right)\\right]$$$$= H(X_1) - H(X_1) - H(X_2|X_1) + H(X_2)$$$$= H(X_2) - H(X_2|X_1)$$$$= I(X_1; X_2)$$因此：\n$$\\boxed{I(X_1; X_2, \\ldots, X_n) = I(X_1; X_2)}$$结论：在马尔科夫链中，$X_1$ 与序列 $(X_2, \\ldots, X_n)$ 的互信息等于 $X_1$ 与 $X_2$ 的互信息，这体现了马尔科夫性质。\n习题 7：KL 散度与最大似然估计 题目：（通过 KL 散度理解 MLE）假设 $x_1, \\ldots, x_n$ 来自密度为 $p(x)$ 的分布 $P$，试说明如果采用具有密度函数 $q_\\theta(x)$ 的分布族 $Q_\\theta$ 来计算 MLE，那么 MLE 将试图找到在 KL 散度意义上最接近真实分布 $P$ 的分布 $Q_\\theta$。\n即证明：\n$$\\arg\\max_\\theta \\prod_{i=1}^n q_\\theta(x_i) \\Leftrightarrow \\arg\\min_\\theta D_{KL}(P \\| Q_\\theta)$$证明：\n从最大似然估计出发：\n$$\\arg\\max_\\theta \\prod_{i=1}^n q_\\theta(x_i) \\Leftrightarrow \\arg\\max_\\theta \\sum_{i=1}^n \\log q_\\theta(x_i)$$$$\\Leftrightarrow \\arg\\min_\\theta -\\frac{1}{n}\\sum_{i=1}^n \\log q_\\theta(x_i)$$当样本量 $n \\to \\infty$ 时，根据大数定律：\n$$-\\frac{1}{n}\\sum_{i=1}^n \\log q_\\theta(x_i) \\xrightarrow{P} -\\mathbb{E}_P[\\log q_\\theta(x)]$$$$= -\\int p(x)\\log q_\\theta(x)dx$$这正是交叉熵 $H(P, Q_\\theta)$ 的定义。因此：\n$$\\arg\\min_\\theta -\\mathbb{E}_P[\\log q_\\theta(x)] \\Leftrightarrow \\arg\\min_\\theta H(P, Q_\\theta)$$由于真实分布 $P$ 的熵 $H(P)$ 是常数（不依赖于 $\\theta$）：\n$$\\arg\\min_\\theta H(P, Q_\\theta) \\Leftrightarrow \\arg\\min_\\theta [H(P, Q_\\theta) - H(P)]$$而 KL 散度定义为：\n$$D_{KL}(P \\| Q_\\theta) = \\int p(x)\\log \\frac{p(x)}{q_\\theta(x)}dx$$$$= \\int p(x)\\log p(x)dx - \\int p(x)\\log q_\\theta(x)dx$$$$= H(P) + H(P, Q_\\theta)$$等价于：\n$$H(P, Q_\\theta) - H(P) = -\\int p(x)\\log q_\\theta(x)dx + \\int p(x)\\log p(x)dx = D_{KL}(P \\| Q_\\theta)$$因此：\n$$\\boxed{\\arg\\max_\\theta \\prod_{i=1}^n q_\\theta(x_i) \\Leftrightarrow \\arg\\min_\\theta D_{KL}(P \\| Q_\\theta)}$$结论：从优化模型参数的角度来说，最小化负对数似然、交叉熵（多分类问题）和 KL 散度这三种方式是等价的。MLE 实际上是在寻找与真实分布 KL 散度最小的模型分布。\n作业六 习题 1：贝叶斯推断求后验分布 题目：假设总体 $X \\sim N(\\mu, \\sigma^2)$（$\\sigma^2$ 已知），$X_1, X_2, \\ldots, X_n$ 为来自总体 $X$ 的样本，由过去的经验和知识，我们可以确定 $\\mu$ 的取值比较集中在 $\\mu_0$ 附近，离 $\\mu_0$ 越远，$\\mu$ 取值的可能性越小，于是我们假定 $\\mu$ 的先验分布为正态分布\n$$\\pi(\\mu) = \\frac{1}{\\sqrt{2\\pi\\sigma_\\mu^2}} \\exp\\left[-\\frac{1}{2\\sigma_\\mu^2}(\\mu - \\mu_0)^2\\right] \\quad (\\mu_0, \\sigma_\\mu \\text{ 已知})$$求 $\\mu$ 的后验概率分布。\n解：\n根据贝叶斯定理，后验分布正比于似然函数与先验分布的乘积。\n似然函数：\n给定 $\\mu$，样本 $x_1, \\ldots, x_n$ 的联合密度函数为：\n$$q(x | \\mu) = \\prod_{i=1}^n \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left[-\\frac{1}{2\\sigma^2}(x_i - \\mu)^2\\right]$$$$= \\frac{1}{\\sigma^n(2\\pi)^{n/2}} \\exp\\left[-\\frac{1}{2\\sigma^2}\\sum_{i=1}^n(x_i - \\mu)^2\\right]$$后验密度函数：\n$$h(\\mu | x) = \\frac{q(x | \\mu) \\cdot \\pi(\\mu)}{f_x(x)} \\propto q(x | \\mu) \\cdot \\pi(\\mu)$$$$\\propto \\exp\\left[-\\frac{1}{2\\sigma^2}\\sum_{i=1}^n(x_i - \\mu)^2\\right] \\cdot \\exp\\left[-\\frac{1}{2\\sigma_\\mu^2}(\\mu - \\mu_0)^2\\right]$$合并指数项：\n$$h(\\mu | x) \\propto \\exp\\left[-\\frac{1}{2}\\left(\\frac{\\sum_{i=1}^n(x_i - \\mu)^2}{\\sigma^2} + \\frac{(\\mu - \\mu_0)^2}{\\sigma_\\mu^2}\\right)\\right]$$展开平方项：\n$$\\sum_{i=1}^n(x_i - \\mu)^2 = \\sum_{i=1}^n x_i^2 - 2\\mu\\sum_{i=1}^n x_i + n\\mu^2 = n(\\mu - \\bar{x})^2 + \\text{常数}$$因此指数项中关于 $\\mu$ 的部分为：\n$$-\\frac{1}{2}\\left[\\frac{n}{\\sigma^2}(\\mu - \\bar{x})^2 + \\frac{1}{\\sigma_\\mu^2}(\\mu - \\mu_0)^2\\right]$$$$= -\\frac{1}{2}\\left[\\left(\\frac{n}{\\sigma^2} + \\frac{1}{\\sigma_\\mu^2}\\right)\\mu^2 - 2\\mu\\left(\\frac{n\\bar{x}}{\\sigma^2} + \\frac{\\mu_0}{\\sigma_\\mu^2}\\right) + \\text{常数}\\right]$$配方得：\n$$h(\\mu | x) \\propto \\exp\\left[-\\frac{(\\mu - t)^2}{2\\eta^2}\\right]$$其中：\n$$t = \\frac{\\frac{n}{\\sigma^2}\\bar{x} + \\frac{1}{\\sigma_\\mu^2}\\mu_0}{\\frac{n}{\\sigma^2} + \\frac{1}{\\sigma_\\mu^2}}, \\quad \\eta^2 = \\frac{1}{\\frac{n}{\\sigma^2} + \\frac{1}{\\sigma_\\mu^2}}$$因此，后验分布为：\n$$\\boxed{\\mu | x \\sim N\\left(\\frac{\\frac{n}{\\sigma^2}\\bar{x} + \\frac{1}{\\sigma_\\mu^2}\\mu_0}{\\frac{n}{\\sigma^2} + \\frac{1}{\\sigma_\\mu^2}}, \\frac{1}{\\frac{n}{\\sigma^2} + \\frac{1}{\\sigma_\\mu^2}}\\right)}$$解释：后验均值是样本均值和先验均值的加权平均，权重由各自的精度（方差的倒数）决定。\n习题 2：Gauss 累积分布函数的对数凹性 题目：证明：Gauss 概率密度函数的累积分布函数\n$$\\Phi(x) = \\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^x e^{-u^2/2}du$$是对数-凹函数，即 $\\log(\\Phi(x))$ 是凹函数。\n证明：\n要证明 $\\log(\\Phi(x))$ 是凹函数，需要证明其二阶导数非正，即：\n$$\\frac{d^2}{dx^2}\\log(\\Phi(x)) \\leq 0$$等价于证明：\n$$\\Phi(x)\\Phi''(x) \\leq [\\Phi'(x)]^2$$计算导数：\n$$\\Phi'(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}$$$$\\Phi''(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}(-x) = -x\\Phi'(x)$$$$[\\Phi'(x)]^2 = \\frac{1}{2\\pi}e^{-x^2}$$情况 1：$x \\geq 0$\n当 $x \\geq 0$ 时，$\\Phi''(x) = -x\\Phi'(x) \\leq 0$，而 $\\Phi(x) \u003e 0$，$[\\Phi'(x)]^2 \\geq 0$，因此：\n$$\\Phi(x)\\Phi''(x) \\leq 0 \\leq [\\Phi'(x)]^2$$情况 2：$x \u003c 0$\n当 $x \u003c 0$ 时，需要证明：\n$$\\Phi(x) \\cdot (-x) \\leq \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}$$即：\n$$\\int_{-\\infty}^x e^{-u^2/2}du \\leq \\frac{e^{-x^2/2}}{-x}$$由于 $\\frac{u^2}{2}$ 是凸函数，对任意 $u \u003c x \u003c 0$，有：\n$$\\frac{u^2}{2} \\geq \\frac{x^2}{2} + (u-x)x = xu - \\frac{x^2}{2}$$因此：\n$$e^{-u^2/2} \\leq e^{-xu + x^2/2}$$积分得：\n$$\\int_{-\\infty}^x e^{-u^2/2}du \\leq \\int_{-\\infty}^x e^{x^2/2-xu}du$$$$= e^{x^2/2} \\int_{-\\infty}^x e^{-xu}du = e^{x^2/2} \\cdot \\frac{e^{-xu}}{-x}\\bigg|_{u=-\\infty}^x$$$$= e^{x^2/2} \\cdot \\frac{e^{-x^2}}{-x} = \\frac{e^{-x^2/2}}{-x}$$因此 $\\Phi(x)\\Phi''(x) \\leq [\\Phi'(x)]^2$ 对 $x \u003c 0$ 也成立。\n综上所述，$\\Phi(x)$ 是对数凹函数。 $\\square$\n习题 3：共轭函数的计算 题目：计算函数 $f(x)$ 的共轭函数，以及共轭函数的定义域。\n(1) $f(x) = -\\log x$\n(2) $f(x) = e^x$\n解：\n共轭函数定义为：\n$$f^*(y) = \\sup_x (xy - f(x))$$(1) $f(x) = -\\log x$ 定义域 $\\text{dom}(f) = \\{x|x \u003e 0\\}$。\n对于给定的 $y$，求 $g(x) = xy + \\log x$ 的上确界。\n求导：$g'(x) = y + \\frac{1}{x}$\n当 $y \\geq 0$ 时，$g'(x) \u003e 0$ 恒成立，函数单调递增，无上界 当 $y \u003c 0$ 时，令 $g'(x) = 0$ 得 $x = -\\frac{1}{y}$ 此时：\n$$g\\left(-\\frac{1}{y}\\right) = -\\frac{1}{y} \\cdot y + \\log\\left(-\\frac{1}{y}\\right) = -1 - \\log(-y)$$因此：\n$$\\boxed{f^*(y) = \\begin{cases} -\\log(-y) - 1, \u0026 y \u003c 0 \\\\ +\\infty, \u0026 y \\geq 0 \\end{cases}}$$定义域：$\\text{dom}(f^*) = \\{y | y \u003c 0\\}$\n(2) $f(x) = e^x$ 定义域 $\\text{dom}(f) = \\mathbb{R}$。\n对于给定的 $y$，求 $g(x) = xy - e^x$ 的上确界。\n求导：$g'(x) = y - e^x$\n当 $y \\leq 0$ 时，$g'(x) \u003c 0$ 恒成立，函数单调递减，无上界（趋于 $-\\infty$ 时） 当 $y \u003e 0$ 时，令 $g'(x) = 0$ 得 $x = \\log y$ 此时：\n$$g(\\log y) = y\\log y - e^{\\log y} = y\\log y - y$$ 当 $y = 0$ 时：$f^*(0) = \\sup_x(-e^x) = 0$（当 $x \\to -\\infty$ 时） 因此：\n$$\\boxed{f^*(y) = \\begin{cases} y\\log y - y, \u0026 y \u003e 0 \\\\ 0, \u0026 y = 0 \\\\ +\\infty, \u0026 y \u003c 0 \\end{cases}}$$定义域：$\\text{dom}(f^*) = \\{y | y \\geq 0\\}$（规定 $0\\log 0 = 0$）\n习题 4：KKT 条件的应用 题目：写出下述非线性规划的 KKT 条件并求解\n(1) $\\max f(x) = (x - 3)^2$ subject to $1 \\leq x \\leq 5$\n(2) $\\min f(x) = (x - 3)^2$ subject to $1 \\leq x \\leq 5$\n解：\n(1) 最大化问题 将最大化问题转化为最小化问题：\n$$\\begin{cases} \\text{minimize} \\quad -f(x) = -(x-3)^2 \\\\ g_1(x) = 1 - x \\leq 0 \\\\ g_2(x) = x - 5 \\leq 0 \\end{cases}$$梯度：\n$$\\nabla_x[-f(x)] = -2(x-3), \\quad \\nabla_x g_1(x) = -1, \\quad \\nabla_x g_2(x) = 1$$KKT 条件：\n$$\\begin{cases} -2(x^* - 3) - v_1^* + v_2^* = 0 \u0026 \\text{(稳定性)} \\\\ v_1^*(1 - x^*) = 0 \u0026 \\text{(互补松弛性)} \\\\ v_2^*(x^* - 5) = 0 \u0026 \\text{(互补松弛性)} \\\\ v_1^* \\geq 0, \\quad v_2^* \\geq 0 \u0026 \\text{(对偶可行性)} \\\\ 1 \\leq x^* \\leq 5 \u0026 \\text{(原始可行性)} \\end{cases}$$情况分析：\n情况 i： $v_1^* = 0, v_2^* = 0$\n由稳定性条件：$-2(x^* - 3) = 0$，得 $x^* = 3$\n此时 $f(x^*) = 0$\n情况 ii： $v_1^* \u003e 0, v_2^* = 0$\n由互补松弛性：$x^* = 1$\n由稳定性条件：$-2(1-3) - v_1^* = 0$，得 $v_1^* = 4 \u003e 0$ ✓\n此时 $f(x^*) = 4$\n情况 iii： $v_1^* = 0, v_2^* \u003e 0$\n由互补松弛性：$x^* = 5$\n由稳定性条件：$-2(5-3) + v_2^* = 0$，得 $v_2^* = 4 \u003e 0$ ✓\n此时 $f(x^*) = 4$\n情况 iv： $v_1^* \u003e 0, v_2^* \u003e 0$\n由互补松弛性：$x^* = 1$ 且 $x^* = 5$，矛盾\n结论：\n$$\\boxed{x^* = 1 \\text{ 或 } x^* = 5, \\quad \\max f(x) = 4}$$(2) 最小化问题 $$\\begin{cases} \\text{minimize} \\quad f(x) = (x-3)^2 \\\\ g_1(x) = 1 - x \\leq 0 \\\\ g_2(x) = x - 5 \\leq 0 \\end{cases}$$梯度：\n$$\\nabla_x f(x) = 2(x-3)$$KKT 条件：\n$$\\begin{cases} 2(x^* - 3) - v_1^* + v_2^* = 0 \\\\ v_1^*(1 - x^*) = 0 \\\\ v_2^*(x^* - 5) = 0 \\\\ v_1^* \\geq 0, \\quad v_2^* \\geq 0 \\\\ 1 \\leq x^* \\leq 5 \\end{cases}$$情况分析：\n情况 i： $v_1^* = 0, v_2^* = 0$\n由稳定性条件：$2(x^* - 3) = 0$，得 $x^* = 3$\n此时 $f(x^*) = 0$ ✓\n情况 ii： $v_1^* \u003e 0, v_2^* = 0$\n$x^* = 1$，$2(1-3) - v_1^* = 0$，得 $v_1^* = -4 \u003c 0$ ✗\n情况 iii： $v_1^* = 0, v_2^* \u003e 0$\n$x^* = 5$，$2(5-3) + v_2^* = 0$，得 $v_2^* = -4 \u003c 0$ ✗\n结论：\n$$\\boxed{x^* = 3, \\quad \\min f(x) = 0}$$ 习题 5：Lagrange 乘子法证明矩阵 2-范数 题目：用 Lagrange 乘子法证明：矩阵 $A \\in \\mathbb{R}^{m\\times n}$ 的 2-范数\n$$\\|A\\|_2 = \\max_{\\|x\\|_2 = 1, x \\in \\mathbb{R}^n} \\|Ax\\|_2$$的平方是 $A^TA$ 的最大特征值。\n证明：\n优化问题为：\n$$\\text{maximize} \\quad f(x) = \\|Ax\\|_2^2 = x^TA^TAx \\quad \\text{subject to} \\quad x^Tx = 1$$Lagrange 函数：\n$$L(x, \\lambda) = x^TA^TAx - \\lambda(x^Tx - 1)$$求梯度并令其为零：\n$$\\frac{\\partial L}{\\partial x} = 2A^TAx - 2\\lambda x = 0$$因此：\n$$A^TAx = \\lambda x$$这说明在极值点 $x^*$ 处，$x^*$ 是 $A^TA$ 的特征向量，$\\lambda$ 是对应的特征值。\n目标函数值：\n$$f(x^*) = (x^*)^TA^TAx^* = (x^*)^T\\lambda x^* = \\lambda(x^*)^Tx^* = \\lambda$$由于我们求的是最大值，因此：\n$$\\|A\\|_2^2 = \\max_{\\|x\\|_2=1} x^TA^TAx = \\lambda_{\\max}(A^TA)$$即：\n$$\\boxed{\\|A\\|_2 = \\sqrt{\\lambda_{\\max}(A^TA)}}$$$\\square$\n习题 6：欠定方程的最小二范数解 题目：用 Lagrange 乘子法求欠定方程 $Ax = b$ 的最小二范数解，其中 $A \\in \\mathbb{R}^{m\\times n}$，$m \\leq n$，$\\text{rank}(A) = m$\n解：\n优化问题为：\n$$\\text{minimize} \\quad f(x) = \\frac{1}{2}\\|x\\|_2^2 = \\frac{1}{2}x^Tx \\quad \\text{subject to} \\quad Ax = b$$Lagrange 函数：\n$$L(x, \\lambda) = \\frac{1}{2}x^Tx - \\lambda^T(Ax - b)$$求梯度并令其为零：\n$$\\frac{\\partial L}{\\partial x} = x - A^T\\lambda = 0$$因此：\n$$x = A^T\\lambda$$代入约束条件：\n$$Ax = b \\Rightarrow A(A^T\\lambda) = b$$$$AA^T\\lambda = b$$由于 $\\text{rank}(A) = m$，矩阵 $AA^T \\in \\mathbb{R}^{m \\times m}$ 是满秩的，因此可逆：\n$$\\lambda = (AA^T)^{-1}b$$最小二范数解：\n$$\\boxed{x^* = A^T(AA^T)^{-1}b}$$验证：\n$Ax^* = AA^T(AA^T)^{-1}b = b$ ✓（满足约束） 可以证明这是所有满足 $Ax = b$ 的解中范数最小的 习题 7：最速下降法 题目：用最速下降法和精确线搜索计算\n$$\\min f(x) = x_1^2 + x_2^2 + x_3^2$$初始点 $x^{(0)} = (2, 2, 1)^T$。当 $|f(x^{(n+1)}) - f(x^{(n)})| \u003c 0.001$ 时迭代终止。\n解：\n目标函数 $f(x) = x^Tx$，梯度 $\\nabla f(x) = 2x$。\n精确线搜索：\n最速下降方向为 $d^{(k)} = -\\nabla f(x^{(k)}) = -2x^{(k)}$\n在该方向上最小化 $f(x^{(k)} + \\lambda d^{(k)})$：\n$$f(x^{(k)} + \\lambda d^{(k)}) = (x^{(k)} - 2\\lambda x^{(k)})^T(x^{(k)} - 2\\lambda x^{(k)})$$$$= (1 - 2\\lambda)^2 (x^{(k)})^Tx^{(k)}$$对 $\\lambda$ 求导并令其为零：\n$$\\frac{d}{d\\lambda}[(1-2\\lambda)^2 (x^{(k)})^Tx^{(k)}] = 2(1-2\\lambda)(-2)(x^{(k)})^Tx^{(k)} = 0$$得 $\\lambda^* = \\frac{1}{2}$\n迭代过程：\n$$x^{(1)} = x^{(0)} + \\frac{1}{2}(-2x^{(0)}) = x^{(0)} - x^{(0)} = 0$$$$f(x^{(1)}) = 0$$$$x^{(2)} = x^{(1)} - x^{(1)} = 0$$$$|f(x^{(1)}) - f(x^{(0)})| = |0 - 9| = 9 \u003e 0.001$$$$|f(x^{(2)}) - f(x^{(1)})| = |0 - 0| = 0 \u003c 0.001$$迭代终止。\n结论：\n$$\\boxed{x^* = (0, 0, 0)^T, \\quad f_{\\min} = 0}$$算法一步即收敛到最优解，这是因为目标函数是简单的二次型，且 Hessian 矩阵为单位矩阵的倍数。\n习题 8：DFP 法求二次函数极小点 题目：试用 DFP 法计算下述二次函数的极小点\n$$\\min f(x) = 3x_1^2 + x_2^2 - 2x_1x_2 - 4x_1$$解：\n选择初始点 $x^{(0)} = (-2, 4)^T$，初始 Hessian 逆近似 $H^{(0)} = I$。\n梯度：\n$$\\nabla f(x) = \\begin{pmatrix} 6x_1 - 2x_2 - 4 \\\\ 2x_2 - 2x_1 \\end{pmatrix}$$第一次迭代 $$\\nabla f(x^{(0)}) = \\begin{pmatrix} 6(-2) - 2(4) - 4 \\\\ 2(4) - 2(-2) \\end{pmatrix} = \\begin{pmatrix} -24 \\\\ 12 \\end{pmatrix}$$搜索方向：\n$$p^{(0)} = -H^{(0)}\\nabla f(x^{(0)}) = -I \\begin{pmatrix} -24 \\\\ 12 \\end{pmatrix} = \\begin{pmatrix} 24 \\\\ -12 \\end{pmatrix}$$精确线搜索： 求 $\\lambda_0 = \\arg\\min_\\lambda f(x^{(0)} + \\lambda p^{(0)})$\n$$f(x^{(0)} + \\lambda p^{(0)}) = 3(-2+24\\lambda)^2 + (4-12\\lambda)^2 - 2(-2+24\\lambda)(4-12\\lambda) - 4(-2+24\\lambda)$$对 $\\lambda$ 求导并令其为零，得：\n$$\\lambda_0 = \\frac{5}{34}$$更新：\n$$x^{(1)} = x^{(0)} + \\lambda_0 p^{(0)} = \\begin{pmatrix} -2 \\\\ 4 \\end{pmatrix} + \\frac{5}{34}\\begin{pmatrix} 24 \\\\ -12 \\end{pmatrix} = \\begin{pmatrix} \\frac{26}{17} \\\\ \\frac{38}{17} \\end{pmatrix}$$$$\\nabla f(x^{(1)}) = \\begin{pmatrix} \\frac{12}{17} \\\\ \\frac{24}{17} \\end{pmatrix}$$DFP 更新公式：\n$$\\Delta x^{(0)} = x^{(1)} - x^{(0)} = \\begin{pmatrix} \\frac{60}{17} \\\\ -\\frac{30}{17} \\end{pmatrix}$$$$\\Delta g^{(0)} = \\nabla f(x^{(1)}) - \\nabla f(x^{(0)}) = \\begin{pmatrix} \\frac{420}{17} \\\\ -\\frac{180}{17} \\end{pmatrix}$$$$H^{(1)} = H^{(0)} + \\frac{\\Delta x^{(0)}(\\Delta x^{(0)})^T}{(\\Delta g^{(0)})^T\\Delta x^{(0)}} - \\frac{H^{(0)}\\Delta g^{(0)}(\\Delta g^{(0)})^TH^{(0)}}{(\\Delta g^{(0)})^TH^{(0)}\\Delta g^{(0)}}$$计算后得：\n$$H^{(1)} = I + \\frac{1}{1800}\\begin{pmatrix} 3600 \u0026 -1800 \\\\ -1800 \u0026 900 \\end{pmatrix} - \\frac{1}{226800}\\begin{pmatrix} 176400 \u0026 -75600 \\\\ -75600 \u0026 32400 \\end{pmatrix}$$第二次迭代 $$p^{(1)} = -H^{(1)}\\nabla f(x^{(1)}) = -\\begin{pmatrix} \\frac{18}{29} \\\\ \\frac{42}{29} \\end{pmatrix}$$精确线搜索得 $\\lambda_1 = \\frac{29}{34}$\n$$x^{(2)} = x^{(1)} + \\lambda_1 p^{(1)} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$$$$\\nabla f(x^{(2)}) = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$$结论：\n$$\\boxed{x^* = (1, 1)^T \\text{ 为极小点}}$$DFP 法对于 $n$ 维二次函数，最多需要 $n$ 步即可收敛到精确解（具有二次终止性）。\n","permalink":"http://localhost:1313/dase-course/math-homework/","summary":"数学基础课程矩阵理论相关作业完整解答","title":"数学基础——数学篇作业集"},{"content":" 论文基本信息 标题: xRWA: A Cross-Chain Framework for Interoperability of Real-World Assets 作者: Yihao Guo, Haoming Zhu, Minghui Xu, Xiuzhen Cheng, Bin Xiao 机构: 香港理工大学计算系, 山东大学计算机科学与技术学院 发表: arXiv预印本 (2025年9月) 领域: 区块链互操作性、真实世界资产、去中心化身份 arXiv: 2509.12957v2 [cs.CR] 代码: GitHub - xRWA 核心问题 RWA市场现状 市场规模: 2025年上半年从86亿增至230亿美元(+260%) 未来预测: Citibank估计2030年达到4万亿美元 典型资产: 政府债券、大宗商品、房地产、稳定币 跨链部署的两大挑战 Q1: 冗余认证 (Redundant Authentication) 单链场景: RWA只需在本地账本认证一次 跨链困境: 每次转移到新链都要完全重新认证 理想方案: 在链A认证后,链B应通过证明直接识别 Q2: 低效操作 (Inefficient Operations) 单链瓶颈: Bitcoin ~7 TPS, Ethereum ~15 TPS (Visa可达数千TPS) 跨链放大: HTLC原子交换需要4个独立链上操作 现有通道: 每次结算都要关闭并重开通道,增加成本和延迟 解决方案概览 xRWA三层架构 ┌─────────────────────────────────────────────────────┐ │ Layer 3: 跨链交互 (Cross-Chain Interaction) │ │ - 跨链通道支持无需关闭的结算 │ │ - 基于HTLC的原子性保证 │ └─────────────────────────────────────────────────────┘ ↓ ┌─────────────────────────────────────────────────────┐ │ Layer 2: 跨链认证 (Cross-Chain Authentication) │ │ - SPV证明避免重复认证 │ │ - Merkle路径 + 轻客户端验证 │ └─────────────────────────────────────────────────────┘ ↓ ┌─────────────────────────────────────────────────────┐ │ Layer 1: 识别与代币化 (Identification \u0026amp; Token) │ │ - DID + VC构建RWA复合凭证 (RWA-CC) │ │ - 四模块设计:资产/身份/合规/托管 │ └─────────────────────────────────────────────────────┘ 技术细节 1. RWA复合凭证 (RWA-CC) 四大核心模块 Asset (资产模块)\n{ \u0026#34;assetId\u0026#34;: \u0026#34;did:ion:EiAa...asset123\u0026#34;, \u0026#34;assetType\u0026#34;: \u0026#34;RealEstate\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Residential\u0026#34;, \u0026#34;classDid\u0026#34;: \u0026#34;did:web:issuer.example.org:class:RE-RESIDENCE\u0026#34;, \u0026#34;tokenBinding\u0026#34;: { \u0026#34;standard\u0026#34;: \u0026#34;ERC-721\u0026#34;, \u0026#34;chain\u0026#34;: \u0026#34;eip155:1\u0026#34;, \u0026#34;contract\u0026#34;: \u0026#34;0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D\u0026#34;, \u0026#34;tokenId\u0026#34;: \u0026#34;1234\u0026#34; } } Identity (身份模块)\nidentifiers[]: 官方注册信息(登记方案、ID值、管辖区) taxonomies[]: 标准化分类码(如UNSPSC) spatialFootprint: GeoJSON格式的地理位置 documents[]: 契约、证书等加密哈希链接 attributes[]: 结构化事实(如面积120平米) Compliance (合规模块)\n{ \u0026#34;licenseId\u0026#34;: \u0026#34;example-2025-8899\u0026#34;, \u0026#34;sellableRegions\u0026#34;: [\u0026#34;CN-11\u0026#34;, \u0026#34;US-CA\u0026#34;], \u0026#34;restrictions\u0026#34;: [\u0026#34;NoCrossBorderSale\u0026#34;], \u0026#34;effectiveFrom\u0026#34;: \u0026#34;2025-01-01\u0026#34;, \u0026#34;effectiveTo\u0026#34;: \u0026#34;2026-01-01\u0026#34;, \u0026#34;regulatorDid\u0026#34;: \u0026#34;did:web:regulator.gov\u0026#34; } Custody (托管模块)\ncustodianDid: 托管人DID location: 物理存放位置 policy: 安全标准(如ISO-27001) auditCycleDays: 审计频率(如30天) insurancePolicyRef: 保险单引用 独立状态管理 每个模块都有独立的 sStatus (状态追踪) 和 sProof (密码学证明),支持:\n模块级别的撤销/暂停 选择性披露(仅透露必要字段) 分级验证(不同验证者看到不同内容) 2. SPV跨链认证协议 算法流程 (Algorithm 1) Phase 1: 源链承诺 (C₁)\n# 发行方在交易tx中嵌入承诺 commitment = { \u0026#34;assetId\u0026#34;: did_a, \u0026#34;credDigest\u0026#34;: hash(cred), \u0026#34;tokenBinding\u0026#34;: {...}, \u0026#34;epoch\u0026#34;: current_epoch, \u0026#34;nonce\u0026#34;: random() } # tx被包含在区块B中,B的头部有Merkle根μ Phase 2: 生成SPV证明\nπ ← SPV.Prove(tx, B) # π = (p, μ) # p: Merkle路径(从tx到根的兄弟哈希序列) # μ: 区块头中的Merkle根 Phase 3: 目标链验证 (C₂)\nfunction verifyCrossChainAuth( bytes memory tx, bytes32[] memory merklePath, bytes32 merkleRoot ) public returns (bool) { // 1. 检查μ对应C₁的有效区块头(轻客户端规则) require(isValidHeader(merkleRoot, chainC1)); // 2. 用路径p重新计算,验证tx包含在μ下 bytes32 computedRoot = recomputePath(tx, merklePath); require(computedRoot == merkleRoot); // 3. 解析tx中的承诺,验证与披露的cred字段一致 Commitment memory c = parseCommitment(tx); require(c.credDigest == hash(disclosedCred)); require(checkIssuerDID(c.assetId)); require(checkRevocationStatus(c.assetId)); return true; } 关键优势 避免重复: C₁上的DID解析、签名检查、撤销查询只需一次 轻量验证: C₂只需验证紧凑的Merkle证明 对数复杂度: 验证时间 T_SPV ≈ 0.69 × log₂(n) + 0.23 μs 3. 无需关闭的跨链通道 传统HTLC问题 每次交互需要4个链上操作: C₁: Lock → Unlock (2 ops) C₂: Lock → Unlock (2 ops) 总计: 4n ops (n次交互) xRWA跨链通道设计 (Algorithm 2) Phase 1: 开启通道\n// 双方在各自链上部署合约并存入保证金 Π.Open: ξ₁ on C₁ ← deposit d_Alice ξ₂ on C₂ ← deposit d_Bob // 此时无哈希锁条件 Phase 2: 链下批量协商\n# 多轮链下状态更新 σ₁: Alice pays v₁ for RWA batch S₁ = {a₁, a₂} σ₂: Alice pays v₂ for RWA batch S₂ = {a₃} σ₃: Alice pays v₃ for RWA batch S₃ = {a₄, a₅, a₆} ... # 签名的最终聚合状态 σ_final = { \u0026#34;totalPayment\u0026#34;: v₁ + v₂ + v₃, \u0026#34;totalRWAs\u0026#34;: S₁ ∪ S₂ ∪ S₃, \u0026#34;signatures\u0026#34;: [sig_Alice, sig_Bob] } Phase 3: 单次链上结算\n// 双方提交最终状态并安装HTLC条件 Π.Lock(σ_final): ξ₁.lock(totalPayment, h(ρ), T₁) // 超时T₁ ξ₂.lock(totalRWAs, h(ρ), T₂) // 超时T₂ \u0026lt; T₁ // 原子性解锁 if Bob reveals ρ before T₂: Π.Unlock on ξ₂: deliver all RWAs to Alice Π.Unlock on ξ₁: release payment to Bob before T₁ else: Π.Refund on ξ₂: return RWAs to Bob at T₂ Π.Refund on ξ₁: return payment to Alice at T₁ Phase 4: 通道持续运行\n可选择继续新的 Π.Update 轮次 或调用 Π.Close 释放剩余保证金 Gas成本对比 方案 n次交互的Gas消耗 节省比例 HTLC 465,426 × n 基准 xRWA通道 917,253 (固定) \u0026gt;99% (n≥2时) 性能评估 实验环境 硬件: Intel i9-13980HX, 32GB RAM 系统: Windows 11 (24H2) 实现: Python 3.12.10 (VC/SPV), Solidity 0.8.30 (合约) 测试网: Remix VM (Prague) 1. VC凭证大小与延迟 资产类型 VC大小(KB) 签发延迟(ms) 验证延迟(ms) 车辆 7.11 8.22 ± 9.04 1.09 ± 1.27 房地产 8.05 8.35 0.81 黄金 6.95 7.82 0.99 艺术品 7.38 8.23 0.85 债券 7.09 8.08 1.01 基金 7.27 8.17 1.02 知识产权 7.10 8.21 0.93 平均 7.27 8.16 ± 9.04 0.96 ± 1.27 测试配置: 500凭证, 100迭代, 8工作线程\n2. SPV验证可扩展性 实验拟合对数模型:\nT_SPV(n) ≈ 0.69 × log₂(n) + 0.23 μs 区块交易数(n) 验证时间(μs) 2⁵ = 32 3.75 2⁷ = 128 5.12 2⁹ = 512 6.48 2¹¹ = 2,048 7.85 2¹³ = 8,192 9.27 结论: 即使区块增大256倍(32→8,192),验证时间仅增长2.5倍\n应用场景 1. 房地产代币化 传统流程:\n链A: 完成KYC/AML, 签发VC, 代币化 链B: 重复KYC/AML, 重新签发VC xRWA流程:\n链A: 完成一次认证,生成SPV证明 链B: 验证SPV证明(\u0026lt; 10μs),直接接受 2. 跨链稳定币结算 场景: Alice(持USDT在以太坊) ↔ Bob(持房产代币在Polygon)\n批量交易示例:\nRound 1: Alice买房产A,B (100 USDT) Round 2: Alice买房产C (50 USDT) Round 3: Alice买房产D,E,F (150 USDT) 成本对比:\nHTLC: 3轮 × 465,426 gas = 1,396,278 gas xRWA: 917,253 gas (节省34%) 3. DAO治理 身份绑定: 通过DID确保一人一票 隐私保护: VC选择性披露(仅证明资格,不暴露详情) 跨链投票: SPV同步多链投票结果 4. DeFi空投防女巫 问题: 传统方式易被多账户攻击 方案: RWA-CC的 identity 模块验证唯一性 效果: 确保每个真实用户仅领取一次 安全性分析 威胁模型 已考虑的攻击:\n重放攻击: nonce + epoch 防止同一证明重用 伪造SPV: 轻客户端验证区块头工作量证明 凭证伪造: VC的发行方签名 + 撤销列表检查 双花攻击: HTLC的 T₁ \u0026gt; T₂ 时间锁机制 假设:\n至少一条链是诚实的(51%算力/权益) DID发行方遵循W3C规范 用户妥善保管私钥 形式化证明(简略) 定理1 (认证一致性): 如果RWA在链C₁通过验证,则SPV证明在链C₂的验证结果一致(除非C₁被51%攻击)。\n定理2 (原子性): 跨链通道的结算要么双方都完成,要么都退款(除非网络永久分区)。\n相关工作对比 项目/研究 单链/跨链 身份管理 认证机制 结算效率 MakerDAO [8] 单链 ❌ 中心化预言机 标准 HSBC金代币 [1] 单链 ❌ KYC/AML 标准 Securitize [21] 单链 部分 合规平台 标准 Chen et al. [5] 单链 ❌ 安全分析 N/A Zhao et al. [29] 单链 DAO治理 L2 Rollup 高 xRWA (本文) 跨链 DID+VC SPV 极高 首创性:\n✅ 首个系统性解决RWA跨链问题的框架 ✅ 首次将SPV应用于RWA认证 ✅ 首个支持无需关闭的RWA跨链通道 总结 xRWA通过DID/VC身份层 + SPV认证层 + 无需关闭的通道层,构建了首个完整的RWA跨链框架。在万亿美元规模的RWA市场即将到来之际,该方案为:\n🏠 房地产代币的全球流通 💰 跨链稳定币的高效结算 🗳️ 去中心化组织的身份治理 🎁 DeFi空投的防女巫机制 提供了关键的技术基础设施。SPV的对数复杂度和通道的99%+ Gas节省证明了方案的实用性,值得进一步在主网环境测试和优化。\n[!IMPORTANT]\n\u0026ldquo;For 𝑛 cross-chain interactions, the cross-chain channel requires only 917,253 gas in total, while the HTLC scheme consumes 465,426 × 𝑛 gas.\u0026rdquo; — 性能评估章节\n个人思考 优势 模块化设计: RWA-CC四模块可独立更新/撤销,灵活性强 标准兼容: 完全遵循W3C DID/VC规范,生态友好 实用性强: 公开代码、测试网部署、详细Gas成本分析 潜在限制 轻客户端依赖: SPV需要维护源链的区块头,增加存储成本 预言机问题: 链下资产状态更新(如房产出售)仍需可信预言机 监管挑战: 跨境RWA流动可能触发复杂的法律合规 改进方向 零知识优化: 用zkSNARK压缩SPV证明大小 动态通道: 支持多方(\u0026gt;2)参与的跨链通道 AI审计: 自动检测RWA凭证中的异常模式 标签: #RWA #跨链互操作 #DID #可验证凭证 #SPV #区块链 #Web3金融\n","permalink":"http://localhost:1313/blockchain/xrwa-cross-chain-real-world-assets/","summary":"xRWA是首个专门针对真实世界资产(RWA)跨链场景设计的完整框架。通过整合去中心化身份标识(DID)、可验证凭证(VC)和简化支付验证(SPV),解决了RWA在多链部署中的冗余认证和低效结算问题。系统采用三层架构:资产识别与代币化、跨链认证协议、跨链交互通道。实验显示SPV验证复杂度为O(log n),跨链通道比HTLC节省超过99%的gas成本。该框架为RWA的万亿美元市场潜力提供了关键的跨链基础设施。","title":"xRWA: 真实世界资产的跨链互操作性框架"},{"content":"论文基本信息 标题: A Comparative Survey of Centralised and Decentralised Identity Management Systems: Analysing Scalability, Security, and Feasibility 作者: Aviral Goel, Yogachandran Rahulamathavan 机构: Loughborough University, Institute for Digital Technologies 发表期刊: Future Internet 2025, 17(1) 发表时间: 2024年12月24日 DOI: https://doi.org/10.3390/fi17010001 研究背景与动机 数字身份的重要性 在网络犯罪高发的时代，数字身份已成为关键资产：\n敏感信息保护：包含姓名、年龄、银行信息等个人数据 服务访问凭证：用于社交媒体、银行、购物等在线服务 安全防护需求：防止身份盗窃和未经授权的访问 身份认证技术演进历程 1990年代初期：简单的用户名+密码认证\n主要问题：用户在多个站点重复使用相同密码 安全隐患：密码管理效率低，容易发生安全漏洞 2000年代至今：引入复杂认证机制\n单点登录（SSO）：一次登录访问多个应用 多因素认证（MFA）：增加额外验证层 生物识别认证：指纹、人脸识别等 传统中心化系统面临的挑战 1. 单点故障风险（Single Point of Failure）\n中央服务器故障导致整个系统不可用 典型案例：2021年微软 Azure AD 故障持续数小时，影响全球服务 2. 隐私安全问题\n所有用户数据集中存储，成为攻击者的首要目标 典型案例：2021年 Facebook 数据泄露，5.33亿用户记录被盗 3. 可扩展性瓶颈\n用户数量增长导致中央服务器负载过高 需要持续投入硬件资源进行扩容 研究方法论 文献检索策略 主要数据库来源：\nGoogle Scholar（初步广泛检索） IEEE Xplore（技术论文） ACM Digital Library（计算机科学） SpringerLink（综合学术） 时间范围设定：2015-2024年\n确保技术相关性和时效性 覆盖区块链技术成熟期 核心检索词组合（e.g.）：\n(\u0026#34;decentralized identity management\u0026#34; OR \u0026#34;self-sovereign identity\u0026#34; OR \u0026#34;DID\u0026#34;) AND (\u0026#34;blockchain\u0026#34; OR \u0026#34;Hyperledger Indy\u0026#34; OR \u0026#34;Sovrin\u0026#34;) AND (\u0026#34;scalability\u0026#34; OR \u0026#34;security\u0026#34; OR \u0026#34;feasibility\u0026#34;) 筛选结果：经过系统筛选标题和摘要，最终纳入约90篇高质量论文，这些论文均衡地描述了去中心化和集中式 IdM 系统，重点关注它们各自的优势、挑战和未来潜力。\n评估维度框架 论文从5个关键维度对身份管理系统进行全面对比：\n可扩展性（Scalability）：系统处理用户数量增长的能力 可靠性（Reliability）：系统持续稳定运行的能力 安全性（Security）：防护数据泄露和网络攻击的能力 适应性（Adaptability）：与现有系统集成的灵活性 成本（Cost）：部署和维护的经济投入 中心化身份管理系统（CIMS） 核心架构设计 基本工作流程：\n用户 → 服务提供商(SP) → 身份提供商(IdP) ↓ 验证凭证 \u0026amp; 发放令牌 ↓ 授予服务访问权限 关键组件说明：\n身份提供商（IdP）：集中管理所有用户身份数据和凭证 服务提供商（SP）：用户实际交互的应用程序或服务 认证服务器：负责处理和验证用户的认证请求 单点登录（SSO）：允许用户一次认证后访问多个应用 主流中心化协议详解 1. LDAP（轻量级目录访问协议） 技术特征：\n基于目录的分层结构存储用户信息 采用客户端-服务器通信模型 广泛应用于 Microsoft Active Directory 等企业环境 认证工作流程：\n客户端发送 Bind 请求，包含 DN（Distinguished Name）和密码 服务器在目录信息树（DIT）中验证凭证 服务器搜索匹配的用户条目 返回认证成功或失败的结果 安全机制与问题：\n默认情况下以明文传输凭证（存在安全风险） 必须配置 SSL/TLS 加密以保护数据传输 配置复杂，需要专业知识进行规划和部署 性能指标：\n优化环境下可达 10,000 查询/秒 典型响应时间低于 200 毫秒 2. RADIUS（远程认证拨号用户服务） 协议特性：\n基于 UDP 协议通信 端口 1812：认证服务 端口 1813：计费服务 提供 AAA 服务（认证、授权、计费） 主要应用于 VPN、WLAN 等网络接入场景 数据包类型：\nCode 1：客户端访问请求 Code 2：认证成功响应 Code 3：访问拒绝响应 安全挑战：\nMD5 加密算法已被认为不够安全 容易遭受 DoS（拒绝服务）攻击 Request Authenticator 随机性不足可能产生安全漏洞 3. SAML（安全断言标记语言） 应用场景：\n企业级单点登录（SSO）解决方案 跨组织域的身份联合认证 完整工作流程：\n用户向服务提供商（SP）请求访问受保护资源 SP 生成 SAML 认证请求并重定向到身份提供商（IdP） IdP 验证用户身份并生成 SAML 断言（Assertion） 用户携带 SAML 断言返回 SP SP 验证断言的数字签名 验证通过后授予用户访问权限 安全保障措施：\n使用数字签名确保断言的完整性和真实性 通过 HTTPS 协议传输防止中间人攻击 实施会话管理机制防止会话劫持 系统局限性：\n配置过程复杂，部署周期较长 依赖中心化的 IdP（存在单点故障风险） 需要注意 XML 相关的安全漏洞 4. OAuth 2.0（开放授权标准） 核心设计优势：\n用户无需向第三方应用共享账号密码 使用时限令牌（Access Token）限制潜在滥用 被 Google、Facebook、Microsoft 等主流平台广泛采用 系统关键角色：\n资源所有者（Resource Owner）：拥有数据的用户 客户端（Client）：请求访问资源的第三方应用 授权服务器（Authorization Server）：负责颁发访问令牌 资源服务器（Resource Server）：存储和提供受保护数据 授权码模式流程：\n1. Client → Authorization Server: /authorize 请求 参数包括: response_type=code, client_id, redirect_uri, scope, state 2. 用户授权 → Authorization Server 返回授权码（Authorization Code） 3. Client → Authorization Server: /token 请求 使用授权码换取 Access Token 4. Client 使用 Access Token 访问资源服务器 5. 资源服务器验证 Token 合法性后返回数据 6. Token 过期后可使用 Refresh Token 获取新的 Access Token 常见安全漏洞：\n过度权限请求：应用请求超出功能需要的访问范围 缺乏用户控制：UI 设计诱导用户授予所有权限 令牌重放攻击：攻击者拦截并重复使用 OAuth 令牌 安全缓解措施：\n实施细粒度的权限控制机制 设置较短的令牌有效期（如1小时） 强制使用 HTTPS 防止令牌被拦截 检测到滥用时立即撤销相关令牌 中心化系统的优势与挑战 主要优势：\n部署简单，成本相对较低（中小企业初始投入 \u0026lt; $10,000） 集中化管理，便于统一实施安全策略 技术成熟稳定，供应商支持体系完善 具备良好的水平扩展能力（如 LDAP、OAuth） 面临挑战：\n单点故障风险：中央服务器故障影响整个系统 隐私问题：数据集中存储容易成为攻击目标 可扩展性受限：中央服务器性能成为瓶颈 灵活性不足：集成新技术和协议较为困难 去中心化身份管理系统（DIMS） 核心理念：自主身份（SSI） Self-Sovereign Identity 核心原则：\n用户完全拥有和控制自己的身份数据 不依赖任何中心化权威机构 支持选择性披露信息（Selective Disclosure） 数据存储在用户本地或分布式网络中 关键技术组件 1. 去中心化标识符（DID） 核心特点：\n全局唯一的身份标识符 基于密码学密钥对生成 公钥发布在区块链上供验证 私钥由用户安全保管，不可泄露 DID 文档内容：\n用户的公钥信息 可访问的服务端点 支持的身份验证方法 2. 可验证凭证（VC） 基本定义：数字化的身份证明文档，类似于电子版的护照或驾驶执照\n技术特征：\n由可信的颁发机构进行数字签名 存储在用户的数字钱包应用中 可通过加密技术验证真伪 支持零知识证明技术 3. 区块链与分布式账本技术（DLT） 系统作用：\n存储 DID 文档和凭证的哈希值 通过密码学保证数据不可篡改 提供透明的验证机制 消除对中心化服务器的依赖 主要共识机制：\n拜占庭容错（BFT）：用于 Hyperledger Indy、Sovrin 工作量证明（PoW）：用于 Bitcoin（Blockstack、ShoCard） 权益证明（PoS）：用于 Ethereum（uPort） 4. 零知识证明（ZKP） 核心能力：在不暴露具体数据的情况下向他人证明某个事实为真\n实际应用示例：\n证明\u0026quot;年满18岁\u0026quot;而不需要透露确切的出生日期 证明\u0026quot;账户余额大于1000美元\u0026quot;而不显示具体金额 证明\u0026quot;拥有某项资质\u0026quot;而不泄露其他无关信息 去中心化身份系统架构 系统层次结构：\n用户层（持有 DID + 私钥） ↓ 数字钱包层（存储可验证凭证 VC） ↓ 区块链网络层（存储 DID 文档 + 凭证证明） ↓ 验证方（验证 VC 的真实性和有效性） 完整认证流程：\n用户向验证方出示可验证凭证（VC） 验证方从区块链获取凭证颁发者的公钥 使用公钥验证凭证的数字签名有效性 检查凭证是否已被撤销 用户选择性披露必要的属性信息 验证通过后授予服务访问权限 主流去中心化身份平台深度分析 1. Hyperledger Indy 基本信息：\n许可型区块链（Permissioned Blockchain） 基于 Linux Foundation Hyperledger 项目 专为自主身份（SSI）设计 技术架构：\n验证者节点（Validators）：由受信任的管理员（Stewards）运营 共识算法：Plenum BFT（拜占庭容错） 多链设计： Domain TXs：存储域特定数据和交易元数据 Pool TXs：管理验证者配置和操作 Config TXs：存储网络参数和策略更新 核心特性：\n支持零知识证明（ZKP）技术 符合 GDPR 等隐私法规要求 支持动态配置修改能力 性能特点：\n写延迟始终低于读延迟 性能受验证者数量和交易速率影响 使用 Docker 容器化部署便于管理 局限性分析：\n可扩展性受 BFT 共识机制限制（计算开销较大） 添加新验证者需要投票过程，影响扩展速度 开源代码相对受限，部署过程较为复杂 最新进展：\nIndy Besu 项目引入模块化架构 兼容许可型和无许可型网络 显著提升交易吞吐量和灵活性 适用场景：\n企业级身份管理系统 政府数字身份基础设施 医疗健康记录管理平台 2. Sovrin Network 基本信息：\n基于 Hyperledger Indy 框架构建 拥有独立加密货币 SOV 用于激励验证者 具备完善的治理框架体系 四层架构设计：\nLayer 1: 账本层（Ledger Layer）\n存储 DID、凭证定义、撤销注册表 使用 RBFT（冗余拜占庭容错）共识机制 保证数据的保密性和完整性 Layer 2: 代理层（Agent Layer）\n管理点对点的安全连接 通过 DIDComm 协议进行加密通信 包括边缘代理（用户设备）和云代理（服务器） Layer 3: 治理层（Governance Layer）\nSovrin 治理框架（SGF）制定运营规则 确保符合法律、安全和隐私要求 所有参与者必须遵守统一标准 Layer 4: 应用层\n支持各类基于 Sovrin 的应用开发 系统优势：\nRBFT 机制提供高容错性（即使部分节点失效仍可运行） 代币激励机制促进生态系统发展 完善的治理框架确保系统可信度 局限性分析：\n依赖 Steward（受信任组织）运营节点，增加一定中心化风险 可扩展性和可移植性仍在早期发展阶段 复杂的治理机制对普通用户不够友好 3. Blockstack 基本信息：\n基于 Bitcoin 区块链构建 使用区块链名称系统（BNS）替代传统 DNS 配备去中心化存储系统 Gaia 核心组件详解：\nBNS（Blockchain Name System）\n将人类可读的名称绑定到公钥 名称注册采用两阶段流程： 预订阶段：生成哈希并记录到区块链 注册阶段：等待期后将名称正式绑定到区块链 VirtualChain（虚拟链）\n作为抽象层独立于底层区块链运行 提升系统速度和灵活性 降低直接操作区块链的复杂度 Atlas 网络\n点对点的数据索引和查找系统 处理 BNS 数据的传播和同步 Gaia 存储系统\n去中心化存储解决方案 数据使用用户私钥签名防止篡改 兼容 Dropbox、Amazon S3 等现有云服务 身份管理流程：\n用户注册过程：\n预订名称（生成加密哈希） 经过强制等待期 完成注册，名称加密绑定到公钥 身份认证过程：\n用户提交 Blockstack ID 提供私钥作为所有权证明 系统验证私钥与公钥是否匹配 密钥撤销与恢复：\n通过名称转移流程将 ID 所有权转移到新地址 密钥撤销后禁用该身份的所有后续操作 独特优势：\n动态定价机制：需求高的名称价格更高 跨链迁移能力：区块链故障时可转移身份到其他链 分叉恢复机制：通过共识哈希检测并纠正不一致状态 局限性分析：\n加密、解密、签名验证的开销影响实时性能 多层架构（区块链+P2P网络+存储）管理复杂 大规模部署需要专业技术人员支持 4. uPort 基本信息：\n基于 Ethereum 区块链平台 完全开源的身份解决方案 通过移动应用安全存储私钥 智能合约架构：\n用户创建身份时会生成两个关键智能合约：\n代理合约（Proxy Contract）\n作为持久化的唯一身份标识 与区块链网络上其他合约进行交互 在私钥和区块链之间添加抽象层 允许密钥恢复而不改变身份本身 控制器合约（Controller Contract）\n维护访问控制策略 允许用户向代理合约进行身份认证 即使私钥丢失也能保护身份完整性 密钥恢复机制：\n恢复法定人数合约（Recovery Quorum Contract）\n由一组受信任的个人（恢复代表）共同控制 当用户私钥丢失时协助恢复身份控制权 采用去中心化方式，无需依赖中心化权威机构 数据存储策略：\n链上数据：智能合约处理核心身份功能 链下数据： 存储在 IPFS 等去中心化存储平台 包括个人资料、证明文件、身份属性 通过注册合约加密链接到 uPort 身份 系统优势：\n用户完全控制自己的身份数据 人性化的密钥恢复机制 链上链下结合优化存储成本和效率 局限性分析：\n依赖 Ethereum 网络（受其可扩展性和交易费用限制） 链下存储方案需要信任所选择的存储服务 主要基于 Ethereum，跨链可移植性和互操作性受限 恶意节点可能追踪和关联 uPort ID 的活动记录，存在隐私风险 5. EverID 基本信息：\n基于许可型 Ethereum 区块链 非开源系统（闭源商业方案） 支持多货币跨境金融交易 技术特点：\n数字身份整合政府 ID、生物特征、第三方认证 数据存储在云端（用户无需移动设备也可使用） 利用生物识别技术创建唯一用户身份 核心组件：\nEverID Datagram：存储生物特征标识符数据 去中心化应用（DApp）：提供自助注册和身份管理功能 应用程序接口（API）：与其他服务进行安全集成 核心智能合约：管理身份创建、验证和交易流程 超级节点（Super Nodes）：存储 Datagram 的副本以提高可用性 局限性分析：\n数据最小化原则未完全实现：验证声明时需要披露所有信息 许可型区块链引入一定程度的中心化（访问受限于批准的参与者） 用户和交易规模增长可能导致： 运营成本持续增加 交易处理速度变慢 整体用户体验下降 6. ShoCard 基本信息：\n基于 Bitcoin 公有区块链 用户身份信息以加密哈希形式存储 第三方验证者通过区块链验证用户身份 核心设计理念：\n私人信息不存储在任何中央位置 用户可在不分散身份碎片的情况下证明账户所有权 使用加密哈希将用户标识符与可信凭证（护照、驾照等）关联 三阶段工作流程：\n阶段1: 引导（Bootstrapping）\nShoCard 移动应用生成加密密钥对 扫描用户的身份凭证（如护照） 凭证数据加密后作为签名哈希存储在 Bitcoin 交易中 生成唯一的 ShoCardID 作为区块链上的参考点 阶段2: 认证（Certification）\n用户与服务提供商进行交互 向用户身份添加经过验证的属性 属性被哈希处理、数字签名并存储在区块链上 阶段3: 验证（Validation）\n依赖方从区块链检索认证信息 验证数字签名的有效性 将数据与区块链记录进行对比 确认用户身份的真实性和有效性 系统优势：\n利用 Bitcoin 区块链的高安全性和全球接受度 无需中心化数据库存储敏感身份信息 用户完全控制自己的身份数据共享 局限性分析：\n依赖中央服务器处理部分功能，引入中心化风险 如果 ShoCard 公司停止运营，用户可能丧失数据访问权 缺乏全向标识符（Omnidirectional Identifiers），限制扩展到更广泛生态 Bitcoin 交易确认延迟（约10分钟）在实时验证场景下存在问题 7.小结 平台 底层区块链 共识机制 核心特色 主要优势 主要局限 Hyperledger Indy 自有许可型链 Plenum BFT SSI专用,支持ZKP 隐私保护强,符合GDPR 扩展性受限,部署复杂 Sovrin Network Hyperledger Indy RBFT 四层架构,SOV代币激励 治理完善,容错性高 依赖Steward,有中心化风险 Blockstack Bitcoin PoW BNS系统,Gaia去中心化存储 跨链迁移能力,动态定价 性能开销大,架构复杂 uPort Ethereum PoS/PoW 智能合约身份,移动优先 用户完全自控,恢复机制好 依赖Ethereum,交易费高 EverID 许可型Ethereum 许可型 生物识别,云端存储 生物识别方便,支持跨境金融 中心化,隐私保护较弱 ShoCard Bitcoin PoW 加密哈希,三阶段验证 Bitcoin安全性高,用户自控 确认慢(约10分钟),依赖中央服务器 中心化 vs 去中心化：全面对比分析 1. 可扩展性（Scalability） 中心化系统的表现 优势特点：\nLDAP 和 OAuth 经过数十年优化，支持灵活的水平和垂直扩展 LDAP 在优化环境下可处理 10,000 查询/秒，响应时间低于 200ms OAuth 能够高效处理大量基于令牌的访问请求 SAML 的联邦模型支持跨多个组织域的扩展 性能瓶颈：\n单点控制架构在系统规模增长时可能引入性能瓶颈 需要持续增加硬件资源以应对用户增长 去中心化系统的表现 核心挑战：可扩展性主要受共识机制的计算复杂度限制\n性能对比表：\n系统 共识机制 吞吐量（TPS） 关键特点 Ethereum (uPort) PoS 15-30 Layer-2 方案可提升至 1000-4000 TPS Bitcoin (Blockstack/ShoCard) PoW 约7 挖矿计算开销大，确认时间约10分钟 Hyperledger Indy (Sovrin) RBFT 约300 可容忍 33% 节点故障 LDAP (中心化) N/A 10,000+ 支持多主复制 最新技术进展：\nIndy Besu 项目：模块化架构，兼容许可型和无许可型网络，提升吞吐量 Ethereum Layer-2 解决方案（Optimistic Rollups、zkRollups）显著改善扩展性 2. 可靠性（Reliability） 中心化系统的可靠性保障 技术机制：\n多主复制（Multi-Master Replication）技术 备份服务器可在几秒钟内接管服务 LDAP 系统年度停机时间通常低于 1% 典型风险案例：\n2021年微软 Azure AD 故障：持续数小时，影响全球范围内的服务访问 去中心化系统的可靠性优势 核心优势：\n分布式网络架构：单个节点故障不影响整体系统运行 RBFT 共识机制：即使 33% 的节点出现故障仍可维持运行 无单点故障风险，系统韧性更强 技术权衡：\n节点添加或配置更新时可能出现临时的数据同步延迟 需要更复杂的协调机制确保网络一致性 3. 安全性（Security） 中心化系统的安全措施 主要防护机制：\nLDAP：使用 SSL/TLS 加密凭证传输过程 OAuth：强制 HTTPS 传输 + 时限令牌（TTL）机制 SAML：XML 加密技术 + 数字签名验证 重大安全事件：\n2021年 Facebook 数据泄露：5.33亿用户记录被窃取 主要攻击面：\n中央服务器一旦被攻破，所有用户数据面临风险 容易遭受暴力破解攻击和令牌重放攻击 去中心化系统的安全优势 先进安全技术：\n零知识证明（ZKP）：可以证明\u0026quot;年满18岁\u0026quot;而无需透露具体出生日期 选择性披露：用户仅分享验证所需的最少信息 区块链不可篡改性：数据一经写入区块链即无法修改 无中央数据库：消除单点大规模数据泄露风险 潜在安全风险：\nBFT 共识机制漏洞：恶意节点串通可能导致系统延迟或操纵 智能合约缺陷：代码漏洞可能导致未授权操作 密钥管理挑战：私钥丢失或被盗通常无法恢复（最大安全隐患） 高交易负载下延迟增加，可能间接影响安全性和性能 4. 适应性（Adaptability） 中心化系统的集成优势 技术成熟度：\n经过数十年的企业级应用实践 提供丰富的 API 库和集成工具 与 SSO、云服务平台可以无缝对接 显著减少系统部署时间和技术复杂度 适用场景：\n需要快速部署上线的企业项目 现有 IT 基础设施已经成熟的大型组织 去中心化系统的集成挑战 主要技术障碍：\n需要开发中间件桥接区块链操作与传统 IT 环境 Hyperledger Indy 集成企业数据库需要定制开发 API 公有链（uPort）受 Gas 费用和网络吞吐量限制 私有链（Sovrin、Indy）虽然提供更多控制权，但初始设置复杂 系统过渡要求：\n需要进行重大的基础设施升级改造 IT 团队必须重新培训以管理分布式系统 整体实施成本和周期显著增加 5. 成本（Cost） 中心化系统的成本结构 经济优势：\n中小企业初始部署成本通常低于 $10,000 运营成本主要包括基础设施维护和定期系统更新 开源工具和完善的供应商支持降低总拥有成本 LDAP 等系统的最小硬件需求减少经常性开支 适用对象：预算相对固定的中小型企业\n去中心化系统的成本结构 详细成本对比：\n成本项目 私有链（Sovrin/Indy） 公有链（uPort/Ethereum） 验证者节点部署 $5,000-$10,000/节点 不适用 整体系统部署 $10,000-$50,000 取决于网络活动量 运营成本 节点维护和管理费用 交易 Gas 费（高峰期 $1-$20/笔） 人力成本 员工再培训或聘请区块链专家 同左 专业支持 需要区块链技术专家 需要智能合约开发者 高频交易场景的成本影响：\n公有链的交易费用在高峰期可能急剧上升 不适合成本敏感且需要频繁身份验证的应用场景 适用对象：\n资源充足的大型组织 长期战略侧重去中心化控制和数据主权 重视隐私法规合规性（如 GDPR）的行业 研究结论 核心发现 本综述论文通过对中心化和去中心化身份管理系统的全面分析，揭示了两种范式各有优劣，不存在普适的最优解决方案。组织需要根据自身需求在可扩展性、成本效益、安全性和复杂度之间做出权衡决策。\n中心化系统的当前优势地位 为何仍是主流选择：\n成熟稳定：经过数十年实战验证，提供可靠的身份认证服务 易于部署：快速上线，无需大规模基础设施改造 成本可控：中小企业初始投入 \u0026lt; $10,000 规模处理：优化后可达 10,000+ TPS，支持水平扩展 安全增强：现代系统通过多因素认证（MFA）和加密会话提升防护能力 适用场景：\n内部企业应用和员工访问管理 需要快速部署的项目 预算和技术资源有限的中小企业 高性能要求场景（低延迟、高并发） 去中心化系统的创新价值 核心优势：\n用户数据主权：将身份控制权交还给用户，消除对中心化机构的依赖 隐私保护：零知识证明（ZKP）实现选择性披露，符合 GDPR 等严格法规 透明性：区块链不可篡改特性确保操作可追溯 高韧性：无单点故障风险，RBFT 共识可容忍 33% 节点故障 面临挑战：\n复杂架构：需要专业区块链工程师和长期学习曲线 高成本：初始部署 $10,000-$50,000，持续运营费用较高 性能瓶颈：共识机制限制吞吐量（BFT ~300 TPS, PoW ~7 TPS） 集成困难：与传统 IT 系统对接需要定制中间件 适用场景：\n高度监管行业（医疗、金融、政府） 数据主权和隐私要求极高的应用 Web3 原生应用（DApps、NFT、DeFi） 拥有专业团队和长期战略投资的大型组织 未来发展展望 1. 混合身份管理模式（Hybrid Approach） 核心理念：结合中心化系统的易用性与去中心化系统的安全性\n两种融合路径：\n路径A：中心化系统增强去中心化特性\n通过 API 集成区块链验证层 关键身份操作记录在链上（不可篡改审计） 用户可选择将身份哈希锚定到公有链 保留现有认证服务器处理日常登录 优势：最小化破坏性改造，逐步提升安全性和用户控制权\n路径B：去中心化系统集成中心化便利性\n区块链作为信任根（Root of Trust） 中心化服务处理高频低风险操作 提供传统 API 接口便于企业集成 可选的托管钱包服务降低使用门槛 优势：继承区块链安全性，改善用户体验和性能\n先行者案例：\nYoti - 智能身份验证平台\n用户友好的移动应用 + 区块链锚定身份 支持零知识属性共享（选择性披露） 被英国政府采用进行年龄验证 符合 GDPR 和 eIDAS 法规 EarthID - 去中心化身份生态\n基于区块链 DID 注册 + 中央索引服务 提供托管钱包和友好 Web 界面 无缝集成现有企业系统 支持教育、医疗、企业等多领域应用 2. 零知识证明（ZKP）与中心化系统的深度融合 技术价值：在不暴露敏感数据的情况下完成身份验证\n实际应用示例：\n银行贷款：证明\u0026quot;年收入 \u0026gt; $50,000\u0026quot;而不透露具体金额 年龄验证：证明\u0026quot;年满18岁\u0026quot;而不泄露确切出生日期 资质认证：证明\u0026quot;拥有某项资质\u0026quot;而不显示其他信息 实施路径：\n通过 API 网关集成 ZKP 验证模块 中央服务器无需存储原始敏感数据 用户在本地客户端生成 ZKP 证明 符合数据最小化原则（GDPR 要求） 3. 区块链可扩展性技术突破 Layer-2 扩展方案：\n技术方案 代表项目 TPS 提升 关键特点 Optimistic Rollup Optimism 1,000-4,000 继承以太坊安全性 ZK Rollup zkSync, StarkNet 2,000-20,000 数学证明，更强安全性 Sharding Ethereum 2.0 未来 100,000+ 分片技术，大规模扩展 Sharding（分片技术）：\n将网络划分为多个并行处理的分片 显著提升整体吞吐量 预计可达 100,000+ TPS 对身份管理的影响：\n降低交易成本：Gas 费降低 100-1000 倍 提升用户体验：交易确认从分钟级降至秒级 支持大规模采用：移除性能瓶颈，支撑全球性身份系统 个人思考 1. 论文的主要贡献 优点：\n✅ 系统性全面：覆盖 LDAP 到 Sovrin 的广泛技术光谱 ✅ 评估框架清晰：5 个维度对比（可扩展性、可靠性、安全性、适应性、成本） ✅ 实践指导价值：为组织选型提供具体的决策依据 ✅ 前沿性：纳入 2024 年最新研究成果 不足之处：\n⚠️ 性能数据来源不够透明：部分 TPS 数据缺乏实验环境细节 ⚠️ 混合模式探讨不够深入：仅简要提及 Yoti 和 EarthID，缺乏架构细节 ⚠️ 成本分析偏粗略：未考虑不同规模组织的具体成本差异 2. 技术发展的关键矛盾 性能 vs 去中心化的永恒权衡：\n区块链的\u0026quot;不可能三角\u0026quot;（Trilemma）始终存在：\n去中心化：节点分布越广，安全性越高 安全性：共识机制越复杂，攻击成本越高 可扩展性：吞吐量越高，对去中心化和安全性的妥协越大 思考：纯粹的去中心化身份系统短期内难以在性能上超越中心化方案，混合模式可能是更现实的过渡路径。\n3. 用户体验的挑战被低估 私钥管理的用户负担：\n普通用户难以理解\u0026quot;私钥丢失 = 身份永久丢失\u0026quot;的概念 助记词备份机制对非技术用户不友好 缺乏类似\u0026quot;忘记密码\u0026quot;的容错机制 解决方向：\n社交恢复机制（通过可信联系人恢复） 生物识别与私钥结合（如 Apple 的 Secure Enclave） 托管钱包服务（牺牲部分去中心化换取便利性） 个人观点：去中心化身份要真正普及，必须在用户体验上实现\u0026quot;隐形化\u0026quot;——用户享受好处而无需理解底层复杂性。\n4. 监管与创新的博弈 现实困境：\n去中心化身份挑战现有监管框架（如 KYC/AML） 完全匿名性与政府监管需求冲突 不同司法管辖区法规不一致 可能的平衡点：\n选择性披露 + 监管机构特权访问 零知识证明满足合规要求（证明合规而不泄露数据） 国际标准化组织推动跨国互认（如 W3C DID 标准） 5. Web3.0 身份的终极愿景 理想状态：\n用户拥有唯一的全球数字身份（跨平台、跨国界） 一次身份验证即可访问所有服务（真正的 SSO） 用户完全控制个人数据的访问权限 身份数据可移植，不被任何平台锁定 实现路径的现实考量：\n技术成熟度：需要 5-10 年持续优化 商业模式转变：互联网巨头依赖用户数据盈利，缺乏动力放弃控制权 用户教育：需要长期的认知普及和习惯培养 监管协调：全球范围内法规统一是巨大挑战 个人预测：去中心化身份将首先在特定垂直领域（医疗、教育、金融）取得突破，而非一蹴而就的全面替代。混合模式将在未来 5 年内成为主流，纯粹的去中心化可能需要等待下一代互联网基础设施的成熟。\n参考资料 原论文：Future Internet 2025, 17(1) Hyperledger Indy: https://www.hyperledger.org/use/hyperledger-indy Sovrin Network: https://sovrin.org/ uPort: https://www.uport.me/ Blockstack: https://www.stacks.co/ W3C DID 标准: https://www.w3.org/TR/did-core/ W3C Verifiable Credentials: https://www.w3.org/TR/vc-data-model/ Yoti: https://www.yoti.com/ EarthID: https://www.earthid.io/ ","permalink":"http://localhost:1313/blockchain/identity-management-systems-survey/","summary":"深度解读 Web3.0 身份认证领域的最新综述论文，对比分析中心化（LDAP、SAML、OAuth）与去中心化（Hyperledger Indy、Sovrin、uPort）身份管理系统的优劣势","title":"Web3.0 身份认证系统综述：中心化与去中心化方案对比分析"},{"content":"第一讲 算法分析 一、算法简介 1. 算法和效率 算法定义：\n任何良定义的计算过程，该过程取某个值或者值的集合作为输入，并产生某个值或值的集合作为输出 把输入转换成输出的计算步骤的一个序列 算法的应用场景：\n生物基因分析 互联网海量数据管理 电子商/务 高速路由器上的IP包分析（频数统计、Top-k查询、范围查询、中位数、平均数+方差等） 效率分析：\n求解相同问题的不同算法的效率可能具有显著的差异 性能可以用曲线来表达 插入排序：$c_1n^2$ vs 归并排序：$c_2n \\log n$ 尽管 $c_1$ 通常小于 $c_2$，但当 $n$ 增长时，最终插入排序的开销更大 案例： 快机器A（100亿条指令/秒）执行插入排序（$2n^2$ 条指令）vs 慢机器B（1000万条指令/秒）执行归并排序（$50n \\log n$ 条指令），当n足够大时，B机器反而更快\n渐进性能： 考虑当n足够大时的复杂度，当n足够大时，$\\Theta(n^2)$ 算法总是优于 $\\Theta(n^3)$ 算法\n2. 渐进符号表示 O-记号（\u0026ldquo;big-Oh\u0026rdquo;，渐近上界）：\n$f(n) = O(g(n))$ if $\\exists$ 常数 $c, n_0$，满足 $0 \\leq f(n) \\leq cg(n), \\forall n \\geq n_0$ 案例：$2n^2 = O(n^3)$ ($c=1, n_0=2$) 集合形式：$O(g(n)) = \\{f(n): \\exists \\text{ 常数 } c, n_0，\\text{满足 } 0 \\leq f(n) \\leq cg(n), \\forall n \\geq n_0\\}$ Ω-记号（渐进下界）：\n$\\Omega(g(n)) = \\{f(n): \\exists \\text{ 常数 } c, n_0，\\text{使得 } 0 \\leq cg(n) \\leq f(n), \\forall n \\geq n_0\\}$ Θ-记号（渐进紧确界）：\n$\\Theta(g(n)) = \\{f(n): \\exists \\text{ 常数 } c_1, c_2, n_0，\\text{满足 } 0 \\leq c_1g(n) \\leq f(n) \\leq c_2g(n), \\forall n \\geq n_0\\}$ o-记号（非渐近紧确的上界）：\n$o(g(n)) = \\{f(n): \\text{对任意正常数 } c \u003e 0，\\text{存在常数 } n_0，\\text{使得对所有 } n \\geq n_0，\\text{有 } 0 \\leq f(n) \u003c cg(n)\\}$ ω-记号（非渐近紧确的下界）：\n$\\omega(g(n)) = \\{f(n): \\text{对任意正常数 } c \u003e 0，\\text{存在常数 } n_0，\\text{使得对所有 } n \\geq n_0，\\text{有 } 0 \\leq cg(n) \u003c f(n)\\}$ 三种分析类型：\n最坏情况（通常使用）： $T(n)$ = 对于任意规模n的输入数据，算法的最大运行时间 平均情况（有时使用）： $T(n)$ = 对于规模为n的所有输入情况，算法的期望运行时间（假设已知输入数据的统计分布） 最佳情况（虚构的）： 所有输入系列之中，运行时间最快的情况下的运行时间 思考题1：紧确界Θ和下界Ω、上界O之间的关系如何？\n解答：\n三者关系可以类比于数学中的等号、大于等于号和小于等于号：\n紧确界 $\\Theta$：$f(n) = \\Theta(g(n))$ 意味着 $f(n)$ 的增长率与 $g(n)$ 相同，即 $f(n)$ 被 $g(n)$ 从上下两边同时夹住。当且仅当 $f(n) = O(g(n))$ 且 $f(n) = \\Omega(g(n))$ 时，$f(n) = \\Theta(g(n))$。\n上界 $O$：$f(n) = O(g(n))$ 意味着 $f(n)$ 的增长率不快于 $g(n)$，$g(n)$ 是 $f(n)$ 的渐近上界。\n下界 $\\Omega$：$f(n) = \\Omega(g(n))$ 意味着 $f(n)$ 的增长率不慢于 $g(n)$，$g(n)$ 是 $f(n)$ 的渐近下界。\n关系总结： $$\\Theta(g(n)) = O(g(n)) \\cap \\Omega(g(n))$$这说明紧确界是上界和下界的交集，表示函数的精确增长率。\n3. 算法设计基本方法 分治策略：\n将原始问题拆分成若干个相似的（规模更小）子问题 递归求解子问题 组合子问题的解，以产生最终答案 动态规划：\n通常用于解决最优化问题，通过做出一组选择来达到最优解 在做出每个选择的同时，通常会生成与原问题形式相同的子问题 关键在于保存每个此类子问题的解，当其重复出现时即可避免重复求解 有时可以将指数时间的算法转换为多项式时间的算法 贪心算法：\n基本思路是使用局部最优解来求得全局最优解 但是，贪心算法并不总是针对所有问题获得最优解 关键是需要知道如何正确区分适用场景 思考题2：快速排序算法的渐进复杂度应该如何表示？\n解答：\n快速排序的复杂度表示取决于分析的角度：\n最坏情况：$O(n^2)$ - 当每次划分都极度不平衡时（如数组已排序或逆序），每次只能减少一个元素，导致递归深度为 $n$。\n平均情况：$\\Theta(n \\log n)$ - 在随机输入或随机化快速排序中，平均情况下划分比较均衡，递归树深度为 $O(\\log n)$。\n最佳情况：$\\Theta(n \\log n)$ - 每次划分都完全平衡时，递归树深度为 $\\log n$。\n实践中的表示： 快速排序通常被描述为平均时间复杂度 $\\Theta(n \\log n)$，最坏情况 $O(n^2)$。通过随机化技术（随机选择主元），可以使最坏情况的概率极低，因此实际应用中快速排序表现优异。\n思考题3：请各说出两种算法，分别是根据分治策略、动态规划、贪心算法设计得来的。\n解答：\n分治策略算法：\n归并排序（Merge Sort）：将数组分成两半，递归排序后合并。时间复杂度 $\\Theta(n \\log n)$。 快速排序（Quick Sort）：选择主元划分数组，递归排序左右两部分。平均时间复杂度 $\\Theta(n \\log n)$。 动态规划算法：\n最长公共子序列（LCS）：通过保存子问题的解（二维表格）避免重复计算。时间复杂度 $O(mn)$。 背包问题（Knapsack Problem）：使用表格记录不同容量和物品数量下的最优解。时间复杂度 $O(nW)$，其中 $n$ 是物品数，$W$ 是背包容量。 贪心算法：\nHuffman编码：根据字符频率构建最优前缀编码树，每次选择频率最小的两个节点合并。 Dijkstra最短路径算法：每次选择距离源点最近的未访问节点，更新其邻居的距离。时间复杂度 $O((V+E) \\log V)$（使用优先队列）。 4. 摊还分析 应用场景：\n用含n个操作的序列 $(o_1, o_2, \\ldots, o_n)$ 维护某数据结构 操作代价：单次操作的代价可能会很大（例如 $\\Theta(n)$），最坏情况下的代价 = $\\max c(o_i)$ 总代价：$\\sum_{i=1}^{n} c_i$，总代价未必就是 $n \\times$ (最坏情况下的单次操作代价) 摊还代价：在上述场景下如何做更紧的分析？（总代价$/n$） 三种典型技术：\n聚合分析： 计算所有操作的总和开销，再除以操作个数，就是平均开销\n核算法： 赋予一个操作的费用，称为它的摊还代价。当一个操作的摊还代价超出其实际代价时，差额部分存入数据结构中的特定对象，存入的差额称为信用。对于后续操作中摊还代价小于实际代价的情况，信用可以用于支付差额。需要确保操作序列的总摊还代价是序列总真实代价的上界。\n势能法： 将势能与整个数据结构相关联，而不是特定对象相关联。将势能释放即可用于支付未来操作的代价。公式：摊余成本 = 真实开销 + 新势能 - 旧势能\n二、相似度搜索 1. 相似性搜索简介 问题定义：\n给定一个查询对象（query object），在大规模图像集合中定位相似的图像。\n核心思想：\n将图像从图像空间（image space）转换到特征空间（feature space） 每张图像可以表示为 $d$ 维特征向量 在特征空间中寻找离查询对象最近的点，即其最近邻居（nearest neighbour, NN） 距离度量：\n在 $d$ 维特征空间中，两点 $p = (p_1, p_2, \\ldots, p_d)$ 和 $q = (q_1, q_2, \\ldots, q_d)$ 之间的距离常用欧氏距离：\n$$d(p, q) = \\sqrt{\\sum_{i=1}^{d} (p_i - q_i)^2}$$最近邻搜索（NN Search）：\n给定查询点 $q$ 和数据集 $S$，找到 $p \\in S$ 使得：\n$$p = \\arg\\min_{x \\in S} d(q, x)$$其中，NN-dist 表示查询点到最近邻的距离。\n2. 一维空间索引方法 (1) 二叉搜索树（Binary Search Tree, BST）\n特点：\n左子树节点值 \u0026lt; 根节点值 \u0026lt; 右子树节点值 搜索时间复杂度：平均 $O(\\log n)$，最坏 $O(n)$（退化为链表） 不平衡的二叉搜索树：\n当插入顺序不当时，树会退化成链表结构 例如：依次插入 5, 10, 15, 20, 25, 22 会形成右偏树 搜索效率降低到 $O(n)$ (2) 红黑树（Red-Black Tree）\n定义： 一种自平衡的二叉搜索树，通过节点染色（红色/黑色）和旋转操作保持平衡。\n性质：\n每个节点是红色或黑色 根节点是黑色 所有叶子节点（NIL/null）是黑色 红色节点的两个子节点都是黑色（不能有两个连续的红色节点） 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点 性能：\n搜索、插入、删除时间复杂度：$O(\\log n)$ 保证最长路径不超过最短路径的2倍 (3) B树（B-Tree）\n特点：\n多路平衡搜索树，适合磁盘存储 每个节点可以有多个键值和子节点 所有叶子节点在同一层 结构组成：\n键值（key）：即索引中记录的主键 指针（pointer）：存储子节点地址的信息 数据（data）：即索引记录中除主键外的数据 性能：\n搜索、插入、删除时间复杂度：$O(\\log_m n)$，其中 $m$ 是节点的最大子节点数 减少磁盘I/O次数 (4) B+树（B+ Tree）\n特点：\nB树的变体，数据库索引的常用结构 所有数据都存储在叶子节点 非叶子节点只存储键值和指针，不存储数据 叶子节点之间通过指针连接，形成有序链表 优势：\n更高的扇出（fan-out），减少树的高度 叶子节点的链表结构便于范围查询 非叶子节点不存储数据，可以在内存中缓存更多索引项 性能：\n搜索时间复杂度：$O(\\log_m n)$ 范围查询效率：$O(\\log_m n + k)$，其中 $k$ 是返回的记录数 3. 多维空间索引方法 (1) R树（R-Tree）\n定义： R树是一种用于空间数据索引的树状数据结构，特别适合处理多维空间对象（如矩形、多边形等）。\n核心思想：\n用**最小边界矩形（MBR, Minimum Bounding Rectangle）**近似表示空间对象 构建层次化的MBR树结构 父节点的MBR包含其所有子节点的MBR 结构特点：\n叶子节点：存储实际的空间对象及其MBR 非叶子节点：存储子节点的MBR 同一层的MBR可能重叠 应用场景：\n地理信息系统（GIS） 计算机辅助设计（CAD） 空间数据库 (2) 空间填充曲线（Space-Filling Curves）\n基本思想： 通过连续曲线遍历多维空间中的所有点，将多维空间映射到一维空间，从而可以使用一维索引方法。\n1. Z曲线（Z-order Curve / Morton Curve）\n特点：\n也称为Morton码 通过交叉组合坐标的二进制位来编码 编码方式：对于二维点 $(x, y)$，交替取 $x$ 和 $y$ 的二进制位 编码示例（2维）：\n1阶Z曲线（$2 \\times 2$ 网格）\n编号顺序: 0 → 1 → 2 → 3 形状: Z字形 2阶Z曲线（$4 \\times 4$ 网格）：\n编号: 00 → 01 → 02 → 03 → \u0026hellip; → 30 → 31 → 32 → 33 （二阶其实就是又多了一个符号位，对4个$2 \\times 2$的网格进行再次编号$0,1,2,3$） 每个$2 \\times 2$子区域内部按Z字形连接 优点：\n编码简单，计算效率高 空间局部性较好 缺点：\n曲线不连续，存在跳跃 局部性保持不如Hilbert曲线 2. Hilbert曲线（Hilbert Curve）\n特点：\n连续的分形曲线 更好地保持空间局部性 相邻的曲线位置对应相邻的空间位置 递归构造：\n1阶Hilbert曲线：连接$2 \\times 2$网格中的4个点 $n$阶Hilbert曲线：将空间分为4个象限，每个象限是上一阶的曲线，起点经过**顺时针旋转$90^\\circ$**后连接起来 优点：\n更好的聚类性：空间上接近的点在曲线上也接近 曲线连续，无跳跃 缺点：\n编码计算相对复杂 生成算法复杂度较高 性能比较：\n特性 Z曲线 Hilbert曲线 计算复杂度 低 中 空间局部性 较好 优秀 连续性 不连续 连续 聚类效果 一般 优秀 4. 四叉树索引（Quadtree Index） (1) 定义与构造方法\n核心思想： 递归地将二维空间分割成四个相等的象限，直到每个区域满足特定条件。\n构造方法：\n将整个数据空间分割成四个相等的矩形，分别对应： 西北（NW, Northwest） 东北（NE, Northeast） 西南（SW, Southwest） 东南（SE, Southeast） 若每个象限内包含的要素不超过给定的**桶量（bucket size）**则停止 否则对超过桶量的矩形按照同样的方法进行划分 直到桶量满足要求或者不再减少为止，最终形成一颗有层次的四叉树 (2) 优缺点分析\n优点：\n一定程度上实现了地理要素真正被网格分割 保证了桶内要素不超过某个量，提高了检索效率 缺点：\n对于海量数据，四叉树的深度会很深，影响查询效率 可扩展性不如网格索引： 当扩大区域时，需要重新划分空间区域，重建四叉树 当增加或删除一个对象，可能导致深度加一或减一 叶节点也有可能重新定位 5. 网格索引（Grid Index） （1） 基本思想\n将研究区域用横竖线划分成大小相等或不等的网格，每个网格可视为一个桶（bucket）。\n索引构建：\n将空间划分为大小相等或不等的网格 记录落入每一个网格区域内的空间实体编号 建立网格号到对象列表的映射（倒排索引） 查询过程：\n先计算出查询对象所在网格 再在该网格中快速查询所选空间实体 （2） 倒排索引示例\n案例： 有三个制图物体：一条河流，一个湖泊，一条省界，关键字分别是 5, 11 和 23。\n对象-网格映射\n河流（ID=5）穿过的栅格：2, 34, 35, 67, 68 湖泊（ID=11）覆盖的栅格：68, 69, 100, 101 省界（ID=23）通过的栅格：5, 37, 36, 35, 67, 99, 98, 97 查询示例\n查询网格68：返回 [5, 11]（河流和湖泊） 查询网格35：返回 [5, 23]（河流和省界） （3） 优缺点分析\n优点\n简单：实现容易，概念直观 易于实现：数据结构简单，编码量少 缺点：网格大小影响检索性能\n三、高维空间的相似性搜索 1. 高维空间的特性 (1) 维度灾难问题\n问题引入： 在各维度上划分原始空间，生成若干个子空间，再将各点划至各子空间内。\n低维空间（2维或3维）：容易理解，且较为合理\n高维空间\n（例如100维）：\n将会产生 $2^{100} = 10^{30}$ 个子空间 几乎所有子空间都是空的 (2) 超立方体特性\n考虑超立方体，其边长为 0.95。\n2维情况：\n任意点在此子空间内的概率：$0.95^2 ≈ 0.90$ 100维情况：\n任意点在此子空间内的概率：$0.95^{100} ≈ 0.0059$ 结论： 随着维度增加，点落在中心区域的概率急剧下降。\n(3) 超球体特性\n考虑最大的超球（内切于单位立方体）。\n2维空间：\n超球的体积为 $\\pi/4 = 0.785$ 40维空间：\n超球的体积为 $3.278 × 10^{-21}$ 关键发现：\n显然，主要空间都在边边角角上 至少需要 $3 × 10^{20}$ 个点，才可期望在超球内部至少有一个点 2. 访问概率 (1) 问题定义\n核心问题： 给定任一查询，某个特定区域必定会被检索到的概率是多少？\n(2) 访问规则\n重要性质： 如果右边的区域先被访问，左边的也必须被访问到。这意味着在高维空间中，查询半径内的区域访问具有传递性。\n(3) 实验结果\n不同区域形状的访问概率：\n结论： 在维度增加到30-50维时，每个区域被访问到的概率极高。\n含义： 在高维空间中，传统的空间划分索引方法失效，因为几乎所有区域都需要被访问。\n3. 签名文件（Signature Files） (1) 设计思路\n核心理念：\n原始数据规模大、处理难度高 针对原始数据对象分别构建小规模的签名数据 这些数据能够以过滤器的角色支持谓词查询 (2) 工作流程\n处理步骤：\n使用哈希函数将原始数据映射为签名 签名文件作为第一层过滤器 只有通过过滤的数据才访问原始数据 优势：\n签名文件体积小，可以快速扫描 减少对原始数据的访问次数 适合作为预处理层 4. 向量近似文件（VA-File） (1) 算法概述\n来源： VLDB 1998\n基本思想：\n通过 **approximation（近似）**方式创建 VA-File 作为 Filter 先过滤大部分不可能的候选点 只对可能的候选点计算精确距离 (2) 数据结构\n空间划分：\n编码方式：\n将每个维度划分成若干个区间（例如用2比特表示4个区间：00, 01, 10, 11） 每个点用所在网格的编码表示 例如：点(0.1, 0.9) → 编码 \u0026ldquo;00 11\u0026rdquo; 示例：\n向量数据 VA-File编码 (0.1, 0.9) 00 11 (0.6, 0.8) 10 11 (0.1, 0.4) 00 01 (0.9, 0.1) 11 00 (3) 最小和最大边界\n关键概念：\nminBnd（最小边界）：查询点到网格的最小可能距离 maxBnd（最大边界）：查询点到网格的最大可能距离 重要性质： 各栅格的边界之间的距离可以预先计算！\n两阶段算法\n第1阶段：过滤\n针对每一点计算 minBnd 和 maxBnd 值 消除无法成为最近邻居的那些点 过滤一些点的minBnd小于已知最近邻的maxBnd值 approx. minBnd maxBnd rank 10 11 0.39 0.68 2 11 00 0.11 0.45 1 00 11 0.58 - × 00 01 0.47 - × 第2阶段：精炼\n根据 minBnd 以递增顺序访问各向量 计算真实的距离 当 minBnd 超出已知的最近邻居时，终止 (4) 性能分析\n块选择率随维度变化\n实验条件：N=100,000，均匀分布，k=10\n观察\n低维（\u0026lt;10维）：需要访问约3%的向量块 中维（10-30维）：访问率下降到约0.5% 高维（\u0026gt;30维）：访问率稳定在约0.3% 与树结构对比、模拟数据（N=50,000，k=10）、图像数据（N=50,000，k=10）、**运行时间对比：**详见PPT\n5. 深入理解：Contrast (1) 定义\nContrast 描述最近邻居与最远邻居之间的差异性高低：\n$$\\text{contrast} = \\frac{D_{\\max} - D_{\\min}}{D_{\\min}}$$(2) 维度影响\n当维度数量增多时，通常 contrast 值会降低 这意味着在高维空间中，所有点到查询点的距离趋于相似 (3) 距离分布\n观察： 对于任意点来说，到其他各个点的距离的分布情况随维度变化。\n不同维度的距离分布：\nd=2：分布较平缓，有明显的近邻和远邻区分 d=6：分布变得更集中 d=14：分布形状变得\u0026quot;尖锐\u0026quot; d=25：分布极度集中，几乎所有点距离都接近平均值 结论： 显然，当维度越高时，整体形状会越\u0026quot;尖锐\u0026quot;。\n(4) 几何直观\n从另一个视角看：\n在低维空间，查询点周围的点分布有明显的距离差异 在高维空间，所有点似乎都在同一个\u0026quot;超球面\u0026quot;上 这使得\u0026quot;最近邻\u0026ldquo;的概念变得模糊 第二讲 尾不等式 一、尾不等式分析概要 1. 问题引入 背景：\n很多情况下，精确计算一个随机事件的概率是很困难的。\n案例： 一个服从参数分别为 1,000 和 1/3 的二项分布随机变量 X，计算尾概率 Pr[X \u0026lt; 100]。\n解决思路：\n当精确计算比较困难时，利用近似方法求得概率的近似值不失为一种理想的选择 但近似方法又会涉及到另一个问题：近似值偏离真实值到底有多大？ 问题引入1：抛硬币问题\n假设抛一枚均匀的硬币，抛得正面和反面朝上的概率都为0.5，而且每次抛币与前次结果无关。\n直觉理解：直觉上来说，抛的次数越多正面朝上的频率越接近于0.5；当抛硬币的次数达到一定次数后，正面朝上的频率非常接近于0.5，波动很小 核心问题：抛多少次才能以95%的概率保证正面朝上的频率和真实概率间的差距小于某个阈值（比如0.125）呢？ 问题引入2：蒙特卡罗方法\n用蒙特卡罗方法（Monte Carlo方法）近似计算π的方法，如果随机打点 1,000,000次能保证以95%的概率近似π到2位、3位…小数吗?\n注： 蒙特卡罗法也称统计模拟法、统计试验法。是把概率现象作为研究对象的数值模拟方法。是按抽样调查法求取统计值来推定未知特性量的计算方法。\n2. 求解尾概率不等式的基本方法 求解一个问题的尾概率的方法通常可以分为两大类：\n(1) 定积分、查表法\n适用场景：当明确知道问题所对应的概率密度函数时 方法：可以采用定积分的方式，把尾概率所对应的区域累积起来；简单来说，可以通过查表法（概率教科书后面的表格）或者使用R/Matlab等软件来做 案例：标准正态分布表可以查询不同区间的概率值 (2) 尾概率不等式法\n适用场景：当无法确切知道对应的概率密度函数的时候 常见的尾概率不等式包括：Markov不等式、Chebyshev不等式、Chernoff不等式 二、三个常见的尾不等式 1. Markov不等式 定义： 令 X 为样本空间上的非负随机变量，对任意的一个正实数 a，有\n$$P(X \\geq a) \\leq \\frac{E[X]}{a}$$证明：\n假设 A 是一个事件，定义\n$$A = {\\omega \\in \\Omega | X(\\omega) \\geq a}$$则随机变量的期望可以计算为：\n$$E(X) = \\sum_{\\omega \\in \\Omega} X(\\omega)P(\\omega)$$$$= \\sum_{\\omega \\in A} X(\\omega)P(\\omega) + \\sum_{\\omega \\notin A} X(\\omega)P(\\omega)$$$$\\geq a \\cdot P(A) + \\sum_{\\omega \\notin A} X(\\omega)P(\\omega)$$$$\\geq a \\cdot P(A)$$因此，结论成立，即\n$$P(A) = P(X \\geq a) \\leq \\frac{E(X)}{a}$$案例分析：\n令随机变量X为抛n次均匀硬币正面向上的次数，运用Markov不等式计算n次抛币结果中正面朝上的次数超过3n/4的概率上界。\n解：因为随机变量X是一个n次独立的贝努里实验结果，因此 $E(X) = np$，其中 p 为每次贝努里实验的成功概率。根据Markov不等式，$$P(X \u003e 3n/4) \\leq \\frac{E[X]}{3n/4} = \\frac{n/2}{3n/4} = \\frac{2}{3}$$ 分析：直觉上说，硬币抛的次数越多，正面向上的频率应该越接近于1/2，那么频率大于3/4的概率应该越小。而Markov不等式给出的上界与硬币抛的次数n无关。可以看出，Markov不等式给出的尾概率上界比较松。 2. Chebyshev不等式 定义： 令X为定义在样本空间Ω上的随机变量，令E(X)和Var(X)分别为X的期望和方差，对任意的一个正实数r，有\n$$P(|X - E(X)| \\geq r) \\leq \\frac{Var(X)}{r^2}$$证明思路：\n不难看出，\n$$P(|X - E(X)| \\geq r) = P((X - E(X))^2 \\geq r^2)$$已知 $E((X - E(X))^2) = Var(X)$，对上式中的尾概率运用 Markov 不等式得到\n$$P((X(\\omega) - E(X))^2 \\geq r^2) \\leq \\frac{E((X(\\omega) - E(X))^2)}{r^2} = \\frac{Var(X)}{r^2}$$因此，结论成立。\n案例分析：\n令随机变量X为抛n次均匀硬币正面向上的次数，运用Chebyshev不等式计算n次抛币结果中正面朝上的次数超过3n/4的概率上界。\n解：已知 $E[X] = np$；$Var[X] = np(1-p)$。$$P(X \u003e 3n/4) = P(X/n \u003e 3/4) = P(X/n - 1/2 \u003e 1/4)$$ $$\u003c P(|X/n - 1/2| \u003e 1/4) \\leq \\frac{16np(1-p)}{n^2} = \\frac{4}{n}$$ 结论：显然，当 n=80 时，这个概率就小于 5% 了。这说明 Chebyshev不等式给出的界比 Markov不等式更紧。 3. Chernoff不等式 基本概念：\n独立Bernoulli试验：令 $X_1, X_2, ..., X_n$ 为独立的n个事件，$Pr[X_i=1] = p$；$Pr[X_i=0] = 1-p$。令 $X = \\sum X_i$，则称X具有二项分布。 Poisson试验：令 $X_1, X_2, ..., X_n$ 为独立的n个事件，$Pr[X_i=1] = p_i$；$Pr[X_i=0] = 1-p_i$。令 $X = \\sum X_i$。易知，Bernoulli试验是Poisson试验的特例。 Chernoff不等式（简化版）：\n若 $X_i$ 为定义在样本空间Ω上的n个独立贝努里随机变量，且 $P(X_i=1) = p_i$。令 $X = \\sum_{i=1}^{n} X_i$ 和 $\\mu = \\sum_{i=1}^{n} p_i$，对任意小的 $\\delta \\in (0,1)$，则以下不等式成立：\n$$P(X \u003c (1-\\delta)\\mu) \u003c \\exp(-\\mu\\delta^2/2)$$$$P(X \u003e (1+\\delta)\\mu) \u003c \\exp(-\\mu\\delta^2/4)$$Chernoff不等式（精确版）：\n$$P(X \u003c (1-\\delta)\\mu) \u003c \\left(\\frac{e^{-\\delta}}{(1-\\delta)^{(1-\\delta)}}\\right)^\\mu$$$$P(X \u003e (1+\\delta)\\mu) \u003c \\left(\\frac{e^{\\delta}}{(1+\\delta)^{(1+\\delta)}}\\right)^\\mu$$证明思路：\n证明第一个不等式。对任意 $t \u003e 0$，\n$$P(X \u003c (1-\\delta)\\mu) = P(\\exp(-tX) \u003e \\exp(-t(1-\\delta)\\mu))$$$$\u003c \\frac{\\prod_{i=1}^{n} E(\\exp(-tX_i))}{\\exp(-t(1-\\delta)\\mu)}$$因为 $(1-x \u003c e^{-x})$，所以\n$$E(\\exp(-tX_i)) = p_ie^{-t} + (1-p_i)$$$$= 1 - p_i(1-e^{-t})$$$$\u003c \\exp(p_i(e^{-t}-1))$$因此，\n$$\\prod_{i=1}^{n} E(\\exp(-tX_i)) \u003c \\prod_{i=1}^{n} \\exp(p_i(e^{-t}-1))$$$$= \\exp(\\mu(e^{-t}-1))$$进一步的，\n$$P(X \u003c (1-\\delta)\\mu) \u003c \\frac{\\exp(\\mu(e^{-t}-1))}{\\exp(-t(1-\\delta)\\mu)} = \\exp(\\mu(e^{-t}+t-t\\delta-1))$$上式中的上界是关于变量 t 的函数，随着 t 取值的变化，概率上界也在变化。因此可以通过择 t 的值，得到概率上界的最小值。为了获得概率上界的最小值，对 $\\mu(e^{-t}+t-t\\delta-1)$ 关于 t 求导，并令其为 0，得到当 $t = \\ln\\frac{1}{1-\\delta}$ 时，概率上界取到最小值。将 $t = \\ln\\frac{1}{1-\\delta}$ 代入公式，可以得到结论。\n应用案例：\n案例1：球队胜率\n某球队赢每一场比赛的概率是1/3。假设比赛结果相互独立，试求他们在一个有n场比赛的赛季获得一半以上场次胜利的概率的上界。\n分析：$X_i$：获胜为1，输为0。则和 $Y = \\sum X_i$，$\\mu = E[Y] = n/3$；$\\delta = 1/2$。$$P(Y \u003e (1+0.5)\\mu) \u003c \\exp(-\\mu\\delta^2/4) = \\exp\\left(-\\frac{n}{3} \\cdot \\frac{(1/2)^2}{4}\\right) = \\exp(-n/48)$$ 结论：若 n=40，概率不高于 0.43；若 n=100，概率不高于 0.12。备注：若调用更精确版本，这两个概率分别为：0.23、0.027 案例1（补充）\n某球队赢每一场比赛的概率是3/4。假设比赛结果相互独立，试求他们在一个有n场比赛的赛季输掉一半以上场次的概率的上界。\n分析：$X_i$：获胜为1，输为0。则和 $Y = \\sum X_i$，$\\mu = E[Y] = 3n/4$；此时，$\\delta = 1/3$。$$P(Y \u003c n/2) = P(Y \u003c (1-1/3)\\mu) \u003c \\exp(-\\mu\\delta^2/2) = \\exp(-n/24)$$ 结论：n=40，概率小于 0.19；n=100，概率小于 0.015 案例2：球和箱子\n均匀、独立地将n个球放置到n个箱子里。令随机变量 $Y_1$ 表示放到第一个箱子里的球的个数。希望确定值m，使得 $Pr[Y_1 \u003e m] \\leq 1/n^2$。\n分析：易知，$p_i = 1/n$；$\\mu = 1$。$$P[X \u003e (1+\\delta)\\mu] \u003c \\exp(-\\mu\\delta^2/4) = 1/n^2$$两边取对数：$\\mu\\delta^2/4 = 2\\ln n$ ⇒ $\\delta = \\sqrt{8\\ln n}$ 案例3：集合平衡（Set Balancing）\n考虑一个 n×m 的矩阵A，各项为0或1，如何寻找向量 $b \\in {-1, +1}^m$，使得 $||Ab||_\\infty$ 最小。\n问题建模：令 $c = Ab$，则 $||Ab||*\\infty = \\max(c_i)$。考虑m个物品（subject），各有最多n个特性（feature），构成一个 n×m 的矩阵A。各列代表一个物品，各行代表特性。项 $a*{ij} \\in {0, 1}$ 表示物品j是否拥有特性i。 核心思想：通过向量b将所有物品划分成两个分组，每一个项的值 $c_i$ 表示这两个分组在第i个特性上的划分的差值。如果能够使得这样的差值在各个特性上均很小，那么就说明各个特性均比较均匀地划分到两个组之中。 算法设计：构造了一个极度简单的算法来构成向量b：各项 $b_i$ 随机均匀地从 {-1, +1} 中选取，即：$$b_i = \\begin{cases} -1 \u0026 \\text{with probability } 1/2 \\ +1 \u0026 \\text{with probability } 1/2 \\end{cases}$$这个算法极度简单，因为根本没有考虑A。 分析：考虑矩阵 A 的第 i 行，则 $c_i = \\sum_j a_{ij}b_j$。令 k 是该行中非0项的个数。$|c_i|$ 的期望值是0。当 $k \\leq 2\\sqrt{2m\\ln n}$ 时，显然 $|c_i|$ 小于等于式子右边。因此，主要考虑k的值比较大的情况。值为+1的项数的期望值为 k/2。当 $c_i \u003c -2\\sqrt{2m\\ln n}$ 时，正的 $b_i$\u0026rsquo;s 不超过 $\\frac{k}{2} - \\sqrt{2m\\ln n} = (1-\\delta)\\mu$。应用Chernoff不等式，得：$$\\exp\\left(-\\frac{\\mu\\delta^2}{2}\\right) = \\exp\\left(-\\frac{k}{2} \\cdot \\frac{8m\\ln n}{2k^2}\\right) = \\exp\\left(-\\frac{2m\\ln n}{k}\\right) \\leq \\exp\\left(-\\frac{2m\\ln n}{m}\\right) \\leq n^{-2}$$说明对单个 $c_i$ 而言，单边的最大概率是 $n^{-2}$。而在该例中，有双边概率，因此：$$Pr[|c_i| \u003e 2\\sqrt{2m\\ln n}] \\leq \\frac{2}{n^2}$$最后，取得n行的一个最终值：$$Pr[||Ab||_\\infty \u003e 2\\sqrt{2m\\ln n}] \\leq n \\cdot Pr[|c_i| \u003e 2\\sqrt{2m\\ln n}] \\leq \\frac{2}{n}$$ 案例4：抛硬币（Chernoff版本）\n令随机变量X为抛n次均匀硬币正面向上的次数，运用Chernoff不等式计算n次抛币结果中正面朝上的次数超过3n/4的概率上界。\n解：已知 $E(X) = np = n/2$。运用Chernoff不等式，$$P(X \u003e 3n/4) = P(X \u003e (1+1/2) \\cdot n/2)$$ $$= P(X \u003e (1+1/2)E(X))$$ $$\u003c \\exp\\left(-\\frac{n}{2} \\cdot (1/2)^2 / 4\\right)$$ $$= \\exp(-n/32)$$ 结果：当 n=50 时，概率为：0.21；当 n=80 时，概率为：0.08；当 n=300 时，概率为：0.000085 4. 尾概率不等式的实际使用 关于尾概率不等式的实际使用，其实是要回答三类问题。这里的原因在于总共有三个控制参数：一个是次数 n，一个是偏移期望的程度 δ，另一个是最终的置信度参数。总是可以固定两个参数，求另外一个参数的情况。\n问题类型：\n其一：已知采样次数和偏移的程度，求解置信度 其二：已知采样次数和置信度，求解偏移的程度 其三：已知置信度和偏移的程度，求解采样次数 第一类问题示例：\n例如：投掷了硬币1000次，总的期望值是500，则当 δ=0.2 的时候，即是在询问正面朝上的总次数超过了 (1+0.2)×500=600 的概率。\n已知：n=1000，μ=1/2，δ=0.2，求解置信度 根据Chernoff不等式：$$P[X \u003e (1+\\delta)n\\mu] \u003c \\exp(-n\\mu\\delta^2/4)$$即：$P[X \u003e 600] \u003c \\exp(-5) = 0.0067$ 第二类问题示例：\n例如：总共投掷了1000次，总的期望值是500，则当想要知道正面朝上的概率不低于95%时，能够确保的正面朝上的次数是几次。\n已知：n=1000，μ=1/2，置信度为0.05，求解偏移程度 根据Chernoff不等式，$P[X \u003e (1+\\delta)n\\mu] \u003c \\exp(-n\\mu\\delta^2/4)$ 令 $\\exp(-n\\mu\\delta^2/4) = 0.05$，则：δ=0.15，(1+0.15)×500=575 则能够以95%的概率确保的正面朝上的次数为575次 第三类问题示例：\n至少需要投掷几次硬币，才可确保正面朝上的比率在0.6以下的概率不低于95%。\n分析：μ=1/2；(1+δ)μ=0.6 ⇒ δ=0.2 根据Chernoff不等式：$P[X \u003e (1+\\delta)n\\mu] \u003c \\exp(-n\\mu\\delta^2/4)$ 可以得到：$\\exp(-0.04n\\mu/4) \u003c 0.05$ 求解以上式子，得到：n \u0026gt; 599.1 所以至少需要投掷600次硬币才能保证正面朝上的比率在0.6以下的概率不低于95% 三、计数问题 1. Morris算法 问题背景与动机：\n场景描述：某电子商城想记录某本畅销书的销售量 传统方法：用一个整数变量来描述，初始化为0，每卖出一本则加1 问题分析：用二进制表示数n需要 $\\lceil \\log_2 n \\rceil$ 位，即计算机需要 $\\lceil \\log_2 n \\rceil$ 位存储整数n。当n值比较大时，存储开销会很大，可否降低开销？ Morris算法原理：\n核心思想是只需要 $\\lceil \\log_2 \\log_2 n \\rceil$ 位就可以近似表示一个大整数。\n算法描述：\nMorris算法 Input: 事件流F Output: 指定事件的计数 C 1 初始化计数器X=0 2 while 事件流F未结束 do 3 if 指定事件发生 then 4 以 1/2^X 的概率更新 X=X+1 5 C=2^X-1 6 return C 两个核心操作：\n更新操作：当指定事件发生时，以 $1/2^X$ 的概率更新X的值为X+1；以 $1-1/2^X$ 的概率保持X的值不变 估计计数结果：返回近似估计值 $C = 2^X - 1$ Morris算法示例：\n事件流 真实计数 抽样概率 X的值 计数估计值 0 1 0 0 1 1 1/2 1 1 1 2 1/2 1 1 1 3 1/4 2 3 1 4 1/4 2 3 1 5 1/4 2 3 1 6 1/4 2 3 1 7 1/8 3 7 1 8 1/8 3 7 Morris算法理论分析：\n定理：令事件真实计数为N，$X_N$ 是Morris算法维护的计数器，则其输出的估计值 $2^{X_N}-1$ 是真实计数N的无偏估计。\n证明过程：注意到当 $X_{N-1} = j$ 时，$X_N = j+1$ 的概率为 $2^{-j}$，而保持 $X_N = j$ 的概率为 $1-2^{-j}$，因此\n$$E(2^{X_N}) = E(E(2^{X_N}|X_{N-1}=j))$$$$= \\sum_{j \\geq 1} P(X_{N-1}=j)E(2^{X_N}|X_{N-1}=j)$$接下来，条件数学期望 $E(2^{X_N}|X_{N-1}=j)$ 可以计算如下：\n$$E(2^{X_N}|X_{N-1}=j) = 2^{j+1}2^{-j} + 2^j(1-2^{-j})$$$$= 2^j + 2 - 1 = 2^j + 1$$最后，运用数学归纳法证明最终结果。\n当 N=1 时，$X_N = 1$。因此，$E(2^1-1) = 2^1-1 = 1$ 结论成立。\n假设当 N=k 时，结论 $E(2^{X_k}-1) = k$ 也成立。\n当 N=k+1 时，\n$$E(2^{X_{k+1}}) = E(E(2^{X_{k+1}}|X_k=j))$$$$= \\sum_{j \\geq 1} P(X_k=j)E(2^{X_{k+1}}|X_k=j)$$$$= \\sum_{j \\geq 1} P(X_k=j)(2^j+1)$$$$= \\sum_{j \\geq 1} P(X_k=j)(2^j-1) + \\sum_{j \\geq 1} P(X_k=j)2$$$$= E(2^{X_k}-1) + 2$$$$= k + 2$$即当 N=k+1 时，有 $E(2^{X_{k+1}}-1) = k+1$ 也成立。\n方差分析：\n$$Var(2^{X_N}) = E((2^{X_N})^2) - (E(2^{X_N}))^2$$$$= E(2^{2X_N}) - (N+1)^2$$通过递推可以得到：\n$$E(2^{2X_N}) = \\frac{3N(N+1)}{2} + 1$$所以，\n$$Var(2^{X_N}) \\approx \\frac{1}{2}N^2$$ 2. Morris+算法 问题分析与改进思路：\nMorris算法的劣势：虽然Morris算法给出了真实计数的无偏估计，但随着计数N的增加，该估计的方差以二次多项式的形式在增加 统计学重要结论：令 $X_1, X_2, ..., X_n$ 为n个独立同分布的样本，且对任意 $1 \\leq i \\leq n$ 有 $E(X_i) = \\mu$ 和 $Var(X_i) = \\sigma^2$，那么样本均值的期望与方差分别为$$E(\\sum X_i / n) = \\mu$$ $$Var(\\sum X_i / n) = \\sigma^2 / n$$ 结论：通过多次估计取平均可以获取波动更小的计数的无偏估计 Morris+算法描述：\n核心思想：对事件计数的每次更新维护n个计数，当事件流结束时，计算这n个计数的平均值，会得到波动更小的真实计数的无偏估计。\nMorris+算法 输入：事件流F, δ和ε 输出：指定事件计数C 01 n = ⌈1/δε²⌉ 02 初始化计数数组 X[1…n]=0 03 while 事件流F未结束 do 04 if 指定事件发生 then 05 for i=1 to n do 06 以1/2^Xi的概率更新Xi=Xi+1 07 for i=1 to n do 08 C=C+2^Xi-1 09 C=C/n 10 return C Morris+算法分析：\n根据方差的性质，相对于Morris算法，Morris+算法返回的计数估计值的方差减小到了 $O(N^2/n)$。\n根据Chebyshev不等式，\n$$P(|\\hat{N} - N| \u003e \\varepsilon N) \u003c \\frac{Var(\\hat{N})}{\\varepsilon^2 N^2}$$由于 $Var(\\hat{N}) = O(N^2/n)$，因此：\n$$P(|\\hat{N} - N| \u003e \\varepsilon N) \u003c \\frac{O(N^2/n)}{\\varepsilon^2 N^2} \\approx \\frac{1}{n\\varepsilon^2}$$令 $\\frac{1}{n\\varepsilon^2} \u003c \\delta$，即 $n = O(1/\\delta\\varepsilon^2)$ 时，$P(|\\hat{N} - N| \u003e \\varepsilon N) \u003c \\delta$\n这表明事件计数的估计值是偏离真实值N大于εN的概率小于δ。此时，称 $\\hat{N}$ 为N的 (ε,δ)近似估计。\n复杂度分析：\n空间复杂度：总共有 $O(1/\\delta\\varepsilon^2)$ 个计数器，每个计数器占用 $O(\\log\\log n)$ 位。因此，空间复杂度是：$O(\\log\\log n / \\delta\\varepsilon^2)$ 时间复杂度（Per-tuple processing cost）：每处理一个元素，需要循环 $O(1/\\delta\\varepsilon^2)$ 次，因此开销是 $O(1/\\delta\\varepsilon^2)$ 3. Morris++算法 拔河（Tug-of-War）思想：\n当目标概率是δ时，可以将实例数从 $1/\\delta$ 降至 $\\log(1/\\delta)$。\n核心思路：运行 t 个Morris+实例，每个实例的失败概率为 1/3，即：$$P(|\\hat{N} - N| \u003e \\varepsilon N) \u003c \\frac{1}{2k\\varepsilon^2} = \\frac{1}{3}$$注：每个Morris+运行了k个Morris实例，且 $k = O(1/\\varepsilon^2)$。然后，输出所有 t 个Morris+实例的中位数估计值。 关键观察：失败的 Morris+ 实例的预期数量不超过 t/3。如果中位数估计值出错，则表明至少一半Morris+ 实例失败了，表示失败实例的数量至少偏离期望值达到 t/6。（原因：t/3 + t/6 = t/2） Morris++算法描述：\nMorris++算法 输入：事件流F, δ和ε 输出：指定事件计数C 01 n = ⌈ln1/δ⌉, m = ⌈1/ε²⌉ 02 初始化数组X[1…n, 1…m]=0, C[1…n]=0 03 while 事件流F未结束 do 04 if 指定事件发生 then 05 for i=1 to n do 06 for j=1 to m do 07 以1/2^Xij的概率更新Xij=Xij+1 08 for i=1 to n do 09 for j=1 to m 10 Ci=Ci+(2^Xij-1) 11 Ci = Ci/n 12 C=C[1…n]的中位数 13 return C Morris++算法分析：\n定义：\n$$Y_i = \\begin{cases} 1, \u0026 \\text{if } |\\frac{1}{k}\\sum_{j=1}^{k} \\hat{n}_{ij} - n| \u003e \\varepsilon N \\ 0, \u0026 \\text{Otherwise} \\end{cases}$$由于 $k = O(1/\\varepsilon^2)$，可知：$P(Y_i=1) \u003c 1/3$\n由于 $\\mu = E(\\sum Y_i) = t/3$，通过Chernoff不等式，可知\n$$P(\\sum Y_i \u003e t/2) \\leq P(\\sum Y_i \u003e (1+1/2)\\mu)$$$$\\leq \\exp(-\\mu(1/2)^2/4) \u003c \\exp(-t/48) \u003c \\delta$$因此：可知：$t = O(\\log 1/\\delta)$\n最终结论：可以用 $O(\\log(1/\\delta)/\\varepsilon^2)$ 个Morris实例的复杂度来得到 (ε, δ) 近似的算法。\n进一步分析：\n总体思路：利用tug-of-war方法降低了空间复杂度 综合运用了Chebyshev不等式和Chernoff不等式： 在调用Chebyshev不等式时，目的是将失败概率降低到常数量级（例如1/3） 在调用Chernoff不等式时，才将失败概率降低到任意一个给定阈值 思考：第一步的失败概率如果是1/4，或者1/2，是否也可行？ 第三讲 数据流 一、数据流模型 数据流模型描述了数据以流的形式到达，只能顺序访问一次或有限次的计算场景。\n数据流的特点：\n数据量巨大，无法全部存储 数据到达速度快，需要实时处理 只能进行一次或有限次扫描 需要在有限空间内近似计算 典型应用：\n网络流量监控 金融交易分析 社交媒体数据处理 IoT传感器数据 数据流算法的目标：\n使用亚线性（sublinear）空间 提供可证明的近似保证 单次扫描或少量扫描 二、频繁元素-确定性算法 问题定义： 找出数据流中出现频率超过某个阈值的元素（heavy hitters）。\nMisra-Gries算法：\n算法描述：\n维护最多k个计数器 对于每个到来的元素： 如果已有计数器，增加其计数 如果没有计数器且有空位，创建新计数器 如果没有空位，所有计数器减1，删除值为0的计数器 输出计数器中的元素 性能保证：\n空间复杂度：O(k) 如果元素出现次数 \u0026gt; n/k，一定会被找到 可能有假阳性，但可以通过二次扫描验证 应用：\n找出访问量最大的网页 检测网络中的大流量 识别热门话题 三、频繁元素-随机算法 Count-Min Sketch算法：\n数据结构：\nd × w 的二维计数器数组 d个独立的哈希函数h₁, h₂, \u0026hellip;, h_d 算法操作：\n更新（插入元素x）：\n对于 i = 1 到 d： count[i][hᵢ(x)] += 1 查询（估计元素x的频率）：\n返回 min{count[i][hᵢ(x)] : i = 1..d} 性能保证：\n空间复杂度：O(d × w) 误差界：ε·n (n为总元素数)，概率至少1-δ 选择w = ⌈e/ε⌉, d = ⌈ln(1/δ)⌉ 只会高估，不会低估 优势：\n空间效率高 支持点查询和范围查询 可以处理删除操作（使用带符号的计数） 四、滑动窗口模型 问题描述： 只关心最近W个元素的统计特性，更早的数据被丢弃。\n挑战：\n无法存储所有W个元素 需要及时更新统计信息 DGIM算法（用于计数）：\n基本思想：\n将窗口划分为桶（bucket） 每个桶代表一段连续的1 桶的大小是2的幂次 维护O(log W)个桶 桶的性质：\n每种大小的桶最多2个 桶按时间戳排序 最老的桶可能不完整 查询操作： 统计窗口内1的个数 ≈ 完整桶的大小之和 + 半个最老桶\n误差保证：\n相对误差：最多50% 可以通过增加每种大小桶的数量来降低误差 应用扩展：\n滑动窗口中的平均值 滑动窗口中的中位数（近似） 滑动窗口中的distinct计数 第四讲 分布式数据流 一、分布式数据流模型 在分布式环境中，数据流分散在多个节点上，需要协调多个节点进行计算。\n系统架构：\n多个监测节点：每个节点观察部分数据流 协调节点：汇总和处理来自监测节点的信息 通信约束：最小化节点间的通信量 挑战：\n数据分散性 通信开销 同步问题 节点故障 典型场景：\n分布式网络监控 多数据中心的日志分析 边缘计算 CDN流量统计 二、聚集查询 问题定义： 计算分布在多个节点上的数据的聚集函数（如SUM、COUNT、AVG）。\n基本方法：\n1. 连续聚集：\n每个节点维护本地的统计信息 周期性发送给协调节点 协调节点汇总计算全局结果 2. 快照聚集：\n在特定时刻获取全局快照 需要处理同步问题 使用逻辑时钟或物理时钟 优化技术：\n采样与估计：\n不发送所有数据，只发送样本 使用统计方法估计全局结果 权衡精度和通信开销 增量更新：\n只发送变化部分 减少冗余通信 适用于变化缓慢的数据 数据结构支持：\n使用Count-Min Sketch等概要结构 可以在协调节点合并 支持分布式查询 三、topk监控 问题定义： 实时监控分布式系统中全局的top-k元素（如最热门的k个商品、最活跃的k个用户）。\n挑战：\n全局top-k可能不在任何单个节点的局部top-k中 需要在精度和通信量之间平衡 数据分布可能高度倾斜 解决方案：\n1. 阈值算法：\n协调节点维护全局top-k的阈值θ 每个节点报告超过θ的元素 动态调整θ以平衡通信量 算法流程：\n初始化：θ = 0 循环： 1. 每个节点报告频率 \u0026gt; θ 的元素 2. 协调节点更新全局top-k 3. 计算新阈值θ（如第k大元素的频率） 4. 将θ广播给各节点 2. 采样方法：\n各节点以概率p采样元素 上传采样的数据到协调节点 基于采样数据估计全局top-k 3. 层次化监控：\n构建监控树 中间节点聚合子节点的信息 减少单点通信压力 性能优化：\n局部过滤：只上传可能进入全局top-k的元素 批量通信：积累一定数量的更新后批量发送 缓存机制：利用时间局部性减少通信 实际应用：\n实时热搜榜 分布式缓存的热点识别 网络安全中的异常检测 广告系统的CTR监控 第五讲 哈希 一、哈希函数和哈希表 哈希技术是一种通过哈希函数将数据映射到固定大小的表中的方法，实现快速的数据存储和检索。\n核心概念：\n哈希函数：将任意大小的数据映射到固定大小的值 哈希表：基于数组实现的数据结构，通过哈希函数计算索引位置 冲突处理：当不同的键映射到相同位置时的解决策略 链地址法（Chaining） 开放地址法（Open Addressing） 时间复杂度：\n平均情况：O(1) 查找、插入、删除 最坏情况：O(n)（当所有元素都冲突时） 二、布隆过滤器（Bloom Filter） 布隆过滤器是一种空间高效的概率型数据结构，用于判断一个元素是否在集合中。\n特点：\n可能产生假阳性（False Positive）：说存在但实际不存在 不会产生假阴性（False Negative）：说不存在就一定不存在 不支持删除操作（标准版本） 应用场景：\n网页URL去重 垃圾邮件过滤 缓存穿透防护 大数据去重 工作原理：\n使用k个不同的哈希函数 将元素映射到位数组的k个位置 查询时检查这k个位置是否都为1 三、最小哈希和LSH（Locality-Sensitive Hashing） 最小哈希（MinHash）： 用于估计两个集合的Jaccard相似度，常用于文档去重和相似度检测。\n局部敏感哈希（LSH）： 一种降维技术，使得相似的数据项以高概率被映射到相同的桶中。\n应用：\n近似最近邻搜索 图像相似度检测 文本去重 推荐系统 第六讲 线性规划与整数规划 线性规划问题研究在资源约束条件下的最大化或最小化目标问题,表示方式有标准型和松弛型,单纯形算法来求解线性规划问题 整数规划比线性规划有更多约束条件 分支界定法是解决整数规划问题的有效方法，但是当变量数量多的时候效率会下降 切平面法是解决整数规划问题的有效方法 一、线性规划:单纯形算法 1. 线性函数与线性规划 线性函数的定义:\n给定一组实数 $a_1, a_2, ..., a_n$ 和一组变量 $x_1, x_2, ..., x_n$,定义在这些变量上的线性函数为:\n$$f(x_1, x_2, ..., x_n) = a_1x_1 + a_2x_2 + ... + a_nx_n$$线性约束的定义:\n如果 $b$ 是一个实数,而 $f$ 是一个线性函数,则:\n$f(x_1, x_2, ..., x_n) = b$ 是线性等式 $f(x_1, x_2, ..., x_n) \\geq b$ 和 $f(x_1, x_2, ..., x_n) \\leq b$ 是线性不等式 线性约束表示线性等式或者线性不等式。\n线性规划问题的定义:\n一个线性规划问题是指:一个线性函数最小化或最大化的问题,该线性函数服从一组有限个线性约束。\n可以分为:\n最小化线性规划 vs. 最大化线性规划 线性规划的几何意义:\n可行解:满足所有约束条件的 $x_1, x_2$ 的取值称为一个可行解 可行区域:所有可行解构成的区域 示例:\n$$ \\begin{align} \\text{最大化} \\quad \u0026 x_1 + x_2 \\\\ \\text{满足约束条件:} \\quad \u0026 4x_1 - x_2 \\leq 8 \\\\ \u0026 2x_1 + x_2 \\leq 10 \\\\ \u0026 5x_1 - 2x_2 \\geq -2 \\\\ \u0026 x_1, x_2 \\geq 0 \\end{align} $$在图示中,可行区域为一个多边形区域,最优解 $x_1 + x_2 = 8$ 出现在可行域的顶点处。\n重要性质: 线性规划的最优解通常出现在可行域的顶点处。\n2. 线性规划转标准型 标准型的定义:\n已知 $n$ 个实数 $c_1, c_2, ..., c_n$; $m$ 个实数 $b_1, b_2, ..., b_m$; 以及 $mn$ 个实数 $a_{ij}$, 其中 $i = 1,2,...,m$;$j = 1,2,...,n$。需要找到 $n$ 个实数 $x_1, x_2,...,x_n$。\n一般形式:\n$$ \\begin{align} \\text{最大化} \\quad \u0026 c_1x_1 + c_2x_2 + ... + c_nx_n \\quad \\text{(目标函数)} \\\\ \\text{满足约束条件:} \\quad \u0026 a_{i1}x_1 + a_{i2}x_2 + ... + a_{in}x_n \\leq b_i \\quad (i = 1,2,...,m) \\quad \\text{(约束)} \\\\ \u0026 x_j \\geq 0 \\quad (j = 1,2,..., n) \\quad \\text{(非负约束)} \\end{align} $$矩阵表示形式:\n构造:\n$m \\times n$ 矩阵 $A = (a_{ij})$ 一个 $m$ 维向量 $b = (b_i)$ 一个 $n$ 维向量 $c = (c_i)$ 一个 $n$ 维向量 $x = (x_i)$ 标准型可表示为:\n$$ \\begin{align} \\text{最大化} \\quad \u0026 c^Tx \\quad \\text{(目标函数)} \\\\ \\text{满足约束条件:} \\quad \u0026 Ax \\leq b \\quad \\text{(约束)} \\\\ \u0026 x \\geq 0 \\quad \\text{(非负约束)} \\end{align} $$可用元组 (A, b, c) 表达一个标准的线性规划问题。\n标准型的特点:\n目标函数是最大化 所有约束都是不等式(小于等于号) 所有变量都有非负约束 转换为标准型的技巧:\n一个线性规划问题可能不是标准型,可能的原因及解决方法包括:\n(1)目标函数是最小化而非最大化\n解决方法: 将目标函数中的系数取负数\n示例:\n$$ \\begin{aligned} \\text{最小化} \\quad \u0026 -2x_1 + 3x_2 \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2 = 7 \\\\ \u0026 x_1 - 2x_2 \\leq 4 \\\\ \u0026 x_1 \\geq 0 \\end{aligned} \\quad \\rightarrow \\quad \\begin{aligned} \\text{最大化} \\quad \u0026 2x_1 - 3x_2 \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2 = 7 \\\\ \u0026 x_1 - 2x_2 \\leq 4 \\\\ \u0026 x_1 \\geq 0 \\end{aligned} $$ (2)变量不具有非负约束\n解决方法: 将该变量 $x_j$ 每次出现的地方都改为 $x_j' - x_j''$,且 $x_j'$ 和 $x_j''$ 均 $\\geq 0$\n示例:\n$$ \\begin{aligned} \\text{最大化} \\quad \u0026 2x_1 - 3x_2 \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2 = 7 \\\\ \u0026 x_1 - 2x_2 \\leq 4 \\\\ \u0026 x_1 \\geq 0 \\end{aligned} \\quad \\rightarrow \\quad \\begin{aligned} \\text{最大化} \\quad \u0026 2x_1 - 3x_2' + 3x_2'' \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2' - x_2'' = 7 \\\\ \u0026 x_1 - 2x_2' + 2x_2'' \\leq 4 \\\\ \u0026 x_1, x_2', x_2'' \\geq 0 \\end{aligned} $$ (3)可能有等式约束\n解决方法: 转化成一对不等式\n示例:\n$$ \\begin{aligned} \\text{最大化} \\quad \u0026 2x_1 - 3x_2' + 3x_2'' \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2' - x_2'' = 7 \\\\ \u0026 x_1 - 2x_2' + 2x_2'' \\leq 4 \\\\ \u0026 x_1, x_2', x_2'' \\geq 0 \\end{aligned} \\quad \\rightarrow \\quad \\begin{aligned} \\text{最大化} \\quad \u0026 2x_1 - 3x_2' + 3x_2'' \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2' - x_2'' \\leq 7 \\\\ \u0026 x_1 + x_2' - x_2'' \\geq 7 \\\\ \u0026 x_1 - 2x_2' + 2x_2'' \\leq 4 \\\\ \u0026 x_1, x_2', x_2'' \\geq 0 \\end{aligned} $$ (4)可能有不等式约束,但不是小于等于号,而是大于等于号\n解决方法: 更改约束的符号(两边同时乘以 $-1$)\n示例:\n$$ \\begin{aligned} \\text{最大化} \\quad \u0026 2x_1 - 3x_2' + 3x_2'' \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2' - x_2'' \\leq 7 \\\\ \u0026 x_1 + x_2' - x_2'' \\geq 7 \\\\ \u0026 x_1 - 2x_2' + 2x_2'' \\leq 4 \\\\ \u0026 x_1, x_2', x_2'' \\geq 0 \\end{aligned} \\quad \\rightarrow \\quad \\begin{aligned} \\text{最大化} \\quad \u0026 2x_1 - 3x_2' + 3x_2'' \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2' - x_2'' \\leq 7 \\\\ \u0026 -x_1 - x_2' + x_2'' \\leq -7 \\\\ \u0026 x_1 - 2x_2' + 2x_2'' \\leq 4 \\\\ \u0026 x_1, x_2', x_2'' \\geq 0 \\end{aligned} $$ 3. 线性规划转松弛型 松弛型的定义:\n松弛型(Slack Form):约束都是等式(除了要求变量非负的约束)\n标准型 vs 松弛型:\n标准型:所有的约束都是不等式 松弛型:约束都是等式(除了要求变量非负的约束) 引入松弛变量:\n通过引入新变量,将不等式改变成等式:\n$$\\sum_{j=1}^{n} a_{ij}x_j \\leq b_i \\quad \\rightarrow \\quad s = b_i - \\sum_{j=1}^{n} a_{ij}x_j, \\quad s \\geq 0$$称 $s$ 为松弛变量,因为它度量了以上不等式左右两边的松弛或差别。\n更简洁的表示:\n去除关于\u0026quot;最大化\u0026rdquo;、\u0026ldquo;满足约束\u0026quot;这些词,直接写成等式形式。\n示例:\n原标准型:\n$$ \\begin{align} \\text{最大化} \\quad \u0026 2x_1 - 3x_2 + 3x_3 \\\\ \\text{满足约束条件:} \\quad \u0026 x_1 + x_2 - x_3 \\leq 7 \\\\ \u0026 -x_1 - x_2 + x_3 \\leq -7 \\\\ \u0026 x_1 - 2x_2 + 2x_3 \\leq 4 \\\\ \u0026 x_1, x_2, x_3 \\geq 0 \\end{align} $$转换为松弛型(引入松弛变量 $x_4, x_5, x_6$):\n$$ \\begin{align} z \u0026= 2x_1 - 3x_2 + 3x_3 \\\\ x_4 \u0026= 7 - x_1 - x_2 + x_3 \\\\ x_5 \u0026= -7 + x_1 + x_2 - x_3 \\\\ x_6 \u0026= 4 - x_1 + 2x_2 - 2x_3 \\end{align} $$重要概念:\n等式左边:基本变量(在等式左边的变量) 等式右边:非基本变量(在等式右边的变量) 松弛型的元组表示:\n可用元组 (N, B, A, b, c, v) 表示松弛型。\n示例:\n$$ \\begin{align} z \u0026= 28 - \\frac{x_3}{6} - \\frac{x_5}{6} - \\frac{2x_6}{3} \\\\ x_1 \u0026= 8 + \\frac{x_3}{6} + \\frac{x_5}{6} - \\frac{x_6}{3} \\\\ x_2 \u0026= 4 - \\frac{8x_3}{3} - \\frac{2x_5}{3} + \\frac{x_6}{3} \\\\ x_4 \u0026= 18 - \\frac{x_3}{2} + \\frac{x_5}{2} \\end{align} $$元组表示:\n$B = \\{1, 2, 4\\}$(基本变量集合) $N = \\{3, 5, 6\\}$(非基本变量集合) $c = (c_3, c_5, c_6)^T = (-1/6, -1/6, -2/3)^T$ $v = 28$ 矩阵 $A$:\n$$ A = \\begin{pmatrix} a_{13} \u0026 a_{15} \u0026 a_{16} \\\\ a_{23} \u0026 a_{25} \u0026 a_{26} \\\\ a_{43} \u0026 a_{45} \u0026 a_{46} \\end{pmatrix} = \\begin{pmatrix} 1/6 \u0026 1/6 \u0026 -1/3 \\\\ -8/3 \u0026 -2/3 \u0026 1/3 \\\\ -1/2 \u0026 1/2 \u0026 0 \\end{pmatrix} $$向量 $b$:\n$$ b = \\begin{pmatrix} b_1 \\\\ b_2 \\\\ b_4 \\end{pmatrix} = \\begin{pmatrix} 8 \\\\ 4 \\\\ 18 \\end{pmatrix} $$ 4. 单纯形算法 算法核心思想:\n单纯形算法的本质是从可行域的一个顶点出发,沿着目标函数值改进的方向移动到相邻顶点,直到找到最优解。\n基本解的概念:\n松弛型等式系统拥有无限个解。我们集中于基本解:\n把等式右边所有(非基本)变量设为 $0$ 再计算等式左边(基本)变量的值 再计算目标值 每次迭代的目标: 重新整理线性规划,使得基本解有一个更大的目标值。\n算法详细步骤(以最大化问题为例):\n初始问题:\n$$ \\begin{align} \\text{最大化} \\quad z \u0026= 3x_1 + x_2 + 2x_3 \\\\ \\text{满足约束条件:} \\quad \u0026 x_1 + x_2 + 3x_3 \\leq 30 \\\\ \u0026 2x_1 + 2x_2 + 5x_3 \\leq 24 \\\\ \u0026 4x_1 + x_2 + 2x_3 \\leq 36 \\\\ \u0026 x_1, x_2, x_3 \\geq 0 \\end{align} $$步骤1:转换为松弛型\n引入松弛变量 $x_4, x_5, x_6$:\n$$ \\begin{align} z \u0026= 3x_1 + x_2 + 2x_3 \\\\ x_4 \u0026= 30 - x_1 - x_2 - 3x_3 \\\\ x_5 \u0026= 24 - 2x_1 - 2x_2 - 5x_3 \\\\ x_6 \u0026= 36 - 4x_1 - x_2 - 2x_3 \\end{align} $$初始基本解:\n基本解:$(\\bar{x}_1, \\bar{x}_2, ..., \\bar{x}_6) = (0, 0, 0, 30, 24, 36)$ 目标值:$z = 3 \\times 0 + 1 \\times 0 + 2 \\times 0 = 0$ 步骤2:第一次迭代\n观察分析:\n考虑增加 $x_1$ 的值(因为其系数为正,可以增加目标值),使所有值保持非负 从三个约束式可知: $x_1$ 超过 $30$ 时,$x_4$ 变负 $x_1$ 超过 $12$ 时,$x_5$ 变负 $x_1$ 超过 $9$ 时,$x_6$ 变负 因此,$x_1$ 最多取 $9$,此时 $x_6 = 0$ 互换 $x_1$ 和 $x_6$($x_1$ 入基,$x_6$ 出基) 第一次迭代后:\n$$ \\begin{align} z \u0026= 27 + \\frac{x_2}{4} + \\frac{x_3}{2} - \\frac{3x_6}{4} \\\\ x_1 \u0026= 9 - \\frac{x_2}{4} - \\frac{x_3}{2} - \\frac{x_6}{4} \\\\ x_4 \u0026= 21 - \\frac{3x_2}{4} - \\frac{5x_3}{2} + \\frac{x_6}{4} \\\\ x_5 \u0026= 6 - \\frac{3x_2}{2} - 4x_3 + \\frac{x_6}{2} \\end{align} $$新基本解:\n基本解:$(9, 0, 0, 21, 6, 0)$ 目标值:$z = 27$ 步骤3:第二次迭代\n观察分析:\n增加 $x_2$ 或 $x_3$ 都可增加目标值 设选择 $x_3$,从三个式子可知 $x_3$ 的最大值分别为 $18, 42/5, 3/2$ 因此,选择第3个约束($x_3$ 最多取 $3/2$),围绕 $x_3$ 和 $x_5$ 进行转动 互换 $x_3$ 和 $x_5$($x_3$ 入基,$x_5$ 出基) 第二次迭代后:\n$$ \\begin{align} z \u0026= \\frac{111}{4} + \\frac{x_2}{16} - \\frac{x_5}{8} - \\frac{11x_6}{16} \\\\ x_1 \u0026= \\frac{33}{4} - \\frac{x_2}{16} + \\frac{x_5}{8} - \\frac{5x_6}{16} \\\\ x_3 \u0026= \\frac{3}{2} - \\frac{3x_2}{8} - \\frac{x_5}{4} + \\frac{x_6}{8} \\\\ x_4 \u0026= \\frac{69}{4} + \\frac{3x_2}{16} + \\frac{5x_5}{8} - \\frac{x_6}{16} \\end{align} $$ 步骤4:第三次迭代\n第三次迭代后:\n$$ \\begin{align} z \u0026= 28 - \\frac{x_3}{6} - \\frac{x_5}{6} - \\frac{2x_6}{3} \\\\ x_1 \u0026= 8 + \\frac{x_3}{6} + \\frac{x_5}{6} - \\frac{x_6}{3} \\\\ x_2 \u0026= 4 - \\frac{8x_3}{3} - \\frac{2x_5}{3} + \\frac{x_6}{3} \\\\ x_4 \u0026= 18 - \\frac{x_3}{2} + \\frac{x_5}{2} \\end{align} $$最终基本解:\n此时,基本解是 $(8, 4, 0, 18, 0, 0)$ 目标值 $z = 28$ 因为目标函数中所有非基本变量的系数都是负数,无法继续增加目标值,求解结束! 最优解: $x_1 = 8, x_2 = 4, x_3 = 0$,最大值 $z = 28$\n算法总结:\n转换为松弛型:引入松弛变量将不等式转换为等式\n找到初始基本可行解:将所有非基本变量设为 $0$\n检验是否最优:检查目标函数中非基本变量的系数\n如果都 $\\leq 0$(最大化问题),则达到最优 如果都 $\\geq 0$(最小化问题),则达到最优 选择入基变量:选择目标函数系数为正(最大化)或负(最小化)的非基本变量\n选择出基变量:选择使入基变量取值最小的约束对应的基本变量\n基变换:通过代数运算更新松弛型\n重复步骤3-6:直到达到最优或判定无界\n二、整数规划：问题定义 1. 整数规划的基本概念 整数规划的定义:\n整数规划(Integer Programming, IP) 是在线性规划基础上,要求部分或全部决策变量必须取整数值的优化问题。\n一般形式:\n$$ \\begin{align} \\text{最大化(或最小化)} \\quad \u0026 \\sum_{i=1}^{n} c_ix_i \\\\ \\text{满足约束条件:} \\quad \u0026 \\sum_{i=1}^{n} a_{ji}x_i \\leq b_j \\quad (j = 1,2,...,m) \\\\ \u0026 x_i \\geq 0, \\quad x_i \\in \\mathbb{Z} \\quad (\\text{部分或全部}\\ i) \\end{align} $$ 整数规划的分类:\n根据变量的整数要求不同,整数规划可分为三类:\n(1)混合整数规划(Mixed Integer Programming, MIP)\n部分变量必须是整数,部分变量可以是连续值。对部分域所有$x_i$,满足:$x_i \\geq 0$且为整数。\n(2)纯整数规划(Pure Integer Programming, PIP)\n所有决策变量都必须取整数值。对每个$x_i$,满足:$x_i \\geq 0$且为整数。\n(3)0-1整数规划(Binary Integer Programming)\n变量只能取0或1两个值,用于表示\u0026quot;是/否\u0026quot;决策。对每个$x_i$,满足:$x_i \\in \\{0,1\\}$。\n2. 整数规划的实际应用示例 运输问题:\n需要运输180台电视和110台洗衣机。有两种运输方式:\n小型货车:可装载20台电视和20台洗衣机,成本360元 大型卡车:可装载40台电视和10台洗衣机,成本400元 数学模型:\n$$ \\begin{align} \\text{最小化} \\quad \u0026 360x_1 + 400x_2 \\\\ \\text{满足约束条件:} \\quad \u0026 20x_1 + 40x_2 \\geq 180 \\\\ \u0026 20x_1 + 10x_2 \\geq 110 \\\\ \u0026 x_1, x_2 \\geq 0, \\quad x_1, x_2 \\in \\mathbb{Z} \\end{align} $$其中$x_1$表示使用小型货车的数量,$x_2$表示使用大型卡车的数量。\n3. 整数规划的建模技术 技术1:定义二元变量\n除了约定部分或所有变量必须为整数值之外,也允许定义二元变量,即:$x_i \\in \\{0,1\\}$。\n优势：能够引入逻辑约束\n示例：假设$x_i \\in \\{0,1\\}$:\n如果选择了$x_1$,则不能选择$x_2$,那么可以表示成:$x_1 + x_2 \\leq 1$;\n如果选择了$x_1$,则必须选择$x_2$,那么可以表示成:$x_1 \\leq x_2$;\n必须选择$x_1$或$x_2$,或两者均选取,那么可以表示成:$x_1 + x_2 \\geq 1$;\n技术2:限定变量的范围\n目标：限定变量$x$的范围是:$x \\leq 2$或者$x \\geq 6$\n方法:\n挑选一个二元变量$w = \\begin{cases} 1, \u0026 x \\leq 2 \\\\ 0, \u0026 x \\geq 6 \\end{cases}$\n设定$M$是一个很大的数,转变成为IP约束:\n$$ \\begin{align} x \u0026\\leq 2 + M(1-w) \\\\ x \u0026\\geq 6 - Mw \\\\ w \u0026\\in \\{0,1\\} \\end{align} $$验证:\n如果$x \\leq 2$,则令$w = 1$:约束变为$x \\leq 2$和$x \\geq 6 - M$(后者自动满足) 如果$x \\geq 6$,则令$w = 0$:约束变为$x \\leq 2 + M$(自动满足)和$x \\geq 6$ 在两种情况下,IP约束都被满足。\n技术3:表达复杂表达式之间的\u0026quot;或\u0026quot;关系\n目标：表达复杂表达式之间的\u0026quot;或\u0026quot;关系\n示例：$x_1 + 2x_2 \\geq 12$或$4x_2 - 10x_3 \\leq 1$\n整数规划建模:\n$$ \\begin{align} x_1 + 2x_2 \u0026\\geq 12 - M(1-w) \\\\ 4x_2 - 10x_3 \u0026\\leq 1 + Mw \\\\ w \u0026\\in \\{0,1\\} \\end{align} $$验证:\n如果$w = 1$,则第一个约束生效:$x_1 + 2x_2 \\geq 12$ 如果$w = 0$,则第二个约束生效:$4x_2 - 10x_3 \\leq 1$ 技术4:考虑分段线性函数\n目标：表达分段线性函数\n示例:\n$$ y = \\begin{cases} 2x, \u0026 \\text{if } 0 \\leq x \\leq 3 \\\\ 9-x, \u0026 \\text{if } 4 \\leq x \\leq 7 \\\\ -5+x, \u0026 \\text{if } 8 \\leq x \\leq 9 \\end{cases} $$建模方法:\n每段分别定义$w_i$和$x_i$:\n$$ w_1 = \\begin{cases} 1, \u0026 0 \\leq x \\leq 3 \\\\ 0, \u0026 \\text{otherwise} \\end{cases}, \\quad x_1 = \\begin{cases} x, \u0026 0 \\leq x \\leq 3 \\\\ 0, \u0026 \\text{otherwise} \\end{cases} $$类似地定义$w_2, x_2$和$w_3, x_3$\n约束系统:\n$$ \\begin{align} \u0026 0 \\leq x_1 \\leq 3w_1, \\quad w_1 \\in \\{0,1\\} \\\\ \u0026 4w_2 \\leq x_2 \\leq 7w_2, \\quad w_2 \\in \\{0,1\\} \\\\ \u0026 8w_3 \\leq x_3 \\leq 9w_3, \\quad w_3 \\in \\{0,1\\} \\\\ \u0026 w_1 + w_2 + w_3 = 1 \\\\ \u0026 x = x_1 + x_2 + x_3 \\\\ \u0026 x_i \\text{ integer } \\forall i \\end{align} $$最终表达式:\n$$y = 2x_1 + (9w_2 - x_2) + (-5w_3 + x_3)$$ 4. 整数规划问题求解:从两个变量开始 案例问题:\n$$ \\begin{align} \\text{Maximize: } z \u0026= 3x + 4y \\\\ \\text{Subject to: } \u0026 5x + 8y \\leq 24 \\\\ \u0026 x, y \\geq 0, \\quad x, y \\in \\mathbb{Z} \\end{align} $$简单的解法:\n先求解线性规划(忽略整数要求),得到$x = 4.8, y = 0$和$z = 14.4$ 四舍五入,得到$x = 5, y = 0$,但此解不可行! 取整,得到$x = 4, y = 0$,且$z = 12$。该解与$x = 0, y = 3$时的解值相同。 最优解:$x = 3, y = 1$,且$z = 13$\n结论:\nQ1:最优整数解是什么? $(3, 1)$ Q2:能否使用线性规划来解决整数规划问题? 不能直接使用,需要专门的算法 三、整数规划：分支界定法（Branch and Bound） 1. 枚举树 - 完全枚举思想 0-1背包问题示例:\n有6件物品,背包容量不超过14,求最大利用率:\n物品 iPad server Brass Rat Au Bon Pain 6.041 tutoring 15.053 dinner 价格 5 7 4 3 4 6 利用率 16 22 12 8 11 19 数学模型: $$ \\begin{align} \\text{Maximize: } \u0026 16x_1 + 22x_2 + 12x_3 + 8x_4 + 11x_5 + 19x_6 \\\\ \\text{Subject to: } \u0026 5x_1 + 7x_2 + 4x_3 + 3x_4 + 4x_5 + 6x_6 \\leq 14 \\\\ \u0026 x_i \\in \\{0,1\\} \\quad \\text{for } 1 \\leq i \\leq 6 \\end{align} $$枚举法分析:\n考虑决策变量的所有可能值,即:$n \\rightarrow 2^n$ 想法:将问题分成两部分迭代。首次迭代时,考虑$x_1 \\in \\{0,1\\}$的情况 树中的每个节点代表原始问题加上额外的约束条件 枚举树基本概念:\n节点2和节点3被称为枝举树中节点1的子节点 IP(1) 是原始的整数规划问题 IP(2) 通过向IP(1)添加约束条件\u0026rdquo;$x_1 = 0$\u0026ldquo;得到 IP(3) 通过向IP(1)添加约束条件\u0026rdquo;$x_1 = 1$\u0026ldquo;得到 IP(1)的最优解可以通过从IP(2)和IP(3)中选取最好的解来获得（整数解） 最优解也可能在IP(2)和IP(3)两个分支中 2. 整数规划线性松弛 线性松弛(LP relaxation)的定义:\n如果去掉变量必须为整数的要求,就称其为整数规划问题的线性松弛。\n背包问题的线性松弛:\n$$ \\begin{align} \\text{最大化: } \u0026 24x_1 + 2x_2 + 20x_3 + 4x_4 \\\\ \\text{约束条件: } \u0026 8x_1 + 1x_2 + 5x_3 + 4x_4 \\leq 9 \\\\ \u0026 0 \\leq x_i \\leq 1, \\quad \\text{对于 } 1 \\leq i \\leq 4 \\end{align} $$贪心算法求解:\n背包问题的线性松弛可以通过\u0026quot;贪心算法\u0026quot;来求解:\n可以将目标函数看作是美元金额,并将约束条件视为对重量的限制。\nitem 1 2 3 4 value/lb. $3 $2 $4 $1 求解策略:\n如果按照每磅价值从高到低依次将物品放入背包,会得到什么结果?\n通过求解每个整数规划问题的线性松弛,可为每个整数规划问题得到一个界限。\n（1） LP(k)的求解结果会给出一个具体的界限值。\n示例:LP(4)的求解\n$$ \\begin{align} \\text{Maximize: } \u0026 24x_1 + 2x_2 + 20x_3 + 4x_4 \\\\ \\text{Subject to: } \u0026 8x_1 + 1x_2 + 5x_3 + 4x_4 \\leq 9 \\\\ \u0026 x_1 = 0, x_2 = 0 \\\\ \u0026 0 \\leq x_i \\leq 1 \\text{ for } 3 \\leq i \\leq 4 \\end{align} $$ LP(4)的最优解:$x_1 = 0, x_2 = 0, x_3 = 1, x_4 = 1, z = 24$ 如果LP(k)的最优解对于IP(k)也是可行的,那么它也是IP(k)的最优解 重要性质:\n对于所有$j$来说,$z_{IP}(j) \\leq z_{LP}(j)$,例如:$z_{IP}(1) \\leq 32$\n不直接求解IP(k),而是求其线性松弛(LP relaxation),以获得边界值。\n（2）当前最优解(incumbent)的定义:\n算法偶然找到的、具有最佳目标函数值的可行整数解。\n注意：当前最优解是整数规划问题的一个可行解,且是迄今为止找到的最佳解。\nLP(1)的求解:\n$$ \\begin{align} \\text{Maximize: } \u0026 24x_1 + 2x_2 + 20x_3 + 4x_4 \\\\ \\text{Subject to: } \u0026 8x_1 + 1x_2 + 5x_3 + 4x_4 \\leq 9 \\\\ \u0026 0 \\leq x_i \\leq 1 \\text{ for } i = 1 \\text{ to } 4 \\end{align} $$ LP(1)的最优解:$x_1 = 1/2, x_2 = 0, x_3 = 1, x_4 = 0, z = 32$ 重要观察:\n对于所有$j$来说,$z_{IP}(j) \\leq z_{LP}(j)$,例如:$z_{IP}(1) \\leq 32$\n（3） 剪枝\n推论：如果$z_{LP}(k) \\leq z_I$,可以剪枝活动节点$k$的IP(k),其中$z_I$是当前最优解的目标函数值。\n活动节点：节点尚未被剪枝,并且LP(k)还没有被解出来\nLP(2)的分析:\n$$ \\begin{align} \\text{Maximize: } \u0026 24x_1 + 2x_2 + 20x_3 + 4x_4 \\\\ \\text{Subject to: } \u0026 8x_1 + 1x_2 + 5x_3 + 4x_4 \\leq 9 \\\\ \u0026 x_1 = 0 \\\\ \u0026 0 \\leq x_i \\leq 1 \\text{ for } i = 2 \\text{ to } 4 \\end{align} $$ LP(2)的最优解为:$z_{LP}(2) = 25$ 假设我们已经知道了一组解:$x_1 = 1, x_2 = 1, x_3 = 0, x_4 = 0, z_I = 26$,则可以剪枝LP(2) 3. 分支界定算法的完整流程 在什么条件下,我们不能从最大化的分支定界树中剪枝活动节点$j$?\n算法伪代码:\nwhile there is some active nodes do select an active node j mark j as inactive Solve LP(j): denote solution as x(j); Case 1 -- if z_LP(j) ≤ z_I then prune node j; Case 2 -- if z_LP(j) \u0026gt; z_I and if x(j) is feasible for IP(j) then Incumbent := x(j), and z_I := z_LP(j); then prune node j; Case 3 -- if z_LP(j) \u0026gt; z_I and if x(j) is not feasible for IP(j) then mark the children of node j as active endwhile 中文说明:\n当存在某些活动节点时,执行以下操作:\n选择一个活动节点$j$ 将$j$标记为不活动 求解LP(j):令$x(j)$表示解决方案; 情况1\u0026ndash;如果$z_{LP}(j) \\leq z_I$,则剪枝节点$j$; 情况2\u0026ndash;如果$z_{LP}(j) \u003e z_I$且$x(j)$是IP(j)的可行解,则Incumbent $:= x(j)$,$z_I := z_{LP}(j)$;然后剪枝节点$j$; 情况3\u0026ndash;如果$z_{LP}(j) \u003e z_I$且$x(j)$不是IP(j)可行解,则标记节点$j$的子节点为活动节点 结束循环\n4. 分支界定法案例 初始状态:LP(1) $$ \\begin{align} \\text{Maximize: } \u0026 24x_1 + 2x_2 + 20x_3 + 4x_4 \\\\ \\text{Subject to: } \u0026 8x_1 + 1x_2 + 5x_3 + 4x_4 \\leq 9 \\\\ \u0026 0 \\leq x_i \\leq 1 \\text{ for } i = 1 \\text{ to } 4 \\end{align} $$ 没有当前最优解,$z_I = -\\infty$ LP(1)的最优方案是:$x_1 = 1/2, x_2 = 0, x_3 = 1, x_4 = 0, z_{LP}(2) = 32$ 分支到LP(2):\nLP(2)的最优方案是:$x_1 = 0, x_2 = 1, x_3 = 1, x_4 = 3/4, z_{LP}(2) = 25$ 分支到LP(3):\n没有当前最优解,$z_I = -\\infty$,$z_{LP}(1) = 32$ LP(3)的最终方案是:$x_1 = 1, x_2 = 0, x_3 = 1/5, x_4 = 0, z_{LP}(3) = 28$ 分支到LP(4):\n没有当前最优解,$z_I = -\\infty$,$z_{LP}(1) = 32$ LP(4)的最优解:$x_1 = 0, x_2 = 0, x_3 = 1, x_4 = 1, z_{LP}(4) = 24$ 剪枝完毕(因为都是整数)，更新$z_I = 24$ 分支到LP(5):\n最优可行解$z_I = 24$ LP(5)的最终方案是:$x_1 = 0, x_2 = 1, x_3 = 1, x_4 = 3/4, z_{LP}(5) = 25$ 分支到LP(6):\n当前最优解$z_I = 24$ LP(6)的最优方案是:$x_1 = 1, x_2 = 0, x_3 = 1/5, x_4 = 0, z_{LP}(6) = 28$ 分支到LP(7):\n当前最优解$z_I = 24$ LP(7)的最优解:$x_1 = 1, x_2 = 1, x_3 = 0, x_4 = 0, z_{LP}(7) = 26$ 剪枝完毕(界限剪枝) 分支到LP(8):\n当前最优解$z_I = 26$ (更新) LP(8)的最优解:$x_1 = 0, x_2 = 1, x_3 = 1, x_4 = 1, z_{LP}(8) = 6$ 子树剪枝(界限剪枝,因为$z_{LP}(8) \u003c z_I$) 分支到LP(9):\n当前最优解$z_I = 26$ LP(9)的最优解:$x_1 = 0, x_2 = 1, x_3 = 1, x_4 = 3/4, z_{LP}(9) = 25$ 子树剪枝(界限剪枝,因为$z_{LP}(9) \u003c z_I$) 分支到LP(10):\n当前最优解$z_I = 26$ LP(10)的最优解:$x_1 = 1, x_2 = 0, x_3 = 0, x_4 = 1/4, z_{LP}(10) = 25$ 子树剪枝(界限剪枝,因为$z_{LP}(10) \u003c z_I$) 最终分支LP(11):\n当前最优解$z_I = 26$ LP(11)的最优解:无可行解,可被剪枝 剪枝完毕(不可行剪枝) 最终结果:\n最优整数解:$x_1 = 0, x_2 = 1, x_3 = 1, x_4 = 1, z^* = 26$ 5. 分支界定法的经验总结 算法优势:\n分支定界法可以加快搜索速度,仅解决部分节点的线性规划问题 算法局限:\n分支定界法依赖于剪枝子树,这可能是因为节点处的整数规划(IP)问题已经被解决,或者因为该IP解不可能是最优解 当变量很多时,完全枚举不可能负担(即使是仅50个变量也有很大消耗) 加速技巧:\n技巧一：能够\u0026quot;智能地\u0026quot;选择最佳分支变量的启发式规则 技巧二：使用\u0026quot;取整\u0026rdquo;,例如,将非整数解通过向上或向下取整转换为整数解,以此来快速获得可行解,从而缩小搜索范围 示例:$x_1 + x_2 \\leq 1.5 \\rightarrow x_1 + x_2 \\leq 1$,or $z_{IP} \\leq z_{LP} = 5.5 \\rightarrow z_{IP} \\leq 5$ 四、整数规划：切平面法（Cutting Plane Method） 1. 有效不等式(Valid Inequalities) 定义:\n整数规划(IP)的有效不等式是指任何不会排除任何可行整数解的约束条件。\n示例问题:\n最大化目标函数:$z = 3x + 4y$\n约束条件:$5x + 8y \\leq 24$ $0 \\leq x, y \\in \\mathbb{Z}$(即x和y都是非负整数)\n有效不等式的特点:\n约束条件$x \\leq 5$是一个有效不等式 约束条件$x \\leq 4$同样是一个有效不等式 整数规划的一个有效不等式也被称为切割平面或切面 目标:\n希望找到能排除部分线性规划可行区域的切割平面。\n2. 取整(Rounding)技术 基本原理:\n一个分数形式的整数变量边界可以被截断。\n示例:\n$x \\leq 1.5 \\rightarrow x \\leq 1$\n整数系数约束的取整:\n给定一个涉及所有整数变量且系数也为整数的约束条件:\n$3x + 6y + 9z \\leq 11$ 可以转化为 $x + 2y + 3z \\leq \\lfloor 11/3 \\rfloor = 3$\n非负整数变量约束的取整:\n对于涉及非负整数变量的约束条件:\n$\\sum a_i x_i \\leq b$ 可以转化为 $\\sum \\lfloor b/a_i \\rfloor x_i \\leq \\lfloor b \\rfloor$\n注意事项:\n注意左边是整数,因此右边也可以被截断,但这并不一定比原始约束条件更严格。\n3. Gomory切割(Gomory Cuts) 定义:\nGomory切割用于向所有整数规划问题(IPs)中添加有效不等式(也称为切割),对于改进界限非常有用。\n核心思想:\nGomory切割是从线性规划(LP)松弛的最优单纯形表中的单个约束条件获得的。\n假设前提:\n这里假设所有变量必须取整数值。\n情况一:所有左侧系数都在0到1之间\n约束形式:$0.2x_1 + 0.3x_2 + 0.3x_3 + 0.5x_4 + x_5 = 1.8$\n有效不等式(忽略来自$x_5$的贡献):\n$0.2x_1 + 0.3x_2 + 0.3x_3 + 0.5x_4 \\geq 0.8$\n这种有效不等式通过从最优解中提取信息并创建新的约束条件,有助于排除非整数解,从而提高求解效率。\n情况二:所有左边的系数都是非负的\n约束形式:$1.2x_1 + 0.3x_2 + 2.3x_3 + 2.5x_4 + x_5 = 4.8$\n有效不等式(focus on fractional parts):\n$0.2x_1 + 0.3x_2 + 0.3x_3 + 0.5x_4 \\geq 0.8$\n情况三:通用情况\n约束形式:$1.2x_1 - 1.3x_2 - 2.4x_3 + 11.8x_4 + x_5 = 2.9$\n向下取整(特别担心负数):\n$1x_1 - 2x_2 - 3x_3 + 11x_4 + x_5 \\leq 2$\n有效不等式(前面两个式子相减):\n$0.2x_1 + 0.7x_2 + 0.6x_3 + 0.8x_4 \\geq 0.9$\n4. 凸包(Convex Hull) 定义:\n凸包是包含所有整数解的最小线性规划可行区域。\n示例1:\n最大化:$z = 3x + 4y$\n约束条件:$5x + 8y \\leq 24$ $0 \\leq x, y \\in \\mathbb{Z}$\n添加凸包 ： $ x + y ≤ 4,2x + 3y ≤ 9$\n示例2:\n最大化:$z = x + y$\n约束条件:$-5x + 4y \\leq 0$ $6x + 2y \\leq 17$ $0 \\leq x, y \\in \\mathbb{Z}$\n使用取整技术添加约束条件： $x ≤ 2,y ≤ x$\n5. 切平面算法 算法步骤:\n步骤1：求解线性规划松弛问题\n步骤2：如果线性规划解是整数解,则它是原始问题的最优解。任务完成!\n步骤3：如果线性规划解不是整数解,找到一个线性约束条件,该条件排除线性规划解但不排除任何整数点(总是可能的);\n步骤4：加入切割约束条件;\n步骤5：返回步骤1。\n6. 切平面法案例详解 初始问题:\n最大化:$z = x + y$\n约束条件:$-5x + 4y \\leq 0$ $6x + 2y \\leq 17$ $0 \\leq x, y \\in \\mathbb{Z}$\n有效不等式:$0 \\leq x, y \\in \\mathbb{Z}$\n最优解 = 4.5（$x = 2,y=2.5$）\n迭代1:添加约束y ≤ 2\n最优解 z = 4.1667（$x = 13/6,y=2$） 移除整数约束以获得线性松弛 最优解是对最优成本的一个上界 如果解是整数,则它是原始问题的最优解 分析:\n约束条件$y \\leq 2$是一个有效的切割,因为它排除了最优的线性规划解,但没有排除任何整数点。\n现在求解这个新问题的线性规划松弛。\n一个切割必须同时排除线性规划解,同时保留所有可行的整数点。至少存在一个有效的切割。\n此时，仍然有变量不完全是整数。再加一个切割！\n迭代2:添加约束x ≤ 2\n最大化:$z = x + y$\n约束条件:$-5x + 4y \\leq 0$ $6x + 2y \\leq 17$ $y \\leq 2$ $x \\leq 2$ $0 \\leq x, y \\in \\mathbb{Z}$\n最优解:$ x = 2, y = 2, z = 4$\n线性规划的解都是整数，因此也是整数规划问题的最优解\n7. 切平面法的特点总结 算法优势:\n通过添加切割约束逐步收紧可行域 每次迭代都会改进上界 最终必定收敛到整数最优解 算法局限:\n可能需要多次迭代 每次迭代需要求解一个线性规划问题 选择合适的切割平面需要一定技巧 与分支界定法的比较:\n切平面法通过添加约束收紧可行域 分支界定法通过分支和剪枝搜索解空间 实际应用中常将两种方法结合使用(分支切割法) 第七讲 内存计算 一、海量内存概述 1. 传统数据处理模式 vs 内存数据处理模式 传统数据处理模式：\nCPU与内存之间频繁交互 内存与磁盘(硬盘)之间存在I/O瓶颈 数据需要从磁盘加载到内存，处理后再写回磁盘 I/O操作成为性能瓶颈 内存数据处理模式：\nCPU直接与内存交互，减少I/O操作 数据主要存储和处理都在内存中完成 大幅减少或消除磁盘I/O瓶颈 显著提升数据处理速度 核心理念： Jim Gray在2006年提出的著名观点：\n\u0026ldquo;Tape is Dead\u0026rdquo;（磁带已死） \u0026ldquo;Disk is Tape\u0026rdquo;（磁盘就是磁带） \u0026ldquo;Flash is Disk\u0026rdquo;（闪存就是磁盘） \u0026ldquo;RAM Locality is King\u0026rdquo;（内存局部性为王） 解释： 随着技术发展，存储介质的角色在不断演变。内存成为数据处理的核心，其他存储介质逐渐降级为备份或归档用途。\n2. 海量内存技术的发展趋势 硬件发展：\n存储器芯片集成度不断提高 内存价格持续下降（如图所示，从1955年到2020年呈指数级下降） 内存容量大幅增长，使得海量数据内存处理成为可能 新型硬件架构：\n3D XPoint™ Technology（英特尔傲腾技术）等新型存储技术的出现 带来的机遇与挑战： 海量内存给传统的数据管理、数据挖掘方法带来了新的机遇和挑战，需要重新设计算法和系统架构。\n3. 内存计算的优势 根据Aberdeen Group 2011年的研究数据对比：\n性能指标 使用内存计算 (n=33) 不使用 (n=163) 内存计算优势 活跃业务数据量（中位数） 38 TB 18 TB 2.1倍数据量 分析数据量（中位数） 14 TB (37%全部数据) 4 TB (22%全部数据) 3.5倍数据量 数据分析/查询平均响应时间 42秒 75分钟 107倍速度提升 每小时处理数据量 1200 TB 3.2 TB 375倍效率提升 主要优势：\n消除了磁盘的I/O瓶颈 提高了单位时间内数据处理的能力与数据访问速度 实现了对大规模海量数据的实时分析和运算 提升数据挖掘的效率和准确度 二、基于单机版内存增大优势 1.关联规则 购物篮模型：从庞大的消费者记录中抽取关于购物模式的信息。\n频繁项集是购物篮模型最基本的问题—— 哪些商品经常被消费者同时购买（营销） 也被称为\u0026quot;关联规则\u0026quot; 从病例中寻找患某种疾病的病人的共同特征等。 关联规则挖掘：发现大量数据中项集之间的相关联系，是数据挖掘中最活跃的研究领域之一。\n关联规则定义：设I = {I₁, I₂, \u0026hellip;, Iₘ}是一个项目的集合，事务tᵢ(i = 1,2,\u0026hellip;,n)是I的一个子集，则由一系列具有唯一标识TID的事务组成的D = {t₁, t₂, \u0026hellip;, tₙ}称为事务数据库。\n关联规则形如X ⇒ Y的蕴含式，X ⊆ I，Y ⊆ I，X∩Y = ∅。\n度量指标：\n支持度(support)：support(面包,牛奶,尿布) = 2/5，计算公式为同时购买面包,牛奶,尿布的记录数/数据集记录总数 置信度(confidence)：confidence(面包⇒牛奶,尿布) = 2/4，计算公式为同时购买面包,牛奶,尿布的记录数/数据集中购买面包的记录数 关联规则挖掘包含两个子问题：\n①发现频繁项目集(基础和研究重点)：寻找所有满足支持度不小于用户给定的minsupport的项目集 ②生成关联规则：在已经发现的最大频繁项目集中，寻找置信度不小于用户给定的minconfidence的关联规则（一条规则的置信度很容易从支持度计数中推出；生成关联规则相对简单，且在内存、I/O、算法效率上的改进余地不大） 2.Apriori算法 基本信息：最经典的关联规则挖掘算法，由Agrawal等人于1993年提出。\n基本思路：逐层迭代，通过连接和剪枝来生成频繁项集。流程为：数据库 → 候选1-项集 →(剪枝)→ 频繁1-项集 →(连接)→ 候选2-项集 → \u0026hellip; → 频繁k-项集\n两条定理——先验性质：\n如果一个集合是频繁项集，则它的所有子集都是频繁项集 如果一个集合不是频繁项集，则它的所有超集都不是频繁项集 基本步骤：\n假设规模为k的频繁项集为Lₖ，它的候选项集为Cₖ。 扫描数据库，对每一项进行累加计数，寻找规模为1的满足minsupport的频繁项集，然后迭代进行以下三步操作，生成所有的频繁项集： ①从规模为k的频繁项集中生成规模为k+1的频繁项集的候选集Cₖ₊₁； ②扫描数据库，计算候选项集中每一个候选的支持度； ③将满足最小支持度的项加入Lₖ₊₁。 发现频繁项集：以minsupport=2（绝对支持度计数）为例，通过多趟扫描逐步生成C₁→L₁→C₂→L₂→C₃→L₃。\n生成关联规则：给定一个频繁项集I，对于它的每个非空子集a，生成满足minconfidence的规则a ⇒ (I-a)，该规则的confidence = support(I) / support(a)。示例：L₂中频繁项{I₁,I₂}，规则I₁⇒I₂的置信度 = 4/6，规则I₂⇒I₁的置信度 = 4/7。\n算法分析：虽然简单且易于实现，是最具代表性的关联规则挖掘算法，\n缺点：\n但随着数据集规模的不断增长，逐渐显现出一定的局限性：需多次扫描数据库，很大的I/O负载，算法的执行效率较低； 产生大量的候选项目集，会消耗大量的内存； 对于每一趟扫描，只有当内存大小足够容纳需要进行计数的候选集时才能正确执行。如果内存不够大，要么使用一种空间复杂度更小的算法，要么只能对一个候选集进行多次扫描，否则将会出现\u0026quot;内存抖动\u0026ldquo;的情况，即在一趟扫描中页面频繁地移进移出内存，造成运行时间的剧增。 观察：在Apriori算法的整个过程中，第一趟扫描时只需对规模为1的项计数，相对于对规模为2的项进行计数所需的空间而言是非常小的，而在第二趟扫描时，所有的可用空间基本都投入用于对候选集C₂进行计数。通过实验发现Apriori算法的内存瓶颈在第二趟扫描时出现，即对候选集C₂进行计数比对候选集C₃、C₄或规模更大的候选集进行计数所需的空间更大。\n3.PCY算法 基本信息：得名于作者Park、Chen和Yu，1995年提出。将哈希技术引入频繁项集发现中，利用第一趟扫描时未使用的大量内存空间来完整地存放一张哈希表，减少了第二趟扫描时候选集C₂的数量。\n主要思想：\n第一趟扫描：对单个项进行计数的同时将商品对散列到对应的桶中，并将该桶的计数加1。频繁桶为最终计数值不小于minsupport的桶，非频繁桶为最终最终计数值小于minsupport的桶。 第二趟扫描：即使一个2-项集中的每一项都是频繁的，但如果它被散列到非频繁桶中，它就不可能是频繁项集，可以从候选项集中删除，这样就可大大减少要考虑的2-项集。 第一趟扫描与第二趟扫描之间：把桶替换成对应的二进制位的位图，如果对应的是频繁桶则该位为1，否则为0。一个占32位(4字节)的桶被换成了1位，在第二趟扫描时只需要1/32的空间并销，因此在第二趟扫描时，PCY算法可用来计数的空间几乎和Apriori算法一样大。 步骤：第一遍扫描生成频繁1-项集，同时对2-项集进行哈希得到哈希表和位向量；第二遍扫描通过L₁自连接生成候选集，使用位图过滤（只有哈希到频繁桶的才是候选），对候选项对计数。结果是候选2-项集的数目大大减少。\n第一步：确定每个项的 order（顺序编号）\n根据字母顺序：\nA 的 order = 1 B 的 order = 2 C 的 order = 3 D 的 order = 4 E 的 order = 5 第二步：计算每个2-项集的哈希位置\n例子1：{A, C}\nh(A,C) = (1 × 10 + 3) mod 7 = 13 mod 7 = 6 ✅ 映射到位置6 例子2：{B, C}\nh(B,C) = (2 × 10 + 3) mod 7 = 23 mod 7 = 2 ✅ 映射到位置2 第三步：进行位向量统计\n统计当前桶的元素个数是否$\u003e=2$ 得到如下位向量\u0026lt;1,0,1,0,1,0,1\u0026gt; 优点：高效地产生频繁项集，提升了性能；减少了数据库的扫描次数；减少计数所需的内存空间的大小。\n分析：最差的情况是所有桶都是频繁桶，则第二遍扫描中PCY算法需要计算的相对数目与Apriori算法相比没有任何减少。在寻找频繁3-项集以及更多项集时，PCY算法与Apriori算法相同。\n4.多阶段算法 主要思路：\n在PCY的第一遍和第二遍之间插入额外的扫描过程，将2-项集哈希到另外的独立的哈希表中（使用不同的哈希函数）。 在每个中间过程中，只需哈希那些在以往扫描中哈希到频繁桶的频繁项。 需要三次扫描数据库。 步骤：\n第一趟扫描与PCY算法相同； 第二趟扫描中2-项集{i,j}被哈希需满足①i和j都是频繁项、②第一趟扫描时{i,j}被哈希到了一个频繁桶，使用不同的哈希函数建立哈希表2； 第三趟扫描中{i,j}是候选2-项集需满足①i和j都是频繁项、②第一趟扫描时{i,j}被哈希到频繁桶(查询Bitmap1)、③第二趟扫描时{i,j}被哈希到频繁桶(查询Bitmap2)。 分析：\nPass3的第③个条件是多阶段算法与PCY算法最本质的区别。 因为在第二趟扫描时，不是所有的2-项集都被散列到桶中，因此桶的计数值变得比第一趟扫描时更小，最终结果是更多的桶变成非频繁桶；(过滤更多) 由于两次扫描采用的哈希函数不同，那些在第一趟扫描时被散列到频繁桶中的非频繁2-项集很可能在第二趟扫描时被哈希到一个非频繁桶中，故排除很多通过了前两个条件判断的2-项集。 多阶段算法寻找频繁2-项集不只局限于使用3次扫描， 可以执行更多次用桶进行哈希的扫描，并且每次使用不同的哈希函数，后面的每一趟扫描都能排除更多的2-项集； 但是如果扫描的次数过多，不仅算法的执行次数更长，也有可能导致最终可用的内存小到无法对所有的频繁2-项集进行计数。 5.多哈希算法 定义：多哈希算法(Multihash Algorithm)是PCY算法的一种变形。\n思路：对PCY算法的第一遍扫描进行修改，将内存划分为多张哈希表，第二遍扫描只需对所有哈希表中都哈希到频繁桶的两个频繁项组成的项对计数。\n与多阶段算法的区别：多阶段算法是在连续的扫描过程中使用两个不同的哈希函数和哈希表，多哈希算法是在第一次扫描的过程中同时使用两个哈希函数和两张哈希表。\n步骤：第一遍扫描统计频繁项，同时维护哈希表1和哈希表2；第二遍扫描输入频繁项+位图1+位图2，对同时在两个哈希表中都哈希到频繁桶的候选项对计数。\n分析：\n优点是只要桶的平均计数不小于阈值，频繁桶的数目仍然比较多，这样一个非频繁2-项集同时哈希到两个哈希表的频繁桶内的概率就更低，可以减少第二遍扫描的运算量。 风险是使用两个哈希表时，每个哈希表仅有PCY算法的一半的桶，这样每个桶上的平均计数会翻倍，必须保证大多数桶的计数不会达到阈值。 多哈希算法也不只局限于使用两个哈希表，风险是桶的平均计数可能会超过阈值。 三、基于共享式内存和分布式内存结合架构优势 1.三种系统架构 SMP (对称多处理)\n也称UMA (一致性存储访问) 各处理器平等,访问内存任何地址时间相同 共享相同物理内存、总线结构和系统资源 主要特征是\u0026rdquo;共享\u0026quot;,单一寻址空间,编程简单 缺点:受总线限制,可扩展性差 MPP (大规模并行处理)\n多个SMP服务器通过互联网络连接 \u0026ldquo;完全无共享(shared-nothing)\u0026ldquo;架构 每个节点只访问本地资源,通过消息传递机制交互 优点:可扩展性好 缺点:通信开销大,编程困难 NUMA (非一致性存储访问)\n访问本地内存速度远高于远端内存 具有多个CPU模块,每个模块有独立的CPU、内存、I/O 每个CPU可访问系统中所有物理内存空间 结合SMP和MPP优势:保持对称性和单一地址空间,同时具备可扩展能力 属于分布/共享内存结构 2.SPADE算法 基本思想\n利用垂直数据格式和连接-剪枝策略 只需对数据库进行三次扫描 产生频繁序列时只需对垂直数据序列进行交集操作 数据表示:垂直格式\n将序列数据库从水平格式转换为垂直格式 每个项用ID_list表示,包含(CID, TID)对 CID: 客户/序列标识 TID: 事务/时间标识 通过扫描数据库构建每个项的ID_list 计算support: 统计ID_list中distinct CID数目 算法流程\n第一步: 生成频繁1-序列\n扫描数据库,构建每个单项的ID_list 统计每个项的distinct CID数目 与minsupport比较,得到频繁1-序列 第二步: 连接生成候选k-序列\n示例: 从频繁1-序列生成频繁2-序列\n频繁1-序列的ID_list:\n项b 项c CID TID CID TID 1 2 2 3 1 3 3 2 2 1 3 5 2 4 3 2 连接过程详解:\n要生成b→c(表示b在c之前发生):\n查找同一个CID中,TID(b) \u0026lt; TID(c)的记录 CID=1: b出现在TID=2,3; c出现在TID=无 → 没有满足条件的 CID=2: b出现在TID=1,4; c出现在TID=3 → TID(b)=1 \u0026lt; TID(c)=3 ✓ CID=3: b出现在TID=2; c出现在TID=2,5 → TID(b)=2 \u0026lt; TID(c)=5 ✓ 要生成c→b(表示c在b之前发生):\n查找同一个CID中,TID(c) \u0026lt; TID(b)的记录 CID=1: c出现在TID=无; b出现在TID=2,3 → 没有c,不满足 CID=2: c出现在TID=3; b出现在TID=1,4 → TID(c)=3 \u0026lt; TID(b)=4 ✓ CID=3: c出现在TID=2,5; b出现在TID=2 → TID(c)=2不小于TID(b)=2 ✗ 连接后生成的频繁2-序列ID_list:\nb→c (序列模式) c→b (序列模式) CID TID(b) TID(c) CID TID(c) TID(b) 2 1 3 2 3 4 3 2 5 频繁(k-1)-序列与频繁(k-1)-序列连接形成候选k-序列 连接规则(必须同时满足): 共享相同的CID 前面项的TID必须在后面项的TID之前(遵守时间顺序) 通过两个序列的ID_list交集操作生成新序列的ID_list 例如: b→c表示在同一CID中,b的TID \u0026lt; c的TID 第三步: 剪枝得到频繁k-序列\n判断哪些候选序列是频繁的:\n假设最小支持度minsupport = 2(至少要在2个客户中出现)\nb→c序列: distinct CID = {2, 3} → 2个客户 → support=2 ≥ minsupport ✓ 保留,是频繁序列 c→b序列: distinct CID = {2} → 1个客户 → support=1 \u0026lt; minsupport ✗ 剪枝,不是频繁序列 最终得到频繁2-序列:\nb→c (频繁序列) CID TID(b) TID(c) 2 1 3 3 2 5 算法的实际意义:\nSPADE算法用于序列模式挖掘 - 发现用户购买行为的规律: 终止条件\n找不到频繁序列,或 无法通过连接形成候选序列时,算法结束 优化特性\nID_list会随着频繁序列长度增加而减小 连接操作速度随之加快 减少了内存占用和计算开销 等价类划分(搜索空间划分)\n采用基于后缀的等价类划分搜索空间 形如Y→X和YX的序列都归入后缀类[X] 每个等价类是独立的,包含生成所有共享相同后缀的频繁序列所需的完整信息 可以在内存中独立处理每个等价类 为pSPADE的并行化提供基础 3.pSPADE算法 算法背景\n第一个应用共享式内存架构进行并行序列模式挖掘的算法 工作在SGI Origin 2000系统(NUMA体系结构)的12台处理器上 采用硬件分布式共享存储(HDSM)架构 任务拆分\n利用SPADE算法的等价类划分性质 所有处理器访问整个数据库的一份拷贝 并行地工作于不同的等价类,异步处理全局计算树 每个类的挖掘工作独立,处理器不需要同步 负载均衡策略\n静态负载均衡(SLB)\n根据等价类中元素数量分配权重 按权重递减顺序排序,依次分配给当前权值和最小的处理器 分配完毕后完全异步,无需同步或交互 示例：P0预先分配好了C1和C3，P1预先分配好了C2。然后就按照这个分配方案来实施。即使P1已经执行完毕所有任务了，它也无法分担P0的任务。 类间动态负载均衡(CDLB)\n按权重将所有类递减排列成逻辑中心任务队列 处理器动态从队列获取类,处理完后自动获取下一个 示例：首先预估所有任务的工作量，进行排序，得C1, C2, C3。然后，分配P0来执行C1，分配P1来执行C2。结束早的那个处理器来执行C3。 递归动态负载均衡(RDLB)\n有空闲处理器时,在树的每一新层递归运用CDLB方法 不同处理器能够处理新层次上的不同类 示例：首先预估工作量，排序得C1、C2、C3。然后P0预先分配好了C1和C3，P1预先分配好了C2，P1执行较快，则又执行C3。此时P0已经执行完毕，则它能够分配C3的子任务（X3）。依次类推，直到完全结束。 算法优点\n减少数据库扫描次数,降低I/O操作开销 采用异步机制,只在负载失衡时同步 将搜索空间分成基于后缀的类,可独立处理 数据局域性最大化,同步最小化 动态负载均衡保证处理器负载均衡 解决大型数据库中搜索空间大、可扩展性差的问题 第八讲 社区发现 社区发现是复杂网络分析中的重要问题，目标是找出网络中紧密连接的节点群组。\n一、图切割（Graph Partitioning） 1. 社区划分问题 给定无向图 $G = (V, E)$，其中：\n$V$ 表示所有的顶点（节点）集合 $E$ 表示所有的边集合 任务： 将所有顶点分成两个不相交的组：\n组 $A$：包含一部分节点 组 $B = V\\backslash A$：包含剩余的所有节点（即 $V$ 中除了 $A$ 之外的所有节点） 核心问题： 如何评判这个划分的好坏？\n2. 评判准则 一个良好的社区划分应该满足：\n最大化社区内部的连接数：同一个社区内的节点之间应该有尽可能多的边连接 最小化社区之间的连接数：不同社区之间的连接应该尽可能少 3. 割（Cut）的定义 为了量化划分的质量，我们引入\u0026quot;割\u0026quot;的概念。\n割(cut) 是指：只有一个端点在社区 $A$ 内，另一个端点在社区 $A$ 外的所有边的权重之和。\n数学表达式：\n$$cut(A) = \\sum_{i \\in A, j \\notin A} w_{ij}$$公式解释：\n$i \\in A$：节点 $i$ 在社区 $A$ 中 $j \\notin A$：节点 $j$ 不在社区 $A$ 中（即在社区 $B$ 中） $w_{ij}$：连接节点 $i$ 和节点 $j$ 的边的权重（如果是无权图，权重为1） $\\sum$：对所有满足条件的边进行求和 通俗理解： 割就是\u0026quot;跨越两个社区的边的总权重\u0026rdquo;，这个值越小，说明两个社区之间的连接越少，划分越好。\n求解方法： 存在多项式时间算法来求解最小割问题，特别是 Edmonds-Karp 算法，其时间复杂度为 $O(|V| \\cdot |E|^2)$。\n4. 最小割 (Minimum-cut) 目标： 找到一个划分 $(A, B)$，使得 $cut(A,B)$ 的值最小。\n$$\\arg\\min_{A,B} cut(A,B)$$公式解释：\n$\\arg\\min$：表示\u0026quot;使得后面的值最小的参数\u0026rdquo; 即找到使 $cut(A,B)$ 最小的划分方式 $(A, B)$ 最小割的局限性：\n虽然最小割能找到连接最少的划分，但存在明显的问题：\n只考虑簇间的联通性：只关心两个社区之间有多少连接 不考虑簇内的连通性：不关心每个社区内部的结构 可能产生不平衡的划分：例如，将一个孤立的节点分离出来，只需要切断很少的边，但这样的划分是没有意义的 举例说明： 假设有一个图，其中有一个节点只通过一条边连接到主图，那么最小割会将这个节点单独分离出来（只需切断1条边），但这样的划分显然不合理。\n5. 归一化切割 (Normalized-cut) 为了解决最小割的问题，我们引入归一化切割，它同时考虑了簇间的连通性和各簇的规模。\n体积（Volume）的定义： 首先需要定义社区 $A$ 的\u0026quot;体积\u0026quot; $vol(A)$：\n$$vol(A) = \\sum_{i \\in A} k_i$$其中 $k_i$ 是节点 $i$ 的度（degree），即连接到节点 $i$ 的所有边的权重之和。$vol(A)$ 表示至少有一个端点在社区 $A$ 中的所有边的总权重，反映了社区 $A$ 的\u0026quot;规模\u0026quot;或\u0026quot;密度\u0026quot;。\n归一化切割的定义：\n$$ncut(A,B) = \\frac{cut(A,B)}{vol(A)} + \\frac{cut(A,B)}{vol(B)}$$公式解释：\n第一项 $\\frac{cut(A,B)}{vol(A)}$：割的大小相对于社区 $A$ 的规模 第二项 $\\frac{cut(A,B)}{vol(B)}$：割的大小相对于社区 $B$ 的规模 两项相加：综合考虑两个社区的规模 为什么要归一化？ 通过除以各自的体积，我们将割的大小\u0026quot;标准化\u0026quot;了。这样如果一个社区很大（$vol$ 很大），即使割的值不变，归一化后的值也会变小，从而避免了将单个节点分离出来的情况（因为单个节点的 $vol$ 很小，归一化后的值会很大）。\n优势：\n使划分更加平衡，避免产生极小的社区 同时考虑了社区间的连接和社区的规模 挑战：\n计算归一化割是 NP-hard 问题 需要使用近似算法或启发式方法来高效地找到好的划分 6. 练习题详解 题目： 对于给定的图(红色节点和绿色节点)，分别计算最优切割和最小切割的 $ncut$ 值。\n题目分析： 从图中可以看到两种切割方式：\n最优切割（蓝色虚线）：在红色社区（左侧）和绿色社区（右侧）之间进行切割 最小切割（红色虚线）：将右下角单个绿色节点孤立出来 （1）最小切割的 $ncut$ 值计算\n划分方式：社区 $A$ 为红色节点+5个绿色节点，社区 $B$ 为右下角单个绿色节点。\n$cut(A,B) = 1$（只有1条边连接孤立节点） $vol(B) = 0$（节点完全孤立，内部没有边） $ncut_{\\text{min}} = \\frac{1}{vol(A)} + \\frac{1}{0} = +\\infty$ 这说明将单个节点完全孤立是一个极差的划分！\n（2）最优切割的 $ncut$ 值计算\n划分方式：社区 $A$ 为所有红色节点（左侧10个节点），社区 $B$ 为所有绿色节点（右侧6个节点）。\n$cut(A,B) = 2$（2条边跨越蓝色虚线） $vol(A) = 2 \\times 15 = 30$（红色区域内部15条边） $vol(B) = 2 \\times 9 = 18$（绿色区域内部9条边） $ncut_{\\text{optimal}} = \\frac{2}{30} + \\frac{2}{18} = \\frac{1}{15} + \\frac{1}{9} = \\frac{8}{45} \\approx 0.178$ 结果对比：\n切割方式 $cut(A,B)$ $vol(A)$ $vol(B)$ $ncut$ 值 最小切割 1 \u0026gt;0 0 $+\\infty$ 最优切割 2 30 18 0.178 结论：\n最小切割将单个节点孤立后，$vol(B) = 0$ 导致 $ncut$ 值趋向无穷大，这是最差的划分 最优切割虽然 $cut$ 值不是最小，但 $ncut$ 值很小，实现了平衡且合理的划分 归一化切割通过考虑社区规模，避免了不合理的极端划分，$ncut$ 值越小说明划分越好 二、边介数（Edge Betweenness） 1. 边介数的定义 边介数（Edge Betweenness）：通过该边的最短路径的数量。\n作用：\n用于衡量图中一条边的重要性或中心性 反映图中有多少条最短路径经过该边 重要性判断：\n若很多最短路径都经过该边，则该边对于保持图的高效连接性就非常重要 相反，如果仅少数最短路径经过该边，则该边的重要性就较低 应用价值：\n边介数有助于识别图中的关键连接，即这些连接一旦断裂会显著影响图中节点之间的通信效率。\n示例：\n在下图中，不同的边具有不同的边介数值：\n左侧的边：$b = 16$（有16条最短路径经过） 右侧的边：$b = 7.5$（有7.5条最短路径经过） 边介数越大，该边在网络中的重要性越高。\n2. Girvan-Newman方法（简称GN方法） GN方法定义：\nGirvan-Newman方法是一种基于边介数概念的层次聚类算法，适用于无向无权网络。\n算法流程：\n重复以下步骤直到没有边剩余：\n计算边介数：计算网络中所有边的边介数 移除边介数最高的边：找到边介数最大的边并将其从图中删除 重新计算：在每个步骤后，需要重新计算剩余边的边介数 输出结果：\n相连接的边构成社区 可输出网络的层次分解 重要提示： 在每个步骤，均需重新计算边介数，因为移除一条边会影响其他边的最短路径。\n3. GN方法案例分析 考虑下图所示的网络，应用GN方法进行社区划分：\nStep 1： 计算所有边的边介数，移除边介数最高的边（边7-8，边介数为49）\n结果：图被分成两个主要部分\nStep 2： 重新计算剩余边的边介数，继续移除边介数最高的边\n结果：进一步细分，形成更小的社区\nStep 3： 持续迭代，直到所有边都被移除\n结果：每个节点成为独立的社区\n最终输出：层次状的网络划分\n通过记录每次移除边的顺序，可以构建一个层次树（dendrogram），展示网络在不同粒度下的社区结构。\n4. 如何计算边介数 （1）基本方法：构建根节点到其余子节点的最短路径数量\n步骤1：构建最短路径树\n从起始节点（如节点A）开始，使用BFS构建到所有其他节点的最短路径树，并标记每个节点的层次：\n第0层：起始节点A 第1层：与A直接相连的节点（B, C, D, E） 第2层：距离A为2的节点（F, G, H） 第3层：距离A为3的节点（I, J） 第4层：距离A为4的节点（K） 步骤2：计算最短路径数量\n计算从起始节点A到网络中其他每个节点的最短路径数量。\n公式：\n从A到某个节点X的最短路径数量 = 所有能到达X的父节点的最短路径数量之和\n示例：\n从A到H的最短路径数量 = 从A到D的最短路径数量 + 从A到E的最短路径数量 从A到K的最短路径数量 = 从A到I的最短路径数量 + 从A到J的最短路径数量 （2）自底向上计算边介数：如果存在多条最短路径，则可按比例划分边介数。\n算法步骤：\n添加边流\n初始化：每个节点的流 = 1 + 其所有子边的流之和 根据父节点的值分配流 对于每个起始节点U，重复广度优先搜索过程\n详细计算规则：\n对于某条边 $(X, Y)$，其边介数的计算遵循以下规则：\n如果从A到Y只有一条最短路径经过X，则该边获得完整的流 如果从A到Y有多条最短路径（通过不同的父节点），则按照各父节点的最短路径数量比例分配流 具体案例：\n以节点为K为例：\nK对于A而言是叶子节点，所以他的流为1（根据算法规则：子节点的流为0）， 共有2条最短路径可被分配，根据I，J各有三条最短路径，为3：3，即1：1，因此每条边分配 $\\frac{1}{2}$ 以节点I为例：\nA-I的最短路径总和算1，外加经过I到K的0.5，所以I的流为1.5 I有1.5可被分配，按照2:1的比例划分（因为A到F有2条最短路径，到G有1条最短路径） 故边$V_{F,I}$得到的流为1，边$V_{G,I}$得到的流为0.5 以此自下而上故能得到所有边的边介数\n5. 练习题 题目：给定下图所示的网络结构，请计算从节点B开始的路径边介数。\n步骤1：构建最短路径树\n从起始节点B开始，使用BFS构建到所有其他节点的最短路径树，并标记每个节点的层次：\n第0层：起始节点B 第1层：与B直接相连的节点（A，C，F） 第2层：距离B为2的节点（D，E，I） 第3层：距离B为3的节点（G，H，K） 第4层：距离B为4的节点（J） 步骤2：计算最短路径数量\n计算从起始节点B到网络中其他每个节点的最短路径数量。定义节点B到节点I的最短路径数量的方法为$N(i)$，故\n第0层：起始节点B 第1层：与B直接相连的节点$N(A) = 1$,$N(C) = 1$,$N(F) = 1$ 第2层：距离B为2的节点$N(D) = N(A)=1$,$N(E) = N(A)=1$,$N(I)=N(F) = 1$ 第3层：距离B为3的节点$N(G) = N(D)+N(I)=2$,$N(H) = N(D)+N(E)=2$,$N(K)=N(I) = 1$ 第4层：距离B为4的节点$N(J) = N(G)+N(H)+N(K) = 5$ 步骤3：自底向上计算边介数\n每个节点的流 = 1 + 其所有子边的流之和，根据父节点的最短路径数量按比例分配流。\n第4层：距离B为4的节点（J），J为叶子节点，所以J的流为1，分配边流： $$V_{G,J} = \\frac{N(G)}{N(J)} \\times 1 = \\frac{2}{5}, \\quad V_{H,J} = \\frac{N(H)}{N(J)} \\times 1 = \\frac{2}{5}, \\quad V_{K,J} = \\frac{N(K)}{N(J)} \\times 1 = \\frac{1}{5}$$ 第3层：距离B为3的节点（G，H，K），计算各自的流：\nG的流 $= 1 + \\frac{2}{5} = \\frac{7}{5}$，分配边流：$V_{D,G} = \\frac{N(D)}{N(G)} \\times \\frac{7}{5} = \\frac{1}{2} \\times \\frac{7}{5} = \\frac{7}{10}$，$V_{I,G} = \\frac{N(I)}{N(G)} \\times \\frac{7}{5} = \\frac{1}{2} \\times \\frac{7}{5} = \\frac{7}{10}$ H的流 $= 1 + \\frac{2}{5} = \\frac{7}{5}$，分配边流：$V_{D,H} = \\frac{N(D)}{N(H)} \\times \\frac{7}{5} = \\frac{1}{2} \\times \\frac{7}{5} = \\frac{7}{10}$，$V_{E,H} = \\frac{N(E)}{N(H)} \\times \\frac{7}{5} = \\frac{1}{2} \\times \\frac{7}{5} = \\frac{7}{10}$ K的流 $= 1 + \\frac{1}{5} = \\frac{6}{5}$，分配边流：$V_{I,K} = \\frac{N(I)}{N(K)} \\times \\frac{6}{5} = 1 \\times \\frac{6}{5} = \\frac{6}{5}$ 第2层：距离B为2的节点（D，E，I），计算各自的流：\nD的流 $= 1 + \\frac{7}{10} + \\frac{7}{10} = 1 + \\frac{14}{10} = \\frac{12}{5}$，分配边流：$V_{A,D} = \\frac{N(A)}{N(D)} \\times \\frac{12}{5} = 1 \\times \\frac{12}{5} = \\frac{12}{5}$ E的流 $= 1 + \\frac{7}{10} = \\frac{17}{10}$，分配边流：$V_{A,E} = \\frac{N(A)}{N(E)} \\times \\frac{17}{10} = 1 \\times \\frac{17}{10} = \\frac{17}{10}$ I的流 $= 1 + \\frac{7}{10} + \\frac{6}{5} = 1 + \\frac{7}{10} + \\frac{12}{10} = \\frac{29}{10}$，分配边流：$V_{F,I} = \\frac{N(F)}{N(I)} \\times \\frac{29}{10} = 1 \\times \\frac{29}{10} = \\frac{29}{10}$ 第1层：距离B为1的节点（A，C，F），计算各自的流：\nA的流 $= 1 + \\frac{12}{5} + \\frac{17}{10} = 1 + \\frac{24}{10} + \\frac{17}{10} = \\frac{51}{10}$，分配边流：$V_{B,A} = \\frac{51}{10} = 5.1$ C的流 $= 1 + 0 = 1$，分配边流：$V_{B,C} = 1$ F的流 $= 1 + \\frac{29}{10} = \\frac{39}{10}$，分配边流：$V_{B,F} = \\frac{39}{10} = 3.9$ 三、模块度（Modularity） 1.模块度 模块度（Modularity）是衡量图结构划分优劣的重要指标。\n令 G=(V,E) 为一个无向图，其邻接矩阵为 A：\n$$A_{ij} = \\begin{cases} 1, \u0026 \\text{if } (v_i, v_j) \\in E \\\\ 0, \u0026 \\text{otherwise} \\end{cases}$$模块度的定义为：\n$$Q = \\frac{1}{2m}\\sum_{i,j} \\left(A_{ij} - \\frac{k_i k_j}{2m}\\right)\\delta(C_i, C_j)$$其中，$m$表示边的数量，$Ci $表示第 $i$ 个社区。$k_i$ 是顶点 $v_i$ 的度（即与顶点 $v_i$ 相连的边的数量），$δ(Ci, Cj) = 1（如果 Ci = Cj）$，否则为 0。\n模块度的直观解读\n模块度用于衡量网络被划分为社区的好坏程度的一种度量。给定网络被划分为一组 c ∈ C 的情况：\n$$Q \\propto \\sum_{i,j}\\left(A_{ij} - \\frac{k_i k_j}{2m}\\right)\\delta(C_i, C_j) = \\left[\\sum_{i,j} A_{ij} - \\sum_{i,j} \\frac{k_i k_j}{2m}\\right]\\delta(C_i, C_j)$$$$= \\sum_{c \\in C} [(\\# \\text{ edges within group } c) - (\\text{expected } \\# \\text{ edges within group } c)]$$给定一个图 G，含 n 个节点和 m 条边，构建一个随机图 G\u0026rsquo;：\n保持相同的度分布，但边是随机生成 G\u0026rsquo; 是一个多重图 模块度计算\n$$Q = \\frac{1}{2m}\\sum_{c \\in C}\\sum_{i \\in c}\\sum_{j \\in c}\\left(A_{ij} - \\frac{k_i k_j}{2m}\\right)$$ 模块度的取值范围是 [-1, 1] 如果组内边的数量超过了预期数量，则模块度值为正 当模块度 M 大于 0.3 至 0.7 时，意味着输入图中存在显著的社区结构 是用于评估社区结构好坏的度量 模块度案例\n$m = 8, k_1 = 2, k_2 = 2, k_3 = 3, k_4 = 3, k_5 = 2, k_6 = 2, k_7 = 2$\n划分方案1（社区A={1,2,3}，社区B={4,5,6,7}）\n$$ \\begin{aligned} Q \u0026amp;= \\frac{1}{2m}\\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{16} \\right)\\delta(C_i, C_j) \\[6pt] \u0026amp;= \\frac{1}{16}\\Big[ (0 - \\tfrac{k_1 k_1}{16})\n2(1 - \\tfrac{k_1 k_2}{16}) 2(1 - \\tfrac{k_1 k_3}{16}) (0 - \\tfrac{k_2 k_2}{16}) \\ \u0026amp;\\quad 2(1 - \\tfrac{k_2 k_3}{16}) (0 - \\tfrac{k_3 k_3}{16}) (0 - \\tfrac{k_4 k_4}{16}) 2(1 - \\tfrac{k_4 k_5}{16}) \\ \u0026amp;\\quad 2(1 - \\tfrac{k_4 k_6}{16}) 2(0 - \\tfrac{k_4 k_7}{16}) (0 - \\tfrac{k_5 k_5}{16}) 2(0 - \\tfrac{k_5 k_6}{16}) \\ \u0026amp;\\quad 2(1 - \\tfrac{k_5 k_7}{16}) (0 - \\tfrac{k_6 k_6}{16}) 2(1 - \\tfrac{k_6 k_7}{16}) (0 - \\tfrac{k_7 k_7}{16}) \\Big] \\[6pt] \u0026amp;= \\frac{51}{128} \\end{aligned} $$ 划分方案2（社区A={1,2}，社区B={3,4,5,6,7}）\n$$ \\begin{aligned} Q \u0026amp;= \\frac{1}{2m}\\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{16} \\right)\\delta(C_i, C_j) \\[6pt] \u0026amp;= \\frac{1}{16}\\Big[ (0 - \\tfrac{k_1 k_1}{16})\n2(1 - \\tfrac{k_1 k_2}{16}) (0 - \\tfrac{k_2 k_2}{16}) (0 - \\tfrac{k_3 k_3}{16}) \\ \u0026amp;\\quad 2(1 - \\tfrac{k_3 k_4}{16}) 2(0 - \\tfrac{k_3 k_5}{16}) 2(0 - \\tfrac{k_3 k_6}{16}) 2(0 - \\tfrac{k_3 k_7}{16}) \\ \u0026amp;\\quad (0 - \\tfrac{k_4 k_4}{16}) 2(1 - \\tfrac{k_4 k_5}{16}) 2(1 - \\tfrac{k_4 k_6}{16}) 2(0 - \\tfrac{k_4 k_7}{16}) \\ \u0026amp;\\quad (0 - \\tfrac{k_5 k_5}{16}) 2(0 - \\tfrac{k_5 k_6}{16}) 2(1 - \\tfrac{k_5 k_7}{16}) (0 - \\tfrac{k_6 k_6}{16}) \\ \u0026amp;\\quad 2(1 - \\tfrac{k_6 k_7}{16}) (0 - \\tfrac{k_7 k_7}{16}) \\Big] \\[6pt] \u0026amp;= \\frac{19}{128} \\end{aligned} $$ 2. 模块度应用 ** （1）针对加权图的模块度**\n给定一个无向图 $G = (V, E)$，其邻接矩阵为 $A$，并关联一个权重矩阵 $W$：\n$$ W_{ij} = \\begin{cases} w_{ij}, \u0026 \\text{if } A_{ij} = 1 \\\\ 0, \u0026 \\text{otherwise} \\end{cases} $$模块度被定义为：\n$$ Q = \\frac{1}{2m} \\sum_{i,j} \\left( W_{ij} - \\frac{k_i k_j}{2m} \\right) \\delta(C_i, C_j) $$其中：\n$m$ 表示图中所有边的总权重 $C_i$ 表示节点 $v_i$ 所属的社区 $k_i$ 不再是节点 $v_i$ 的度，而是连接到 $v_i$ 的所有边的权重之和 （2）针对有向图的模块度\n给定有向图 $G = (V, E)$，其邻接矩阵为 $A$：\n$$ A_{ij} = \\begin{cases} 1, \u0026 \\text{if } (v_i, v_j) \\in E \\\\ 0, \u0026 \\text{otherwise} \\end{cases} $$模块度被定义为（注意分母是 $m$，不是 $2m$）：\n$$ Q = \\frac{1}{m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i^{\\text{out}} k_j^{\\text{in}}}{m} \\right) \\delta(C_i, C_j) $$其中：\n$m$ 表示图中的总边数 $C_i$ 表示节点 $v_i$ 所属的社区 $k_i^{\\text{out}}$ 和 $k_i^{\\text{in}}$ 分别表示节点 $v_i$ 的出度和入度 （3）模块度矩阵形式\n对于无向图，模块度还可以写成矩阵形式。\n定义一个 $n \\times k$ 的社区指派矩阵 $S$，其中：\n$S_{ir} = 1$ 表示节点 $v_i$ 属于第 $r$ 个社区 $S_{ir} = 0$ 表示节点 $v_i$ 不属于第 $r$ 个社区 则有：\n$$ \\delta(C_i, C_j) = \\sum_r S_{ir} S_{jr} $$定义实对称矩阵 $B$，其元素为：\n$$ B_{ij} = A_{ij} - \\frac{k_i k_j}{2m} $$社区结构的模块度可以改写为：\n$$ Q = \\frac{1}{2m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) \\delta(C_i, C_j) $$$$ = \\frac{1}{2m} \\sum_{i,j} B_{ij} \\sum_r S_{ir} S_{jr} $$$$ = \\frac{1}{2m} \\sum_{i,j} \\sum_r B_{ij} S_{ir} S_{jr} $$$$ = \\frac{1}{2m} \\operatorname{Tr}(S^{\\mathsf T} B S) $$其中，$\\operatorname{Tr}(S^{\\mathsf T} B S)$ 表示矩阵 $S^{\\mathsf T} B S$ 的迹，即其对角元素之和。\n3. 谱方法 谱方法：自顶向下的迭代式社区发现方法，基于分裂思想。\n每次只将一个图分成两个社区，以此类推，直到模块度不再变化为止 假设每次划分时，划分的两个社区分别为社区 1 和社区 2 顶点要么落在社区 1，要么在社区 2 （1）二分划分变量的定义\n因此定义变量：\n$$ s_i = \\begin{cases} 1, \u0026 \\text{如果顶点 } v_i \\text{ 在社区 1} \\\\ -1, \u0026 \\text{否则} \\end{cases} $$ （2）二分情况下的模块度表达式\n因此，二分社区的模块度可以改写为：\n$$ Q = \\frac{1}{4m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) (s_i s_j + 1) $$$$ = \\frac{1}{4m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) s_i s_j $$$$ = \\frac{1}{4m} s^{\\mathsf T} B s $$其中模块度矩阵 $B$ 定义为：\n$$ B_{ij} = A_{ij} - \\frac{k_i k_j}{2m} $$注意到，在模块度矩阵 $B$ 中，每一行和每一列的元素之和均为 0，因此向量 $(1,1,\\dots,1)$ 是特征值为 0 的特征向量。\n（3）模块度矩阵的谱分解\n假设模块度矩阵 $B$ 具有 $n$ 个正交特征向量 $\\{u_i\\}$，对应特征值为：\n$$ \\beta_1 \\ge \\beta_2 \\ge \\cdots \\ge \\beta_n $$因此，划分向量 $s = (s_1, s_2, \\dots, s_n)$ 可以展开为：\n$$ s = \\sum_{i=1}^n a_i u_i, \\qquad a_i = u_i^{\\mathsf T} s $$ （4）模块度的谱展开形式\n将上述展开代入模块度表达式，得到：\n$$ Q = \\frac{1}{4m} \\sum_i a_i u_i^{\\mathsf T} B \\sum_j a_j u_j $$利用特征向量的正交性，可进一步化简为：\n$$ Q = \\frac{1}{4m} \\sum_{i=1}^n (u_i^{\\mathsf T} s)^2 \\beta_i $$由此可见，模块度由所有特征值 $\\beta_i$ 共同决定。\n（5）基于最大特征值的近似最优化\n给定图 $G$，其模块度矩阵 $B$ 的特征值和特征向量是固定的。\n为了最大化模块度，需要考虑所有特征值 $\\beta_i$，但计算代价较高。\n因此，通常仅考虑最大的特征值 $\\beta_1$ 及其对应的特征向量 $u_1$。\n若对划分向量 $s$ 不加限制，最优解应使 $s$ 与 $u_1$ 平行。\n但由于 $s_i \\in \\{1, -1\\}$，问题转化为最大化点积 $u_1^{\\mathsf T} s$。\n因此定义划分规则为：\n$$ s_i = \\begin{cases} 1, \u0026 \\text{如果 } u_{1i} \u003e 0 \\\\ -1, \u0026 \\text{否则} \\end{cases} $$即在最大特征值对应的特征向量 $u_1$ 中：\n同号分量对应的顶点属于同一社区 不同号分量对应的顶点属于不同社区 （6）扩展到多个社区的递归划分问题\n鉴于图中可能包含超过 2 个社区，因此希望可以划分为更多部分。\n一种自然的做法是重复进行二分划分：\n首先将网络分成两部分 然后对每个子图继续应用上述方法 但这种方法并不正确，原因在于：\n边的删除会改变模块度的定义 后续的模块度最大化将不断放大误差 （7）基于模块度增量的正确递归策略\n为避免上述问题，每次仅考虑划分带来的模块度增量。\n设子社区 $g$ 的规模为 $n$，其模块度增量定义为：\n$$ \\Delta Q = \\frac{1}{2m} \\left[ \\frac{1}{2} \\sum_{i,j \\in g} B_{ij}(s_i s_j + 1)\n\\sum_{i,j \\in g} B_{ij} \\right] $$ $$ = \\frac{1}{4m} \\left[ \\sum_{i,j \\in g} B_{ij} s_i s_j\n\\sum_{i,j \\in g} B_{ij} \\right] $$ $$ = \\frac{1}{4m} \\sum_{i,j \\in g} \\left[ B_{ij}\n\\delta_{ij} \\sum_{k \\in g} B_{ik} \\right] s_i s_j $$ $$ = \\frac{1}{4m} s^{\\mathsf T} B^{(g)} s $$其中，当 $i=j$ 时 $\\delta_{ij}=1$，否则 $\\delta_{ij}=0$。\n因此，仅当模块度增量 $\\Delta Q \u003e 0$ 时，才继续划分该子社区；否则停止划分。\n由此可以保证，每一次社区划分都会使整体模块度单调增加。\n四、Louvain 方法 1. Louvain 方法概述 Louvain 方法是一种社区检测的贪心算法，具有以下特点：\n支持有向图和加权图 提供层次化分区 社区数量不是超参数，算法自动确定 广泛用于研究大型网络，因为： 快速：运行时间仅为 $O(|E|)$，其中 $|E|$ 是边的数量 收敛速度快 输出的模块度高（即“更好的社区”） Louvain 算法以贪心方式逐步最大化模块度。\n每次遍历包含两个阶段，迭代重复这些遍历，直到模块度不再增加为止。\n2. 模块度重写 在 Louvain 方法中，模块度可以重写为更便于计算的形式：\n$$ M = \\frac{1}{2m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) \\delta(C_i, C_j) $$$$ = \\left[ \\sum_{i,j} \\frac{A_{ij}}{2m}\n\\frac{\\sum_i k_i \\sum_j k_j}{4m^2} \\right] \\delta(C_i, C_j) $$ $$ = \\sum_{c \\in C} \\left[ \\frac{\\Sigma_{in}^c}{2m}\n\\left( \\frac{\\Sigma_{tot}^c}{2m} \\right)^2 \\right] $$ 其中：\n$\\Sigma_{in}^c$ 是社区 $c$ 内部顶点之间的边权重之和 $\\Sigma_{tot}^c$ 是社区 $c$ 中所有顶点的边权重总和 $m$ 是图中所有边的权重总和 3. Louvain 方法：阶段 1（模块度重写） 初始化：\n将图中的每个顶点放入一个独立的社区（每个社区一个顶点）。\n迭代过程：\n对于每个顶点 $v_i$，算法执行以下计算：\n（1） 计算当把顶点 $v_i$ 从其当前社区移动到某个邻近顶点 $v_j$ 的社区时模块度的增量 $\\Delta Q$\n（2） 将 $v_i$ 移动到能够产生最大模块度增量 $\\Delta Q$ 的社区\n（3） 循环运行直到没有移动能带来增益为止\n第一阶段在达到模块度的局部最大值时停止，即当任何单个移动都不能再改进模块度时。\n需要注意的是，算法的输出依赖于考虑顶点的顺序，但研究表明顶点顺序对最终模块度的影响并不显著。\n4. 模块度增益计算 模块度变化的两个部分：\n模块度的变化可以分为两个部分：\n增益：$\\Delta Q(v_i \\to C)$，表示将顶点 $v_i$ 移动到社区 $C$ 时模块度 $Q$ 的增益 损失：$\\Delta Q(D \\to v_i)$，表示将顶点 $v_i$ 从社区 $D$ 中移出时模块度 $Q$ 的损失 将顶点 $v_i$ 移入社区 $C$ 的增益：\n$$ \\Delta Q(v_i \\to C) = \\left[\\frac{\\Sigma_{in}^C + k_{i,in}^C}{2m} - \\left(\\frac{\\Sigma_{tot}^C + k_i}{2m}\\right)^2\\right] - \\left[\\frac{\\Sigma_{in}^C}{2m} - \\left(\\frac{\\Sigma_{tot}^C}{2m}\\right)^2 - \\left(\\frac{k_i}{2m}\\right)^2\\right] $$$$ = \\left[\\frac{k_{i,in}^C}{2m} - \\frac{\\Sigma_{tot}^C \\cdot k_i}{2m^2}\\right] $$其中：\n$k_{i,in}^C$ 是顶点 $v_i$ 与社区 $C$ 内部顶点之间的边权重之和 $k_i$ 是顶点 $v_i$ 的度（所有相连边的权重之和） 将顶点 $v_i$ 从社区 $D$ 中移出的损失：\n设 $D'$ 是移出 $v_i$ 后的社区 $D$，则：\n$$ \\Delta Q(D \\to v_i) = - \\Delta Q(v_i \\to D') $$$$ = \\frac{\\Sigma_{tot}^{D'} \\cdot k_i}{2m^2} - \\frac{k_{i,in}^{D'}}{2m} $$ 总的模块度变化：\n$$ \\Delta Q = \\Delta Q(v_i \\to C) + \\Delta Q(D \\to v_i) $$5. Louvain 方法：阶段 2（社区聚合） 在第一阶段获得的分区被收缩成超级节点，并按照以下方式创建加权网络：\n如果对应社区之间的顶点之间至少存在一条边，则超级节点之间是连接的。 两个超级节点之间边的权重是它们对应分区之间所有边的权重之和。 聚合之后，图成为一个加权图， 7. Louvain 方法分析 计算效率：\n算法运行速度快，在第一次遍历后社区数量急剧减少 后续遍历中的计算量显著降低 模块度增益计算简单 时间复杂度为 $O(|E|)$ 对于包含 $10^6$ 个顶点的图，找到社区结构所需时间通常不到 1 分钟 其他优势：\n社区数量不是超参数，算法自动确定 可以用于评估社区结构的质量 可通过模块度曲线确定最佳的簇数量 模块度用于确定簇的数量：\n在层次聚类等方法中，可以通过计算不同切割高度下的模块度， 选择模块度最大时对应的簇数量作为最优划分。\n模块度曲线通常呈现“先上升、后下降”的趋势，其峰值对应最佳的社区划分。\n第九讲 子模函数及其应用 一、应用背景 1.特征选择（Feature Selection） 问题描述：给定一组特征 X₁, \u0026hellip;, Xₙ，构造子集 A = (Xᵢ₁, \u0026hellip;, Xᵢₖ) 用以预测目标变量 Y 核心问题：如何选取 k 个特征，使子集信息量最丰富？ 信息增益：I(A; Y) = H(Y) − H(Y | A) H(Y)：Y 的熵（表示不确定性） H(Y | A)：给定 A 条件下 Y 的条件熵 I(A; Y) 描述通过知道 A 能够获得关于 Y 的信息量 2.影响力最大化（Influence Maximization） 基于社交网络，向哪些用户投放广告以达到最佳传播效果 找出最具影响力的博客或个人，将信息快速、有效地传播给受众 3.传感器部署（Sensor Placement） 问题：给定水分配网络，如何部署传感器以快速检测污染？\n函数定义：f(A) 表示在子集 A 处部署传感器的效用值\n效用特性：\n信息量高的配置（如 A = {1, 2, 3}）：f(A) 值大 信息冗余度大的配置（如 A = {1, 4, 5}）：f(A) 值较低 4.图的割函数（Graph Cut） 定义：对无向图 G(V, E)，割函数 f(S) = |{(u, v) | u ∈ S ⊂ V, v ∈ Sᶜ}| 含义：集合 S 与其补集之间的边数 示例：S = {1, 2, 3} 时 f(S) = 1；S = {1, 2} 时 f(S) = 2 5. 连续优化 凸函数优化（求最小值）\n若 f: Rⁿ → R 是凸函数，则可高效获取最小值 凸函数特性：连接凸函数图像上任意两点的线段总是在函数图像之上或恰好位于图像上 几何直观：U形曲线，底部有唯一最小值点 凹函数优化（求最大值）\n若 f: Rⁿ → R 是凹函数，则可高效获取最大值 凹函数特性：连接凹函数图像上任意两点的线段总是在函数图像之下或恰好位于图像上 几何直观：倒U形曲线，顶部有唯一最大值点 6. 离散优化：从凹性到子模性 连续优化中的凹函数\n若 f : Rⁿ → R 是凹函数，则可高效获取最大值 连接凹函数图像上任意两点的线段总在函数图像之下或恰好位于图像上 导数 f\u0026rsquo;(x) 随 x 增加而非递增 离散情况下的子模性\n对于函数 f : {0,1}ⁿ → R 离散导数：∂ᵢf(x) = f(x + eᵢ) − f(x) 若 ∂ᵢf(x) 随 x 增加而非递增，则函数是子模的 eᵢ 表示第 i 个分量为 1，其余分量为 0 的单位向量 二、子模函数 1. 集合函数基础 定义\n给定有限集合 V = {1, 2, ···, n} 集合函数：f : 2^V → R（或 f : {0, 1}ⁿ → R） 2^V 是集合 V 的幂集 集合函数的基本性质\n单调性：若 A ⊆ B ⊆ X，则 F(A) ≤ F(B) 非负性：对于所有 S ⊆ X，F(A) ≥ 0 规范化：F(∅) = 0 2.子模性定义 定义1：基本形式\n对于函数 f : 2^V → R，如果对于所有 A, B ⊆ V，均有：\n$f(A) + f(B) ≥ f(A ∪ B) + f(A ∩ B)$ 则该函数是子模的。 等价形式：$f(A) − f(A ∩ B) ≥ f(A ∪ B) − f(B)$\n定义2：边际效用递减\n对于所有 $S ⊆ T ⊆ V$，对于所有 $v ∈ V T$：$f(S ∪ {v}) − f(S) ≥ f(T ∪ {v}) − f(T)$\n经济学解释：对象在更大的上下文中增加的价值逐渐减少\n定义3：群体边际效用递减\n对于所有 S ⊆ T ⊆ V，且 C ⊆ V \\ T：$f(S ∪ C) − f(S) ≥ f(T ∪ C) − f(T)$\n4. 子模性的闭合性质 子模性在非负线性组合下具有闭合性质：\n非负线性组合：若 f₁ 和 f₂ 都是子模函数，a₁, a₂ ≥ 0，则 a₁f₁ + a₂f₂ 是子模函数\n集合限制：若 S ⊂ V 是固定集合，则 f\u0026rsquo;(A) = f(A ∩ S) 和 f(A) = f(Aᶜ) 都是子模的\n期望保持：若 fθ(A) 是子模的，则 Σθ P(θ)fθ(A) 也是子模的\n多目标优化：若 f₁, ···, fₘ 都是子模的，且 λᵢ \u0026gt; 0，则 Σᵢλᵢfᵢ(A) 也是子模的\n5. 典型案例 案例1：传感器部署\n边际效应：Δf(s|A) = f(A ∪ {s}) − f(A)\n若 A = {1, 2}，增加部署 s 的效果显著\n若 A = {1, 2, 3}，增加部署 s 的效果一般\n验证子模性：∀A ⊂ B，s ∉ B，Δf(s|A) ≥ Δf(s|B)\n案例2：计算不同颜色数量\n给定一组球的集合 S，f(S) 计算不同颜色的数量\n子模性：对象在更大上下文中增加的价值逐渐减少\n案例3：集合覆盖\nC 的覆盖定义为：f(C) = |⋃_{sᵢ∈C} sᵢ|\n满足单调性和子模性\n三、集合覆盖问题 1. k-最大覆盖问题 问题定义\n集合覆盖：每个条目 u 是由某些基础元素组成的子集 覆盖函数：f(S) = |⋃_{u∈S} u|（所有属于 S 中子集的并集的大小） 边际覆盖增加：f(S ∪ {v}) − f(S) k-最大覆盖问题\n目标：寻找 k 个子集，使联合覆盖尽可能大 复杂性：NP-hard 问题（无多项式时间算法，除非 P=NP） 示例（k=2）\n给定：\n真实集合：{a, b, c, d, e, f, g, h, i, j, k, l} 子集： A₁ = {a, b, c, d} A₂ = {e, f, g, h} A₃ = {i, j, k, l} A₄ = {a, e} A₅ = {i, b, f, g} A₆ = {c, d, g, h, k, l} A₇ = {l} 计算：\nA₆ 有 6 个元素，A₁, A₂, A₃, A₅ 各有 4 个元素 |A1 ∪ A6| = 8, |A2 ∪ A6| = 8, |A3 ∪ A6| = 8, |A5 ∪ A6| = 9 |A₅ ∪ A₆| = 9（最大）\n结果：C = {A₅, A₆} 是最大覆盖集合\n2. 抽取式文本摘要问题 给定：\n关键词集合 W = {w₁, w₂, ···, wₙ} 句子集合 S = {s₁, s₂, ···, sₘ} 每个 sⱼ = {wₖ | wₖ ∈ W} 目标：找到 k 个句子，包含尽可能多的关键词\n数学表达：\n最大化：Σⱼ₌₁ⁿ Σᵢ₌₁ᵐ Xᵢsᵢⱼ 约束条件：Σᵢ₌₁ᵐ Xᵢ = k 其中：\nXᵢ = 1（若 sᵢ ∈ C），0（否则） sᵢⱼ = 1（若 wᵢ ∈ sⱼ），0（否则） 3.子模覆盖 C的覆盖被定义为：f(C)=|⋃1_(s_i∈C)▒s_i |\n令 C ⊂ D, 且 sk ∈ D, 我们有：\nf(C∪{S_k })-f(C)=|s_k-⋃1_(S_i∈C)▒s_i |≥|s_k-⋃1_(s_i∈D)▒s_i |=f(D∪{s_k })-f(D)\n此外, 由于 ⋃1_(s_i∈C)▒〖s_i⊂⋃1_(s_i∈D)▒s_i 〗 , 则：f (C) ≤ f (D).\n4. 爬山算法（Greedy Algorithm） 算法流程\n1. 初始化 C = ∅ 2. for i = 1 to k do 3. c = arg max_{s∈S\\C} [f(C ∪ {s}) − f(C)] 4. C = C ∪ {c} 5. output C 理论保证\n若集合函数 f 是单调、子模的，且 f(∅) = 0，则贪心算法可达到 (1 − 1/e) 的近似率：\nf(S) ≥ (1 − 1/e) max_{S\u0026#39;⊆V, |S\u0026#39;|=k} f(S\u0026#39;) 其中 e ≈ 2.718（自然常数）\n算法示例\n给定：\n关键词集合 W = {w₁, w₂, ···, w₈} 9个句子 s₁, s₂, \u0026hellip;, s₉ 目标：选择 k=3 个句子 第一轮：\n计算每个句子的覆盖增益 Δ(Sᵢ) s₄ 具有最大覆盖增益（Δ = 4），被选中 C = {s₄} 第二轮：\n在剩余句子中计算边际增益 s₅ 和 s₈ 具有最大边际增益（Δ = 2） 选择 s₅ C = {s₄, s₅} 第三轮：\ns₁, s₈, s₉ 具有相同边际增益（Δ = 1） 选择 s₁ C = {s₄, s₅, s₁} 最终输出：C = {s₄, s₅, s₁}\n5. 最小规模集合覆盖问题 问题定义\n输入：\n元素集合 X = {e₁, e₂, \u0026hellip;, eₙ} m 个子集 S₁, S₂, \u0026hellip;, Sₘ ⊆ E 输出：找到集合 I ⊆ {1,2,\u0026hellip;,m}，满足：\n⋃ᵢ∈I Sᵢ = X |I| 最小化 注意：顶点覆盖问题是集合覆盖问题的特例\n实际案例\n软件公司员工各有不同技能（C++, Python, Linux, Database, Network\u0026hellip;）\n项目需要多种技能 a₁, a₂, \u0026hellip; 如何组建最精干的队伍完成项目？ 贪心近似算法\nGreedy-Set-Cover(X, F) 1. U ← X 2. I ← ∅ 3. while U ≠ ∅ 4. 选择 Sᵢ 使得 |Sᵢ ∩ U| 最大 5. U ← U − Sᵢ 6. I ← I ∪ {i} 7. return I 理论结果\n定理：GREEDY-SET-COVER 是一个多项式时间的 ρ(n) 近似算法，其中：\nρ(n) = H(max{|S| : S ∈ F}) H 是调和级数：H(d) = 1 + 1/2 + 1/3 + \u0026hellip; + 1/d\n","permalink":"http://localhost:1313/dase-course/mathematical-algorithms-lecture/","summary":"本笔记涵盖数学基础算法篇的完整内容，包括算法分析与相似度搜索、尾不等式及其应用、数据流算法（频繁元素检测、滑动窗口模型）、分布式数据流处理、哈希技术（布隆过滤器、LSH）、线性规划与整数规划、内存计算架构、社区发现算法以及子模函数应用等核心理论与实践。","title":"数学基础算法篇"},{"content":"0.前言 功能概要 数据库设计 1. tb_blog (博客/探店笔记表) 功能: 存储用户发布的探店笔记内容\n字段 类型 说明 id bigint(20) 主键，自增 shop_id bigint(20) 关联的商户ID user_id bigint(20) 发布用户ID title varchar(255) 笔记标题 images varchar(2048) 图片路径，多张用逗号分隔，最多9张 content varchar(2048) 文字描述内容 liked int(8) 点赞数量 comments int(8) 评论数量 create_time timestamp 创建时间 update_time timestamp 更新时间 示例数据: 包含美食探店笔记，如\u0026quot;无尽浪漫的夜晚\u0026quot;、\u0026ldquo;人均30💰杭州港式茶餐厅\u0026quot;等\n2. tb_blog_comments (博客评论表) 功能: 存储博客的评论信息，支持多级评论\n字段 类型 说明 id bigint(20) 主键，自增 user_id bigint(20) 评论用户ID blog_id bigint(20) 关联的博客ID parent_id bigint(20) 父评论ID，一级评论为0 answer_id bigint(20) 回复的评论ID content varchar(255) 评论内容 liked int(8) 点赞数 status tinyint(1) 状态: 0正常, 1被举报, 2禁止查看 create_time timestamp 创建时间 update_time timestamp 更新时间 设计亮点: 通过parent_id和answer_id支持多层级的评论回复\n3. tb_follow (关注关系表) 功能: 记录用户之间的关注关系\n字段 类型 说明 id bigint(20) 主键，自增 user_id bigint(20) 用户ID follow_user_id bigint(20) 被关注的用户ID create_time timestamp 创建时间 用途: 实现社交功能，构建用户关系网络\n4. tb_shop (商铺表) 功能: 存储商铺的基本信息\n字段 类型 说明 id bigint(20) 主键，自增 name varchar(128) 商铺名称 type_id bigint(20) 商铺类型ID images varchar(1024) 商铺图片，多张用逗号分隔 area varchar(128) 商圈，如\u0026quot;陆家嘴\u0026rdquo; address varchar(255) 详细地址 x double 经度 y double 纬度 avg_price bigint(10) 人均价格（整数） sold int(10) 销量 comments int(10) 评论数量 score int(2) 评分(1-5分，乘10保存) open_hours varchar(32) 营业时间 create_time timestamp 创建时间 update_time timestamp 更新时间 示例商铺: 包含103茶餐厅、海底捞火锅、开乐迪KTV等14家商铺\n5. tb_shop_type (商铺类型表) 功能: 商铺分类管理\n字段 类型 说明 id bigint(20) 主键，自增 name varchar(32) 类型名称 icon varchar(255) 图标路径 sort int(3) 排序 create_time timestamp 创建时间 update_time timestamp 更新时间 分类: 美食、KTV、丽人美发、健身运动、按摩足疗、美容SPA、亲子游乐、酒吧、轰趴馆、美睫美甲\n6. tb_user (用户表) 功能: 存储用户基本信息\n字段 类型 说明 id bigint(20) 主键，自增 phone varchar(11) 手机号（唯一索引） password varchar(128) 加密密码 nick_name varchar(32) 昵称 icon varchar(255) 头像路径 create_time timestamp 创建时间 update_time timestamp 更新时间 安全设计: 密码加密存储，手机号唯一\n7. tb_user_info (用户详细信息表) 功能: 存储用户的扩展信息\n字段 类型 说明 user_id bigint(20) 主键，关联用户ID city varchar(64) 城市 introduce varchar(128) 个人介绍 fans int(8) 粉丝数 followee int(8) 关注数 gender tinyint(1) 性别: 0男, 1女 birthday date 生日 credits int(8) 积分 level tinyint(1) 会员等级(0-9) create_time timestamp 创建时间 update_time timestamp 更新时间 8. tb_voucher (代金券表) 功能: 管理商铺的优惠券信息\n字段 类型 说明 id bigint(20) 主键，自增 shop_id bigint(20) 商铺ID title varchar(255) 券标题 sub_title varchar(255) 副标题 rules varchar(1024) 使用规则 pay_value bigint(10) 支付金额（分） actual_value bigint(10) 抵扣金额（分） type tinyint(1) 类型: 0普通券, 1秒杀券 status tinyint(1) 状态: 1上架, 2下架, 3过期 create_time timestamp 创建时间 update_time timestamp 更新时间 9. tb_seckill_voucher (秒杀券表) 功能: 存储秒杀券的特殊信息\n字段 类型 说明 voucher_id bigint(20) 主键，关联券ID stock int(8) 库存数量 begin_time timestamp 生效时间 end_time timestamp 失效时间 create_time timestamp 创建时间 update_time timestamp 更新时间 特点: 与tb_voucher是一对一关系，专门处理秒杀场景\n10. tb_voucher_order (优惠券订单表) 功能: 记录用户购买优惠券的订单\n字段 类型 说明 id bigint(20) 主键（非自增） user_id bigint(20) 用户ID voucher_id bigint(20) 优惠券ID pay_type tinyint(1) 支付方式: 1余额, 2支付宝, 3微信 status tinyint(1) 订单状态: 1未支付, 2已支付, 3已核销, 4已取消, 5退款中, 6已退款 create_time timestamp 下单时间 pay_time timestamp 支付时间 use_time timestamp 核销时间 refund_time timestamp 退款时间 update_time timestamp 更新时间 设计亮点: 完整的订单状态流转，支持退款流程\n11. tb_sign (签到表) 功能: 记录用户的签到信息\n字段 类型 说明 id bigint(20) 主键，自增 user_id bigint(20) 用户ID year year 签到年份 month tinyint(2) 签到月份 date date 签到日期 is_backup tinyint(1) 是否补签 用途: 用户激励体系，支持补签功能\n1.短信登录 基于session实现登录 1.登录流程 2.代码实现 发送短信验证码\n@Slf4j @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements IUserService { @Override public Result sendcode(String phone, HttpSession session){ //1.校验手机号,utils的工具包 if(RegexUtils.isPhoneInvalid(phone)){ //2.如果不符合，返回错误信息 return Result.fail(\u0026#34;手机号格式错误！\u0026#34;); } //3.符合，生成验证码,一个java的工具包 String code = RandomUtil.randomNumbers(6); //4.保存验证码道session session.setAttribute(\u0026#34;code\u0026#34;,code); //5.发送验证码,需要调用第三方的短信平台，比如说阿里云 //TODO log.debug(\u0026#34;发送短信验证码成功，验证码：{}\u0026#34;,code); //返回ok return Result.ok(code); } } 短信验证码验证和登录\n@Override public Result login(LoginFormDTO loginForm, HttpSession session){ //1.校验手机号 String phone = loginForm.getPhone(); if(RegexUtils.isPhoneInvalid(phone)){ return Result.fail(\u0026#34;手机号格式错误！\u0026#34;); } //2.校验验证码 Object cacheCode = session.getAttribute(\u0026#34;code\u0026#34;); String code = loginForm.getCode(); if(cacheCode==null || !cacheCode.toString().equals(code)){ //3.不一致报错 return Result.fail(\u0026#34;验证码错误\u0026#34;); } //4.一致，根据手机号查询用户,select * from tb_user where phone = ? User user = query().eq(\u0026#34;phone\u0026#34;, phone).one(); //5.判断用户是否存在 if(user==null){ //6.不存在，创建用户并保存,只需要填充phone和nickname字段即可 user = createUserWithPhone(String phone); } //7.保存用户信息到session中 session.setAttribute(\u0026#34;user\u0026#34;,user); return Result.ok(); } private User createUserWithPhone(String phone){ //1.创建用户 User user = new User(); user.setPhone(phone); user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(10)); //2.保存用户 save(user); return user; } 校验登录状态\n/* 在utils中添加LoginInterceptor.java作为拦截器 */ public class LoginInterceptor implements HandlerInterceptor { //预拦截 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.获取session HttpSession session = request.getSession(); //2.获取session中的user Object user = session.getAttribute(\u0026#34;user\u0026#34;); //3.判断用户是否在存在 if(user==null){ //4.不存在，返回401状态码 response.setStatus(401); return false; } //5.存在，保存用户信息到ThreadLocal UserHolder.saveUser((UserDTO) user); //6.放行 return true; } //渲染之前的拦截 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { //移除用户 UserHolder.removeUser(); } } /* 在config中添加MvcConfig.java */ @Configuration public class MvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( \u0026#34;/user/code\u0026#34; , \u0026#34;/user/login\u0026#34; , \u0026#34;/blog/hot\u0026#34; , \u0026#34;/shop/**\u0026#34; , \u0026#34;/shop-type/**\u0026#34; , \u0026#34;/upload/**\u0026#34; , \u0026#34;/voucher/**\u0026#34; ); } } /* controller拿到用户登录的信息，通过这个ThreadLocal\t*/ @GetMapping(\u0026#34;/me\u0026#34;) public Result me(){ // 获取当前登录的用户并返回 UserDTO user = UserHolder.getUser(); return Result.ok(user); } 隐藏用户信息\n/* 1.需要在登录的时候，将传入session的user更改成userDTO 2.更改UserHolder中的所有的相关信息和拦截器调用信息为userDTO 3.更改me接口，return一个UserDTO信息 */ //登录时保存用户信息到session中 session.setAttribute(\u0026#34;user\u0026#34;, BeanUtil.copyProperties(user, UserDTO.class)); 集群的session共享问题 基于Redis实现共享session问题 1.Redis字段选择 设计key的要求\n唯一性 便携带 2.Redis实现验证码发送登录问题 3.Redis实现校验登录功能 4.代码实现 发送短信验证码\n@Resource private StringRedisTemplate stringRedisTemplate; @Override public Result sendcode(String phone, HttpSession session){ //1.校验手机号,utils的工具包 if(RegexUtils.isPhoneInvalid(phone)){ //2.如果不符合，返回错误信息 return Result.fail(\u0026#34;手机号格式错误！\u0026#34;); } //3.符合，生成验证码,一个java的工具包 String code = RandomUtil.randomNumbers(6); //4.保存验证码到redis stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY+phone,code,LOGIN_CODE_TTL, TimeUnit.MINUTES); //5.发送验证码,需要调用第三方的短信平台，比如说阿里云 log.debug(\u0026#34;发送短信验证码成功，验证码：{}\u0026#34;,code); //返回ok return Result.ok(code); } 短信验证码验证和登录\n@Override public Result login(LoginFormDTO loginForm, HttpSession session){ //1.校验手机号 String phone = loginForm.getPhone(); if(RegexUtils.isPhoneInvalid(phone)){ return Result.fail(\u0026#34;手机号格式错误！\u0026#34;); } //2.从redis中获取验证码并进行校验 String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY+phone); String code = loginForm.getCode(); if(cacheCode==null || !cacheCode.equals(code)){ //3.不一致报错 return Result.fail(\u0026#34;验证码错误\u0026#34;); } //4.一致，根据手机号查询用户,select * from tb_user where phone = ? User user = query().eq(\u0026#34;phone\u0026#34;, phone).one(); //5.判断用户是否存在 if(user==null){ //6.不存在，创建用户并保存,只需要填充phone和nickname字段即可 user = createUserWithPhone(phone); } //7.保存用户信息到redis //7.1随机生成token,作为登录令牌 String token = UUID.randomUUID().toString(); //7.2将user对象转为hash存储 UserDTO userDTO = BeanUtil.copyProperties(user,UserDTO.class); Map\u0026lt;String, Object\u0026gt; userMap = BeanUtil.beanToMap(userDTO,new HashMap\u0026lt;\u0026gt;(), //解决id字段是整型而不是字符串类型 CopyOptions.create().setIgnoreNullValue(true).setFieldValueEditor((fieldName,fieldValue)-\u0026gt;fieldValue.toString()) ); //7.3存储 String tokenKey = LOGIN_USER_KEY+token; stringRedisTemplate.opsForHash().putAll(tokenKey,userMap); //添加hash对象 stringRedisTemplate.expire(tokenKey,LOGIN_USER_TTL, TimeUnit.MINUTES); //8.返回token return Result.ok(token); 校验登录状态\n需要在MvcConfig中导入RedisTemplate 使用拦截器是为了解决redis像session一样只要有操作就会自动延长过期时间 private StringRedisTemplate stringRedisTemplate; public LoginInterceptor(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } //预拦截 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.获取请求头中的token String token = request.getHeader(\u0026#34;authorization\u0026#34;); if(StrUtil.isBlank(token)){ response.setStatus(401); return false; } //2.基于token获取redis中的用户 String key = RedisConstants.LOGIN_USER_KEY + token; Map\u0026lt;Object, Object\u0026gt; userMap = stringRedisTemplate.opsForHash().entries(key); //3.判断用户是否在存在 if(userMap.isEmpty()){ //4.不存在，返回401状态码 response.setStatus(401); return false; } //5.将查询到的hash数据转为UserDTO对象 UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap,new UserDTO(),false); //6.存在，保存用户信息到ThreadLocal UserHolder.saveUser(userDTO); //7.刷新token的有效期 stringRedisTemplate.expire(key,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES); //8.放行 return true; } /* 此时的MVCCONFIG需要更新 */ @Configuration public class MvcConfig implements WebMvcConfigurer { @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginInterceptor(stringRedisTemplate)) .excludePathPatterns( \u0026#34;/user/code\u0026#34; , \u0026#34;/user/login\u0026#34; , \u0026#34;/blog/hot\u0026#34; , \u0026#34;/shop/**\u0026#34; , \u0026#34;/shop-type/**\u0026#34; , \u0026#34;/upload/**\u0026#34; , \u0026#34;/voucher/**\u0026#34; ); } } 登录拦截器的优化\n如果用户访问的全都不是在拦截器的页面，token仍然会失效 //具体做法：拷贝一份新的RefreshTokenInterceptor，并重写一下LoginInterceptor @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.判断是否需要进行拦截（ThreadLocal中是否有用户） if(UserHolder.getUser() == null){ //没有，需要进行拦截 response.setStatus(401); //拦截 return false; } //有用户，进行放行操作 return true; } //需要更新一下MvcConfig @Configuration public class MvcConfig implements WebMvcConfigurer { @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( \u0026#34;/user/code\u0026#34; , \u0026#34;/user/login\u0026#34; , \u0026#34;/blog/hot\u0026#34; , \u0026#34;/shop/**\u0026#34; , \u0026#34;/shop-type/**\u0026#34; , \u0026#34;/upload/**\u0026#34; , \u0026#34;/voucher/**\u0026#34; ).order(1); registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(\u0026#34;/**\u0026#34;).order(0); } }\t2.商户查询缓存 什么是缓存 缓存的级别\n缓存的优缺点\n添加Redis缓存 1.添加商户查询缓存 代码实现\n@Service public class ShopServiceImpl extends ServiceImpl\u0026lt;ShopMapper, Shop\u0026gt; implements IShopService { @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result queryById(Long id) { String key = RedisConstants.CACHE_SHOP_KEY +id; //1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if(StrUtil.isNotBlank(shopJson)){ //3.存在，直接返回 Shop shop = JSONUtil.toBean(shopJson,Shop.class); return Result.ok(shop); } //4.不存在，根据id查询数据库 Shop shop = getById(id); //5.数据库不存在，返回错误 if(shop==null){ return Result.fail(\u0026#34;店铺不存在\u0026#34;); } //6.存在，将查询结果写入redis stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop)); //7.返回数据 return Result.ok(shop); } } 2.添加商铺类型查询业务 代码实现\n@Service public class ShopTypeServiceImpl extends ServiceImpl\u0026lt;ShopTypeMapper, ShopType\u0026gt; implements IShopTypeService { @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result queryTypeList() { String typeKey= RedisConstants.CACHE_TYPE_KEY; //1.从redis中查询 Long typeListSize = stringRedisTemplate.opsForList().size(typeKey); //2.redis存在数据 if (typeListSize!=null\u0026amp;\u0026amp;typeListSize!=0){ List\u0026lt;String\u0026gt; typeJsonList = stringRedisTemplate.opsForList().range(typeKey, 0, typeListSize-1); List\u0026lt;ShopType\u0026gt; typeList=new ArrayList\u0026lt;\u0026gt;(); for (String typeJson : typeJsonList) { typeList.add(JSONUtil.toBean(typeJson,ShopType.class)); } return Result.ok(typeList); } //3.redis不存在数据 查询数据库 List\u0026lt;ShopType\u0026gt; typeList = query().orderByAsc(\u0026#34;sort\u0026#34;).list(); //4.数据库中不存在相关数据 if (typeList==null){ //数据库不存在数据 return Result.fail(\u0026#34;发生错误\u0026#34;); } //转换 List\u0026lt;String\u0026gt; typeJsonList=new ArrayList\u0026lt;\u0026gt;(); for (ShopType shopType : typeList) { typeJsonList.add(JSONUtil.toJsonStr(shopType)); } //5.数据库存在数据 写入redis stringRedisTemplate.opsForList().rightPushAll(typeKey,typeJsonList); //6.返回数据 return Result.ok(typeList); } } 缓存更新策略 当数据库的数据发生修改时，需要及时更新redis中的值\n1.三种更新策略 2.主动更新策略 3.案例：实现商铺缓存和数据库的双写一致 需求\n代码实现\n@Override @Transactional public Result update(Shop shop) { Long id = shop.getId(); if(id==null){ return Result.fail(\u0026#34;店铺id不能为空\u0026#34;); } //1.更新数据库 updateById(shop); //2.删除缓存 stringRedisTemplate.delete(RedisConstants.CACHE_SHOP_KEY+shop.getId()); return Result.ok(); } 缓存穿透 问题详情\n缓存空对象*\npublic Shop queryWithPassThrough(Long id){ String key = RedisConstants.CACHE_SHOP_KEY +id; //1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if(StrUtil.isNotBlank(shopJson)){ //3.存在，直接返回 Shop shop = JSONUtil.toBean(shopJson,Shop.class); return Result.ok(shop); } //判断是否为空值，如果是“”，就不用返回数据库的查询了，如果是null,就需要进行数据库的查询（因为数据库没有查到会默认传一个“”，省略了查数据库的这一步） if(shopJson != null){ return Result.fail(\u0026#34;店铺信息不存在！\u0026#34;); } //4.不存在，根据id查询数据库 Shop shop = getById(id); //5.数据库不存在，返回错误 if(shop==null){ //将空值写入redis stringRedisTemplate.opsForValue().set(key,\u0026#34;\u0026#34;,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES); return Result.fail(\u0026#34;店铺不存在\u0026#34;); } //6.存在，将查询结果写入redis stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); //7.返回数据 return Result.ok(shop); } 缓存雪崩 缓存击穿 1.互斥锁 案例：\n解决办法:setnx\n代码实现\n@Override public Result queryById(Long id) { //缓存穿透 Shop shop = queryWithPassThrough(id); if(shop == null){ return Result.fail(\u0026#34;店铺查询失败\u0026#34;); } //返回数据 return Result.ok(shop); } //封装缓存穿透的代码——基于锁机制 public Shop queryWithPassThrough(Long id) { String key = RedisConstants.CACHE_SHOP_KEY +id; //1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在，isNotBlank方法会剔除掉null,\u0026#34;\u0026#34;的情况 if(StrUtil.isNotBlank(shopJson)){ //3.存在，直接返回 return JSONUtil.toBean(shopJson,Shop.class); } //4.实现缓存重建 //4.1 获取互斥锁 String lockKey = RedisConstants.LOCK_SHOP_KEY+id; Shop shop = null; try { boolean isLock = tryLock(lockKey); //4.2 判断是否获取成功 if(!isLock){ //4.3 获取失败，休眠 Thread.sleep(50); return queryWithPassThrough(id); //递归处理 } //4.4 成功，进行数据库的查询和缓存重建 shop = getById(id); //模拟重建的超时 Thread.sleep(200); //5.数据库不存在，返回错误 if(shop==null){ //将空值写入redis stringRedisTemplate.opsForValue().set(key,\u0026#34;\u0026#34;,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES); return null; } //6.存在，将查询结果写入redis stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); } catch (InterruptedException e) { throw new RuntimeException(e); }finally { //7.释放互斥锁 unlock(lockKey); } //8.返回数据 return shop; } //获取锁 private boolean tryLock(String key){ Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key,\u0026#34;1\u0026#34;,RedisConstants.LOCK_SHOP_TTL,TimeUnit.SECONDS); //如果flag的值为null，自动进行拆箱将包装类转换为基本数据类型时会抛出NullPointerException return BooleanUtil.isTrue(flag); } //删除锁 private boolean unlock(String key){ return stringRedisTemplate.delete(key); } 2.逻辑过期 案例\n代码实现\nprivate static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); //封装缓存穿透的代码——基于逻辑过期 public Shop queryWithLogicalExpire(Long id) { String key = RedisConstants.CACHE_SHOP_KEY +id; //1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if(StrUtil.isBlank(shopJson)){ //3.不存在，直接返回null return null; } //4.命中，需要把这个json对象反序列化 RedisData redisDate = JSONUtil.toBean(shopJson, RedisData.class); Shop shop = JSONUtil.toBean((JSONObject) redisDate.getData();, Shop.class); LocalDateTime expireTime = redisDate.getExpireTime(); //5，判断是否过期 if (expireTime.isAfter(LocalDateTime.now())) { //5.1 未过期，直接返回店铺信息 return shop; } //5.2 已过期，需要缓存重建 //6.缓存重建 //6.1 获取互斥锁 String localKey = RedisConstants.LOCK_SHOP_KEY + id; boolean isLock = tryLock(localKey); //6.2 判断是否获取锁成功 if(isLock){ //6.3 成功，开启独立线程，实现缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -\u0026gt; { try { //重建缓存 this.saveShopToRedis(id,20L); } catch (Exception e) { throw new RuntimeException(e); } finally { //释放锁 unlock(localKey); } }); } //6.4 返回过期的商铺信息 return shop; } public void saveShopToRedis(Long id,Long expireSeconds){ //1.查询店铺数据 Shop shop = getById(id); Thread.sleep(200); //2.封装逻辑过期时间 RedisData redisData = new RedisData(); redisData.setData(shop); redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds)); //3.写入Redis stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(redisData)); } 缓存封装工具 1.方法类型 2.代码封装 @Slf4j @Component public class CacheClient { private final StringRedisTemplate stringRedisTemplate; public CacheClient(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } public void set(String key, Object value, Long time, TimeUnit unit){ stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit); } public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit){ RedisData redisData = new RedisData(); redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time))); redisData.setData(value); stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData)); } public \u0026lt;R,ID\u0026gt; R queryWithPassThrough( String keyPrefix, ID id, Class\u0026lt;R\u0026gt; type, Function\u0026lt;ID,R\u0026gt; dbFallback, Long time, TimeUnit unit){ String key = keyPrefix +id; //1.从redis查询商铺缓存 String json = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if(StrUtil.isNotBlank(json)){ //3.存在，直接返回 return JSONUtil.toBean(json,type); } //判断是否为空值，如果是“”，就不用返回数据库的查询了，如果是null,就需要进行数据库的查询（因为数据库没有查到会默认传一个“”，省略了查数据库的这一步） if(json != null){ return null; } //4.不存在，根据id查询数据库 R r = dbFallback.apply(id); //5.数据库不存在，返回错误 if(r==null){ //将空值写入redis stringRedisTemplate.opsForValue().set(key,\u0026#34;\u0026#34;,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES); return null; } //6.存在，将查询结果写入redis this.stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(r),time,unit); //7.返回数据 return r; } private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); //封装缓存穿透的代码——基于逻辑过期 public \u0026lt;R,ID\u0026gt; R queryWithLogicalExpire( String prefix, ID id, Class\u0026lt;R\u0026gt; type, Function\u0026lt;ID,R\u0026gt; dbFallback, Long time, TimeUnit unit) { String key = prefix +id; //1.从redis查询商铺缓存 String json = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if(StrUtil.isBlank(json)){ //3.不存在，直接返回null return null; } //4.命中，需要把这个json对象反序列化 RedisData redisDate = JSONUtil.toBean(json, RedisData.class); R r = JSONUtil.toBean((JSONObject) redisDate.getData(), type); LocalDateTime expireTime = redisDate.getExpireTime(); //5，判断是否过期 if (expireTime.isAfter(LocalDateTime.now())) { //5.1 未过期，直接返回店铺信息 return r; } //5.2 已过期，需要缓存重建 //6.缓存重建 //6.1 获取互斥锁 String localKey = RedisConstants.LOCK_SHOP_KEY + id; boolean isLock = tryLock(localKey); //6.2 判断是否获取锁成功 if(isLock){ //6.3 成功，开启独立线程，实现缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -\u0026gt; { try { //查询数据库 R r1 = dbFallback.apply(id); //写入redis this.setWithLogicalExpire(key,r1,time,unit); } catch (Exception e) { throw new RuntimeException(e); } finally { //释放锁 unlock(localKey); } }); } //6.4 返回过期的商铺信息 return r; } //获取锁 private boolean tryLock(String key){ Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key,\u0026#34;1\u0026#34;,RedisConstants.LOCK_SHOP_TTL,TimeUnit.SECONDS); //如果flag的值为null，自动进行拆箱将包装类转换为基本数据类型时会抛出NullPointerException return BooleanUtil.isTrue(flag); } //删除锁 private boolean unlock(String key){ return stringRedisTemplate.delete(key); } } 3.实现样例 //缓存穿透 //Shop shop = cacheClient. //queryWithPassThrough(RedisConstants.CACHE_SHOP_KEY,id,Shop.class,this::getById, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES); //逻辑过期解决缓存击穿 Shop shop = cacheClient. queryWithLogicalExpire(RedisConstants.CACHE_SHOP_KEY,id,Shop.class,this::getById,20L,TimeUnit.SECONDS); 3.优惠券秒杀 全局唯一ID 1.问题来源 2.全局id生成器 3.代码实现 private static final long BEGIN_TIMESTAMP = 1735689600; //序列号位数 private static final int COUNT_BITS = 32; @Resource private StringRedisTemplate stringRedisTemplate; public long nextId(String keyPrefix){ //1.生成时间戳,当前时间-初始时间 LocalDateTime now = LocalDateTime.now(); long nowSecond = now.toEpochSecond(ZoneOffset.UTC); long timeStamp = nowSecond-BEGIN_TIMESTAMP; //2.生成序列号,为了防止序列号进行超标，所以引入了时间key String date = now.format(DateTimeFormatter.ofPattern(\u0026#34;yyyy:MM:dd\u0026#34;)); Long count = stringRedisTemplate.opsForValue().increment(\u0026#34;icr:\u0026#34; + keyPrefix + \u0026#34;:\u0026#34; + date); //3.借助位运算拼接并返回 return timeStamp \u0026lt;\u0026lt; COUNT_BITS | count; } 4.并发测试 @Test void testIdWorker() throws InterruptedException { // CountDownLatch：并发控制工具，这里初始计数为 300（对应 300 个并发任务） CountDownLatch latch = new CountDownLatch(300); // 定义一个并发任务 Runnable Runnable task = () -\u0026gt; { // 每个线程循环生成 100 个 ID for(int i=0;i\u0026lt;100;i++){ // 调用 RedisIdWorker 生成分布式唯一 ID，\u0026#34;order\u0026#34; 是业务前缀 long id = redisIdWorker.nextId(\u0026#34;order\u0026#34;); // 打印生成的 ID，方便观察是否有重复 System.out.println(\u0026#34;id = \u0026#34;+id); } //把 CountDownLatch 的计数器减 1 latch.countDown(); }; // 记录开始时间，用于统计生成 ID 的耗时 long begin = System.currentTimeMillis(); // 向线程池提交 300 个并发任务 for(int i=0;i\u0026lt;300;i++){ executorService.execute(task); } // 主线程阻塞，等待所有任务执行完成 latch.await(); // 记录结束时间 long end = System.currentTimeMillis(); // 输出从提交任务到当前时刻的耗时 System.out.println(\u0026#34;time:\u0026#34;+(end-begin)); } 实现优惠券秒杀下单 1.需求分析 2.添加优惠券(秒杀) 代码实现：\n@Override @Transactional public void addSeckillVoucher(Voucher voucher) { // 保存优惠券 save(voucher); // 保存秒杀信息 SeckillVoucher seckillVoucher = new SeckillVoucher(); seckillVoucher.setVoucherId(voucher.getId()); seckillVoucher.setStock(voucher.getStock()); seckillVoucher.setBeginTime(voucher.getBeginTime()); seckillVoucher.setEndTime(voucher.getEndTime()); seckillVoucherService.save(seckillVoucher); } post测试样例：http://localhost:8081/voucher/seckill\n{ \u0026#34;shopId\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;100元代金券\u0026#34;, \u0026#34;subTitle\u0026#34;: \u0026#34;新用户专享\u0026#34;, \u0026#34;rules\u0026#34;: \u0026#34;仅限堂食使用，不可叠加其他优惠\u0026#34;, \u0026#34;payValue\u0026#34;: 7000, \u0026#34;actualValue\u0026#34;: 10000, \u0026#34;type\u0026#34;: 1, \u0026#34;stock\u0026#34;: 100, \u0026#34;beginTime\u0026#34;: \u0026#34;2025-01-01T10:00:00\u0026#34;, \u0026#34;endTime\u0026#34;: \u0026#34;2030-01-07T23:59:59\u0026#34; } 3.秒杀下单 功能需求\n代码实现\n@Resource private ISeckillVoucherService seckillVoucherService; @Resource private RedisIdWorker redisIdWorker; @Override @Transactional public Result seckillVoucher(Long voucherId) { //1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); //2.判断秒杀是否开始 if(voucher.getBeginTime().isAfter(LocalDateTime.now())){ //尚未开始 return Result.fail(\u0026#34;秒杀尚未开始\u0026#34;); } //3.判断秒杀是否已经结束 if(voucher.getEndTime().isBefore(LocalDateTime.now())){ //已经结束 return Result.fail(\u0026#34;秒杀已经结束\u0026#34;); } //4.判断库存是否充足 if(voucher.getStock() \u0026lt; 1){ //库存不足 return Result.fail(\u0026#34;库存不足！\u0026#34;); } //5.扣减库存 boolean success = seckillVoucherService.update() .setSql(\u0026#34;stock = stock - 1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId).update(); if(!success){ return Result.fail(\u0026#34;库存不足！\u0026#34;); } //6.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); //6.1生成全局唯一的订单Id Long orderId = redisIdWorker.nextId(\u0026#34;order\u0026#34;); voucherOrder.setId(orderId); //6.2设置当前线程内的用户id voucherOrder.setUserId(UserHolder.getUser().getId()); //6.3设置代金券id voucherOrder.setVoucherId(voucherId); //6.4保存到数据库 save(voucherOrder); //7.返回订单 return Result.ok(orderId); } 超卖问题 1.问题来源 2.解决方案 3.乐观锁 版本号法\nCAS法\n4.代码实现 //5.扣减库存 boolean success = seckillVoucherService.update() .setSql(\u0026#34;stock = stock - 1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId).gt(\u0026#34;stock\u0026#34;,0).update(); 一人一单 1.解决方案 2.代码实现 pom.xml中添加依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 添加启动类\n@EnableAspectJAutoProxy(exposeProxy = true) 悲观锁解决一人一单\n@Override public Result seckillVoucher(Long voucherId) { //1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); //2.判断秒杀是否开始 if(voucher.getBeginTime().isAfter(LocalDateTime.now())){ //尚未开始 return Result.fail(\u0026#34;秒杀尚未开始\u0026#34;); } //3.判断秒杀是否已经结束 if(voucher.getEndTime().isBefore(LocalDateTime.now())){ //已经结束 return Result.fail(\u0026#34;秒杀已经结束\u0026#34;); } //4.判断库存是否充足 if(voucher.getStock() \u0026lt; 1){ //库存不足 return Result.fail(\u0026#34;库存不足！\u0026#34;); } Long userId = UserHolder.getUser().getId(); synchronized (userId.toString().intern()) { //获取代理对象，避免没提交到数据库就释放锁的安全问题 IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); } } @Transactional public Result createVoucherOrder(Long voucherId) { //5.一人一单 Long userId = UserHolder.getUser().getId(); //5.1查询订单 Long count = query().eq(\u0026#34;user_id\u0026#34;, userId).eq(\u0026#34;voucher_id\u0026#34;, voucherId).count(); //5.2判断是否存在 if(count \u0026gt; 0L){ //用户已经购买过了 return Result.fail(\u0026#34;用户已经购买过一次！\u0026#34;); } //6.扣减库存 boolean success = seckillVoucherService.update() .setSql(\u0026#34;stock = stock - 1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId).gt(\u0026#34;stock\u0026#34;,0).update(); if(!success){ return Result.fail(\u0026#34;库存不足！\u0026#34;); } //7.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); //7.1生成全局唯一的订单Id Long orderId = redisIdWorker.nextId(\u0026#34;order\u0026#34;); voucherOrder.setId(orderId); //7.2设置当前线程内的用户id voucherOrder.setUserId(UserHolder.getUser().getId()); //7.3设置代金券id voucherOrder.setVoucherId(voucherId); //7.4保存到数据库 save(voucherOrder); //8.返回订单 return Result.ok(orderId); } 分布式锁 1.集群模式下的并发安全问题（TODO） 添加集群\n配置反向代理\n重启nginx nginx.exe -s reload\n问题来源\n2.分布式锁原理 3.redis实现分布式锁 代码实现\npublic class SimpleRedisLock implements ILock{ private final String name; private final StringRedisTemplate stringRedisTemplate; public SimpleRedisLock(String name,StringRedisTemplate stringRedisTemplate){ this.name = name; this.stringRedisTemplate = stringRedisTemplate; } private static final String KEY_PREFIX = \u0026#34;lock:\u0026#34;; @Override public boolean tryLock(Long timeoutSec) { //获取线程标识 long threadId = Thread.currentThread().getId(); //获取锁 Boolean success = stringRedisTemplate.opsForValue(). setIfAbsent(KEY_PREFIX + name, threadId + \u0026#34;\u0026#34;, timeoutSec, TimeUnit.SECONDS); //防止拆箱为NULL return Boolean.TRUE.equals(success); } @Override public void unlock() { //释放锁 stringRedisTemplate.delete(KEY_PREFIX + name); } } 使用样例\n//创建锁对象 SimpleRedisLock lock = new SimpleRedisLock(\u0026#34;order:\u0026#34; + userId, stringRedisTemplate); //获取锁 boolean isLock = lock.tryLock(1200L); //判断锁是否获取成功 if(!isLock){ //获取锁失败或者重试 return Result.fail(\u0026#34;一个人不允许重复下单\u0026#34;); } try { //获取代理对象，避免没提交到数据库就释放锁的安全问题 IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); } catch (IllegalStateException e) { throw new RuntimeException(e); } finally { lock.unlock(); } 4.误删问题 问题来源：业务未完成超时释放锁 。导致线程2，3全都获取锁执行成功\n**解决办法：**判断获取锁的标识前后是否一致。\n代码实现\nprivate static final String KEY_PREFIX = \u0026#34;lock:\u0026#34;; private static final String ID_PREFIX = UUID.randomUUID().toString() + \u0026#39;-\u0026#39;; @Override public boolean tryLock(Long timeoutSec) { //获取线程标识 String threadId = ID_PREFIX+Thread.currentThread().getId(); //获取锁 Boolean success = stringRedisTemplate.opsForValue(). setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS); //防止拆箱为NULL return Boolean.TRUE.equals(success); } @Override public void unlock() { //获取线程标识 String threadId = ID_PREFIX + Thread.currentThread().getId(); //获取锁中的标识 String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name); if(threadId.equals(id)){ //释放锁 stringRedisTemplate.delete(KEY_PREFIX + name); } } 5.原子性问题 问题来源：判断锁标识和释放锁之间产生了阻塞问题，导致锁超时自动释放，导致线程2，3并发安全问题、导致于线程1，3的执行都成功\nLua语言\nLua语言的执行\nLua脚本:实现判断锁标识和释放锁的一致性\n-- 比较线程标识与锁中的线程标识是否一致 if(redis.call(\u0026#39;get\u0026#39;,KEYS[i]) == ARGV[i]) then -- 释放锁 del key return redis.call(\u0026#39;del\u0026#39;,KEYS[i]) end return 0 java调用这个lua脚本\nprivate static final DefaultRedisScript\u0026lt;Long\u0026gt; UNLOCK_SCRIPT; //初始化脚本 static { UNLOCK_SCRIPT = new DefaultRedisScript\u0026lt;\u0026gt;(); UNLOCK_SCRIPT.setLocation(new ClassPathResource(\u0026#34;unlock.lua\u0026#34;)); UNLOCK_SCRIPT.setResultType(Long.class); } @Override public void unlock() { //调用lua脚本 stringRedisTemplate.execute( UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX+name), ID_PREFIX+Thread.currentThread().getId() ); } 6.Redisson重构 问题来源\nRedis秒杀优化 Redis消息队列实现异步秒杀优化 4.达人探店 5.好友关注 6.附近商铺搜索 7.用户签到 8.UV统计 ","permalink":"http://localhost:1313/java-notes/hmdp/","summary":"黑马点评项目学习笔记，涵盖 Redis 缓存、分布式锁、消息队列等核心技术实践","title":"黑马点评项目笔记"},{"content":"第一题：线性回归梯度下降 题目： 对线性模型 $h_\\theta(x) = \\theta^\\top x$，给定训练集 $\\{(x^{(i)}, y^{(i)})\\}$，推导其向量形式的最小二乘损失梯度下降更新公式为：\n$$\\theta := \\theta + \\alpha \\sum_{i=1}^{n} (y^{(i)} - h_\\theta(x^{(i)})) x^{(i)}$$解：\n最小二乘损失函数为：\n$$J(\\theta) = \\frac{1}{2}\\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)})^2 = \\frac{1}{2}\\sum_{i=1}^{n}(\\theta^\\top x^{(i)} - y^{(i)})^2$$对 $\\theta$ 求梯度：\n$$\\begin{aligned} \\nabla_\\theta J(\\theta) \u0026= \\sum_{i=1}^{n}(\\theta^\\top x^{(i)} - y^{(i)}) \\cdot x^{(i)} \\\\ \u0026= \\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} \\end{aligned}$$梯度下降更新规则为 $\\theta := \\theta - \\alpha \\nabla_\\theta J(\\theta)$，因此：\n$$\\theta := \\theta - \\alpha \\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} = \\theta + \\alpha \\sum_{i=1}^{n}(y^{(i)} - h_\\theta(x^{(i)})) x^{(i)}$$ 第二题：交叉熵损失梯度 题目： Cross Entropy Loss 定义如下：\n$$l_{ce}((t_1,\\ldots,t_k),y) = -\\log\\left(\\frac{\\exp(t_y)}{\\sum_j \\exp(t_j)}\\right)$$令向量 $t = (t_1,t_2,\\ldots,t_k)$，推导 CEL 对任意 $t_i$ 求导为：\n$$\\frac{\\partial l_{ce}(t,y)}{\\partial t_i} = \\phi_i - \\mathbb{1}\\{y=i\\}$$解：\n记 $\\phi_i = \\frac{\\exp(t_i)}{\\sum_j \\exp(t_j)}$ 为 softmax 函数。\n首先简化损失函数：\n$$l_{ce}(t,y) = -\\log(\\phi_y) = -t_y + \\log\\left(\\sum_j \\exp(t_j)\\right)$$对 $t_i$ 求导：\n$$\\begin{aligned} \\frac{\\partial l_{ce}(t,y)}{\\partial t_i} \u0026= -\\frac{\\partial t_y}{\\partial t_i} + \\frac{\\partial}{\\partial t_i}\\log\\left(\\sum_j \\exp(t_j)\\right) \\\\ \u0026= -\\mathbb{1}\\{y=i\\} + \\frac{\\exp(t_i)}{\\sum_j \\exp(t_j)} \\\\ \u0026= \\phi_i - \\mathbb{1}\\{y=i\\} \\end{aligned}$$其中 $\\mathbb{1}\\{y=i\\}$ 是指示函数，当 $y=i$ 时为1，否则为0。\n第三题：高斯假设下的最大似然估计 题目： 证明在高斯差异假定下，对线性模型 $h_\\theta(x) = \\theta^\\top x$，最大化参数似然 $L(\\theta)$ 等价于最小化二乘损失 $\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2$。\n解：\n假设误差 $\\epsilon^{(i)} = y^{(i)} - \\theta^\\top x^{(i)}$ 服从独立同分布的高斯分布 $\\mathcal{N}(0, \\sigma^2)$，即：\n$$p(\\epsilon^{(i)}) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(\\epsilon^{(i)})^2}{2\\sigma^2}\\right)$$因此：\n$$p(y^{(i)} | x^{(i)}; \\theta) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right)$$似然函数为：\n$$\\begin{aligned} L(\\theta) \u0026= \\prod_{i=1}^{n} p(y^{(i)} | x^{(i)}; \\theta) \\\\ \u0026= \\prod_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right) \\end{aligned}$$对数似然为：\n$$\\begin{aligned} \\log L(\\theta) \u0026= \\sum_{i=1}^{n}\\left[\\log\\frac{1}{\\sqrt{2\\pi}\\sigma} - \\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right] \\\\ \u0026= n\\log\\frac{1}{\\sqrt{2\\pi}\\sigma} - \\frac{1}{2\\sigma^2}\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2 \\end{aligned}$$最大化 $\\log L(\\theta)$ 等价于最小化 $\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2$。\n第四题：Logistic回归的NLL损失 题目： 对Logistic回归模型 $h_\\theta(x) = g(\\theta^\\top x) = \\frac{1}{1+e^{-\\theta^\\top x}}$，推导其在单样本 $(x,y)$ 下的NLL（negative log likelihood）损失，以及损失对特定参数 $\\theta_j$ 的导数为 $(h_\\theta(x) - y)x_j$。\n提示：Logistic回归预测概率的统一形式为 $P(y|x;\\theta) = (h_\\theta(x))^y(1-h_\\theta(x))^{1-y}$\n解：\n根据提示，Logistic回归的概率模型为：\n$$P(y|x;\\theta) = (h_\\theta(x))^y(1-h_\\theta(x))^{1-y}$$其中 $y \\in \\{0,1\\}$，$h_\\theta(x) = g(\\theta^\\top x) = \\frac{1}{1+e^{-\\theta^\\top x}}$。\n对数似然为：\n$$\\log P(y|x;\\theta) = y\\log(h_\\theta(x)) + (1-y)\\log(1-h_\\theta(x))$$NLL损失为：\n$$\\text{NLL}(x,y;\\theta) = -\\log P(y|x;\\theta) = -y\\log(h_\\theta(x)) - (1-y)\\log(1-h_\\theta(x))$$对 $\\theta_j$ 求导。首先注意到：\n$$\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j} = h_\\theta(x)(1-h_\\theta(x)) \\cdot x_j$$这是因为 $g'(z) = g(z)(1-g(z))$。\n因此：\n$$\\begin{aligned} \\frac{\\partial \\text{NLL}}{\\partial \\theta_j} \u0026= -y\\frac{1}{h_\\theta(x)}\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j} - (1-y)\\frac{1}{1-h_\\theta(x)}\\left(-\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j}\\right) \\\\ \u0026= -y\\frac{1}{h_\\theta(x)} \\cdot h_\\theta(x)(1-h_\\theta(x))x_j + (1-y)\\frac{1}{1-h_\\theta(x)} \\cdot h_\\theta(x)(1-h_\\theta(x))x_j \\\\ \u0026= -y(1-h_\\theta(x))x_j + (1-y)h_\\theta(x)x_j \\\\ \u0026= (h_\\theta(x) - y)x_j \\end{aligned}$$ 第五题：Poisson分布的指数族形式 题目： 已知指数分布族定义如下：$p(y;\\eta) = b(y)\\exp(\\eta^\\top y - a(\\eta))$。推导Poisson分布的指数分布族形式，并构建Poisson分布对应的广义线性模型。其中，Poisson分布 $\\text{Pois}(\\lambda)$ 的概率密度函数如下：\n$$P(X=k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}$$解：\n将Poisson分布改写为指数族形式：\n$$\\begin{aligned} P(X=k) \u0026= \\frac{\\lambda^k e^{-\\lambda}}{k!} \\\\ \u0026= \\frac{1}{k!}\\exp(k\\log\\lambda - \\lambda) \\\\ \u0026= \\frac{1}{k!}\\exp(\\eta \\cdot k - e^\\eta) \\end{aligned}$$其中 $\\eta = \\log\\lambda$（自然参数），因此 $\\lambda = e^\\eta$。\n对应指数族形式：\n$b(y) = \\frac{1}{y!}$ $\\eta = \\log\\lambda$ $a(\\eta) = e^\\eta = \\lambda$ $y$ 的充分统计量就是 $y$ 本身 构建广义线性模型：\n假设 $y|x;\\theta \\sim \\text{Pois}(\\lambda)$ 自然参数 $\\eta = \\theta^\\top x$ 因为 $\\lambda = e^\\eta$，所以 $\\lambda = e^{\\theta^\\top x}$ 响应函数（期望）为：$h_\\theta(x) = \\mathbb{E}[y|x;\\theta] = \\lambda = e^{\\theta^\\top x}$ 这就是Poisson回归模型。\n第六题：Shapley值计算 题目： 计算以下3人团队的Shapley值 $\\phi_1$、$\\phi_2$、$\\phi_3$。\n给定：\n$C_{123} = 10000$，$C_0 = 0$ $C_{12} = 7500$，$C_{13} = 7500$，$C_{23} = 5000$ $C_1 = 5000$，$C_2 = 5000$，$C_3 = 0$ 解：\nShapley值的公式为：\n$$\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(|N|-|S|-1)!}{|N|!}[C(S \\cup \\{i\\}) - C(S)]$$对于3人团队，$|N| = 3$，计算每个玩家的边际贡献：\n玩家1的Shapley值：\n$$\\begin{aligned} \\phi_1 \u0026= \\frac{0!2!}{3!}[C_1 - C_0] + \\frac{1!1!}{3!}[C_{12} - C_2] + \\frac{1!1!}{3!}[C_{13} - C_3] + \\frac{2!0!}{3!}[C_{123} - C_{23}] \\\\ \u0026= \\frac{1}{3}[5000 - 0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[7500 - 0] + \\frac{1}{3}[10000 - 5000] \\\\ \u0026= \\frac{5000}{3} + \\frac{2500}{6} + \\frac{7500}{6} + \\frac{5000}{3} \\\\ \u0026= \\frac{10000}{3} + \\frac{10000}{6} = \\frac{20000 + 10000}{6} = 5000 \\end{aligned}$$玩家2的Shapley值：\n$$\\begin{aligned} \\phi_2 \u0026= \\frac{0!2!}{3!}[C_2 - C_0] + \\frac{1!1!}{3!}[C_{12} - C_1] + \\frac{1!1!}{3!}[C_{23} - C_3] + \\frac{2!0!}{3!}[C_{123} - C_{13}] \\\\ \u0026= \\frac{1}{3}[5000 - 0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[5000 - 0] + \\frac{1}{3}[10000 - 7500] \\\\ \u0026= \\frac{5000}{3} + \\frac{2500}{6} + \\frac{5000}{6} + \\frac{2500}{3} \\\\ \u0026= \\frac{10000 + 2500 + 5000 + 5000}{6} = \\frac{22500}{6} =3750 \\end{aligned}$$玩家3的Shapley值：\n由对称性或直接计算：\n$$\\phi_3 = 10000 - \\phi_1 - \\phi_2 = 10000 - 5000 - 4583.33 = 416.67$$或直接计算：\n$$\\begin{aligned} \\phi_3 \u0026= \\frac{1}{3}[0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[5000 - 5000] + \\frac{1}{3}[10000 - 7500] \\\\ \u0026= 0 + \\frac{2500}{6} + 0 + \\frac{2500}{3} = \\frac{7500}{6} =1250 \\end{aligned}$$答案： $\\phi_1 = 5000$，$\\phi_2 = 3750$，$\\phi_3 $=1250\n第七题：协方差矩阵性质 题目： 基于协方差矩阵定义 $\\Sigma = \\text{Cov}(X)$ 证明：\n$\\Sigma$ 为对称矩阵； $\\Sigma$ 半正定，记 $\\Sigma \\geq 0$，即对任意向量 $z \\in \\mathbb{R}^d$ 有 $z^\\top \\Sigma z \\geq 0$。 解：\n设 $X \\in \\mathbb{R}^d$ 为随机向量，$\\mu = \\mathbb{E}[X]$，则：\n$$\\Sigma = \\text{Cov}(X) = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top]$$(1) 证明 $\\Sigma$ 为对称矩阵：\n$$\\Sigma^\\top = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top]^\\top = \\mathbb{E}[((X-\\mu)(X-\\mu)^\\top)^\\top] = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top] = \\Sigma$$因此 $\\Sigma$ 是对称矩阵。\n(2) 证明 $\\Sigma$ 半正定：\n对任意 $z \\in \\mathbb{R}^d$：\n$$\\begin{aligned} z^\\top \\Sigma z \u0026= z^\\top \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top] z \\\\ \u0026= \\mathbb{E}[z^\\top(X-\\mu)(X-\\mu)^\\top z] \\\\ \u0026= \\mathbb{E}[(z^\\top(X-\\mu))^2] \\\\ \u0026\\geq 0 \\end{aligned}$$最后一步是因为期望中的项是平方项，必然非负。因此 $\\Sigma$ 半正定。\n第八题：高斯判别分析的MLE 题目： 对高斯判别分析，已知各变量概率分布为：\n$$\\begin{aligned} p(y) \u0026= \\phi^y(1-\\phi)^{1-y} \\\\ p(x|y=0) \u0026= \\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}\\exp\\left(-\\frac{1}{2}(x-\\mu_0)^\\top\\Sigma^{-1}(x-\\mu_0)\\right) \\\\ p(x|y=1) \u0026= \\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}\\exp\\left(-\\frac{1}{2}(x-\\mu_1)^\\top\\Sigma^{-1}(x-\\mu_1)\\right) \\end{aligned}$$证明在极大似然估计下，参数 $\\phi$、$\\mu_0$、$\\mu_1$ 的形式为：\n$$\\begin{aligned} \\phi \u0026= \\frac{1}{n}\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\} \\\\ \\mu_0 \u0026= \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}} \\\\ \\mu_1 \u0026= \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}} \\end{aligned}$$解：\n对数似然函数为：\n$$\\log L = \\sum_{i=1}^{n}\\left[\\log p(y^{(i)}) + \\log p(x^{(i)}|y^{(i)})\\right]$$估计 $\\phi$：\n$$\\log L_\\phi = \\sum_{i=1}^{n}\\log p(y^{(i)}) = \\sum_{i=1}^{n}[y^{(i)}\\log\\phi + (1-y^{(i)})\\log(1-\\phi)]$$令 $\\frac{\\partial \\log L_\\phi}{\\partial \\phi} = 0$：\n$$\\sum_{i=1}^{n}\\left[\\frac{y^{(i)}}{\\phi} - \\frac{1-y^{(i)}}{1-\\phi}\\right] = 0$$解得：\n$$\\phi = \\frac{1}{n}\\sum_{i=1}^{n}y^{(i)} = \\frac{1}{n}\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}$$估计 $\\mu_0$：\n只考虑 $y=0$ 的样本：\n$$\\log L_{\\mu_0} = \\sum_{i:y^{(i)}=0}\\left[-\\frac{1}{2}(x^{(i)}-\\mu_0)^\\top\\Sigma^{-1}(x^{(i)}-\\mu_0) + \\text{const}\\right]$$令 $\\frac{\\partial \\log L_{\\mu_0}}{\\partial \\mu_0} = 0$：\n$$\\sum_{i:y^{(i)}=0}\\Sigma^{-1}(x^{(i)}-\\mu_0) = 0$$解得：\n$$\\mu_0 = \\frac{\\sum_{i:y^{(i)}=0}x^{(i)}}{\\sum_{i:y^{(i)}=0}1} = \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}}$$同理可得 $\\mu_1$ 的估计。\n第九题：GDA可转化为Logistic回归 题目： 证明GDA可转化为Logistic回归。提示：\n$p(y=1|x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=1)p(y=1) + p(x|y=0)p(y=0)}$ 可记 $r(x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)}$ 给出 $p(x|y=0)$, $p(x|y=1)$, $p(y=1)$ 的表达式 解：\n根据贝叶斯定理：\n$$p(y=1|x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=1)p(y=1) + p(x|y=0)p(y=0)} = \\frac{1}{1 + \\frac{p(x|y=0)p(y=0)}{p(x|y=1)p(y=1)}} = \\frac{1}{1 + \\frac{1}{r(x)}}$$其中：\n$$r(x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)}$$计算 $\\log r(x)$：\n$$\\begin{aligned} \\log r(x) \u0026= \\log p(x|y=1) + \\log p(y=1) - \\log p(x|y=0) - \\log p(y=0) \\\\ \u0026= -\\frac{1}{2}(x-\\mu_1)^\\top\\Sigma^{-1}(x-\\mu_1) + \\frac{1}{2}(x-\\mu_0)^\\top\\Sigma^{-1}(x-\\mu_0) + \\log\\frac{\\phi}{1-\\phi} \\end{aligned}$$展开：\n$$\\begin{aligned} \\log r(x) \u0026= -\\frac{1}{2}x^\\top\\Sigma^{-1}x + x^\\top\\Sigma^{-1}\\mu_1 - \\frac{1}{2}\\mu_1^\\top\\Sigma^{-1}\\mu_1 \\\\ \u0026\\quad + \\frac{1}{2}x^\\top\\Sigma^{-1}x - x^\\top\\Sigma^{-1}\\mu_0 + \\frac{1}{2}\\mu_0^\\top\\Sigma^{-1}\\mu_0 + \\log\\frac{\\phi}{1-\\phi} \\\\ \u0026= x^\\top\\Sigma^{-1}(\\mu_1 - \\mu_0) + \\frac{1}{2}(\\mu_0^\\top\\Sigma^{-1}\\mu_0 - \\mu_1^\\top\\Sigma^{-1}\\mu_1) + \\log\\frac{\\phi}{1-\\phi} \\\\ \u0026= \\theta^\\top x + \\theta_0 \\end{aligned}$$其中：\n$$\\theta = \\Sigma^{-1}(\\mu_1 - \\mu_0), \\quad \\theta_0 = \\frac{1}{2}(\\mu_0^\\top\\Sigma^{-1}\\mu_0 - \\mu_1^\\top\\Sigma^{-1}\\mu_1) + \\log\\frac{\\phi}{1-\\phi}$$因此：\n$$p(y=1|x) = \\frac{1}{1+e^{-\\theta^\\top x - \\theta_0}} = \\frac{1}{1+e^{-\\tilde{\\theta}^\\top \\tilde{x}}}$$这正是Logistic回归的形式（其中 $\\tilde{x}$ 包含截距项）。\n第十题：Kernel Method分析 题目： Kernel method中，若Kernel function $K(x,z) = (x^\\top z + c)^2$，推导对应的feature mapping $\\phi$，并讨论对于 $n$ 个样本一轮SGD，使用Kernel method和在feature map上的计算效率优化比。\n提示：\n基于feature map的参数更新方法为：$\\theta := \\theta + \\alpha\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top\\phi(x^{(i)}))\\phi(x^{(i)})$ Kernel method的参数更新方法为：$\\theta := \\theta + \\alpha(\\tilde{y} - K\\theta)$，其中 $K_j = K(x^{(i)}, x^{(j)})$ 解：\n推导feature mapping：\n对于 $x,z \\in \\mathbb{R}^d$，展开核函数：\n$$\\begin{aligned} K(x,z) \u0026= (x^\\top z + c)^2 \\\\ \u0026= (x_1z_1 + x_2z_2 + \\cdots + x_dz_d + c)^2 \\\\ \u0026= \\sum_{i=1}^{d}x_i^2z_i^2 + \\sum_{i \\neq j}2x_ix_jz_iz_j + 2c\\sum_{i=1}^{d}x_iz_i + c^2 \\end{aligned}$$因此，feature mapping为：\n$$\\phi(x) = (x_1^2, x_2^2, \\ldots, x_d^2, \\sqrt{2}x_1x_2, \\sqrt{2}x_1x_3, \\ldots, \\sqrt{2}x_{d-1}x_d, \\sqrt{2c}x_1, \\ldots, \\sqrt{2c}x_d, c)$$维度为：$d + \\binom{d}{2} + d + 1 = d + \\frac{d(d-1)}{2} + d + 1 = \\frac{d(d+3)}{2} + 1 = O(d^2)$\n计算效率比较：\nFeature map方法： 计算 $\\phi(x^{(i)})$：$O(d^2)$ 每个样本 内积 $\\theta^\\top\\phi(x^{(i)})$：$O(d^2)$ 更新 $\\theta$：$O(d^2)$ 总计：$O(nd^2)$ 每轮SGD Kernel method： 计算核矩阵 $K$：$O(n^2d)$（一次性预计算） 更新参数：$O(n^2)$（矩阵向量乘法） 总计：$O(n^2d + n^2) = O(n^2d)$ 每轮 效率比：\n$$\\frac{\\text{Feature map}}{\\text{Kernel method}} = \\frac{O(nd^2)}{O(n^2d)} = \\frac{d}{n}$$ 当 $n \\ll d$ 时（样本少，特征多），Kernel method更高效 当 $n \\gg d$ 时（样本多，特征少），Feature map方法更高效 第十一题：超平面的函数间隔和几何间隔 题目： 对超平面 $w^\\top x + b = 0$，样本 $x^{(i)}$ 到的函数间隔 $\\hat{\\gamma}^{(i)}$ 与几何间隔 $\\gamma^{(i)}$ 满足何关系？直接给出答案即可。\n解：\n函数间隔定义为：\n$$\\hat{\\gamma}^{(i)} = y^{(i)}(w^\\top x^{(i)} + b)$$几何间隔定义为：\n$\\gamma^{(i)} = \\frac{y^{(i)}(w^\\top x^{(i)} + b)}{|w|} = \\frac{\\hat{\\gamma}^{(i)}}{|w|}$\n关系：\n$\\gamma^{(i)} = \\frac{\\hat{\\gamma}^{(i)}}{|w|}$\n几何间隔是函数间隔除以权重向量的范数，表示点到超平面的真实距离。\n第十二题：SVM的Lagrange函数和对偶形式 题目： 已知SVM的优化目标为：\n$$ \\min_{w,b} \\quad \\frac{1}{2}\\|w\\|^2 \\qquad (1) $$$$ \\text{s.t.} \\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1, \\quad i=1,\\ldots,n $$请构造其Lagrange函数 $\\mathcal{L}(w,b,\\alpha)$。\n已知 $\\mathcal{L}(w,b,\\alpha)$ 满足Slater条件，因此强对偶成立，问题(1)最终可转化为 $\\max_{\\alpha;\\alpha_i\\geq 0}\\min_w \\mathcal{L}(w,b,\\alpha)$，证明该对偶形式问题可进一步转化为：\n$$ \\max_\\alpha W(\\alpha) = \\max_\\alpha \\left(\\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle\\right) \\qquad (2) $$约束条件：\n$$ \\alpha_i \\geq 0, \\quad i=1,\\ldots,n $$$$ \\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0 $$解：\n步骤1：构造Lagrange函数\n$\\mathcal{L}(w,b,\\alpha) = \\frac{1}{2}\\|w\\|^2 - \\sum_{i=1}^{n}\\alpha_i[y^{(i)}(w^\\top x^{(i)} + b) - 1]$\n其中 $\\alpha_i \\geq 0$ 为Lagrange乘子。\n步骤2：固定 $\\alpha$，对 $w$ 求导\n$\\frac{\\partial \\mathcal{L}}{\\partial w} = w - \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)} = 0$\n因此：\n$w = \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}$\n步骤3：固定 $\\alpha$，对 $b$ 求导\n$\\frac{\\partial \\mathcal{L}}{\\partial b} = -\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$\n因此：\n$\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$\n步骤4：代入Lagrange函数\n将 $w = \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}$ 代入 $\\mathcal{L}$：\n$\\begin{aligned} \\mathcal{L}(w,b,\\alpha) \u0026= \\frac{1}{2}w^\\top w - \\sum_{i=1}^{n}\\alpha_i y^{(i)} w^\\top x^{(i)} - b\\sum_{i=1}^{n}\\alpha_i y^{(i)} + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\frac{1}{2}\\left(\\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}\\right)^\\top\\left(\\sum_{j=1}^{n}\\alpha_j y^{(j)} x^{(j)}\\right) - \\sum_{i=1}^{n}\\alpha_i y^{(i)} \\left(\\sum_{j=1}^{n}\\alpha_j y^{(j)} x^{(j)}\\right)^\\top x^{(i)} + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle - \\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle \\end{aligned}$\n其中使用了 $\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$，所以 $b$ 项消失。\n因此对偶问题为：\n$\\max_\\alpha W(\\alpha) = \\max_\\alpha \\left(\\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle\\right)$\n约束条件为：\n$\\begin{aligned} \\alpha_i \u0026\\geq 0, \\quad i=1,\\ldots,n \\\\ \\sum_{i=1}^{n}\\alpha_i y^{(i)} \u0026= 0 \\end{aligned}$\n第十三题：线性不可分的SVM与L1正则 题目： 对线性不可分的训练集，SVM对应带L1正则的优化目标是什么？已知对线性可分情况的优化为：\n$$ \\min_{w,b} \\quad \\frac{1}{2}\\|w\\|^2 \\qquad (1) $$ $$ \\text{s.t.} \\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1, \\quad i=1,\\ldots,n $$解：\n对于线性不可分的情况，引入松弛变量 $\\xi_i \\geq 0$，允许某些样本违反间隔约束。\n带L1正则的软间隔SVM优化目标为：\n$\\begin{aligned} \\min_{w,b,\\xi} \u0026\\quad \\frac{1}{2}|w|^2 + C\\sum_{i=1}^{n}\\xi_i \\\\ \\text{s.t.} \u0026\\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1 - \\xi_i, \\quad i=1,\\ldots,n \\\\ \u0026\\quad \\xi_i \\geq 0, \\quad i=1,\\ldots,n \\end{aligned}$\n其中：\n$\\xi_i$ 是松弛变量，表示样本 $i$ 违反间隔的程度 $C \u003e 0$ 是惩罚参数，控制间隔最大化与违反程度之间的权衡 $C\\sum_{i=1}^{n}\\xi_i$ 是L1正则项（对松弛变量的惩罚） 这个目标函数平衡了两个目标：\n最大化间隔（通过最小化 $|w|^2$） 最小化分类错误（通过最小化 $\\sum\\xi_i$） 第十四题：SVM最优化问题分析 题目： 已知SVM的最终优化目标为：\n$W(\\alpha) = \\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle$\n假设此时正在优化 $\\alpha_1$ 与 $\\alpha_2$，并有 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$。请推导此时 $\\alpha_2$ 应当更新的值。\n解：\n简化目标函数：\n在固定其他 $\\alpha_i$ ($i \\geq 3$) 的情况下，目标函数关于 $\\alpha_1, \\alpha_2$ 可写为：\n$W(\\alpha_1, \\alpha_2) = \\alpha_1 + \\alpha_2 + W_0 - \\frac{1}{2}[K_{11}\\alpha_1^2 + K_{22}\\alpha_2^2 + 2K_{12}\\alpha_1\\alpha_2y^{(1)}y^{(2)}] + \\text{线性项}$\n其中 $K_{ij} = \\langle x^{(i)}, x^{(j)}\\rangle$，$W_0$ 是常数项。\n利用约束 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$：\n这个约束来自 $\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$，可以改写为：\n$\\alpha_1 y^{(1)} + \\alpha_2 y^{(2)} = -\\sum_{i=3}^{n}\\alpha_i y^{(i)} = \\zeta \\quad \\text{（常数）}$\n将 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$ 代入目标函数，得到关于 $\\alpha_2$ 的单变量优化问题。\n对 $\\alpha_2$ 求导并令其为0，经过复杂推导（涉及预测误差），得到 $\\alpha_2$ 的无约束最优解：\n$\\alpha_2^{\\text{new, unc}} = \\alpha_2^{\\text{old}} + \\frac{y^{(2)}(E_1 - E_2)}{\\eta}$\n其中：\n$E_i = f(x^{(i)}) - y^{(i)}$ 是预测误差 $\\eta = K_{11} + K_{22} - 2K_{12} = \\|x^{(1)} - x^{(2)}\\|^2$（特征空间距离） 考虑约束 $0 \\leq \\alpha_2 \\leq C$：\n根据约束 $\\alpha_1 y^{(1)} + \\alpha_2 y^{(2)} = \\zeta$：\n若 $y^{(1)} \\neq y^{(2)}$： $L = \\max(0, \\alpha_2^{\\text{old}} - \\alpha_1^{\\text{old}}), \\quad H = \\min(C, C + \\alpha_2^{\\text{old}} - \\alpha_1^{\\text{old}})$ 若 $y^{(1)} = y^{(2)}$： $L = \\max(0, \\alpha_1^{\\text{old}} + \\alpha_2^{\\text{old}} - C), \\quad H = \\min(C, \\alpha_1^{\\text{old}} + \\alpha_2^{\\text{old}})$ 最终更新公式：\n$\\alpha_2^{\\text{new}} = \\begin{cases} H \u0026 \\text{if } \\alpha_2^{\\text{new, unc}} \u003e H \\\\ \\alpha_2^{\\text{new, unc}} \u0026 \\text{if } L \\leq \\alpha_2^{\\text{new, unc}} \\leq H \\\\ L \u0026 \\text{if } \\alpha_2^{\\text{new, unc}} \u003c L \\end{cases}$\n然后通过约束更新 $\\alpha_1$：\n$\\alpha_1^{\\text{new}} = \\alpha_1^{\\text{old}} + y^{(1)}y^{(2)}(\\alpha_2^{\\text{old}} - \\alpha_2^{\\text{new}})$\n第十五题：信息增益比计算 题目： 计算给定数据集中四个特征的信息增益比。可保留log项，统一底数为2。\n解：\n首先计算数据集的熵。类别分布：否=6，是=9，总计15。\n$H(D) = -\\frac{6}{15}\\log_2\\frac{6}{15} - \\frac{9}{15}\\log_2\\frac{9}{15} = -0.4\\log_2(0.4) - 0.6\\log_2(0.6) = 0.971$\n特征1：年龄 青年(5个)：否=3，是=2，$H = 0.971$ 中年(5个)：否=1，是=4，$H = 0.722$ 老年(5个)：否=2，是=3，$H = 0.971$ 条件熵：\n$H(D|\\text{年龄}) = \\frac{5}{15}(0.971) + \\frac{5}{15}(0.722) + \\frac{5}{15}(0.971) = 0.888$\n信息增益：\n$\\text{Gain}(\\text{年龄}) = 0.971 - 0.888 = 0.083$\n特征熵（分裂信息）：\n$H_A(\\text{年龄}) = -3 \\times \\frac{5}{15}\\log_2\\frac{5}{15} = \\log_2 3 = 1.585$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{年龄}) = \\frac{0.083}{1.585} = 0.052 $$特征2：有工作 否(8个)：否=4，是=4，$H = 1.0$ 是(7个)：否=2，是=5，$H = 0.863$ 条件熵：$H(D|\\text{有工作}) = 0.936$\n信息增益：$\\text{Gain}(\\text{有工作}) = 0.035$\n特征熵：$H_A(\\text{有工作}) = 0.997$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{有工作}) = 0.035 $$特征3：有自己的房子 否(9个)：否=3，是=6，$H = 0.918$ 是(6个)：否=3，是=3，$H = 1.0$ 条件熵：$H(D|\\text{有房}) = 0.951$\n信息增益：$\\text{Gain}(\\text{有房}) = 0.020$\n特征熵：$H_A(\\text{有房}) = 0.971$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{有房}) = 0.021 $$特征4：信贷情况 一般(5个)：否=4，是=1，$H = 0.722$ 好(6个)：否=2，是=4，$H = 0.918$ 非常好(4个)：否=0，是=4，$H = 0$ 条件熵：$H(D|\\text{信贷}) = 0.608$\n信息增益：$\\text{Gain}(\\text{信贷}) = 0.363$\n特征熵：$H_A(\\text{信贷}) = 1.557$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{信贷}) = 0.233 $$总结（信息增益比排序） 信贷情况：0.233 ⭐（最佳分裂特征） 年龄：0.052 有工作：0.035 有自己的房子：0.021 应选择\u0026quot;信贷情况\u0026quot;作为根节点的分裂特征。\n第十六题：XGBoost损失函数二阶泰勒展开 题目： 已知XGBoost优化第t棵树时的损失函数为：\n$\\mathcal{L}^{(t)} = \\sum_{i=1}^{n}l(y_i, \\hat{y}*i^{(t-1)} + f_t(x_i)) + \\gamma T + \\frac{1}{2}\\lambda\\sum*{j=1}^{T}w_j^2$\n请推导 $l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i))$ 在 $l(y_i, \\hat{y}_i^{(t-1)})$ 处对于 $f_t(x_i)$ 的二阶泰勒展开。其中，一阶和二阶导数可使用：\n$g_i = \\frac{\\partial l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i}\\Big|*{\\hat{y}_i^{(t-1)}}, \\quad h_i = \\frac{\\partial^2 l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i^2}\\Big|*{\\hat{y}_i^{(t-1)}}$\n在此基础上，推导叶子节点 $j$ 对应的 $w_j^*$ 满足：\n$w_j^* = -\\frac{\\sum_{i \\in \\mathcal{I}*j}g_i}{\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda}$\n其中，$\\mathcal{I}_j = \\{i \\mid q(x_i) = j\\}$ 表示属于叶子节点 $j$ 的样本集合。\n解：\n二阶泰勒展开 在 $\\hat{y}_i^{(t-1)}$ 处对 $l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i))$ 关于 $f_t(x_i)$ 进行二阶泰勒展开：\n$\\begin{aligned} l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i)) \u0026\\approx l(y_i, \\hat{y}_i^{(t-1)}) + \\frac{\\partial l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i}\\Big|*{\\hat{y}_i^{(t-1)}} \\cdot f_t(x_i) \\\\ \u0026\\quad + \\frac{1}{2}\\frac{\\partial^2 l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i^2}\\Big|*{\\hat{y}_i^{(t-1)}} \\cdot f_t(x_i)^2 \\\\ \u0026= l(y_i, \\hat{y}_i^{(t-1)}) + g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2 \\end{aligned}$\n因此损失函数变为：\n$\\mathcal{L}^{(t)} \\approx \\sum_{i=1}^{n}[l(y_i, \\hat{y}*i^{(t-1)}) + g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2] + \\gamma T + \\frac{1}{2}\\lambda\\sum*{j=1}^{T}w_j^2$\n去掉常数项 $\\sum_{i=1}^{n}l(y_i, \\hat{y}_i^{(t-1)})$：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{i=1}^{n}[g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2] + \\gamma T + \\frac{1}{2}\\lambda\\sum_{j=1}^{T}w_j^2$\n推导叶子权重 $w_j^*$ 对于树模型，$f_t(x_i) = w_{q(x_i)}$，其中 $q(x_i)$ 表示样本 $i$ 落在的叶子节点。\n将样本按叶子节点分组：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{j=1}^{T}\\left[\\left(\\sum_{i \\in \\mathcal{I}*j}g_i\\right)w_j + \\frac{1}{2}\\left(\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda\\right)w_j^2\\right] + \\gamma T$\n记 $G_j = \\sum_{i \\in \\mathcal{I}*j}g_i$，$H_j = \\sum*{i \\in \\mathcal{I}_j}h_i$，则：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{j=1}^{T}\\left[G_j w_j + \\frac{1}{2}(H_j + \\lambda)w_j^2\\right] + \\gamma T$\n对 $w_j$ 求导并令其为0：\n$\\frac{\\partial \\tilde{\\mathcal{L}}^{(t)}}{\\partial w_j} = G_j + (H_j + \\lambda)w_j = 0$\n解得：\n$w_j^* = -\\frac{G_j}{H_j + \\lambda} = -\\frac{\\sum_{i \\in \\mathcal{I}*j}g_i}{\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda}$\n这就是叶子节点的最优权重。将其代入损失函数，得到：\n$\\tilde{\\mathcal{L}}^{(t)} = -\\frac{1}{2}\\sum_{j=1}^{T}\\frac{G_j^2}{H_j + \\lambda} + \\gamma T$\n这个公式用于评估树结构的质量，指导分裂决策。\n第十七题 KV Cache 计算 题目： 假设我们要在一台服务器上对一个采用多头注意力（MHA）的 Transformer 模型进行推理。模型参数如下：隐藏层维度 $d = 4096$，层数 $L = 32$，注意力头数 $h = 32$，采用 FP16 半精度存储（每个元素占 2 Bytes）。\n请给出生成第 $N$ 个 token 时，KV Cache 新增存储占用的计算公式。 当 Batch Size $B = 1$，序列长度达到 $N = 1024$ 时，请计算该请求在显存中占用的 KV Cache 总量（单位：MB）。 解：\n1. KV Cache 新增存储计算公式 生成第 $N$ 个 token 时，每一层需要存储该 token 的 Key 和 Value 向量。\n每个 token 的 K 和 V 向量维度均为 $d$ 总层数为 $L$ 每个元素占 2 Bytes（FP16） 因此，生成第 $N$ 个 token 时，KV Cache 新增存储占用为：\n$$\\text{新增存储} = 2 \\times L \\times d \\times 2 \\text{ Bytes} = 4Ld \\text{ Bytes}$$其中第一个 2 表示 K 和 V 两部分。\n2. 序列长度 N=1024 时的总 KV Cache 当序列长度为 $N = 1024$，Batch Size $B = 1$ 时：\n$$\\begin{aligned} \\text{总存储} \u0026= B \\times N \\times 2 \\times L \\times d \\times 2 \\text{ Bytes} \\\\\u0026= 1 \\times 1024 \\times 2 \\times 32 \\times 4096 \\times 2 \\text{ Bytes} \\\\\u0026= 1024 \\times 2 \\times 32 \\times 4096 \\times 2 \\text{ Bytes} \\\\\u0026= 536{,}870{,}912 \\text{ Bytes} \\\\ \u0026= 512 \\text{ MB} \\end{aligned}$$ 第十八题 RoPE 旋转位置编码 题目： 对于位置 $m$ 的查询向量 $q_m$ 和位置 $n$ 的键向量 $k_n$：\n证明旋转位置编码（RoPE）下变换后的向量 $\\tilde{q}_m$ 和 $\\tilde{k}_n$ 的点积仅和 $q_m$、$k_n$ 及相对位置 $m - n$ 相关； 进一步说明 RoPE 会对 q/k/v 向量中的哪几个进行位置信息注入。 提示： RoPE 通过旋转矩阵 $R_{pos}$ 将位置信息注入向量。\n解：\n1. 证明点积仅与相对位置相关 RoPE 通过旋转矩阵将位置信息编码。对于二维情况，旋转矩阵为：\n$$R_\\theta = \\begin{pmatrix} \\cos\\theta \u0026 -\\sin\\theta \\ \\sin\\theta \u0026 \\cos\\theta \\end{pmatrix}$$对于位置 $m$ 和 $n$，变换后的向量为：\n$$\\tilde{q}*m = R*{m\\theta} q_m, \\quad \\tilde{k}*n = R*{n\\theta} k_n$$它们的点积为： $$ \\begin{aligned} \\tilde{q}_m^\\top \\tilde{k}_n \u0026= (R_{m\\theta} q_m)^\\top (R_{n\\theta} k_n) \\\\ \u0026= q_m^\\top R_{m\\theta}^\\top R_{n\\theta} k_n \\\\ \u0026= q_m^\\top R_{(n-m)\\theta} k_n \\end{aligned} $$ 由于旋转矩阵满足 $R_\\alpha^\\top R_\\beta = R_{\\beta - \\alpha}$，因此点积仅依赖于相对位置 $m - n$。\n更高维度的情况下，RoPE 将向量分成多个二维子空间，每个子空间独立应用旋转，结论同样成立。\n2. RoPE 对哪些向量注入位置信息 RoPE 仅对 Query (q) 和 Key (k) 向量注入位置信息，不对 Value (v) 向量进行位置编码。\n原因是注意力机制通过 $\\text{softmax}(q^\\top k)$ 计算注意力权重，位置信息需要影响这个权重计算，而 Value 向量仅用于加权求和，不需要位置编码。\n第十九题 Transformer Block 的 Post-norm 和 Pre-norm 题目： 对于 Transformer Block 的 Post-norm 有：\n$$x_{l+1} = x_l + \\text{Sublayer}(x_l)$$ $$y_{l+1} = \\text{LN}(x_{l+1})$$ 请相应给出 Pre-norm 的计算公式； 结合梯度分析证明 Post-norm 相比 Pre-norm 更易出现梯度消失或放大，并指出其中的梯度恒等映射通路。 解：\n1. Pre-norm 计算公式 Pre-norm 将 LayerNorm 应用在 Sublayer 之前：\n$$y_l = \\text{LN}(x_l)$$ $$x_{l+1} = x_l + \\text{Sublayer}(y_l)$$2. 梯度分析 Post-norm 的梯度：\n对于 Post-norm：$y_{l+1} = \\text{LN}(x_l + \\text{Sublayer}(x_l))$\n反向传播时：\n$$\\frac{\\partial \\mathcal{L}}{\\partial x_l} = \\frac{\\partial \\mathcal{L}}{\\partial y_{l+1}} \\cdot \\frac{\\partial \\text{LN}}{\\partial x_{l+1}} \\cdot \\left(I + \\frac{\\partial \\text{Sublayer}}{\\partial x_l}\\right)$$由于 LayerNorm 的导数和 Sublayer 的导数都可能较大或较小，梯度容易累积放大或缩小，导致梯度爆炸或消失。\nPre-norm 的梯度：\n对于 Pre-norm：$x_{l+1} = x_l + \\text{Sublayer}(\\text{LN}(x_l))$\n反向传播时：\n$$\\frac{\\partial \\mathcal{L}}{\\partial x_l} = \\frac{\\partial \\mathcal{L}}{\\partial x_{l+1}} \\cdot \\left(I + \\frac{\\partial \\text{Sublayer}}{\\partial y_l} \\cdot \\frac{\\partial \\text{LN}}{\\partial x_l}\\right)$$梯度恒等映射通路： $\\frac{\\partial x_{l+1}}{\\partial x_l}$ 包含恒等项 $I$，即：\n$$\\frac{\\partial x_{l+1}}{\\partial x_l} = I + \\frac{\\partial \\text{Sublayer}}{\\partial y_l} \\cdot \\frac{\\partial \\text{LN}}{\\partial x_l}$$这个恒等项提供了一条直接的梯度传播路径，即使 Sublayer 的梯度很小，梯度仍能通过恒等映射传播，避免梯度消失。\n结论： Pre-norm 由于存在梯度恒等映射通路（residual connection 在 LayerNorm 之后），梯度更稳定；Post-norm 的梯度需要先经过 LayerNorm，更容易出现梯度消失或放大。\n第二十题 Gated Attention 的 Output 计算 题目： 已知 MHA 中第 $k$ 层第 $i$ 位置 token 的 output 表征计算如下：\n$$o_i^k = \\left(\\sum_{j=0}^{i} S_{ij}^k \\cdot X_j W_V^k\\right)W_O^k = \\sum_{j=0}^{i} S_{ij}^k \\cdot X_j(W_V^k W_O^k)$$请相应给出下图 Gated Attention 中 G1/G2/G3 对应的 output $o_i^k$ 计算方法。\n注意：可用 Non-Linearity-Map 算子表示 element-wise gating 机制，即 $$Y' = Y \\odot \\sigma(XW_\\theta) = \\text{Non-Linearity-Map}(Y)$$解：\n根据图示，Gated Attention 在不同位置应用门控机制：\nG1（最有效）： 在 Concat 之后、Dense Layer 之前应用门控\n$$o_i^k = \\left[\\sum_{j=0}^{i} S_{ij}^k \\cdot X_j W_V^k\\right] \\odot \\sigma(Z_i W_{g1}) \\cdot W_O^k$$其中 $Z_i$ 可以是 Query、Key 或其他输入特征。\nG2： 在 Value Layer 输出上应用门控\n$$o_i^k = \\sum_{j=0}^{i} S_{ij}^k \\cdot \\left[X_j W_V^k \\odot \\sigma(X_j W_{g2})\\right] W_O^k$$G3： 在 Key Layer 上应用门控\n$$\\tilde{K}*j = X_j W_K^k \\odot \\sigma(X_j W*{g3})$$ $$S_{ij}^k = \\text{softmax}\\left(\\frac{Q_i \\tilde{K}*j^\\top}{\\sqrt{d_k}}\\right)$$ $$o_i^k = \\sum*{j=0}^{i} S_{ij}^k \\cdot X_j W_V^k \\cdot W_O^k$$G4： 在 Query Layer 上应用门控（类似 G3）\nG5： 在最终输出上应用门控\n$$o_i^k = \\left[\\sum_{j=0}^{i} S_{ij}^k \\cdot X_j W_V^k \\cdot W_O^k\\right] \\odot \\sigma(X_i W_{g5})$$ 第二十一题 GPT-OSS 20B 架构分析 题目： GPT-OSS 20B 架构相比标准 Transformer 有多处改动，请依次文字分析各个改动的具体内容与意义：\nRoPE RMSNorm GQA MoE SwiGLU 解：\n1. RoPE（Rotary Position Embedding） 内容： 旋转位置编码，通过旋转矩阵将位置信息注入 Query 和 Key 向量。\n意义：\n相对位置编码：attention score 仅依赖于相对位置 $m-n$ 外推性好：可以处理训练时未见过的序列长度 计算高效：不需要额外的位置嵌入参数 2. RMSNorm（Root Mean Square Normalization） 内容： 简化的 LayerNorm，公式为：\n$$y = \\frac{x}{\\sqrt{|x|_2^2 + \\epsilon}} \\cdot \\gamma$$不计算均值，只进行缩放。\n意义：\n计算效率高：省去均值计算和减法操作 参数更少：只需 scale 参数 $\\gamma$，不需要 shift 参数 $\\beta$ 性能相当：在实践中与 LayerNorm 效果相当 3. GQA（Grouped Query Attention） 内容： 将多个 Query head 共享同一组 Key 和 Value head。\n意义：\n减少 KV Cache：多个 Query 共享 KV，显著降低显存占用 推理加速：减少 KV 读取的内存带宽需求 折中方案：介于 MHA（每个 head 独立 KV）和 MQA（所有 head 共享 KV）之间 4. MoE（Mixture of Experts） 内容： 使用路由器（Router）动态选择激活的专家（FFN），每个 token 只激活部分专家。\n意义：\n增加模型容量：总参数量大幅增加（20B 模型容量） 计算效率：每次前向只激活少量参数（实际激活 3.6B） 专业化：不同专家学习处理不同类型的输入 5. SwiGLU（Swish-Gated Linear Unit） 内容： 激活函数，结合 Swish 激活和门控机制：\n$$\\text{SwiGLU}(x) = \\text{Swish}(xW_1) \\odot (xW_2)$$其中 $\\text{Swish}(x) = x \\cdot \\sigma(x)$\n意义：\n性能提升：比标准 ReLU/GELU 效果更好 门控机制：允许模型动态控制信息流 平滑激活：Swish 的平滑特性有助于优化 第二十二题 Roofline Model 分析 题目： 结合下列代码和结果，设 repeat=32 时，f 函数在 GPU 上执行时用于数据移动和计算的时间分别为 $T_{\\text{move}}$ 和 $T_{\\text{comp}}$，并假设此时恰处于 Memory 和计算的平衡点，依次分析：\nrepeat=16 时，用于数据移动和计算的时间各是多少，此时 GPU 处于 Memory-bounded or Compute-bounded? repeat=64 时，用于数据移动和计算的时间各是多少，此时 GPU 处于 Memory-bounded or Compute-bounded? 解：\n分析 从图中可以看出：\nRuntime 在 repeat=32 之前增长缓慢，之后快速增长 FLOPS 逐渐增加并趋于平稳 Memory Bandwidth 在 repeat=32 之前保持高位，之后急剧下降 这表明在 repeat=32 时达到平衡点，此时： $$T_{\\text{move}} = T_{\\text{comp}}$$1. repeat=16 时 计算量减半： $$T_{\\text{comp}}^{(16)} = \\frac{1}{2} T_{\\text{comp}}$$数据移动量不变（输入输出大小固定）： $$T_{\\text{move}}^{(16)} = T_{\\text{move}}$$总时间： $$T_{\\text{total}}^{(16)} = T_{\\text{move}}^{(16)} + T_{\\text{comp}}^{(16)} = T_{\\text{move}} + \\frac{1}{2}T_{\\text{comp}} = \\frac{3}{2}T_{\\text{move}}$$由于 $T_{\\text{move}}^{(16)} \u003e T_{\\text{comp}}^{(16)}$，GPU 处于 Memory-bounded。\n2. repeat=64 时 计算量翻倍： $$T_{\\text{comp}}^{(64)} = 2T_{\\text{comp}}$$数据移动量不变： $$T_{\\text{move}}^{(64)} = T_{\\text{move}}$$总时间： $$T_{\\text{total}}^{(64)} = T_{\\text{move}}^{(64)} + T_{\\text{comp}}^{(64)} = T_{\\text{move}} + 2T_{\\text{comp}} = 3T_{\\text{move}}$$由于 $T_{\\text{comp}}^{(64)} \u003e T_{\\text{move}}^{(64)}$，GPU 处于 Compute-bounded。\n第二十三题 Operation Intensity 计算 题目： GPU 的 Operation Intensity 定义为浮点操作数 FLOPS 与数据移动（Bytes）的比值，请计算并对比 LayerNorm 和 RMSNorm 的 Operation Intensity。\n注意：d=8192，dtype=bf16，所有数据初始存于全局 DRAM，结果需写回全局 DRAM，且 SRAM 足够存放所有中间计算结果。\n解：\nLayerNorm 计算过程：\n计算均值：$\\mu = \\frac{1}{d}\\sum_{i=1}^d x_i$ → $d$ 次加法，1 次除法 ≈ $d$ FLOPs 计算方差：$\\sigma^2 = \\frac{1}{d}\\sum_{i=1}^d (x_i - \\mu)^2$ → $d$ 次减法，$d$ 次乘法，$d$ 次加法，1 次除法 ≈ $3d$ FLOPs 归一化和缩放：$y_i = \\frac{x_i - \\mu}{\\sqrt{\\sigma^2 + \\epsilon}} \\cdot \\gamma_i + \\beta_i$ → $d$ 次减法，$d$ 次除法，$d$ 次乘法，$d$ 次加法 ≈ $4d$ FLOPs 总计算量： $8d$ FLOPs\n数据移动：\n读取 $x$：$d \\times 2$ bytes 读取 $\\gamma, \\beta$：$2d \\times 2$ bytes 写入 $y$：$d \\times 2$ bytes 总计：$8d$ bytes Operation Intensity： $$\\text{OI}_{\\text{LN}} = \\frac{8d}{8d} = 1 \\text{ FLOP/Byte}$$RMSNorm 计算过程：\n计算 RMS：$\\text{RMS} = \\sqrt{\\frac{1}{d}\\sum_{i=1}^d x_i^2}$ → $d$ 次乘法，$d$ 次加法，1 次除法，1 次开方 ≈ $2d$ FLOPs 归一化和缩放：$y_i = \\frac{x_i}{\\text{RMS}} \\cdot \\gamma_i$ → $d$ 次除法，$d$ 次乘法 ≈ $2d$ FLOPs 总计算量： $4d$ FLOPs\n数据移动：\n读取 $x$：$d \\times 2$ bytes 读取 $\\gamma$：$d \\times 2$ bytes 写入 $y$：$d \\times 2$ bytes 总计：$6d$ bytes Operation Intensity： $$\\text{OI}_{\\text{RMS}} = \\frac{4d}{6d} = \\frac{2}{3} \\text{ FLOP/Byte}$$对比 LayerNorm 的 OI 为 1 FLOP/Byte，RMSNorm 的 OI 为 2/3 FLOP/Byte。两者都很低，属于 Memory-bounded 操作。RMSNorm 虽然计算量更少，但由于数据移动占主导，实际加速效果有限。\n第二十四题 A100 Operation Intensity 分析 题目： 以 A100 为例，分析 FP32 和 BF16（TensorCore，考虑 dense 即左边列的 FLOPS）类型在进入 Compute-bounded 时需要的 Operation Intensity 分别是多少。Bandwidth 统一简化为 2TB/s。\n解：\n从表格中读取：\nFP32：19.5 TFLOPS BF16（TensorCore）：312 TFLOPS Memory Bandwidth：2TB/s = 2000 GB/s Compute-bounded 临界点 当计算时间等于数据传输时间时，达到平衡点：\n$$\\frac{\\text{FLOPs}}{\\text{Peak FLOPS}} = \\frac{\\text{Bytes}}{\\text{Bandwidth}}$$因此临界 Operation Intensity 为：\n$$\\text{OI}_{\\text{critical}} = \\frac{\\text{Peak FLOPS}}{\\text{Bandwidth}}$$FP32 $$\\text{OI}_{\\text{FP32}} = \\frac{19.5 \\text{ TFLOPS}}{2 \\text{ TB/s}} = \\frac{19.5}{2} = 9.75 \\text{ FLOP/Byte}$$BF16 TensorCore $$\\text{OI}_{\\text{BF16}} = \\frac{312 \\text{ TFLOPS}}{2 \\text{ TB/s}} = \\frac{312}{2} = 156 \\text{ FLOP/Byte}$$结论 要让 FP32 计算进入 Compute-bounded，Operation Intensity 需要 ≥ 9.75 FLOP/Byte 要让 BF16（TensorCore） 计算进入 Compute-bounded，Operation Intensity 需要 ≥ 156 FLOP/Byte 这解释了为什么使用 TensorCore 进行矩阵乘法（OI 通常为 $O(N)$，其中 $N$ 是矩阵维度）更容易达到计算瓶颈，而 LayerNorm/RMSNorm（OI ≈ 1）始终是 Memory-bounded。\n第二十五题 ε-greedy 多臂老虎机问题 题目： 考虑一多臂老虎机问题（K=10），3 个 ε-greedy 策略下每一时刻可以获得的平均 reward 下图所示。已知该问题中随机以及最有策略下可获得 reward 的期望分别为 1 与 1.55，则：\n哪个 ε 在游戏后期（steps → +∞）可以获得更高的 average reward。 在（steps → +∞）时，这 3 个 ε-greedy 策略每次可获得 reward 的期望各是多少。 解：\n1. 后期表现 从图中可以观察到：\n$\\varepsilon = 0.1$ 收敛到约 1.4 $\\varepsilon = 0.01$ 收敛到约 1.3 $\\varepsilon = 0$（greedy）收敛到约 1.0 $\\varepsilon = 0.1$ 在后期获得更高的 average reward。\n2. 期望分析 ε-greedy 策略的期望 reward 为：\n$$\\mathbb{E}[R] = (1-\\varepsilon) \\cdot R_{\\text{greedy}} + \\varepsilon \\cdot R_{\\text{random}}$$其中：\n$R_{\\text{random}} = 1$（随机策略期望） $R_{\\text{optimal}} = 1.55$（最优策略期望） 对于 $\\varepsilon = 0$（greedy）：\n由于没有探索，可能陷入局部最优。从图中看收敛到 1.0，说明找到的并非最优臂：\n$$\\mathbb{E}[R_{\\varepsilon=0}] \\approx 1.0$$对于 $\\varepsilon = 0.01$：\n假设经过充分探索后，greedy 部分能找到最优臂：\n$$\\mathbb{E}[R_{\\varepsilon=0.01}] = 0.99 \\times 1.55 + 0.01 \\times 1 = 1.5345 + 0.01 = 1.5445 \\approx 1.3$$实际从图中看约为 1.3，可能 greedy 部分未完全收敛到最优。\n对于 $\\varepsilon = 0.1$：\n$$\\mathbb{E}[R_{\\varepsilon=0.1}] = 0.9 \\times 1.55 + 0.1 \\times 1 = 1.395 + 0.1 = 1.495 \\approx 1.4$$实际从图中看约为 1.4，与理论接近。\n总结 当 steps → ∞ 时：\n$\\varepsilon = 0$：约 1.0 $\\varepsilon = 0.01$：约 1.3-1.5 $\\varepsilon = 0.1$：约 1.4-1.5 $\\varepsilon = 0.1$ 虽然探索开销大，但能更稳定地找到最优臂，长期表现最好。\n第二十六题 MDP Bellman 方程 题目： 下图左是一个有限 Markov Decision Process (MDP) 的例子。网格中的单元格对应于环境的状态，在每个单元格中，智能体可以采取四种可能动作：上、下、左、右。这些动作确定性地使智能体在网格上沿相应方向移动一个单元格，并获取 0 的奖励。但有 2 类特殊情况：(1) 如果动作会导致智能体移出网格，则其位置保持不变，但会产生 -1 的奖励；(2) 如果智能体在状态 A 或 B 中，不管采取任意动作都会使智能体传送到 A\u0026rsquo;或 B\u0026rsquo;，并或者 +10 或 +5 的奖励。取 discount factor $\\gamma = 0.9$。\n随机策略对应的 state value 函数如下右图所示，保留 1 位有效数字。记左下状态坐标为 (1, 1)，右上状态坐标为 (5, 5)，请给出 坐标 (2, 5)、(3, 3)、(4, 5)、(5, 1) 4 个状态对应 value 的 Bellman 法代公式。\n注：上述 4 状态的 value 分别为 8.8、0.7、5.3、-2.0。\n解：\nBellman 方程的一般形式为：\n$$v(s) = \\sum_a \\pi(a|s) \\sum_{s',r} p(s',r|s,a)[r + \\gamma v(s')]$$对于随机策略，$\\pi(a|s) = 0.25$ 对所有动作 $a \\in {\\text{上, 下, 左, 右}}$。\n坐标系统 根据题意，左下为 (1,1)，右上为 (5,5)。状态 A 在 (2,4)，A\u0026rsquo; 在 (2,1)；状态 B 在 (4,2)，B\u0026rsquo; 在 (4,5)。\n(2, 5) - value = 8.8 位置 (2,5) 在网格顶部。各方向移动：\n上：出界 → 保持 (2,5)，奖励 -1 下：到 (2,4) = 状态 A 左：到 (1,5) 右：到 (3,5) 但 (2,4) 是状态 A，从 A 出发会传送到 A\u0026rsquo; = (2,1) 并获得 +10。\n$$v(2,5) = 0.25 \\times [(-1 + 0.9 v(2,5)) + (0 + 0.9 v(2,4)) + (0 + 0.9 v(1,5)) + (0 + 0.9 v(3,5))]$$由于 (2,4) 是 A，应该使用 A 的 value：\n$$v(2,5) = 0.25 \\times [(-1 + 0.9 \\times 8.8) + (0 + 0.9 \\times 8.8) + (0 + 0.9 \\times 3.0) + (0 + 0.9 \\times 4.4)]$$(3, 3) - value = 0.7 位置 (3,3) 在网格中心。各方向移动：\n上：到 (3,4) 下：到 (3,2) 左：到 (2,3) 右：到 (4,3) $$v(3,3) = 0.25 \\times [(0 + 0.9 v(3,4)) + (0 + 0.9 v(3,2)) + (0 + 0.9 v(2,3)) + (0 + 0.9 v(4,3))]$$从图中读取相邻格子的值： $$v(3,3) = 0.25 \\times 0.9 \\times [v(3,4) + v(3,2) + v(2,3) + v(4,3)]$$(4, 5) - value = 5.3 位置 (4,5) 在网格顶部。各方向移动：\n上：出界 → 保持 (4,5)，奖励 -1 下：到 (4,4) 左：到 (3,5) 右：到 (5,5) $$v(4,5) = 0.25 \\times [(-1 + 0.9 v(4,5)) + (0 + 0.9 v(4,4)) + (0 + 0.9 v(3,5)) + (0 + 0.9 v(5,5))]$$(5, 1) - value = -2.0 位置 (5,1) 在右下角。各方向移动：\n上：到 (5,2) 下：出界 → 保持 (5,1)，奖励 -1 左：到 (4,1) 右：出界 → 保持 (5,1)，奖励 -1 $$v(5,1) = 0.25 \\times [(0 + 0.9 v(5,2)) + (-1 + 0.9 v(5,1)) + (0 + 0.9 v(4,1)) + (-1 + 0.9 v(5,1))]$$化简： $$v(5,1) = 0.25 \\times [0.9 v(5,2) + 0.9 v(4,1) - 2 + 1.8 v(5,1)]$$ 第二十七题 MDP 最优策略 题目： 下图左是一个有限 Markov Decision Process (MDP) 的例子（与上题相同）。已知下图右是最优策略对应的 value function，请对应给出各状态的最佳行动策略。\n解：\n最优策略选择使 $Q(s,a) = r + \\gamma v(s')$ 最大的动作。对于每个状态，计算四个方向的 Q 值并选择最大的。\n系统方法 对于每个状态 $(i,j)$，最优动作 $a^*$ 满足：\n$$a^* = \\arg\\max_a [r(s,a) + \\gamma v(s')]$$其中 $s'$ 是执行动作 $a$ 后到达的状态。\n具体分析（部分状态示例） 状态 (1,1) - 左下角，v = 22.0\n四个方向的 Q 值：\n上：$0 + 0.9 \\times 24.4 = 21.96$ 下：$-1 + 0.9 \\times 22.0 = 18.8$（出界） 左：$-1 + 0.9 \\times 22.0 = 18.8$（出界） 右：$0 + 0.9 \\times 22.0 = 19.8$ 最优动作：上\n状态 (3,3) - 中心，v = 17.8\n四个方向的 Q 值计算邻近状态的 value，选择最大的。\n状态 A (2,4)，v = 24.4\n从 A 采取任意动作都传送到 A\u0026rsquo;(2,1) 并获得 +10： $$Q(A, a) = 10 + 0.9 \\times 22.0 = 29.8$$所有动作等价，可以任选。\n状态 B (4,2)，v = 19.8\n从 B 采取任意动作都传送到 B\u0026rsquo;(4,5) 并获得 +5： $$Q(B, a) = 5 + 0.9 \\times 19.4 = 22.46$$所有动作等价。\n最优策略总结 通过计算每个状态的所有可能动作的 Q 值，最优策略为：\n第1行（底部）：大部分向上，靠近 A\u0026rsquo; 的向右 第2行：向 B 或向上 第3行（中间）：向 A 或 B 方向 第4行：向 A 方向 第5行（顶部）：向 B\u0026rsquo; 或向左 具体每个格子的最优动作需要根据其邻居的 value 值计算得出，选择使 $r + \\gamma v(s')$ 最大的方向。\n第二十八题 AI Agent 特性解释 题目： AI Agent 是一类能够感知环境、自主决策并采取行动以实现特定目标的智能系统，并具备自主性、反应性、主动性、社会性以及进化性。请选择其中 3 种性质进行解释，并分别举例一种代表性技术（正式发表于 NeurIPS、ICLR、ICML）介绍其原理。（该题必考）\n解：\n1. 自主性 (Autonomy) 性质解释 AI Agent 能够在没有外部持续干预的情况下独立运行，自主做出决策并执行任务，无需人工指导每一步操作。\n代表性技术：ReAct\n会议：ICLR 2023 **论文：**ReAct: Synergizing Reasoning and Acting in Language Models (Yao et al.) 核心原理 ReAct 框架通过将推理（Reasoning）和行动（Acting）相结合，使语言模型能够以交替方式生成推理轨迹和任务特定的行动序列：\n思维-行动-观察循环\nThought (思考): 模型生成推理步骤，分析当前状态、任务目标和下一步计划 Action (行动): 执行具体操作（如调用搜索API、使用计算器、访问数据库） Observation (观察): 接收环境反馈和执行结果 推理增强的行动选择\n通过显式的推理轨迹，模型能够：\n动态分解复杂任务为子目标 根据中间结果调整策略 处理异常情况和错误 提示工程实现 使用 few-shot prompting，提供示例展示 Thought-Action-Observation 模式，引导模型学习这种交互模式。\n➡️ 体现的自主性：Agent 无需预定义完整的行动序列，能根据环境反馈自主决策每一步，实现端到端的任务自动化。\n2. 反应性 (Reactivity) 性质解释 AI Agent 能够感知环境变化并及时做出响应，从失败中学习，动态调整行为策略以适应变化的情境。\n代表性技术：Reflexion\n会议：NeurIPS 2023 **论文：**Reflexion: Language Agents with Verbal Reinforcement Learning (Shinn et al.) 核心原理 Reflexion 引入了语言化的自我反思机制，使 Agent 能够从试错中快速学习：\n反思-行动循环 Actor: 基于当前记忆生成行动轨迹 Evaluator: 评估行动结果（成功/失败，输出奖励信号） Self-Reflection: 当失败时，生成具体的反思文本，分析失败原因 语言化的情景记忆 将失败经验和反思以自然语言形式存储在短期记忆中 在后续尝试中，将相关反思加入提示上下文 类似于人类的\u0026quot;从错误中学习\u0026quot;机制 迭代改进机制 通过多轮试错-反思循环，Agent 逐步优化策略： Attempt 1 → Fail → Reflect (\u0026#34;边界条件未处理\u0026#34;) Attempt 2 → 根据反思调整 → Success ➡️ 体现的反应性：Agent 能够快速识别环境反馈（错误信息、失败信号），生成针对性的策略调整，实时适应新情况。\n3. 社会性 (Sociality) 性质解释 AI Agent 能够与其他 Agent 进行协作、竞争或沟通，在多智能体环境中通过合作完成单个 Agent 无法完成的复杂任务。\n代表性技术：QMIX\n会议：ICML 2018 **论文：**Monotonic Value Function Factorisation for Deep Multi-Agent Reinforcement Learning (Rashid et al.) 核心原理 QMIX 通过单调价值函数分解解决多智能体协作中的信用分配问题：\n集中训练-分散执行 (CTDE) 范式 训练阶段: 可访问全局状态 ss s 和所有 Agent 的观测 执行阶段: 每个 Agent 仅基于局部观测 oio_i oi 独立决策 单调价值函数分解 将全局 Q 函数分解为各 Agent 局部 Q 函数的单调组合： $$Q_{tot}(s, \\mathbf{a}) = f_{\\text{mix}}(Q_1(o_1, a_1), \\ldots, Q_n(o_n, a_n); s) 约束条件（单调性）： $$\\frac{\\partial Q_{tot}}{\\partial Q_i} \\geq 0, \\quad \\forall i 这保证了：局部贪婪动作（argmax QiQ_i Qi​）的组合等于全局最优动作 混合网络 (Mixing Network) 使用超网络 (hypernetwork) 根据全局状态 ss s 生成混合网络的权重 权重非负性通过绝对值函数保证单调性 网络结构：Agent Networks→Mixing Network→Qtot\\text{Agent Networks} \\rightarrow \\text{Mixing Network} \\rightarrow Q_{tot} Agent Networks→Mixing Network→Qtot ➡️ 体现的社会性：多个 Agent 无需显式通信即可通过学习形成隐式协作策略，共同最大化团队奖励，展现涌现的群体智能。\n","permalink":"http://localhost:1313/dase-course/ml-exercise-set/","summary":"25fall机器学习课程习题集解答汇总","title":"机器学习习题集"},{"content":"前言 四川麻将，又称成都麻将或血战麻将，是中国最流行的麻将玩法之一。与传统麻将相比，四川麻将节奏快、变化多，充满了刺激性和趣味性。本文将带你从零开始，系统学习四川麻将的规则和技巧。\n一、基础规则入门 1.1 牌面组成 四川麻将使用108张牌，包括：\n万子：一万到九万，各4张（36张） 条子：一条到九条，各4张（36张） 筒子：一筒到九筒，各4张（36张） 注意：四川麻将没有东南西北中发白这些字牌和花牌。\n1.2 基本概念 刻子：三张相同的牌（如：三张五万） 顺子：三张连续的同花色牌（如：三四五条） 对子：两张相同的牌（如：两张八筒） 杠：四张相同的牌\n1.3 胡牌基本型 标准胡牌牌型：3n+2 结构（n个刻子或顺子 + 1个对子）\n例如：\n一一一 + 二三四 + 五六七 + 八八八 + 九九（4组3张+1对） 1.4 游戏流程 定庄：掷骰子决定庄家 配牌：每人抓13张牌，庄家多抓一张（14张） 出牌：庄家先出一张牌，其他玩家依次摸牌、出牌 胡牌：谁先凑齐胡牌牌型谁获胜 血战到底：已胡牌的玩家退出，剩余玩家继续游戏，直到3人胡牌或流局 二、四川麻将特色规则 2.1 缺一门 四川麻将的核心规则：必须缺一门才能胡牌\n也就是说，你的手牌中只能有两种花色（万、条、筒三选二）。\n例如：\n✅ 可以胡：万子+条子（缺筒） ✅ 可以胡：万子+筒子（缺条） ❌ 不能胡：万子+条子+筒子（三门齐全） 2.2 杠牌规则 明杠：\n碰牌后，再摸到第四张，可以杠牌 别人打出的牌，自己有三张，可以直接杠 暗杠：\n自己摸到四张相同的牌，可以暗杠 杠牌后：\n摸一张牌 多算一番（底分×2） 杠后可以继续杠或胡牌 2.3 血战到底 这是四川麻将最大的特色：\n第一个人胡牌后不结束游戏 剩余三人继续打，直到有第二、第三个人胡牌 最后没胡的人要赔给所有胡牌的人 第一个胡牌的人可以继续胡（查叫） 2.4 查叫 游戏结束时，如果有人没胡牌：\n如果他已听牌（只差一张就能胡），他只赔给胡牌的人 如果他未听牌（没有听牌），他要加倍赔偿 三、番型与计分 3.1 基础番型 番型 番数 说明 平胡 1番 基础胡牌 自摸 1番 自己摸牌胡 根（杠） 1番 每杠一次+1番 对对胡 2番 全是刻子+对子，没有顺子 清一色 4番 全部是一种花色 龙七对 4番 七个对子 天胡 封顶 庄家起手就胡 地胡 封顶 闲家第一轮胡 3.2 计分方式 基础公式：底分 × 2^(番数)\n例如：\n底分1元，平胡（1番）= 1×2¹ = 2元 底分1元，清一色（4番）= 1×2⁴ = 16元 底分1元，清一色+对对胡（6番）= 1×2⁶ = 64元 封顶：很多地方设置封顶番数（如10番），防止输赢过大\n四、进阶技巧 4.1 定缺策略 游戏开始后，要快速决定缺哪一门：\n判断依据：\n数量最少的门：哪门牌少就缺哪门 孤张多的门：有很多不连续的孤张，这门不好组合 对子情况：如果某门有对子，考虑留下，可能组成刻子 例子：\n手牌：一万 三万 五万 六万 | 二条 七条 | 一筒 二筒 三筒 四筒 八筒 九筒 分析：万子4张分散，条子2张，筒子6张且有顺子潜力 建议：缺条子 4.2 听牌技巧 多面听优于单钓：\n单钓：只有一种牌能胡（如：等一张五万） 两面听：能胡两种牌（如：三四条，等二条或五条） 多面听：能胡多种牌（如：卡张、边张、对子等组合） 例子：\n手牌：一万 二万 | 三万 四万 | 五万 六万 | 七万 八万 | 九万 拆牌选择： - 打九万：听二万和五万（两面） - 打一万：听三万和六万和九万（多面） 建议打一万，听牌面更多 4.3 防守策略 观察舍牌：\n对手打出的牌反映他要什么、不要什么 如果对手大量打某一门，可能在做清一色 如果对手突然不打某种牌，可能在攒那个牌 生张和熟张：\n生张：桌面上没出现过的牌，危险度较高 熟张：已经有人打过的牌，相对安全 听牌信号：\n出牌犹豫 打牌速度突然变化 开始打生张或中张 4.4 做大牌策略 什么时候做大牌：\n起手牌型好（比如某门很多，可以做清一色） 当前领先或持平，可以冒险 对手没有明显听牌迹象 做大牌风险：\n听牌较慢，容易被别人截胡 如果未听牌查叫，要加倍赔偿 建议新手以稳为主，先保证听牌 4.5 心理战术 诱敌出牌：\n故意打出中张，引诱对手出你需要的牌 注意节奏，不要过于明显 藏牌意图：\n不要急于碰牌或杠牌，暴露自己的牌型 暗刻比明刻更有迷惑性 施压策略：\n快速出牌，给对手压力 适当沉默，让对手摸不清你的意图 五、常见错误与避免 5.1 新手常犯错误 忘记缺门：手牌三门齐全还以为能胡 盲目做大牌：不顾牌型强行做清一色，最后未听牌 不会算番：不知道自己多少番，糊里糊涂胡牌 乱碰乱杠：过早暴露牌型，让对手防范 不看舍牌：只顾自己手牌，不观察对手 5.2 进阶常犯错误 过度防守：太在意对手，错失自己的听牌机会 贪大求全：总想胡大牌，反而听牌慢 不会放弃：明知牌型不好还死撑，最后查叫 心态失衡：连续点炮后急躁，决策失误 六、实战案例分析 案例1：定缺选择 起手牌：\n二万 四万 六万 八万 九万 一条 二条 三条 五筒 六筒 七筒 八筒 分析：\n万子：5张但分散，不易组合 条子：3张成顺，很好 筒子：4张有两个顺子潜力 决策：缺万子，保留条筒两门\n案例2：听牌选择 当前牌型：\n二万 三万 四万 | 五万 六万 七万 | 一条 二条 三条 | 五筒 六筒 | 八筒 八筒 选择1：打五筒或六筒，听七筒（单钓） 选择2：打八筒，听四筒或七筒（两面）\n决策：选择2更优，两面听更容易胡牌\n案例3：要不要做清一色 当前牌型（已缺条）：\n一万 二万 三万 四万 五万 六万 | 二筒 五筒 七筒 | 八筒 八筒 分析：\n距离清一色还差3张筒子替换万子 如果做清一色，需要拆掉现有的顺子 当前可以快速听牌（1-2轮） 决策：不做清一色，保证快速听牌，除非后续摸牌特别好\n七、练习建议 7.1 新手阶段 熟悉规则：先玩小局，熟悉缺门、血战等规则 记住番型：至少记住基础番型和分数 多观察：看别人怎么打，学习经验 求稳为主：不要急于做大牌，先学会稳定胡牌 7.2 进阶阶段 提高速度：加快判断和决策速度 学习算牌：记住哪些牌出过，推测剩余牌 心理博弈：学会观察对手，做出针对性策略 复盘总结：每局结束后思考得失 7.3 推荐练习方式 线上平台：在手机或电脑上玩四川麻将游戏，方便练习 观战学习：看高手直播或录像，学习思路 实战练习：找朋友线下对局，积累实战经验 理论学习：阅读麻将书籍或教程，系统提升 八、总结 四川麻将规则简单但策略丰富，从新手到高手需要：\n扎实的基本功：熟练掌握规则和番型 灵活的战术：根据牌型和局势调整策略 敏锐的观察力：读懂对手意图，做出正确判断 稳定的心态：胜不骄败不馁，理性决策 记住：麻将三分靠运气，七分靠技术。多练习、多思考，你一定能成为四川麻将高手！\n祝你好运，胡牌多多！🀄\n","permalink":"http://localhost:1313/game-guide/sichuan-mahjong-guide/","summary":"四川麻将完全攻略：从基础规则到高阶技巧，涵盖缺一门、血战到底、番型计分、定缺策略、听牌技巧、防守要点和实战案例分析。无论你是零基础\n新手还是想提升的进阶玩家，这篇指南都能帮你系统掌握四川麻将的精髓，快速从入门到精通","title":"四川麻将指南"},{"content":"Windows PowerShell 常用指令 文件和目录操作 列出目录内容\nGet-ChildItem / ls - 列出当前目录内容 ls -Force - 显示隐藏文件 ls -Recurse - 递归列出所有子目录 ls | Sort-Object Length -Descending - 按文件大小排序 切换目录\nSet-Location \u0026lt;路径\u0026gt; / cd - 切换目录 cd ~ - 返回用户主目录 cd .. - 返回上级目录 cd - - 返回上一个目录 创建文件和目录\nNew-Item -ItemType Directory \u0026lt;名称\u0026gt; / mkdir - 创建目录 New-Item -ItemType File \u0026lt;名称\u0026gt; / ni - 创建文件 复制、移动和删除\nCopy-Item \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; 复制文件\nMove-Item \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; / mv - 移动/重命名文件\nRemove-Item \u0026lt;路径\u0026gt; 删除文件\n查看文件\nGet-Content \u0026lt;文件\u0026gt; / cat - 查看文件内容 Get-Content \u0026lt;文件\u0026gt; -Tail 10 - 查看最后 10 行 Get-Content \u0026lt;文件\u0026gt; -Wait - 实时查看文件更新（类似 tail -f） Test-Path \u0026lt;路径\u0026gt; - 检查路径是否存在 以默认方式打开文件或目录\nstart filename打开当前目录下的指定文件 code filename使用vscode打开 code .使用vscode打开当前目录 文本处理和搜索 Select-String \u0026lt;模式\u0026gt; \u0026lt;文件\u0026gt; - 在文件中搜索文本（类似 grep） Select-String \u0026quot;error\u0026quot; *.log - 在所有 log 文件中搜索 ls -Recurse | Select-String \u0026quot;TODO\u0026quot; - 递归搜索 Out-File \u0026lt;文件\u0026gt; - 输出重定向到文件 Tee-Object \u0026lt;文件\u0026gt; - 同时输出到控制台和文件 系统信息和管理 进程管理\nGet-Process / ps - 查看进程列表 Get-Process | Sort-Object CPU -Descending | Select-Object -First 5 - CPU 占用最高的 5 个进程 Stop-Process -Name \u0026lt;进程名\u0026gt; - 结束进程 服务管理\nGet-Service - 查看服务列表 Get-Service | Where-Object {$_.Status -eq \u0026quot;Running\u0026quot;} - 只显示运行中的服务 Start-Service \u0026lt;服务名\u0026gt; - 启动服务 Stop-Service \u0026lt;服务名\u0026gt; - 停止服务 系统信息\nGet-ComputerInfo - 查看计算机信息 Get-NetIPAddress - 查看网络配置 Get-Disk - 查看磁盘信息 Get-Volume - 查看卷信息 systeminfo - 显示详细系统信息 环境变量 $env:PATH - 查看 PATH 环境变量 $env:变量名 = \u0026quot;值\u0026quot; - 设置临时环境变量 [Environment]::SetEnvironmentVariable(\u0026quot;变量名\u0026quot;, \u0026quot;值\u0026quot;, \u0026quot;User\u0026quot;) - 永久设置 网络操作 Test-Connection \u0026lt;主机\u0026gt; / ping - 测试网络连接 Invoke-WebRequest \u0026lt;URL\u0026gt; / curl - 发送 HTTP 请求 Invoke-WebRequest -Uri \u0026lt;URL\u0026gt; -OutFile \u0026lt;文件\u0026gt; - 下载文件 Get-NetTCPConnection - 查看 TCP 连接 ipconfig - 查看 IP 配置 ipconfig /flushdns - 刷新 DNS 缓存 实用命令 Clear-Host / cls - 清屏 Get-History / history - 查看命令历史 Get-Help \u0026lt;命令\u0026gt; - 获取帮助 Get-Help \u0026lt;命令\u0026gt; -Examples - 查看使用示例 Get-Command - 列出所有可用命令 Get-Command *process* - 搜索包含 process 的命令 Get-Alias - 查看所有别名 Measure-Object - 统计对象 Start-Process \u0026lt;程序\u0026gt; - 启动程序 Get-Location / pwd - 显示当前路径 Linux Terminal 常用指令 文件和目录操作 列出目录\nls - 列出目录内容 ls -l - 长格式显示（详细信息） ls -a - 显示隐藏文件 ls -lh - 人性化显示文件大小 ls -lt - 按修改时间排序 ls -lS - 按文件大小排序 ls -R - 递归列出所有子目录 切换目录\ncd \u0026lt;路径\u0026gt; - 切换目录 cd / cd ~ - 返回主目录 cd .. - 返回上级目录 cd - - 返回上一个目录 pwd - 显示当前完整路径 创建\nmkdir \u0026lt;目录名\u0026gt; - 创建目录 mkdir -p a/b/c - 递归创建多级目录 touch \u0026lt;文件名\u0026gt; - 创建空文件或更新时间戳 复制、移动和删除\ncp \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 复制文件 cp -r \u0026lt;源目录\u0026gt; \u0026lt;目标\u0026gt; - 递归复制目录 cp -i \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 交互式复制（覆盖前询问） mv \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 移动/重命名文件 rm \u0026lt;文件\u0026gt; - 删除文件 rm -r \u0026lt;目录\u0026gt; - 递归删除目录 rm -f \u0026lt;文件\u0026gt; - 强制删除 rm -rf \u0026lt;目录\u0026gt; - 强制递归删除（危险！） rm -i \u0026lt;文件\u0026gt; - 交互式删除（推荐） 链接\nln -s \u0026lt;源\u0026gt; \u0026lt;链接名\u0026gt; - 创建符号链接 readlink -f \u0026lt;链接\u0026gt; - 查看链接目标 文件查看和编辑 查看文件\ncat \u0026lt;文件\u0026gt; - 显示文件内容 cat -n \u0026lt;文件\u0026gt; - 显示行号 less \u0026lt;文件\u0026gt; - 分页查看（可前后翻页） more \u0026lt;文件\u0026gt; - 分页查看（只能向前） head \u0026lt;文件\u0026gt; - 查看文件开头 head -n 20 \u0026lt;文件\u0026gt; - 查看前 20 行 tail \u0026lt;文件\u0026gt; - 查看文件末尾 tail -n 20 \u0026lt;文件\u0026gt; - 查看最后 20 行 tail -f \u0026lt;文件\u0026gt; - 实时查看文件更新 tail -f \u0026lt;文件\u0026gt; | grep \u0026quot;error\u0026quot; - 实时过滤查看 编辑文件\nnano \u0026lt;文件\u0026gt; - 简单文本编辑器 vim \u0026lt;文件\u0026gt; / vi \u0026lt;文件\u0026gt; - 强大的文本编辑器 统计文件\nwc \u0026lt;文件\u0026gt; - 统计文件 wc -l \u0026lt;文件\u0026gt; - 统计行数 wc -w \u0026lt;文件\u0026gt; - 统计单词数 wc -c \u0026lt;文件\u0026gt; - 统计字节数 文件搜索和查找 find 命令\nfind \u0026lt;路径\u0026gt; -name \u0026lt;名称\u0026gt; - 按名称查找 find . -name \u0026quot;*.txt\u0026quot; - 查找所有 txt 文件 find . -type f -name \u0026quot;*.log\u0026quot; - 查找文件（不含目录） find . -type d -name \u0026quot;node_modules\u0026quot; - 查找目录 find . -mtime -7 - 查找 7 天内修改的文件 find . -size +100M - 查找大于 100MB 的文件 find . -name \u0026quot;*.tmp\u0026quot; -delete - 查找并删除 grep 命令\ngrep \u0026lt;模式\u0026gt; \u0026lt;文件\u0026gt; - 搜索文本 grep -r \u0026quot;TODO\u0026quot; . - 递归搜索当前目录 grep -i \u0026quot;error\u0026quot; log.txt - 忽略大小写 grep -n \u0026quot;function\u0026quot; code.js - 显示行号 grep -v \u0026quot;debug\u0026quot; log.txt - 反向匹配（不包含） grep -E \u0026quot;error|warning\u0026quot; log.txt - 使用正则表达式 grep -c \u0026quot;error\u0026quot; log.txt - 统计匹配行数 其他查找工具\nlocate \u0026lt;文件名\u0026gt; - 快速查找文件 updatedb - 更新 locate 数据库 which \u0026lt;命令\u0026gt; - 查找命令位置 whereis \u0026lt;程序\u0026gt; - 查找程序位置 文件权限 chmod \u0026lt;权限\u0026gt; \u0026lt;文件\u0026gt; - 修改文件权限 chmod 755 script.sh - 数字方式（rwxr-xr-x） chmod +x script.sh - 添加执行权限 chmod -R 644 directory/ - 递归修改 chown \u0026lt;用户\u0026gt;:\u0026lt;组\u0026gt; \u0026lt;文件\u0026gt; - 修改所有者 chgrp \u0026lt;组\u0026gt; \u0026lt;文件\u0026gt; - 修改所属组 umask - 查看或设置默认权限掩码 进程管理 查看进程\nps - 查看进程 ps aux - 查看所有进程详细信息 ps -ef - 另一种格式 ps aux | grep \u0026lt;进程名\u0026gt; - 搜索特定进程 top - 实时查看系统资源（按 q 退出） htop - 增强版 top 管理进程\nkill \u0026lt;PID\u0026gt; - 结束进程 kill -9 \u0026lt;PID\u0026gt; - 强制结束 killall \u0026lt;进程名\u0026gt; - 按名称结束进程 pkill \u0026lt;进程名\u0026gt; - 按模式匹配结束 bg - 将任务放到后台 fg - 将后台任务调到前台 jobs - 查看后台任务 nohup \u0026lt;命令\u0026gt; \u0026amp; - 后台运行，不受终端关闭影响 磁盘和存储 df -h - 查看磁盘使用情况 du -sh \u0026lt;目录\u0026gt; - 查看目录大小 du -h --max-depth=1 - 查看各子目录大小 du -sh * | sort -h - 按大小排序 free -h - 查看内存使用 lsblk - 列出块设备 mount - 挂载文件系统 umount - 卸载文件系统 系统信息 uname -a - 完整系统信息 uname -r - 内核版本 hostname - 主机名 whoami - 当前用户 id - 用户 ID 和组 ID uptime - 系统运行时间和负载 date - 系统时间 cal - 日历 lsb_release -a - Linux 发行版信息（Ubuntu/Debian） cat /etc/os-release - 系统版本信息 网络操作 连接测试\nping \u0026lt;地址\u0026gt; - 测试网络连接 ping -c 4 google.com - 发送 4 个包后停止 traceroute \u0026lt;地址\u0026gt; - 追踪路由路径 文件传输\ncurl \u0026lt;URL\u0026gt; - 发送 HTTP 请求 curl -O \u0026lt;URL\u0026gt; - 下载文件（保持原文件名） curl -o \u0026lt;文件名\u0026gt; \u0026lt;URL\u0026gt; - 下载并重命名 curl -I \u0026lt;URL\u0026gt; - 只获取 HTTP 头 curl -X POST -d \u0026quot;data\u0026quot; \u0026lt;URL\u0026gt; - 发送 POST 请求 wget \u0026lt;URL\u0026gt; - 下载文件 wget -c \u0026lt;URL\u0026gt; - 断点续传 远程连接\nssh \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt; - SSH 连接 ssh -p \u0026lt;端口\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt; - 指定端口 scp \u0026lt;源\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt;:\u0026lt;目标\u0026gt; - 安全复制文件 scp -r \u0026lt;目录\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt;:\u0026lt;目标\u0026gt; - 复制目录 网络信息\nnetstat -tuln - 查看网络端口（传统） ss -tuln - 查看网络端口（现代） ip addr / ifconfig - 查看网络接口 nslookup \u0026lt;域名\u0026gt; - DNS 查询 dig \u0026lt;域名\u0026gt; - DNS 详细查询 压缩和解压 tar 格式\ntar -czf \u0026lt;文件.tar.gz\u0026gt; \u0026lt;目录\u0026gt; - 压缩为 tar.gz tar -xzf \u0026lt;文件.tar.gz\u0026gt; - 解压 tar.gz tar -xzf \u0026lt;文件.tar.gz\u0026gt; -C \u0026lt;目标目录\u0026gt; - 解压到指定目录 tar -tvf \u0026lt;文件.tar.gz\u0026gt; - 查看压缩包内容 zip 格式\nzip -r \u0026lt;文件.zip\u0026gt; \u0026lt;目录\u0026gt; - 创建 zip 压缩包 unzip \u0026lt;文件.zip\u0026gt; - 解压 zip unzip \u0026lt;文件.zip\u0026gt; -d \u0026lt;目标目录\u0026gt; - 解压到指定目录 gzip 格式\ngzip \u0026lt;文件\u0026gt; - 压缩为 .gz gunzip \u0026lt;文件.gz\u0026gt; - 解压 .gz 文本处理工具 sed（流编辑器）\nsed 's/old/new/g' file.txt - 替换文本 sed -i 's/old/new/g' file.txt - 直接修改文件 awk（文本处理）\nawk '{print $1}' file.txt - 打印第一列 awk -F',' '{print $2}' file.csv - 指定分隔符 排序和去重\nsort \u0026lt;文件\u0026gt; - 排序 sort -r \u0026lt;文件\u0026gt; - 反向排序 sort -n \u0026lt;文件\u0026gt; - 按数字排序 uniq \u0026lt;文件\u0026gt; - 去除重复行 sort file.txt | uniq - 配合使用 uniq -c \u0026lt;文件\u0026gt; - 统计重复次数 其他工具\ncut -d',' -f1,3 file.csv - 按分隔符提取列 tr 'a-z' 'A-Z' \u0026lt; file.txt - 字符转换 系统管理 用户管理\nsudo \u0026lt;命令\u0026gt; - 以管理员权限执行 su - 切换用户 su - - 切换到 root passwd - 修改密码 useradd \u0026lt;用户名\u0026gt; - 创建用户 userdel \u0026lt;用户名\u0026gt; - 删除用户 usermod -aG \u0026lt;组\u0026gt; \u0026lt;用户\u0026gt; - 添加用户到组 服务管理（systemd）\nsystemctl start \u0026lt;服务\u0026gt; - 启动服务 systemctl stop \u0026lt;服务\u0026gt; - 停止服务 systemctl restart \u0026lt;服务\u0026gt; - 重启服务 systemctl status \u0026lt;服务\u0026gt; - 查看状态 systemctl enable \u0026lt;服务\u0026gt; - 设置开机启动 journalctl -u \u0026lt;服务\u0026gt; - 查看服务日志 实用快捷键 Ctrl + C - 终止当前命令 Ctrl + Z - 暂停当前命令 Ctrl + D - 退出终端 Ctrl + L - 清屏 Ctrl + A - 光标移到行首 Ctrl + E - 光标移到行尾 Ctrl + U - 删除光标前的内容 Ctrl + K - 删除光标后的内容 Ctrl + R - 搜索命令历史 Tab - 自动补全 !! - 执行上一条命令 !$ - 上一条命令的最后一个参数 其他实用命令 clear - 清屏 history - 查看命令历史 history | grep \u0026lt;关键词\u0026gt; - 搜索历史命令 echo \u0026lt;文本\u0026gt; - 输出文本 echo \u0026quot;text\u0026quot; \u0026gt; file.txt - 覆盖写入 echo \u0026quot;text\u0026quot; \u0026gt;\u0026gt; file.txt - 追加写入 alias \u0026lt;别名\u0026gt;='\u0026lt;命令\u0026gt;' - 创建别名 watch \u0026lt;命令\u0026gt; - 定期执行命令 watch -n 2 df -h - 每 2 秒更新 xargs - 将标准输入转换为命令参数 tee \u0026lt;文件\u0026gt; - 同时输出到文件和标准输出 Git 常用指令 初始化和配置 初始化仓库\ngit init - 初始化新仓库 git clone \u0026lt;URL\u0026gt; - 克隆远程仓库 git clone \u0026lt;URL\u0026gt; \u0026lt;目录名\u0026gt; - 克隆到指定目录 git clone --depth 1 \u0026lt;URL\u0026gt; - 浅克隆（只克隆最新提交） git clone -b \u0026lt;分支名\u0026gt; \u0026lt;URL\u0026gt; - 克隆指定分支 配置 Git\ngit config --global user.name \u0026quot;\u0026lt;名字\u0026gt;\u0026quot; - 设置用户名 git config --global user.email \u0026quot;\u0026lt;邮箱\u0026gt;\u0026quot; - 设置邮箱 git config --list - 查看所有配置 git config --global core.editor \u0026quot;vim\u0026quot; - 设置编辑器 git config --global alias.st status - 设置别名 基本操作 查看状态\ngit status - 查看工作区状态 git status -s - 简短格式 添加和提交\ngit add \u0026lt;文件\u0026gt; - 添加文件到暂存区 git add . - 添加所有修改 git add -A - 添加所有变化（包括删除） git add -p - 交互式添加 git commit -m \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 提交 git commit -am \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 添加并提交已跟踪文件 git commit --amend - 修改最后一次提交 git commit --amend --no-edit - 修改提交但不改消息 推送和拉取\ngit push - 推送到远程 git push origin \u0026lt;分支名\u0026gt; - 推送指定分支 git push -u origin \u0026lt;分支名\u0026gt; - 推送并设置上游 git push --force / git push -f - 强制推送（危险！） git push --tags - 推送标签 git pull - 拉取并合并 git pull --rebase - 使用 rebase 方式拉取 git fetch - 获取但不合并 git fetch --all - 获取所有远程分支 git fetch --prune - 获取并清理已删除的远程分支 分支操作 查看分支\ngit branch - 查看本地分支 git branch -a - 查看所有分支（包括远程） git branch -r - 只查看远程分支 git branch -v - 查看分支及最后一次提交 创建和切换分支\ngit branch \u0026lt;分支名\u0026gt; - 创建分支 git checkout \u0026lt;分支名\u0026gt; - 切换分支 git checkout -b \u0026lt;分支名\u0026gt; - 创建并切换 git checkout -b \u0026lt;分支名\u0026gt; origin/\u0026lt;分支名\u0026gt; - 从远程分支创建 git switch \u0026lt;分支名\u0026gt; - 切换分支（新语法） git switch -c \u0026lt;分支名\u0026gt; - 创建并切换（新语法） 合并和删除分支\ngit merge \u0026lt;分支名\u0026gt; - 合并分支 git merge --no-ff \u0026lt;分支名\u0026gt; - 非快进合并 git merge --squash \u0026lt;分支名\u0026gt; - 压缩合并 git branch -d \u0026lt;分支名\u0026gt; - 删除已合并分支 git branch -D \u0026lt;分支名\u0026gt; - 强制删除分支 git branch -m \u0026lt;旧名\u0026gt; \u0026lt;新名\u0026gt; - 重命名分支 git push origin --delete \u0026lt;分支名\u0026gt; - 删除远程分支 查看历史 日志查看\ngit log - 查看提交历史 git log --oneline - 每个提交一行 git log --graph - 图形化显示 git log --oneline --graph --all - 图形化显示所有分支 git log -p - 显示详细差异 git log --author=\u0026quot;\u0026lt;作者\u0026gt;\u0026quot; - 按作者筛选 git log --since=\u0026quot;2 weeks ago\u0026quot; - 按时间筛选 git log --grep=\u0026quot;\u0026lt;关键词\u0026gt;\u0026quot; - 搜索提交消息 git log \u0026lt;文件\u0026gt; - 查看文件历史 git log --stat - 显示文件统计 差异比较\ngit diff - 查看未暂存的更改 git diff --staged / git diff --cached - 查看已暂存的更改 git diff \u0026lt;分支1\u0026gt; \u0026lt;分支2\u0026gt; - 比较分支 git diff \u0026lt;提交1\u0026gt; \u0026lt;提交2\u0026gt; - 比较提交 git diff HEAD - 比较工作区和最新提交 其他查看命令\ngit show \u0026lt;提交\u0026gt; - 查看提交详情 git show HEAD - 查看最新提交 git blame \u0026lt;文件\u0026gt; - 查看每行的修改者 git shortlog - 按作者分组显示 撤销和回退 撤销修改\ngit restore \u0026lt;文件\u0026gt; - 撤销工作区修改（新语法） git restore --staged \u0026lt;文件\u0026gt; - 取消暂存（新语法） git checkout -- \u0026lt;文件\u0026gt; - 撤销修改（旧语法） 重置提交\ngit reset \u0026lt;文件\u0026gt; - 取消暂存 git reset HEAD~ - 撤销最后一次提交，保留更改 git reset --soft HEAD~ - 撤销提交，更改在暂存区 git reset --hard HEAD~ - 撤销提交并丢弃更改（危险！） git reset --hard \u0026lt;提交\u0026gt; - 重置到指定提交 回退操作\ngit revert \u0026lt;提交\u0026gt; - 创建新提交来撤销 git revert HEAD - 撤销最新提交 git clean -fd - 删除未跟踪的文件 git clean -n - 预览将要删除的文件 暂存操作（Stash） git stash - 暂存当前更改 git stash save \u0026quot;描述\u0026quot; - 暂存并添加描述 git stash list - 查看暂存列表 git stash pop - 恢复并删除最新暂存 git stash apply - 恢复但不删除暂存 git stash apply stash@{0} - 恢复指定暂存 git stash drop - 删除最新暂存 git stash drop stash@{0} - 删除指定暂存 git stash clear - 清空所有暂存 git stash show - 查看暂存内容 远程仓库 查看远程\ngit remote - 查看远程仓库 git remote -v - 查看详细信息 管理远程\ngit remote add \u0026lt;名称\u0026gt; \u0026lt;URL\u0026gt; - 添加远程仓库 git remote add origin \u0026lt;URL\u0026gt; - 添加 origin git remote remove \u0026lt;名称\u0026gt; - 删除远程仓库 git remote rename \u0026lt;旧名\u0026gt; \u0026lt;新名\u0026gt; - 重命名 git remote set-url \u0026lt;名称\u0026gt; \u0026lt;新URL\u0026gt; - 修改 URL git remote show \u0026lt;名称\u0026gt; - 查看详细信息 git remote prune origin - 清理已删除的远程分支引用 标签操作 git tag - 查看所有标签 git tag \u0026lt;标签名\u0026gt; - 创建轻量标签 git tag -a \u0026lt;标签名\u0026gt; -m \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 创建带注释的标签 git tag -d \u0026lt;标签名\u0026gt; - 删除本地标签 git push origin \u0026lt;标签名\u0026gt; - 推送标签 git push origin --tags - 推送所有标签 git push origin :refs/tags/\u0026lt;标签名\u0026gt; - 删除远程标签 高级操作 变基（Rebase）\ngit rebase \u0026lt;分支\u0026gt; - 变基到指定分支 git rebase -i HEAD~3 - 交互式变基最近 3 个提交 git rebase --continue - 解决冲突后继续 git rebase --abort - 取消变基 其他高级命令\ngit cherry-pick \u0026lt;提交\u0026gt; - 将指定提交应用到当前分支 git reflog - 查看引用日志（恢复丢失的提交） git bisect start - 开始二分查找问题提交 git submodule add \u0026lt;URL\u0026gt; - 添加子模块 git submodule update --init - 初始化并更新子模块 .gitignore 配置 New-Item -ItemType File .gitignore创建 .gitignore 文件来忽略不需要跟踪的文件：\n# 忽略日志文件 *.log # 忽略 node_modules 目录 node_modules/ # 忽略环境变量文件 .env .env.local # 忽略构建输出 dist/ build/ # 忽略操作系统文件 .DS_Store Thumbs.db # 忽略 IDE 配置 .vscode/ .idea/ GitHub CLI 常用指令 认证 gh auth login - 登录 GitHub 账号 gh auth status - 查看认证状态 gh auth logout - 登出 gh auth refresh - 刷新令牌 gh config set editor vim - 设置编辑器 仓库操作 创建和克隆\ngh repo create - 创建仓库 gh repo create \u0026lt;名称\u0026gt; - 创建指定名称的仓库 gh repo create --public - 创建公开仓库 gh repo create --private - 创建私有仓库 gh repo create --clone - 创建并克隆 gh repo clone \u0026lt;仓库\u0026gt; - 克隆仓库 gh repo clone owner/repo - 克隆指定仓库 查看和管理\ngh repo view - 查看仓库信息 gh repo view --web - 在浏览器中打开 gh repo list - 列出仓库 gh repo list \u0026lt;用户名\u0026gt; - 列出指定用户的仓库 gh repo list --limit 50 - 限制显示数量 gh repo fork - Fork 仓库 gh repo fork --clone - Fork 并克隆 gh repo delete \u0026lt;仓库\u0026gt; - 删除仓库 gh repo rename \u0026lt;新名称\u0026gt; - 重命名仓库 or gh repo rename owner/repo 新名字 gh repo sync - 同步 fork Pull Request 创建 PR\ngh pr create - 创建 PR gh pr create --title \u0026quot;标题\u0026quot; --body \u0026quot;描述\u0026quot; - 指定标题和描述 gh pr create --web - 在浏览器中创建 gh pr create --draft - 创建草稿 PR 查看 PR\ngh pr list - 列出 PR gh pr list --state open - 只显示开放的 gh pr list --author \u0026lt;用户名\u0026gt; - 按作者筛选 gh pr list --label \u0026lt;标签\u0026gt; - 按标签筛选 gh pr view \u0026lt;编号\u0026gt; - 查看详情 gh pr view \u0026lt;编号\u0026gt; --web - 在浏览器中查看 gh pr view \u0026lt;编号\u0026gt; --comments - 查看评论 操作 PR\ngh pr checkout \u0026lt;编号\u0026gt; - 检出 PR 分支 gh pr diff \u0026lt;编号\u0026gt; - 查看差异 gh pr merge \u0026lt;编号\u0026gt; - 合并 PR gh pr merge \u0026lt;编号\u0026gt; --squash - 压缩合并 gh pr merge \u0026lt;编号\u0026gt; --rebase - 变基合并 gh pr close \u0026lt;编号\u0026gt; - 关闭 PR gh pr reopen \u0026lt;编号\u0026gt; - 重新打开 gh pr ready \u0026lt;编号\u0026gt; - 标记为准备好 审查 PR\ngh pr review \u0026lt;编号\u0026gt; - 审查 PR gh pr review \u0026lt;编号\u0026gt; --approve - 批准 gh pr review \u0026lt;编号\u0026gt; --request-changes - 请求更改 gh pr review \u0026lt;编号\u0026gt; --comment - 添加评论 gh pr checks \u0026lt;编号\u0026gt; - 查看 CI/CD 状态 Issue 创建 Issue\ngh issue create - 创建 Issue gh issue create --title \u0026quot;标题\u0026quot; --body \u0026quot;描述\u0026quot; - 指定内容 gh issue create --web - 在浏览器中创建 gh issue create --label \u0026quot;bug,help wanted\u0026quot; - 添加标签 查看 Issue\ngh issue list - 列出 Issues gh issue list --state open - 只显示开放的 gh issue list --assignee \u0026lt;用户名\u0026gt; - 按指派人筛选 gh issue list --label \u0026lt;标签\u0026gt; - 按标签筛选 gh issue list --author \u0026lt;用户名\u0026gt; - 按作者筛选 gh issue view \u0026lt;编号\u0026gt; - 查看详情 gh issue view \u0026lt;编号\u0026gt; --web - 在浏览器中查看 操作 Issue\ngh issue close \u0026lt;编号\u0026gt; - 关闭 Issue gh issue close \u0026lt;编号\u0026gt; --comment \u0026quot;已修复\u0026quot; - 关闭并评论 gh issue reopen \u0026lt;编号\u0026gt; - 重新打开 gh issue edit \u0026lt;编号\u0026gt; - 编辑 Issue gh issue edit \u0026lt;编号\u0026gt; --add-label \u0026quot;bug\u0026quot; - 添加标签 gh issue comment \u0026lt;编号\u0026gt; - 添加评论 gh issue status - 查看状态 Gist gh gist create \u0026lt;文件\u0026gt; - 创建 Gist gh gist create --public \u0026lt;文件\u0026gt; - 创建公开 Gist gh gist create --desc \u0026quot;描述\u0026quot; \u0026lt;文件\u0026gt; - 添加描述 gh gist list - 列出 Gists gh gist view \u0026lt;ID\u0026gt; - 查看 Gist gh gist view \u0026lt;ID\u0026gt; --web - 在浏览器中查看 gh gist edit \u0026lt;ID\u0026gt; - 编辑 Gist gh gist delete \u0026lt;ID\u0026gt; - 删除 Gist gh gist clone \u0026lt;ID\u0026gt; - 克隆到本地 Release 创建和查看\ngh release create \u0026lt;标签\u0026gt; - 创建 Release gh release create v1.0.0 --title \u0026quot;版本 1.0.0\u0026quot; --notes \u0026quot;说明\u0026quot; - 指定内容 gh release create v1.0.0 *.zip - 附加文件 gh release create v1.0.0 --draft - 创建草稿 gh release list - 列出所有 Releases gh release view \u0026lt;标签\u0026gt; - 查看详情 gh release view \u0026lt;标签\u0026gt; --web - 在浏览器中查看 下载和管理\ngh release download \u0026lt;标签\u0026gt; - 下载资源 gh release download \u0026lt;标签\u0026gt; --pattern \u0026quot;*.zip\u0026quot; - 下载匹配文件 gh release delete \u0026lt;标签\u0026gt; - 删除 Release gh release upload \u0026lt;标签\u0026gt; \u0026lt;文件\u0026gt; - 上传文件 GitHub Actions 工作流管理\ngh workflow list - 列出工作流 gh workflow view \u0026lt;工作流\u0026gt; - 查看详情 gh workflow view \u0026lt;工作流\u0026gt; --web - 在浏览器中查看 gh workflow run \u0026lt;工作流\u0026gt; - 触发工作流 gh workflow run \u0026lt;工作流\u0026gt; --ref \u0026lt;分支\u0026gt; - 在指定分支运行 运行管理\ngh run list - 列出运行记录 gh run list --workflow \u0026lt;工作流名\u0026gt; - 按工作流筛选 gh run view \u0026lt;运行ID\u0026gt; - 查看详情 gh run view \u0026lt;运行ID\u0026gt; --log - 查看日志 gh run watch \u0026lt;运行ID\u0026gt; - 实时查看状态 gh run rerun \u0026lt;运行ID\u0026gt; - 重新运行 gh run cancel \u0026lt;运行ID\u0026gt; - 取消运行 其他功能 浏览和搜索\ngh browse - 在浏览器中打开仓库 gh browse \u0026lt;文件\u0026gt; - 打开指定文件 gh browse --settings - 打开设置 gh search repos \u0026lt;关键词\u0026gt; - 搜索仓库 gh search repos --stars \u0026quot;\u0026gt;1000\u0026quot; - 按星标搜索 gh search repos --language python - 按语言搜索 gh search issues \u0026lt;关键词\u0026gt; - 搜索 Issues gh search prs \u0026lt;关键词\u0026gt; - 搜索 PRs API 和扩展\ngh api \u0026lt;端点\u0026gt; - 调用 GitHub API gh api user - 获取用户信息 gh alias set \u0026lt;别名\u0026gt; \u0026lt;命令\u0026gt; - 创建别名 gh extension install \u0026lt;扩展\u0026gt; - 安装扩展 gh extension list - 列出扩展 标签和项目\ngh label list - 列出标签 gh label create \u0026lt;名称\u0026gt; - 创建标签 gh project list - 列出项目 gh project view \u0026lt;编号\u0026gt; - 查看项目 ","permalink":"http://localhost:1313/doc-intro/command-reference/","summary":"详细的命令行指令参考手册，包含 Windows PowerShell、Linux Terminal、Git 和 GitHub CLI 的常用命令及实用技巧","title":"常用命令行指令参考"},{"content":"一、数据库操作 1.1 创建和删除数据库 -- 创建数据库 CREATE DATABASE database_name; CREATE DATABASE IF NOT EXISTS database_name CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; -- 删除数据库 DROP DATABASE database_name; DROP DATABASE IF EXISTS database_name; -- 查看所有数据库 SHOW DATABASES; -- 选择数据库 USE database_name; -- 查看当前数据库 SELECT DATABASE(); 二、数据表操作 2.1 创建表 -- 基础创建表 CREATE TABLE users ( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(50) NOT NULL UNIQUE, email VARCHAR(100), age INT DEFAULT 0, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ); -- 创建表时指定引擎和字符集 CREATE TABLE products ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(100) NOT NULL, price DECIMAL(10, 2), stock INT DEFAULT 0 ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; -- 从查询结果创建表 CREATE TABLE users_backup AS SELECT * FROM users; 2.2 修改表结构 -- 添加列 ALTER TABLE users ADD COLUMN phone VARCHAR(20); ALTER TABLE users ADD COLUMN address TEXT AFTER email; -- 修改列 ALTER TABLE users MODIFY COLUMN age TINYINT; ALTER TABLE users CHANGE COLUMN username user_name VARCHAR(60); -- 删除列 ALTER TABLE users DROP COLUMN phone; -- 重命名表 RENAME TABLE users TO members; ALTER TABLE members RENAME TO users; -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键 ALTER TABLE users DROP PRIMARY KEY; -- 添加索引 ALTER TABLE users ADD INDEX idx_username (username); ALTER TABLE users ADD UNIQUE INDEX idx_email (email); -- 删除索引 ALTER TABLE users DROP INDEX idx_username; 2.3 查看表信息 -- 查看所有表 SHOW TABLES; -- 查看表结构 DESC users; DESCRIBE users; SHOW COLUMNS FROM users; -- 查看创建表的语句 SHOW CREATE TABLE users; -- 查看表状态 SHOW TABLE STATUS LIKE \u0026#39;users\u0026#39;; 2.4 删除和清空表 -- 删除表 DROP TABLE users; DROP TABLE IF EXISTS users; -- 清空表数据（保留结构） TRUNCATE TABLE users; DELETE FROM users; -- 与 TRUNCATE 的区别是可以回滚 三、数据操作（CRUD） 3.1 插入数据（INSERT） -- 插入单条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;, 25); -- 插入多条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;李四\u0026#39;, \u0026#39;lisi@example.com\u0026#39;, 28), (\u0026#39;王五\u0026#39;, \u0026#39;wangwu@example.com\u0026#39;, 30); -- 插入所有列（可省略列名） INSERT INTO users VALUES (NULL, \u0026#39;赵六\u0026#39;, \u0026#39;zhaoliu@example.com\u0026#39;, 22, NOW(), NOW()); -- 插入或更新（存在则更新） INSERT INTO users (id, username, email) VALUES (1, \u0026#39;张三\u0026#39;, \u0026#39;new@example.com\u0026#39;) ON DUPLICATE KEY UPDATE email = \u0026#39;new@example.com\u0026#39;; -- 忽略重复插入错误 INSERT IGNORE INTO users (username, email) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;); -- 从其他表插入数据 INSERT INTO users_backup SELECT * FROM users WHERE age \u0026gt; 25; 3.2 查询数据（SELECT） 基础查询 -- 查询所有列 SELECT * FROM users; -- 查询指定列 SELECT username, email FROM users; -- 使用别名 SELECT username AS name, email AS mail FROM users; -- 去重查询 SELECT DISTINCT age FROM users; -- 限制结果数量 SELECT * FROM users LIMIT 10; SELECT * FROM users LIMIT 10, 20; -- 跳过前10条，取20条 SELECT * FROM users LIMIT 20 OFFSET 10; -- 同上 WHERE 条件查询 -- 基本条件 SELECT * FROM users WHERE age \u0026gt; 25; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users WHERE email IS NULL; SELECT * FROM users WHERE email IS NOT NULL; -- 多条件组合 SELECT * FROM users WHERE age \u0026gt; 20 AND age \u0026lt; 30; SELECT * FROM users WHERE age BETWEEN 20 AND 30; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39; OR username = \u0026#39;李四\u0026#39;; SELECT * FROM users WHERE username IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;); SELECT * FROM users WHERE username NOT IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;); -- 模糊查询 SELECT * FROM users WHERE username LIKE \u0026#39;张%\u0026#39;; -- 以\u0026#34;张\u0026#34;开头 SELECT * FROM users WHERE username LIKE \u0026#39;%三\u0026#39;; -- 以\u0026#34;三\u0026#34;结尾 SELECT * FROM users WHERE username LIKE \u0026#39;%张%\u0026#39;; -- 包含\u0026#34;张\u0026#34; SELECT * FROM users WHERE username LIKE \u0026#39;张_\u0026#39;; -- 张+一个字符 SELECT * FROM users WHERE username NOT LIKE \u0026#39;张%\u0026#39;; 排序和分组 -- 排序 SELECT * FROM users ORDER BY age ASC; -- 升序（默认） SELECT * FROM users ORDER BY age DESC; -- 降序 SELECT * FROM users ORDER BY age DESC, username ASC; -- 多列排序 -- 分组 SELECT age, COUNT(*) as count FROM users GROUP BY age; SELECT age, AVG(age) as avg_age FROM users GROUP BY age; -- HAVING 过滤分组结果 SELECT age, COUNT(*) as count FROM users GROUP BY age HAVING count \u0026gt; 5; 聚合函数 -- 计数 SELECT COUNT(*) FROM users; SELECT COUNT(DISTINCT age) FROM users; -- 求和、平均、最大、最小 SELECT SUM(age) FROM users; SELECT AVG(age) FROM users; SELECT MAX(age) FROM users; SELECT MIN(age) FROM users; -- 多个聚合函数 SELECT COUNT(*) as total, AVG(age) as avg_age, MAX(age) as max_age FROM users; 连接查询（JOIN） -- 内连接（INNER JOIN） SELECT users.username, orders.order_no FROM users INNER JOIN orders ON users.id = orders.user_id; -- 左连接（LEFT JOIN） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id; -- 右连接（RIGHT JOIN） SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 全连接（FULL JOIN，MySQL不直接支持，需要用UNION） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id UNION SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 自连接 SELECT a.username, b.username as friend FROM users a INNER JOIN users b ON a.friend_id = b.id; -- 多表连接 SELECT u.username, o.order_no, p.product_name FROM users u INNER JOIN orders o ON u.id = o.user_id INNER JOIN order_items oi ON o.id = oi.order_id INNER JOIN products p ON oi.product_id = p.id; 子查询 -- WHERE 子查询 SELECT * FROM users WHERE id IN (SELECT user_id FROM orders WHERE amount \u0026gt; 1000); -- FROM 子查询 SELECT avg_age FROM (SELECT AVG(age) as avg_age FROM users GROUP BY city) as subquery; -- EXISTS 子查询 SELECT * FROM users WHERE EXISTS (SELECT 1 FROM orders WHERE orders.user_id = users.id); -- 标量子查询 SELECT username, (SELECT COUNT(*) FROM orders WHERE user_id = users.id) as order_count FROM users; 联合查询（UNION） -- UNION（去重） SELECT username FROM users WHERE age \u0026gt; 30 UNION SELECT username FROM admins WHERE age \u0026gt; 30; -- UNION ALL（不去重，性能更好） SELECT username FROM users WHERE age \u0026gt; 30 UNION ALL SELECT username FROM admins WHERE age \u0026gt; 30; 3.3 更新数据（UPDATE） -- 更新单列 UPDATE users SET age = 26 WHERE username = \u0026#39;张三\u0026#39;; -- 更新多列 UPDATE users SET age = 26, email = \u0026#39;new@example.com\u0026#39; WHERE username = \u0026#39;张三\u0026#39;; -- 批量更新 UPDATE users SET age = age + 1 WHERE age \u0026lt; 30; -- 使用表达式更新 UPDATE users SET updated_at = NOW() WHERE id = 1; -- 基于其他表更新 UPDATE users u INNER JOIN orders o ON u.id = o.user_id SET u.total_orders = u.total_orders + 1 WHERE o.created_at \u0026gt; \u0026#39;2024-01-01\u0026#39;; -- 条件更新（CASE） UPDATE users SET level = CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END; 3.4 删除数据（DELETE） -- 删除指定数据 DELETE FROM users WHERE id = 1; -- 批量删除 DELETE FROM users WHERE age \u0026lt; 18; -- 删除所有数据 DELETE FROM users; -- 基于其他表删除 DELETE u FROM users u INNER JOIN orders o ON u.id = o.user_id WHERE o.status = \u0026#39;cancelled\u0026#39;; 四、索引管理 4.1 创建索引 -- 普通索引 CREATE INDEX idx_username ON users(username); -- 唯一索引 CREATE UNIQUE INDEX idx_email ON users(email); -- 复合索引 CREATE INDEX idx_name_age ON users(username, age); -- 全文索引 CREATE FULLTEXT INDEX idx_content ON articles(content); -- 在创建表时添加索引 CREATE TABLE users ( id INT PRIMARY KEY, username VARCHAR(50), email VARCHAR(100), INDEX idx_username (username), UNIQUE INDEX idx_email (email) ); 4.2 查看和删除索引 -- 查看索引 SHOW INDEX FROM users; -- 删除索引 DROP INDEX idx_username ON users; ALTER TABLE users DROP INDEX idx_username; 五、约束管理 5.1 主键约束 -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键（需要先删除 AUTO_INCREMENT 属性） ALTER TABLE users MODIFY id INT; ALTER TABLE users DROP PRIMARY KEY; 5.2 外键约束 -- 添加外键 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id); -- 添加外键时设置级联操作 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE; -- 删除外键 ALTER TABLE orders DROP FOREIGN KEY fk_user_id; 5.3 其他约束 -- 唯一约束 ALTER TABLE users ADD UNIQUE (email); -- 非空约束 ALTER TABLE users MODIFY username VARCHAR(50) NOT NULL; -- 检查约束（MySQL 8.0.16+） ALTER TABLE users ADD CONSTRAINT chk_age CHECK (age \u0026gt;= 0 AND age \u0026lt;= 150); -- 默认值约束 ALTER TABLE users ALTER COLUMN status SET DEFAULT \u0026#39;active\u0026#39;; 六、视图 -- 创建视图 CREATE VIEW active_users AS SELECT id, username, email FROM users WHERE status = \u0026#39;active\u0026#39;; -- 创建或替换视图 CREATE OR REPLACE VIEW active_users AS SELECT id, username, email, age FROM users WHERE status = \u0026#39;active\u0026#39;; -- 查询视图 SELECT * FROM active_users; -- 查看视图定义 SHOW CREATE VIEW active_users; -- 删除视图 DROP VIEW active_users; DROP VIEW IF EXISTS active_users; 七、事务处理 -- 开启事务 START TRANSACTION; -- 或 BEGIN; -- 提交事务 COMMIT; -- 回滚事务 ROLLBACK; -- 设置保存点 SAVEPOINT sp1; ROLLBACK TO sp1; -- 完整示例 START TRANSACTION; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; COMMIT; -- 设置自动提交 SET autocommit = 0; -- 关闭自动提交 SET autocommit = 1; -- 开启自动提交 八、存储过程和函数 8.1 存储过程 -- 创建存储过程 DELIMITER // CREATE PROCEDURE GetUserById(IN userId INT) BEGIN SELECT * FROM users WHERE id = userId; END // DELIMITER ; -- 调用存储过程 CALL GetUserById(1); -- 带输出参数的存储过程 DELIMITER // CREATE PROCEDURE GetUserCount(OUT total INT) BEGIN SELECT COUNT(*) INTO total FROM users; END // DELIMITER ; CALL GetUserCount(@count); SELECT @count; -- 删除存储过程 DROP PROCEDURE IF EXISTS GetUserById; -- 查看存储过程 SHOW PROCEDURE STATUS; SHOW CREATE PROCEDURE GetUserById; 8.2 函数 -- 创建函数 DELIMITER // CREATE FUNCTION GetUserAge(userId INT) RETURNS INT BEGIN DECLARE userAge INT; SELECT age INTO userAge FROM users WHERE id = userId; RETURN userAge; END // DELIMITER ; -- 使用函数 SELECT GetUserAge(1); -- 删除函数 DROP FUNCTION IF EXISTS GetUserAge; 九、触发器 -- 创建 BEFORE INSERT 触发器 DELIMITER // CREATE TRIGGER before_user_insert BEFORE INSERT ON users FOR EACH ROW BEGIN SET NEW.created_at = NOW(); END // DELIMITER ; -- 创建 AFTER UPDATE 触发器 DELIMITER // CREATE TRIGGER after_user_update AFTER UPDATE ON users FOR EACH ROW BEGIN INSERT INTO user_logs (user_id, action, created_at) VALUES (OLD.id, \u0026#39;update\u0026#39;, NOW()); END // DELIMITER ; -- 查看触发器 SHOW TRIGGERS; -- 删除触发器 DROP TRIGGER IF EXISTS before_user_insert; 十、用户和权限管理 -- 创建用户 CREATE USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; CREATE USER \u0026#39;username\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; -- 允许任何主机 -- 授予权限 GRANT ALL PRIVILEGES ON database_name.* TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; GRANT SELECT, INSERT, UPDATE ON database_name.table_name TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 刷新权限 FLUSH PRIVILEGES; -- 查看用户权限 SHOW GRANTS FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 撤销权限 REVOKE INSERT, UPDATE ON database_name.* FROM \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 修改密码 ALTER USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;new_password\u0026#39;; SET PASSWORD FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; = PASSWORD(\u0026#39;new_password\u0026#39;); -- 删除用户 DROP USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; 十一、备份和恢复 -- 使用 mysqldump 备份（在命令行执行） mysqldump -u username -p database_name \u0026gt; backup.sql mysqldump -u username -p database_name table_name \u0026gt; table_backup.sql mysqldump -u username -p --all-databases \u0026gt; all_databases.sql -- 恢复数据库（在命令行执行） mysql -u username -p database_name \u0026lt; backup.sql -- 导出为 CSV SELECT * FROM users INTO OUTFILE \u0026#39;/tmp/users.csv\u0026#39; FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; -- 从 CSV 导入 LOAD DATA INFILE \u0026#39;/tmp/users.csv\u0026#39; INTO TABLE users FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; 十二、性能优化相关 12.1 EXPLAIN 分析查询 -- 分析查询执行计划 EXPLAIN SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; -- 详细分析 EXPLAIN EXTENDED SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SHOW WARNINGS; -- JSON 格式 EXPLAIN FORMAT=JSON SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; 12.2 查询优化 -- 使用索引提示 SELECT * FROM users USE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users FORCE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users IGNORE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; -- 优化 COUNT SELECT COUNT(1) FROM users; -- 比 COUNT(*) 快一点 -- 分页优化（避免大 OFFSET） SELECT * FROM users WHERE id \u0026gt; 10000 ORDER BY id LIMIT 20; 12.3 查看状态和变量 -- 查看数据库状态 SHOW STATUS; SHOW STATUS LIKE \u0026#39;Threads%\u0026#39;; -- 查看系统变量 SHOW VARIABLES; SHOW VARIABLES LIKE \u0026#39;max_connections\u0026#39;; -- 查看进程列表 SHOW PROCESSLIST; SHOW FULL PROCESSLIST; -- 杀死进程 KILL process_id; 十三、常用字符串和日期函数 13.1 字符串函数 -- 字符串连接 SELECT CONCAT(\u0026#39;Hello\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;World\u0026#39;); SELECT CONCAT_WS(\u0026#39;-\u0026#39;, \u0026#39;2024\u0026#39;, \u0026#39;12\u0026#39;, \u0026#39;10\u0026#39;); -- 字符串长度 SELECT LENGTH(\u0026#39;Hello\u0026#39;), CHAR_LENGTH(\u0026#39;你好\u0026#39;); -- 大小写转换 SELECT UPPER(\u0026#39;hello\u0026#39;), LOWER(\u0026#39;HELLO\u0026#39;); -- 截取字符串 SELECT SUBSTRING(\u0026#39;Hello World\u0026#39;, 1, 5); SELECT LEFT(\u0026#39;Hello World\u0026#39;, 5), RIGHT(\u0026#39;Hello World\u0026#39;, 5); -- 替换和删除 SELECT REPLACE(\u0026#39;Hello World\u0026#39;, \u0026#39;World\u0026#39;, \u0026#39;MySQL\u0026#39;); SELECT TRIM(\u0026#39; Hello \u0026#39;), LTRIM(\u0026#39; Hello\u0026#39;), RTRIM(\u0026#39;Hello \u0026#39;); -- 查找位置 SELECT POSITION(\u0026#39;World\u0026#39; IN \u0026#39;Hello World\u0026#39;); SELECT LOCATE(\u0026#39;World\u0026#39;, \u0026#39;Hello World\u0026#39;); 13.2 日期时间函数 -- 获取当前时间 SELECT NOW(), CURDATE(), CURTIME(); SELECT CURRENT_TIMESTAMP(), CURRENT_DATE(), CURRENT_TIME(); -- 日期格式化 SELECT DATE_FORMAT(NOW(), \u0026#39;%Y-%m-%d %H:%i:%s\u0026#39;); SELECT DATE_FORMAT(NOW(), \u0026#39;%Y年%m月%d日\u0026#39;); -- 日期计算 SELECT date_add(\u0026#39;2023-01-01\u0026#39;, interval 1 day) 输出 \u0026#39;2023-01-02\u0026#39; SELECT date_sub(\u0026#39;2023-01-01\u0026#39;, interval 1 day) 输出 \u0026#39;2022-12-31\u0026#39; SELECT datediff(\u0026#39;2023-02-01\u0026#39;, \u0026#39;2023-01-01\u0026#39;) 输出31 -- 提取日期部分 SELECT YEAR(NOW()), MONTH(NOW()), DAY(NOW()); SELECT HOUR(NOW()), MINUTE(NOW()), SECOND(NOW()); -- 时间戳转换 SELECT UNIX_TIMESTAMP(NOW()); SELECT FROM_UNIXTIME(1702195200); 13.3 数学和其他函数 -- 数学函数 SELECT ROUND(3.14159, 2), CEIL(3.2), FLOOR(3.8); SELECT ABS(-5), MOD(10, 3), POWER(2, 3); SELECT RAND(), RAND()*100; -- 条件函数 SELECT IF(age \u0026gt; 18, \u0026#39;成年\u0026#39;, \u0026#39;未成年\u0026#39;) FROM users; SELECT IFNULL(email, \u0026#39;无邮箱\u0026#39;) FROM users; SELECT COALESCE(NULL, NULL, \u0026#39;default\u0026#39;, \u0026#39;value\u0026#39;); -- CASE 表达式 SELECT username, CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END as age_group FROM users; 十四、JSON 操作（MySQL 5.7+） -- 创建 JSON 列 CREATE TABLE products ( id INT PRIMARY KEY, name VARCHAR(100), attributes JSON ); -- 插入 JSON 数据 INSERT INTO products VALUES (1, \u0026#39;iPhone\u0026#39;, \u0026#39;{\u0026#34;color\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;storage\u0026#34;: \u0026#34;128GB\u0026#34;}\u0026#39;); -- 查询 JSON 数据 SELECT JSON_EXTRACT(attributes, \u0026#39;$.color\u0026#39;) as color FROM products; SELECT attributes-\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; SELECT attributes-\u0026gt;\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; -- 去除引号 -- 修改 JSON 数据 UPDATE products SET attributes = JSON_SET(attributes, \u0026#39;$.color\u0026#39;, \u0026#39;white\u0026#39;) WHERE id = 1; UPDATE products SET attributes = JSON_INSERT(attributes, \u0026#39;$.price\u0026#39;, 999) WHERE id = 1; UPDATE products SET attributes = JSON_REMOVE(attributes, \u0026#39;$.storage\u0026#39;) WHERE id = 1; -- JSON 数组操作 SELECT JSON_ARRAY(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;); SELECT JSON_CONTAINS(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;, \u0026#39;\u0026#34;a\u0026#34;\u0026#39;); SELECT JSON_LENGTH(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;); 十五、窗口函数（MySQL 8.0+） -- ROW_NUMBER：行号 SELECT username, age, ROW_NUMBER() OVER (ORDER BY age DESC) as row_num FROM users; -- RANK：排名（有并列，跳号） SELECT username, score, RANK() OVER (ORDER BY score DESC) as rank FROM students; -- DENSE_RANK：密集排名（有并列，不跳号） SELECT username, score, DENSE_RANK() OVER (ORDER BY score DESC) as rank FROM students; -- 分组窗口 SELECT department, username, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank FROM employees; -- 累计求和 SELECT username, amount, SUM(amount) OVER (ORDER BY created_at) as running_total FROM transactions; -- LAG 和 LEAD：访问上下行 SELECT username, salary, LAG(salary, 1) OVER (ORDER BY id) as prev_salary, LEAD(salary, 1) OVER (ORDER BY id) as next_salary FROM employees; 十六、常见问题和技巧 16.1 查找重复数据 -- 查找重复的用户名 SELECT username, COUNT(*) as count FROM users GROUP BY username HAVING count \u0026gt; 1; -- 删除重复数据（保留ID最小的） DELETE u1 FROM users u1 INNER JOIN users u2 WHERE u1.id \u0026gt; u2.id AND u1.username = u2.username; 16.2 随机获取数据 -- 随机获取一条数据 SELECT * FROM users ORDER BY RAND() LIMIT 1; -- 更高效的随机（大表适用） SELECT * FROM users WHERE id \u0026gt;= (SELECT FLOOR(MAX(id) * RAND()) FROM users) LIMIT 1; 16.3 行转列 -- 使用 CASE WHEN SELECT name, SUM(CASE WHEN subject = \u0026#39;语文\u0026#39; THEN score ELSE 0 END) as chinese, SUM(CASE WHEN subject = \u0026#39;数学\u0026#39; THEN score ELSE 0 END) as math FROM scores GROUP BY name; 16.4 列转行 -- 使用 UNION ALL SELECT name, \u0026#39;语文\u0026#39; as subject, chinese as score FROM scores UNION ALL SELECT name, \u0026#39;数学\u0026#39; as subject, math as score FROM scores; 十七、常用管理命令 -- 查看 MySQL 版本 SELECT VERSION(); -- 查看当前用户 SELECT USER(), CURRENT_USER(); -- 查看数据库大小 SELECT table_schema AS \u0026#39;Database\u0026#39;, ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables GROUP BY table_schema; -- 查看表大小 SELECT table_name AS \u0026#39;Table\u0026#39;, ROUND(((data_length + index_length) / 1024 / 1024), 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables WHERE table_schema = \u0026#39;database_name\u0026#39; ORDER BY (data_length + index_length) DESC; -- 修复表 REPAIR TABLE users; -- 优化表 OPTIMIZE TABLE users; -- 分析表 ANALYZE TABLE users; -- 检查表 CHECK TABLE users; 总结 这份笔记涵盖了 MySQL 从基础到进阶的大部分常用操作，当然也适合在刷题中补充，包括：\n数据库和表的管理 完整的 CRUD 操作 索引和约束 视图、事务、存储过程 用户权限管理 性能优化技巧 常用函数和 JSON、窗口函数！ ","permalink":"http://localhost:1313/database/mysql-cheatsheet/","summary":"MySQL 常用语句全面速查手册，涵盖从基础 CRUD 到高级特性（索引、事务、存储过程、窗口函数等）的所有常用操作，适合快速查阅和刷题使用","title":"MySQL 语句速查笔记"},{"content":"论文基本信息 标题: Linking Souls to Humans: Blockchain Accounts with Credible Anonymity for Web 3.0 Decentralized Identity 作者: Taotao Wang, Zibin Lin, Shengli Zhang, Long Shi, Qing Yang, Boris Düdder 会议: WWW \u0026lsquo;25 (ACM Web Conference 2025) 时间: 2025年4月28日-5月2日，悉尼 机构: 深圳大学、南京理工大学、哥本哈根大学 研究背景 数字身份的三个发展阶段 数字身份系统经历了三个演进阶段，分别对应互联网的三个时代：\n阶段 身份类型 对应时代 特点 问题 1 中心化身份 Web 1.0 用户创建，应用提供商管理 多账户管理复杂，数据泄露风险 2 联盟身份 Web 2.0 少数大型提供商管理，可跨应用使用 数据霸权，用户数据集中在少数巨头手中 3 去中心化身份 Web 3.0 用户自主创建和管理（自主权身份） 完全匿名导致无法追溯真实社交关系 Web 3.0的核心价值 Web 3.0的革命性转变在于：\n用户拥有数据主权 数据不被应用提供商占有 需要去中心化身份系统支撑 当前区块链账户系统的问题 区块链账户系统是Web 3.0去中心化身份的理想原型，但存在以下问题：\n完全匿名的缺陷： 用户可以无需认证创建多个账户 无法准确记录真实用户之间的社交关系和互动 用户与区块链身份之间的映射关系模糊 Soulbound Token的局限性： Vitalik Buterin提出的\u0026quot;灵魂\u0026quot;（Soul）概念和\u0026quot;灵魂绑定代币\u0026quot;（Soulbound Token） 用户仍可创建多个\u0026quot;灵魂\u0026quot;账户来抹除、转移或隐藏关系 无法真实反映人类社会中的真实关系 研究方案：zkBID 核心目标 zkBID（Zero-Knowledge Blockchain-account-based Web 3.0 decentralized IDentity）旨在实现：\n一对一映射：将灵魂（区块链账户）与人类（用户）建立一对一关联 去中心化：无需第三方中心化机构参与 隐私保护：隐藏身份与账户之间的绑定关系（即匿名） 可信性：每个账户在区块链上的信用与对应的真实用户一对一映射 关键技术 zkBID采用三大核心技术：\n零知识证明（zkSNARK） 可链接环签名（Linkable Ring Signature） 区块链智能合约（Smart Contracts） 技术预备知识 1. 可验证凭证（Verifiable Credentials, VC） 由W3C提出的去中心化标识符（DID）体系中的关键组件。\n三个主要角色：\n颁发者（Issuer）：签发凭证 持有者（Holder）：拥有凭证 验证者（Verifier）：验证凭证 VC的数据结构（JSON对象）：\n{ \u0026#34;metadata\u0026#34;: \u0026#34;包含颁发者DID、颁发日期、声明类型\u0026#34;, \u0026#34;claims\u0026#34;: \u0026#34;关于持有者的断言，包括持有者DID\u0026#34;, \u0026#34;proofs\u0026#34;: \u0026#34;颁发者的数字签名\u0026#34; } 2. 人格凭证（Personhood Credentials, PHC） 定义：证明用户是真人而非AI的数字凭证\n运作流程：\n注册流程 用户向PHC颁发者证明自己是真人 → 颁发者签发PHC\n使用流程 第三方服务可要求用户出示PHC作为授权过程的一部分\n验证方法（颁发者确保用户是真人的三种主要方式）：\n现有身份文件 基于政府签发的身份证件 利用现有可信来源 生物识别信息 测量持久且唯一的人体特征（掌纹、虹膜、指纹） 确保是真人且限制每人只注册一次 信任网络（Web of Trust） 通过社交图谱分析区分真人和机器 检测用户是否曾获得过凭证 在zkBID中的应用：\nPHC以VC形式作为每个人类用户的身份凭证 3. zkSNARK算法 全称：Zero-knowledge Succinct Non-interactive Argument of Knowledge\n优势：\n简洁性（Succinct）：证明大小仅几个字节，验证时间短 非交互性（Non-interactive）：证明者和验证者无需同步通信 工作原理：\n使用算术电路表示，包含基本运算：加、减、乘、除\nF-算术电路：\n输入：$x \\in \\mathbb{F}^n$ 辅助输入（见证）：$w \\in \\mathbb{F}^h$ 输出：$C(x, w) \\in \\mathbb{F}^l$ 三个算法组件：\n密钥生成（KEYGEN）\n(PK, VK) ← KEYGEN(1^λ, C) 输入：安全参数λ和电路C 输出：证明密钥PK和验证密钥VK 证明生成（PROVE）\nπ ← PROVE(PK, x, W) 输入：PK、公开输入x、私密见证W 输出：证明π 证明验证（VERIFY）\n1/0 ← VERIFY(VK, x, π) 输入：VK、公开输入x、证明π 输出：接受（1）或拒绝（0） zkBID采用的算法：Groth16\n原因：验证速度快，证明紧凑 适用于大规模应用和大型区块链网络 4. 可链接环签名（Linkable Ring Signature） 基本环签名：\n验证者可以确认签名由预定义集合中的某个成员创建 但无法确定具体是哪个成员 可链接环签名的额外特性：\n允许验证者确定两个签名是否由同一签名者生成 四个算法组件：\n密钥生成（GEN）\n(pk, sk) ← GEN(1^k) 签名生成（SIG）\nσ ← SIG(1^k, 1^n, m, L, sk) 输入：安全参数k、环大小n、消息m、公钥环L、私钥sk 输出：签名σ 签名验证（VER）\n1/0 ← VER(1^k, 1^n, m, L, σ) 可链接性检查（LINK）\n1/0 ← LINK(1^k, 1^n, m1, m2, σ1, σ2, L1, L2) 判断两个签名是否由同一签名者生成 关键属性：\n签名者模糊性（Signer Ambiguity）： 攻击者正确猜测真实签名者的概率不超过 1/(n-t) 其中n是环大小，t是攻击者拥有的私钥数量 可链接性（Linkability）： 同一签名者（相同私钥）签名的两条消息可被验证为关联 zkBID采用的算法：MLSAGS（Multilayered Linkable Spontaneous Anonymous Group Signature）\n原因：实现可链接性的技术复杂度较低，适合在智能合约上实现 密钥图像（Key Image）机制：\ny₀ ← sk * Hₚ(pk) y₀对于给定的(sk, pk)对是唯一的 所有由同一签名者产生的签名都带有相同的密钥图像 即使环中的公钥改变，签名仍可链接 zkBID系统设计 整体架构 映射关系图 真实用户 → PHC（人格凭证）→ PHC哈希 → 种子公钥 → 灵魂账户 关系说明：\n实线：可见的一对一关系 虚线：不可见但可验证的关系 箭头：单向计算关系 核心设计理念 隐私保护： PHC的具体内容不上链，只存储零知识证明 灵魂账户与种子公钥的关联不可见 可信匿名： 账户是匿名的（无法追踪到真实身份） 账户是可信的（确实与真实用户一对一绑定） 完全去中心化： 所有数据由用户生成 通过区块链上的智能合约验证 IVAC流程（Identity Verification and Account Certification） zkBID通过三个子流程生成具有可信匿名性的灵魂账户：\n[用户] → [注册信息生成] → [用户身份验证] → [灵魂账户认证] → [灵魂账户] ↓ ↓ ↓ 零知识证明 智能合约验证 可链接环签名 详细设计 阶段1：注册信息生成 目标：生成隐私保护的注册信息，不泄露PHC的具体内容\nPHC格式设计 zkBID中的PHC采用VC格式，包含三个关键字段：\n{ \u0026#34;credentialSubject\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_holder\u0026#34; // 持有者公钥 }, \u0026#34;proof\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_issuer\u0026#34;, // 颁发者公钥 \u0026#34;signature\u0026#34;: \u0026#34;sig_issuer\u0026#34; // 颁发者签名 } } 零知识证明生成流程 Protocol 1: PHC的ZK证明生成\n输入： - hash_PHC：PHC的哈希值 - sig_holder：持有者的签名 - pk_issuer：颁发者的公钥 - PHC：完整的PHC数据 设置： (PK, VK) ← zkSNARK.KEYGEN(1^λ, C) 生成证明： 1. 公开输入 x ← (hash_PHC, sig_holder, pk_issuer) 2. 私密见证 W ← PHC 3. π ← zkSNARK.PROVE(PK, x, W) 输出：π（零知识证明） 算术电路验证逻辑 graph TD A[私密输入: PHC] --\u0026gt; B[计算PHC的哈希] C[公开输入: hash_PHC] --\u0026gt; B B --\u0026gt; D{哈希值是否相等?} A --\u0026gt; E[提取pk_holder] F[公开输入: sig_holder] --\u0026gt; G[验证sig_holder] E --\u0026gt; G G --\u0026gt; H{签名是否有效?} A --\u0026gt; I[提取sig_issuer] J[公开输入: pk_issuer] --\u0026gt; K[验证sig_issuer] I --\u0026gt; K K --\u0026gt; L{签名是否有效?} D --\u0026gt; M[AND] H --\u0026gt; M L --\u0026gt; M M --\u0026gt; N{输出TRUE/FALSE} 验证步骤：\n验证哈希正确性： 计算PHC的哈希 检查是否等于公开输入中的hash_PHC 确保hash_PHC确实从PHC计算得出 验证所有权： 从PHC中提取持有者公钥pk_holder 用pk_holder验证sig_holder 证明用户拥有PHC 验证PHC有效性： 从PHC中提取颁发者签名sig_issuer 用pk_issuer验证sig_issuer 证明PHC由可信颁发者签发 输出：\n如果所有检查通过：输出TRUE和证明π π证明的声明：\u0026ldquo;PHC哈希正确，持有者拥有PHC，PHC由颁发者签发\u0026rdquo; 关键：不泄露PHC的具体内容 阶段2：用户身份验证 目标：\n验证用户的真人身份（通过验证ZK证明） 防止重复注册（检查PHC哈希未被使用） 智能合约流程 Protocol 2: 用户身份验证智能合约\n输入： - π：零知识证明 - hash_PHC：PHC哈希 - sig_holder：持有者签名 - pk_seed：种子公钥 执行步骤： 1. pk_issuer ← GetIssuerPK() // 获取预定义的颁发者公钥 2. validation ← zkSNARK.VERIFY(VK, hash_PHC, pk_issuer, π) 3. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 4. stored ← Traverse(hash_PHC) // 检查是否已注册 5. if stored ≠ 0: return \u0026#34;已经注册\u0026#34; 6. Store(hash_PHC, pk_seed) // 存储为键值对 7. return \u0026#34;认证成功\u0026#34; 用户操作步骤 生成种子密钥对：\n(pk_seed, sk_seed) ← MLSAGS.GEN(1^k) 构造交易：\n数据字段包含：π, hash_PHC, sig_holder, pk_issuer, pk_seed 发送到身份验证合约地址 合约验证：\n验证颁发者公钥匹配 验证零知识证明 检查PHC哈希未被使用 链上记录：\n存储键值对：(hash_PHC, pk_seed) hash_PHC用于防止重复注册 pk_seed作为用户在下一阶段创建灵魂账户的凭证 安全保证：\nPHC的具体内容不上链 仍能验证PHC的所有权和有效性 防止同一PHC多次注册 阶段3：灵魂账户认证 目标：认证灵魂账户与合法种子公钥的一对一关联\n整体流程 生成灵魂账户（普通以太坊账户） 建立关联（使用可链接环签名） 链上验证（智能合约验证签名） 可链接环签名的生成和验证 graph LR A[用户端] --\u0026gt; B[签名生成] B --\u0026gt; C[智能合约] C --\u0026gt; D[签名验证] E[输入] --\u0026gt; B E --\u0026gt; |选择的L-1个种子公钥| B E --\u0026gt; |用户的种子公钥pk_seed| B E --\u0026gt; |用户的种子私钥sk_seed| B E --\u0026gt; |灵魂账户地址addr_soul| B E --\u0026gt; |密钥图像y₀| B B --\u0026gt; |签名σ| C F[公钥环L] --\u0026gt; C G[addr_soul] --\u0026gt; C D --\u0026gt; H{验证结果} H --\u0026gt; |True| I[认证成功] H --\u0026gt; |False| J[认证失败] 详细步骤 步骤1：生成灵魂账户\n(addr_soul, pk_soul, sk_soul) = 生成以太坊账户 步骤2：构造公钥环\n从已注册的种子公钥中选择L-1个 加上用户自己的pk_seed 形成大小为L的公钥环 步骤3：计算密钥图像\ny₀ ← sk_seed * Hₚ(pk_seed) y₀对于给定的(sk_seed, pk_seed)是唯一的 用于防止重复注册 步骤4：生成可链接环签名\nσ ← MLSAGS.SIG(1^k, 1^n, addr_soul, L, sk_seed) 消息m = addr_soul（要签名的是灵魂账户地址） 签名格式：σ = (y₀, \u0026hellip;) y₀作为签名的一部分 步骤5：智能合约验证\nProtocol 3: 灵魂账户认证智能合约\n输入： - σ：可链接环签名 - L：公钥环 - addr_soul：灵魂账户地址 执行步骤： 1. validation ← LRS.VER(1^k, 1^n, addr_soul, L, σ) 2. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 3. stored ← Traverse(σ.y₀) // 检查密钥图像是否已使用 4. if stored ≠ 0: return \u0026#34;已经认证\u0026#34; 5. Store(σ.y₀, addr_soul) // 存储密钥图像和灵魂账户 6. return \u0026#34;认证成功\u0026#34; 隐私保护机制 关键特性：\n签名者模糊性： 签名可以被验证为有效 但无法确定环L中哪个公钥是真正的签名者 攻击者猜对的概率：1/(n-t)，其中n是环大小，t是攻击者拥有的私钥数 一对一保证： 密钥图像y₀唯一对应一个种子密钥对 同一种子密钥对只能生成一个有效签名 确保一个PHC只能关联一个灵魂账户 可验证的匿名性： 任何人都可以验证灵魂账户与某个合法种子公钥关联 但无法确定具体是哪个种子公钥 实现\u0026quot;可信匿名\u0026quot; 链上数据 存储内容：\n(σ.y₀, addr_soul) 键值对 可见信息：\n所有种子公钥（从阶段2） 所有灵魂账户地址 所有密钥图像 不可见关联：\n哪个种子公钥对应哪个灵魂账户 哪个PHC哈希对应哪个灵魂账户 哪个真实用户对应哪个灵魂账户 安全性分析 安全前提条件 计算对手受限：攻击者为多项式时间的计算对手 验证者诚实：智能合约不会接受虚假验证请求 PHC唯一性：每个用户只能从颁发者获得一个PHC 安全目标 zkBID需要满足三个核心安全属性：\n安全属性 定义 目标 身份唯一性 防止重复注册 一个用户不能注册多个灵魂账户 不可伪造性 防止身份伪造 攻击者不能冒充诚实用户认证灵魂账户 匿名性 保护身份隐私 攻击者无法检测用户身份(PHC)与灵魂账户的关联 威胁模型与防御 1. 女巫攻击（Sybil Attack） 攻击场景： 攻击者已拥有一个灵魂账户，试图获取新的灵魂账户\n攻击方法：\n方法A：使用相同PHC关联新的种子公钥 → 用新种子公钥认证新灵魂账户\n方法B：直接使用已用过的种子公钥认证新灵魂账户\n防御分析：\n方法A的防御：\n在用户身份验证合约中： 1. 合约检查hash_PHC是否已存储 2. 由于哈希函数的抗碰撞性，每个PHC只能生成一个唯一哈希 3. zkSNARK的可靠性保证：攻击者通过伪造哈希成功的概率可忽略不计 4. 因此无法用同一PHC注册两个种子账户 方法B的防御：\n在灵魂账户认证合约中： 1. 合约检查密钥图像y₀是否已使用 2. 由于可链接环签名的可链接性，同一种子私钥无法构造两个不同y₀的有效签名 3. 因此无法用同一种子密钥对认证两个灵魂账户 结论：无法使用相同PHC或种子公钥注册两个灵魂账户\n2. 链接攻击（Linkage Attack） 攻击场景： 攻击者试图通过破解环签名的真实签名者，建立用户身份（PHC哈希）与灵魂账户的链接\n攻击方法： 分析链上存储的环签名，推断哪个种子公钥是真正的签名者\n防御分析：\n基于可链接环签名的签名者模糊性： - 假设环大小为n - 攻击者拥有t个私钥 - 攻击者正确识别真实签名者的概率 = 1/(n-t) 示例： - 环大小 n = 100 - 攻击者拥有 t = 10 个私钥 - 成功概率 = 1/90 ≈ 1.1% 结论：攻击者无法有效建立身份与账户的链接 环大小的影响：\n环越大 → 匿名性越强 但签名生成和验证成本增加 需要在匿名性和效率之间权衡 3. 伪造攻击（Forgery Attack） 攻击场景： 攻击者试图冒充诚实用户获取灵魂账户\n攻击方法：\n方法A：伪造holder签名生成有效zkSNARK证明\n攻击者获得诚实用户的PHC ↓ 伪造sig_holder ↓ 生成通过验证的zkSNARK证明 ↓ 注册种子公钥 ↓ 认证灵魂账户 方法B：伪造种子账户的环签名\n已注册的种子公钥公开可见 ↓ 伪造某个诚实用户的环签名sig_seed ↓ 认证新的灵魂账户 防御分析：\n方法A的防御：\n依赖两个密码学保证： 1. EdDSA算法的不可伪造性 → 攻击者无法伪造任何诚实用户的sig_holder 2. zkSNARK的可靠性 → 没有有效签名，无法创建有效的zkSNARK证明 结论：攻击者无法通过伪造签名获得种子公钥 方法B的防御：\n依赖可链接环签名的不可伪造性： - 攻击者无法伪造任何已注册种子账户的有效签名 - 即使种子公钥公开可见 结论：攻击者无法冒充诚实用户认证灵魂账户 总结：zkBID协议能够抵御伪造攻击\n安全性总结表 攻击类型 攻击目标 依赖的安全属性 防御结果 女巫攻击-方法A 重复注册PHC 哈希抗碰撞性 + zkSNARK可靠性 ✅ 安全 女巫攻击-方法B 重复使用种子密钥 可链接环签名的可链接性 ✅ 安全 链接攻击 破坏匿名性 可链接环签名的签名者模糊性 ✅ 安全 伪造攻击-方法A 伪造身份验证 EdDSA不可伪造性 + zkSNARK可靠性 ✅ 安全 伪造攻击-方法B 伪造账户认证 可链接环签名不可伪造性 ✅ 安全 实验评估 实验环境 测试网络配置 区块链测试网络：\n平台：阿里云 节点数：6个以太坊全节点 共识协议：工作量证明（PoW） 客户端：Go-Ethereum 网络拓扑：全连接（每个节点有独立IP） 用户节点：\n1个用户节点连接到1个以太坊节点 运行用户端功能 硬件配置（所有节点）：\n操作系统：Ubuntu 20.04 CPU：Intel(R) Core(TM) i7-10700 @ 2.90GHz 内存：48GB RAM 实现技术栈 智能合约：\n语言：Solidity 部署：以太坊测试网络 zkSNARK：\n算法：Groth16 平台：Circom 2 功能：Setup和证明生成 可链接环签名：\n算法：MLSAGS 用户端实现：Python（密钥生成、签名算法） 合约实现：Solidity（签名验证） 性能评估指标 指标 说明 重要性 ZK证明生成时间 Groth16证明算法的执行时间 影响用户体验 ZK证明大小 证明所占字节数 影响链上存储 ZK证明验证成本 智能合约验证所需Gas 影响使用成本 算术电路大小 R1CS约束数量 影响系统复杂度 MLSAGS签名生成时间 环签名生成的执行时间 影响用户体验 MLSAGS签名验证成本 智能合约验证所需Gas 影响使用成本 实验结果 1. Groth16性能测试 测试方案：\n使用单个算术电路验证多个PHC批次 测试不同批次大小下的性能表现 图表 6(a)：电路大小和证明大小 PHC批次大小 R1CS约束数量 ZK证明大小 1 ~19,000 192 Bytes 2 ~38,000 192 Bytes 4 ~76,000 192 Bytes 8 ~152,000 192 Bytes 16 ~304,000 192 Bytes 32 ~608,000 192 Bytes 64 ~1,216,000 192 Bytes 128 ~2,432,000 192 Bytes 关键发现：\n✨ 证明大小恒定：无论批次大小如何，证明始终为192字节 这是Groth16的核心优势：简洁性（Succinctness） 电路大小随批次线性增长 图表 6(b)：证明生成时间和验证成本 证明生成时间：\nPHC批次大小 生成时间 (ms) 增长趋势 1 ~2,000 基准 2 ~4,000 2x 4 ~8,000 4x 8 ~16,000 8x 16 ~32,000 16x 32 ~64,000 32x 证明验证成本（Gas）：\nPHC批次大小 验证Gas消耗 单个PHC平均Gas 1 215.7K 215.7K 2 247.2K 123.6K 4 310.2K 77.6K 8 436.2K 54.5K 16 688.2K 43.0K 32 1,040.0K 32.5K 关键发现：\n📈 线性增长：生成时间和验证成本都与批次大小呈线性关系\n💰\n批处理优势\n：批次大小为32时，单个PHC的Gas消耗仅为32.5K\n相比单独验证（215.7K），节省约85% 效率提升约7倍 ⚠️ 部署限制：批次大小≥64时，验证合约因以太坊合约大小限制无法部署\n最佳实践建议：\n推荐批次大小：16-32个PHC - 在合约大小限制内 - 获得显著的Gas优化 - 用户体验可接受 2. MLSAGS性能测试 测试方案：\n测试不同环大小L下的签名生成和验证性能 环大小影响匿名性和性能的权衡 图表 6(c)：MLSAGS性能指标 签名生成时间：\n环大小 L 生成时间 (ms) 增量时间 1 ~40 - 2 ~80 +40ms 4 ~160 +40ms 8 ~320 +40ms 16 ~640 +40ms 32 ~1,280 +40ms 64 ~2,560 +40ms 128 ~5,120 +40ms 签名验证成本（Gas）：\n环大小 L 验证Gas消耗 增量Gas 1 ~57K - 2 ~114K +57K 4 ~228K +57K 8 ~456K +57K 16 ~912K +57K 32 ~1,824K +57K 64 ~3,648K +57K 128 ~7,296K +57K 关键发现：\n📏\n完美线性关系\n：\n每增加1个公钥，生成时间增加约40ms 每增加1个公钥，验证Gas增加约57K ⚖️\n匿名性vs效率权衡\n：\n环越大 → 匿名性越强（攻击者猜中概率 = 1/L） 环越大 → 成本越高（时间和Gas） 匿名性分析：\n环大小 L 攻击者成功率 匿名性等级 Gas成本 10 10% 较弱 570K 50 2% 中等 2,850K 100 1% 强 5,700K 1000 0.1% 非常强 57,000K 实际应用建议：\n小规模应用（\u0026lt; 1000用户）： 环大小：10-20 匿名性：10%-5%攻击成功率 Gas成本：570K-1,140K（可接受） 中等规模应用（1000-10000用户）： 环大小：50-100 匿名性：2%-1%攻击成功率 Gas成本：2,850K-5,700K（需要优化） 大规模应用（\u0026gt; 10000用户）： 环大小：100+ 匿名性：\u0026lt; 1%攻击成功率 Gas成本：\u0026gt; 5,700K（需要Layer 2或批处理） 性能优化建议 1. 对于zkSNARK部分 批处理策略：\n低频场景（个人注册）： - 批次大小：1-4 - 适用：个人用户单次注册 - 优点：即时处理 - 缺点：Gas成本较高（215K-310K） 高频场景（批量注册）： - 批次大小：16-32 - 适用：组织批量入职、大规模注册活动 - 优点：Gas效率提升7倍 - 缺点：需要等待批次凑齐 2. 对于MLSAGS部分 环大小配置：\n# 根据用户总数动态调整 def calculate_ring_size(total_users, target_anonymity=0.01): \u0026#34;\u0026#34;\u0026#34; total_users: 系统总用户数 target_anonymity: 目标攻击成功率（如0.01 = 1%） \u0026#34;\u0026#34;\u0026#34; # 环大小不超过总用户数 ring_size = min(int(1 / target_anonymity), total_users) # 考虑Gas成本限制（假设单笔交易Gas上限为8M） max_affordable_ring = 8_000_000 / 57_000 # ≈ 140 return min(ring_size, max_affordable_ring) # 示例 calculate_ring_size(1000, 0.01) # 返回 100 calculate_ring_size(10000, 0.01) # 返回 100（受成本限制） calculate_ring_size(50, 0.01) # 返回 50（受用户数限制） 分层匿名策略：\nVIP用户/高价值账户： - 使用较大环（100+） - 提供更强匿名性 - 愿意支付更高Gas 普通用户： - 使用中等环（20-50） - 平衡匿名性和成本 - 实际应用最常见 测试/低价值账户： - 使用小环（10-20） - 基本匿名性 - 成本最低 实验结论 zkSNARK的优势： ✅ 证明大小恒定（192字节）：不受批次影响 ✅ 批处理优化显著：32个PHC可节省85% Gas ✅ 验证快速：链上验证成本可接受 MLSAGS的特性： ✅ 性能可预测：完美线性关系 ⚠️ 需要权衡：匿名性与成本呈正比 ✅ 灵活配置：可根据场景调整环大小 系统可行性： ✅ 在实际以太坊网络上完全可行 ✅ 通过参数优化可适应不同规模 ✅ 性能瓶颈明确且可优化 相关工作对比 现有方案分析 论文对比了8个相关的区块链身份方案：\n方案 年份 主要技术 应用场景 TradeMap [12] 2019 ZKP 符合FINMA的匿名KYC平台 Pauwels et al. [14] 2022 zkSNARK DeFi协议的KYC系统 Aydar et al. [3] 2019 Blockchain 数字身份验证框架 Singh et al. [18] 2020 Credential Protocol 保护个人属性的身份系统 Abraham et al. [1] 2020 SSI Model 支持凭证撤销的自主身份 ZEBRA [15] 2022 zkSNARK 链上匿名凭证验证 Zhang et al. [26] 2024 ZKP 能源交易身份认证 Kim et al. [10] 2023 SBT + DID 元宇宙的KYC系统 设计目标对比 方案 DG1 技术灵活性 DG2 身份匿名性 DG3 身份可信性 DG4 隐私存储 TradeMap [12] ✅ ❌ ❌ ❌ Pauwels [14] ✅ ❌ ✅ ✅ Aydar [3] ❌ ✅ ❌ ❌ Singh [18] ❌ ✅ ✅ ✅ Abraham [1] ✅ ✅ ❌ ❌ ZEBRA [15] ❌ ✅ ❌ ❌ Zhang [26] ✅ ❌ ✅ ❌ Kim [10] ❌ ✅ ❌ ❌ zkBID ✅ ✅ ✅ ✅ 设计目标说明：\nDG1 - 技术灵活性：不局限于特定的ZKP算法或区块链平台 DG2 - 身份匿名性：无法从链上活动推断用户真实身份 DG3 - 身份可信性：每个身份可信地连接到真实世界用户 DG4 - 隐私存储：身份文档保密存储，不公开可见 zkBID的独特优势 1. 唯一全面满足所有设计目标 其他方案的局限： ├─ TradeMap: 只关注合规性，缺乏匿名性和可信映射 ├─ Pauwels: DeFi场景，但身份匿名性不足 ├─ Aydar/Singh: 技术灵活性差，绑定特定实现 ├─ Abraham/ZEBRA: 缺乏与真实用户的可信绑定 ├─ Zhang: 特定场景（能源交易），匿名性不足 └─ Kim: 元宇宙场景，技术灵活性和可信性不足 zkBID的创新： ✅ 同时实现匿名性和可信性（看似矛盾的目标） ✅ 完全去中心化（无需可信第三方） ✅ 技术灵活（可替换ZKP算法和环签名方案） ✅ 隐私保护（身份信息不上链） 2. 技术组合的创新性 现有方案的技术使用：\n大多只使用zkSNARK进行凭证验证 少数使用环签名，但未实现身份-账户绑定 没有方案同时使用zkSNARK + 可链接环签名 zkBID的技术创新：\nzkSNARK（阶段1-2）： 目的：验证PHC有效性 优势：不泄露PHC内容 创新：批处理优化 可链接环签名（阶段3）： 目的：建立身份-账户映射 优势：保持匿名性的同时确保一对一 创新：使用密钥图像防止重复绑定 组合效果： = 可验证的身份 + 不可追踪的账户绑定 = 可信匿名（Credible Anonymity） 3. 实际应用价值 传统KYC系统的问题：\n中心化KYC： ❌ 隐私泄露风险 ❌ 数据被服务商控制 ❌ 跨平台不互通 区块链匿名账户： ❌ 无法防止女巫攻击 ❌ 信誉系统难以建立 ❌ 监管合规困难 zkBID的解决方案：\n对用户： ✅ 保护隐私（身份信息不泄露） ✅ 自主控制（无需信任中心化机构） ✅ 一次认证，多处使用 对平台： ✅ 防止女巫攻击（一人一账户） ✅ 建立信誉系统（账户可信） ✅ 满足监管要求（有认证机制） 对监管： ✅ 可验证的身份（PHC由可信机构签发） ✅ 可追责性（必要时可追踪） ✅ 隐私保护合规 应用场景 1. 去中心化社交网络 问题：\nTwitter/X上的机器人和假账户泛滥 难以区分真人和AI生成的内容 水军和虚假舆论操纵 zkBID解决方案：\n用户注册： 1. 用政府ID获取PHC 2. 通过zkBID认证获得灵魂账户 3. 使用灵魂账户在社交网络发布内容 效果： ✅ 每个账户对应一个真人 ✅ 保持用户匿名性 ✅ 机器人和假账户显著减少 ✅ 信誉系统可以建立在灵魂账户上 2. DAO治理 问题：\n一人多账户操纵投票 女巫攻击破坏治理公平性 难以验证投票者资格 zkBID解决方案：\n治理流程： 1. DAO成员通过zkBID认证 2. 每个灵魂账户 = 一个真实成员 3. 投票时保持匿名 4. 防止多重投票 效果： ✅ 一人一票（真正的民主） ✅ 投票匿名（防止胁迫和贿赂） ✅ 可验证（确保只有成员投票） ✅ 信誉加权（可基于历史贡献） 3. DeFi空投和激励 问题：\n空投被羊毛党多账户瓜分 难以识别真实用户 激励机制被滥用 zkBID解决方案：\n空投流程： 1. 要求使用zkBID认证的灵魂账户 2. 每个灵魂账户只能领取一次 3. 基于链上行为的信誉评分 效果： ✅ 公平分配（每人一份） ✅ 防止女巫攻击 ✅ 识别真实活跃用户 ✅ 建立长期激励机制 4. Web3游戏和元宇宙 问题：\n工作室多开刷金币 游戏经济被破坏 难以建立公平竞技环境 zkBID解决方案：\n游戏应用： 1. 玩家使用灵魂账户登录 2. 游戏内资产绑定到灵魂账户 3. 排行榜和竞技只认可灵魂账户 效果： ✅ 一人一号（公平竞争） ✅ 资产真实归属 ✅ 游戏经济稳定 ✅ 社交关系可信 5. 去中心化信用系统 问题：\n传统信用系统中心化 跨平台信用不互通 隐私泄露风险 zkBID解决方案：\n信用体系： 1. 灵魂账户作为信用载体 2. 链上行为建立信用历史 3. 跨DApp信用互认 4. 保护用户隐私 效果： ✅ 去中心化信用（不被单一机构控制） ✅ 可移植性（跨平台使用） ✅ 隐私保护（匿名但可信） ✅ 防止信用欺诈（一人一信用档案） 局限性与未来工作 当前局限性 1. 性能限制 Gas成本：\n当前状态： - 单次PHC验证：215.7K Gas - 环大小100的签名验证：5,700K Gas - 在以太坊主网上成本较高 影响： ❌ 大规模应用成本高 ❌ 限制了环大小（影响匿名性） 可能的解决方案：\nLayer 2方案（如Optimism、Arbitrum） 侧链部署 批处理优化 2. PHC依赖 当前状态：\n依赖可信的PHC颁发机构： - 政府机构 - 大型科技公司 - 其他可信第三方 问题： ❌ PHC系统尚未广泛部署 ❌ 不同颁发者的互操作性 ❌ 颁发者可能成为中心化风险点 3. 隐私权衡 匿名性级别：\n环大小的限制： - 小环（\u0026lt;20）：匿名性较弱 - 大环（100+）：成本高昂 - 实际应用中需要权衡 4. 撤销机制 当前缺失：\n无法撤销已认证的灵魂账户： ❌ 如果PHC被吊销怎么办？ ❌ 如果用户想注销怎么办？ ❌ 如果发现欺诈怎么办？ 需要设计： - 灵活的撤销机制 - 保持匿名性的撤销 - 防止滥用撤销权 未来研究方向 1. 性能优化 方向A：递归证明：\n使用递归zkSNARK： - 将多个证明聚合成一个 - 减少链上验证成本 - 提高批处理效率 预期效果： - Gas成本降低50%+ - 支持更大批次 方向B：量子抗性：\n替换为抗量子密码算法： - 格基密码学 - 哈希基签名 - 为后量子时代做准备 2. PHC生态系统 多颁发者互操作：\n标准化PHC格式： - 统一的VC模板 - 跨颁发者互认 - 去中心化颁发者网络 目标： - 减少单点故障 - 提高可用性 - 增强去中心化 去中心化PHC颁发：\n探索无需中心化颁发者的方案： - 基于生物识别的去中心化验证 - 社交图谱验证 - 组合多种验证方式 3. 隐私增强 方向A：动态环：\n允许用户动态选择环大小： - 根据交易重要性调整 - 重要交易用大环 - 普通交易用小环 效果： - 灵活性提高 - 成本优化 方向B：分层匿名：\n不同隐私级别的灵魂账户： - 公开级：最小匿名性，低成本 - 标准级：中等匿名性，中等成本 - 隐私级：高匿名性，高成本 4. 跨链支持 多链部署：\n扩展到其他区块链： - Polkadot/Cosmos生态 - 高性能链（Solana、Aptos） - 专用隐私链（Zcash、Monero概念） 跨链身份： - 一个PHC，多链认证 - 统一的身份层 5. 撤销和恢复机制 优雅的撤销：\n设计保护隐私的撤销： - 使用累加器（Accumulator） - 撤销列表不泄露身份 - 高效的撤销验证 恢复机制： - PHC过期后的更新流程 - 密钥丢失的恢复方案 - 保持连续性的信誉迁移 6. 合规和监管 可选的透明性：\n为监管场景设计： - 选择性披露机制 - 紧急情况下的去匿名化 - 法院命令的执行 平衡： - 保护普通用户隐私 - 满足反洗钱（AML）要求 - 支持合法调查 关键takeaways 技术创新 可信匿名的突破： 首次在区块链上实现\u0026quot;可信\u0026quot;+\u0026ldquo;匿名\u0026quot;的结合 通过零知识证明保护隐私 通过可链接环签名确保一对一映射 完全去中心化： 无需可信第三方参与验证 所有逻辑在智能合约中执行 用户完全控制自己的身份 实用性验证： 在真实以太坊测试网络上实现 性能指标明确可测 成本可接受且可优化 理论贡献 身份模型创新：\n传统模型：身份 → 账户（可见映射） zkBID模型：身份 → [ZK层] → 种子 → [环签名层] → 账户 创新点： - 两层隐私保护 - 可验证但不可追踪 - 数学上可证明的安全性 密码学组合：\nzkSNARK + 可链接环签名的首次组合应用 各取所长，弥补对方不足 为未来类似系统提供范式 实践意义 Web3基础设施： 为Web3提供关键的身份层 解决匿名性与可信性的矛盾 使去中心化应用更实用 防止AI冒充： 在AI时代区分人类和机器 PHC作为\u0026quot;数字人格证\u0026rdquo; 保护在线空间的人类性 新经济模式： 支持基于信誉的去中心化经济 公平的激励分配机制 可持续的社区治理 结论 zkBID是一个创新的Web 3.0去中心化身份方案，成功解决了区块链账户系统中匿名性与可信性的矛盾。\n核心成就 ✅ 技术突破：\n零知识证明保护身份隐私 可链接环签名确保一对一映射 完全去中心化的验证机制 ✅ 安全保证：\n抵御女巫攻击 抵御链接攻击 抵御伪造攻击 ✅ 实用验证：\n以太坊测试网络成功部署 性能指标满足实际应用需求 成本可通过参数优化控制 未来展望 zkBID为Web3去中心化身份提供了一个可行的解决方案，但仍有改进空间：\n继续优化性能和成本 推动PHC生态系统发展 探索跨链和多链支持 完善撤销和恢复机制 平衡隐私保护 ","permalink":"http://localhost:1313/blockchain/linking-souls-to-humans/","summary":"zkBID通过零知识证明和可链接环签名技术，首次实现了区块链账户的\u0026quot;可信匿名\u0026quot;：每个账户与真实用户一对一绑定（可信），但外界无法追踪具体对应关系（匿名）。系统采用三阶段IVAC流程，将人格凭证(PHC)通过零知识证明验证后绑定到种子公钥，再用环签名将种子公钥关联到灵魂账户。实验显示批处理可将验证成本降低85%，环大小灵活可调以平衡匿名性与效率。该方案为Web3提供了关键身份基础设施，可有效防止女巫攻击，支持去中心化社交、DAO治理、DeFi空投等场景。","title":"zkBID: 区块链账户与Web 3.0去中心化身份"},{"content":"📚 Part 1: Java 集合使用手册 0.String - 不可变字符串 // 初始化 String s = \u0026#34;hello\u0026#34;; String s2 = new String(\u0026#34;world\u0026#34;); String s3 = String.valueOf(123); // 数字转字符串 // 基本属性 int len = s.length(); // 长度 boolean empty = s.isEmpty(); // 是否为空 char ch = s.charAt(0); // 获取字符 // 查找 int index = s.indexOf(\u0026#34;ll\u0026#34;); // 查找子串位置 int lastIndex = s.lastIndexOf(\u0026#34;l\u0026#34;); // 最后出现位置 boolean contains = s.contains(\u0026#34;el\u0026#34;); // 是否包含 // 截取 String sub = s.substring(1, 4); // [1, 4) 截取 String sub2 = s.substring(2); // 从索引2到结尾 // 替换 String replaced = s.replace(\u0026#34;l\u0026#34;, \u0026#34;L\u0026#34;); // 替换所有 String replaced2 = s.replaceFirst(\u0026#34;l\u0026#34;, \u0026#34;L\u0026#34;); // 替换第一个 String replaced3 = s.replaceAll(\u0026#34;[aeiou]\u0026#34;, \u0026#34;*\u0026#34;); // 正则替换 // 分割 String[] parts = \u0026#34;a,b,c\u0026#34;.split(\u0026#34;,\u0026#34;); // 按分隔符分割 String[] parts2 = \u0026#34;a b c\u0026#34;.split(\u0026#34;\\\\s+\u0026#34;); // 按空格分割 // 拼接 String joined = String.join(\u0026#34;,\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); // \u0026#34;a,b,c\u0026#34; String concat = s.concat(\u0026#34; world\u0026#34;); // 拼接 // 大小写 String upper = s.toUpperCase(); String lower = s.toUpperCase().toLowerCase(); // 去空格 String trimmed = \u0026#34; hello \u0026#34;.trim(); // 去两端空格 String stripped = \u0026#34; hello \u0026#34;.strip(); // Java 11+ // 比较 boolean equals = s.equals(\u0026#34;hello\u0026#34;); boolean equalsIgnoreCase = s.equalsIgnoreCase(\u0026#34;HELLO\u0026#34;); int compare = s.compareTo(\u0026#34;world\u0026#34;); // 字典序比较 // 判断 boolean startsWith = s.startsWith(\u0026#34;he\u0026#34;); boolean endsWith = s.endsWith(\u0026#34;lo\u0026#34;); // 转换 char[] chars = s.toCharArray(); // 转字符数组 byte[] bytes = s.getBytes(); // 转字节数组 StringBuilder - 可变字符串 使用场景：单线程环境下需要频繁修改字符串\n// 初始化 StringBuilder sb = new StringBuilder(); StringBuilder sb2 = new StringBuilder(\u0026#34;hello\u0026#34;); StringBuilder sb3 = new StringBuilder(100); // 指定初始容量 // 添加（拼接） sb.append(\u0026#34;hello\u0026#34;); // 尾部添加 sb.append(123); // 添加数字 sb.append(\u0026#39;!\u0026#39;); // 添加字符 sb.insert(0, \u0026#34;start \u0026#34;); // 指定位置插入 // 删除 sb.delete(0, 5); // 删除 [0, 5) sb.deleteCharAt(0); // 删除指定位置 sb.setLength(0); // 清空（重置长度为0） // 修改 sb.replace(0, 5, \u0026#34;world\u0026#34;); // 替换 [0, 5) sb.setCharAt(0, \u0026#39;H\u0026#39;); // 修改指定位置字符 // 反转 sb.reverse(); // 查询 int len = sb.length(); char ch = sb.charAt(0); String sub = sb.substring(0, 5); // 转换为 String String result = sb.toString(); // 常见应用：循环拼接字符串 StringBuilder result = new StringBuilder(); for (int i = 0; i \u0026lt; 1000; i++) { result.append(i).append(\u0026#34;,\u0026#34;); } // 比用 String + 拼接快得多！ StringBuffer - 可变字符串 使用场景：多线程环境下需要频繁修改字符串\n// API 与 StringBuilder 完全相同 StringBuffer sb = new StringBuffer(); sb.append(\u0026#34;hello\u0026#34;); sb.append(\u0026#34; world\u0026#34;); String result = sb.toString(); // 区别：StringBuffer 的方法都是 synchronized 的 // 多线程安全，但性能比 StringBuilder 差 常用字符串操作技巧 // 1. 字符串转数字 int num = Integer.parseInt(\u0026#34;123\u0026#34;); long l = Long.parseLong(\u0026#34;123\u0026#34;); double d = Double.parseDouble(\u0026#34;3.14\u0026#34;); // 2. 数字转字符串 String s1 = String.valueOf(123); String s2 = Integer.toString(123); String s3 = \u0026#34;\u0026#34; + 123; // 不推荐 // 3. 字符串数组拼接 String[] arr = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; String joined = String.join(\u0026#34;,\u0026#34;, arr); // \u0026#34;a,b,c\u0026#34; // 4. 重复字符串（Java 11+） String repeated = \u0026#34;ab\u0026#34;.repeat(3); // \u0026#34;ababab\u0026#34; // 5. 判断空字符串 if (s != null \u0026amp;\u0026amp; !s.isEmpty()) { } if (s != null \u0026amp;\u0026amp; !s.isBlank()) { } // Java 11+，忽略空白字符 // 6. 字符串格式化 String formatted = String.format(\u0026#34;Hello %s, you are %d years old\u0026#34;, \u0026#34;Alice\u0026#34;, 25); 1. List - 列表 ArrayList - 动态数组 // 初始化 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); List\u0026lt;Integer\u0026gt; list3 = new ArrayList\u0026lt;\u0026gt;(100); // 指定初始容量 // 增 list.add(1); // 尾部添加 list.add(0, 10); // 指定位置添加 list.addAll(Arrays.asList(2,3,4)); // 批量添加 // 删 list.remove(0); // 删除指定索引 list.remove(Integer.valueOf(1)); // 删除指定元素 list.clear(); // 清空 // 改 list.set(0, 100); // 修改指定位置 // 查 int val = list.get(0); // 获取元素 int size = list.size(); // 获取大小 boolean empty = list.isEmpty(); // 是否为空 boolean contains = list.contains(1); // 是否包含 int index = list.indexOf(1); // 查找索引 // 遍历 for (int num : list) { System.out.println(num); } // 或使用迭代器 Iterator\u0026lt;Integer\u0026gt; it = list.iterator(); while (it.hasNext()) { System.out.println(it.next()); } LinkedList - 双向链表 LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 头部操作 list.addFirst(1); list.removeFirst(); int first = list.getFirst(); // 尾部操作 list.addLast(2); list.removeLast(); int last = list.getLast(); // 作为队列使用 list.offer(3); // 入队 int head = list.poll(); // 出队 // 作为栈使用 list.push(4); // 入栈 int top = list.pop(); // 出栈 2. Set - 集合 HashSet - 无序不重复 // 初始化 Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); // 增 set.add(1); set.addAll(Arrays.asList(2, 3, 4)); // 删 set.remove(1); set.clear(); // 查 boolean contains = set.contains(1); int size = set.size(); boolean empty = set.isEmpty(); // 遍历 for (int num : set) { System.out.println(num); } TreeSet - 有序集合（红黑树） TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 基本操作同 HashSet set.add(3); set.add(1); set.add(2); System.out.println(set); // [1, 2, 3] 自动排序 // 特有方法 int first = set.first(); // 最小元素 int last = set.last(); // 最大元素 int lower = set.lower(2); // 小于 2 的最大元素 int higher = set.higher(2); // 大于 2 的最小元素 int floor = set.floor(2); // ≤ 2 的最大元素 int ceiling = set.ceiling(2); // ≥ 2 的最小元素 // 子集操作 SortedSet\u0026lt;Integer\u0026gt; subset = set.subSet(1, 3); // [1, 3) SortedSet\u0026lt;Integer\u0026gt; headSet = set.headSet(2); // \u0026lt; 2 SortedSet\u0026lt;Integer\u0026gt; tailSet = set.tailSet(2); // \u0026gt;= 2 LinkedHashSet - 保持插入顺序 Set\u0026lt;Integer\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); set.add(3); set.add(1); set.add(2); System.out.println(set); // [3, 1, 2] 保持插入顺序 3. Map - 映射 HashMap - 键值对 // 初始化 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 增/改 map.put(\u0026#34;apple\u0026#34;, 1); map.put(\u0026#34;banana\u0026#34;, 2); map.putIfAbsent(\u0026#34;apple\u0026#34;, 10); // 键不存在时才添加 // 删 map.remove(\u0026#34;apple\u0026#34;); map.clear(); // 查 int val = map.get(\u0026#34;apple\u0026#34;); int valOrDefault = map.getOrDefault(\u0026#34;orange\u0026#34;, 0); boolean hasKey = map.containsKey(\u0026#34;apple\u0026#34;); boolean hasValue = map.containsValue(1); int size = map.size(); // 遍历键值对 for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { String key = entry.getKey(); int value = entry.getValue(); } // 遍历键 for (String key : map.keySet()) { System.out.println(key); } // 遍历值 for (int value : map.values()) { System.out.println(value); } // Java 8+ 新方法 map.computeIfAbsent(\u0026#34;cherry\u0026#34;, k -\u0026gt; 3); map.merge(\u0026#34;apple\u0026#34;, 1, Integer::sum); // 累加 TreeMap - 有序映射（红黑树） TreeMap\u0026lt;Integer, String\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); map.put(3, \u0026#34;c\u0026#34;); map.put(1, \u0026#34;a\u0026#34;); map.put(2, \u0026#34;b\u0026#34;); // 基本操作同 HashMap // 特有方法 int firstKey = map.firstKey(); int lastKey = map.lastKey(); Map.Entry\u0026lt;Integer, String\u0026gt; firstEntry = map.firstEntry(); Map.Entry\u0026lt;Integer, String\u0026gt; lastEntry = map.lastEntry(); int lowerKey = map.lowerKey(2); // \u0026lt; 2 的最大键 int higherKey = map.higherKey(2); // \u0026gt; 2 的最小键 int floorKey = map.floorKey(2); // \u0026lt;= 2 的最大键 int ceilingKey = map.ceilingKey(2); // \u0026gt;= 2 的最小键 LinkedHashMap - 保持插入顺序 Map\u0026lt;String, Integer\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;c\u0026#34;, 3); map.put(\u0026#34;a\u0026#34;, 1); map.put(\u0026#34;b\u0026#34;, 2); // 遍历时保持插入顺序: c, a, b 4. Queue - 队列 普通队列 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 入队 queue.offer(1); queue.add(2); // 队列满时抛异常 // 出队 int head = queue.poll(); // 空时返回 null int head2 = queue.remove(); // 空时抛异常 // 查看队首 int peek = queue.peek(); // 空时返回 null int peek2 = queue.element(); // 空时抛异常 PriorityQueue - 优先队列（堆） // 小根堆（默认） PriorityQueue\u0026lt;Integer\u0026gt; minHeap = new PriorityQueue\u0026lt;\u0026gt;(); // 大根堆 PriorityQueue\u0026lt;Integer\u0026gt; maxHeap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); // 自定义对象 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); minHeap.offer(3); minHeap.offer(1); minHeap.offer(2); while (!minHeap.isEmpty()) { System.out.println(minHeap.poll()); // 1, 2, 3 } Deque - 双端队列 Deque\u0026lt;Integer\u0026gt; deque = new ArrayDeque\u0026lt;\u0026gt;(); // 头部操作 deque.offerFirst(1); deque.pollFirst(); deque.peekFirst(); // 尾部操作 deque.offerLast(2); deque.pollLast(); deque.peekLast(); // 作为栈使用 deque.push(3); int top = deque.pop(); 5. Stack - 栈 Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(1); // 入栈 int top = stack.pop(); // 出栈 int peek = stack.peek(); // 查看栈顶 boolean empty = stack.isEmpty(); int size = stack.size(); // 推荐使用 Deque 代替 Stack Deque\u0026lt;Integer\u0026gt; stack2 = new ArrayDeque\u0026lt;\u0026gt;(); 🧮 Part 2: 算法模板 1. 树的遍历 二叉树定义 class TreeNode { int val; // 节点值 TreeNode left; // 左子节点 TreeNode right; // 右子节点 TreeNode(int val) { this.val = val; } } DFS - 深度优先遍历 前序遍历（根-左-右） // 递归版本 - 最简洁直观 void preorder(TreeNode root) { if (root == null) return; // 递归终止条件：空节点 System.out.println(root.val); // 1. 先访问根节点 preorder(root.left); // 2. 再遍历左子树 preorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 使用栈模拟递归 List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); // 根节点入栈 while (!stack.isEmpty()) { TreeNode node = stack.pop(); // 弹出栈顶节点 res.add(node.val); // 访问该节点 // 关键：先压右子节点，再压左子节点 // 这样出栈时左子节点先出（栈是后进先出） if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); } return res; } 中序遍历（左-根-右） // 递归版本 void inorder(TreeNode root) { if (root == null) return; // 递归终止条件 inorder(root.left); // 1. 先遍历左子树 System.out.println(root.val); // 2. 再访问根节点 inorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 一直向左走到底 List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode curr = root; while (curr != null || !stack.isEmpty()) { // 第一步：一直向左走到底，沿途节点入栈 while (curr != null) { stack.push(curr); curr = curr.left; } // 第二步：弹出栈顶（当前最左节点），访问它 curr = stack.pop(); res.add(curr.val); // 第三步：转向右子树 curr = curr.right; } return res; } 后序遍历（左-右-根） // 递归版本 void postorder(TreeNode root) { if (root == null) return; // 递归终止条件 postorder(root.left); // 1. 先遍历左子树 postorder(root.right); // 2. 再遍历右子树 System.out.println(root.val); // 3. 最后访问根节点 } // 迭代版本 - 巧妙方法：前序遍历变形 + 反转 // 思路：前序是\u0026#34;根左右\u0026#34;，改成\u0026#34;根右左\u0026#34;，反转后得到\u0026#34;左右根\u0026#34; List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); res.add(node.val); // 添加到结果（根右左顺序） // 注意：这里先左后右，出栈时就是先右后左 if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); } Collections.reverse(res); // 反转得到左右根 return res; } BFS - 层序遍历 // 按层遍历二叉树，每层的节点放在一个列表中 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); // 根节点入队 while (!queue.isEmpty()) { int size = queue.size(); // 当前层的节点数（重要！） List\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); // 遍历当前层的所有节点 for (int i = 0; i \u0026lt; size; i++) { TreeNode node = queue.poll(); // 出队 level.add(node.val); // 记录节点值 // 将下一层的节点入队 if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } res.add(level); // 保存当前层结果 } return res; } 线段树（Segment Tree） /** * 线段树：用于高效处理区间查询和单点修改 * 时间复杂度：构建 O(n)，查询 O(log n)，更新 O(log n) */ class SegmentTree { private int[] tree; // 线段树数组 private int n; // 原数组大小 public SegmentTree(int[] nums) { n = nums.length; tree = new int[4 * n]; // 线段树最多需要 4n 空间 build(nums, 0, 0, n - 1); } // 构建线段树：递归构建 // node: 当前节点在 tree 中的索引 // start, end: 当前节点代表的区间 [start, end] private void build(int[] nums, int node, int start, int end) { if (start == end) { // 叶子节点：直接存储原数组的值 tree[node] = nums[start]; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; // 左子节点索引 int rightNode = 2 * node + 2; // 右子节点索引 // 递归构建左右子树 build(nums, leftNode, start, mid); build(nums, rightNode, mid + 1, end); // 当前节点的值 = 左子树 + 右子树（区间和） tree[node] = tree[leftNode] + tree[rightNode]; } // 区间查询：查询区间 [l, r] 的和 public int query(int l, int r) { return query(0, 0, n - 1, l, r); } private int query(int node, int start, int end, int l, int r) { // 情况1：当前区间与查询区间完全不相交 if (l \u0026gt; end || r \u0026lt; start) return 0; // 情况2：当前区间完全包含在查询区间内 if (l \u0026lt;= start \u0026amp;\u0026amp; end \u0026lt;= r) return tree[node]; // 情况3：部分相交，需要递归查询左右子树 int mid = start + (end - start) / 2; int leftSum = query(2 * node + 1, start, mid, l, r); int rightSum = query(2 * node + 2, mid + 1, end, l, r); return leftSum + rightSum; } // 单点更新：将 index 位置的值更新为 val public void update(int index, int val) { update(0, 0, n - 1, index, val); } private void update(int node, int start, int end, int index, int val) { if (start == end) { // 找到叶子节点，更新值 tree[node] = val; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; int rightNode = 2 * node + 2; // 判断 index 在左子树还是右子树 if (index \u0026lt;= mid) { update(leftNode, start, mid, index, val); } else { update(rightNode, mid + 1, end, index, val); } // 更新完子树后，更新当前节点 tree[node] = tree[leftNode] + tree[rightNode]; } } 2. 图算法 图的表示 // 方式1：邻接表（适合稀疏图） Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; graph = new HashMap\u0026lt;\u0026gt;(); // 或使用 ArrayList List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); // 方式2：邻接矩阵（适合密集图） int[][] graph = new int[n][n]; // graph[i][j] 表示 i 到 j 的边权 DFS - 图的深度优先遍历 // 递归实现 DFS void dfs(int node, Set\u0026lt;Integer\u0026gt; visited, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { visited.add(node); // 标记当前节点已访问 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { // 如果邻居未访问 dfs(neighbor, visited, graph); // 递归访问邻居 } } } // 使用示例 Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); dfs(0, visited, graph); // 从节点 0 开始 DFS BFS - 图的广度优先遍历 // 使用队列实现 BFS void bfs(int start, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(start); // 起始节点入队 visited.add(start); // 标记已访问 while (!queue.isEmpty()) { int node = queue.poll(); // 出队 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { queue.offer(neighbor); // 邻居入队 visited.add(neighbor); // 标记已访问 } } } } 拓扑排序（Kahn 算法） /** * 拓扑排序：将有向无环图(DAG)转换为线性序列 * 应用：课程安排、任务调度等 * 核心思想：不断移除入度为0的节点 */ List\u0026lt;Integer\u0026gt; topologicalSort(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] inDegree = new int[n]; // 记录每个节点的入度 for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } // 构建图并计算入度 for (int[] edge : edges) { graph.get(edge[0]).add(edge[1]); // edge[0] -\u0026gt; edge[1] inDegree[edge[1]]++; // edge[1] 的入度+1 } // 将所有入度为0的节点入队 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (inDegree[i] == 0) { queue.offer(i); } } List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); while (!queue.isEmpty()) { int node = queue.poll(); res.add(node); // 将节点加入结果 // 删除该节点的所有出边 for (int neighbor : graph.get(node)) { inDegree[neighbor]--; // 邻居的入度-1 if (inDegree[neighbor] == 0) { // 入度变为0，入队 queue.offer(neighbor); } } } // 如果所有节点都被访问，说明无环，返回结果；否则返回空 return res.size() == n ? res : new ArrayList\u0026lt;\u0026gt;(); } Dijkstra 最短路径算法 /** * Dijkstra算法：单源最短路径（不能有负权边） * 时间复杂度：O(E log V)，E是边数，V是顶点数 * 核心思想：贪心，每次选择距离最小的未访问节点 */ int[] dijkstra(int n, int[][] edges, int start) { // 构建邻接表: {neighbor, weight} List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // edge = [from, to, weight] graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); } // dist[i] 表示从 start 到 i 的最短距离 int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 优先队列: {distance, node}，按距离从小到大排序 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); pq.offer(new int[]{0, start}); while (!pq.isEmpty()) { int[] curr = pq.poll(); int d = curr[0], node = curr[1]; // 如果当前距离大于已知最短距离，跳过 if (d \u0026gt; dist[node]) continue; // 遍历所有邻居，尝试松弛操作 for (int[] neighbor : graph.get(node)) { int next = neighbor[0], weight = neighbor[1]; int newDist = d + weight; // 如果找到更短的路径，更新距离 if (newDist \u0026lt; dist[next]) { dist[next] = newDist; pq.offer(new int[]{newDist, next}); } } } return dist; } Bellman-Ford 算法（可处理负权边） /** * Bellman-Ford算法：单源最短路径，可处理负权边 * 时间复杂度：O(V * E) * 可以检测负环 */ int[] bellmanFord(int n, int[][] edges, int start) { int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 松弛操作：最多进行 n-1 次 // 原理：最短路径最多包含 n-1 条边 for (int i = 0; i \u0026lt; n - 1; i++) { for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; // 松弛操作：如果经过 u 到 v 更短，则更新 if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { dist[v] = dist[u] + w; } } } // 第 n 次松弛：如果还能更新，说明存在负环 for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { return null; // 存在负环 } } return dist; } Floyd-Warshall 全源最短路径 /** * Floyd-Warshall算法：计算所有点对之间的最短路径 * 时间复杂度：O(V³) * 核心思想：动态规划，逐步加入中间节点 */ int[][] floydWarshall(int n, int[][] edges) { int[][] dist = new int[n][n]; // 初始化距离矩阵 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(dist[i], Integer.MAX_VALUE / 2); // 除以2防止溢出 dist[i][i] = 0; // 自己到自己距离为0 } // 填入边的权重 for (int[] edge : edges) { dist[edge[0]][edge[1]] = edge[2]; } // 动态规划：k 是中间节点 // dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) for (int k = 0; k \u0026lt; n; k++) { // 枚举中间节点 for (int i = 0; i \u0026lt; n; i++) { // 枚举起点 for (int j = 0; j \u0026lt; n; j++) { // 枚举终点 // 如果经过 k 中转更短，则更新 dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]); } } } return dist; } Prim 最小生成树 /** * Prim算法：构建最小生成树 * 时间复杂度：O(E log V) * 核心思想：从一个节点开始，逐步扩展，每次选最小边 */ int prim(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // 无向图：添加双向边 graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); graph.get(edge[1]).add(new int[]{edge[0], edge[2]}); } boolean[] visited = new boolean[n]; // 优先队列：{node, weight}，按权重从小到大 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[1] - b[1]); pq.offer(new int[]{0, 0}); // 从节点0开始，权重0 int totalWeight = 0; // 最小生成树的总权重 int edgeCount = 0; // 已添加的边数 while (!pq.isEmpty() \u0026amp;\u0026amp; edgeCount \u0026lt; n) { int[] curr = pq.poll(); int node = curr[0], weight = curr[1]; if (visited[node]) continue; // 已访问，跳过 visited[node] = true; totalWeight += weight; // 加入最小生成树 edgeCount++; // 将邻居节点的边加入优先队列 for (int[] neighbor : graph.get(node)) { if (!visited[neighbor[0]]) { pq.offer(neighbor); } } } // 如果所有节点都连通，返回总权重；否则返回-1 return edgeCount == n ? totalWeight : -1; } Kruskal 最小生成树（并查集） /** * 并查集：用于判断连通性和合并集合 */ class UnionFind { int[] parent; // parent[i] 表示 i 的父节点 int[] rank; // rank[i] 表示以 i 为根的树的高度 public UnionFind(int n) { parent = new int[n]; rank = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; // 初始时每个节点的父节点是自己 } } // 查找：找到 x 所在集合的代表元素（路径压缩） public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); // 路径压缩：直接连到根节点 } return parent[x]; } // 合并：将 x 和 y 所在的集合合并（按秩合并） public boolean union(int x, int y) { int rootX = find(x), rootY = find(y); if (rootX == rootY) return false; // 已经在同一集合 // 按秩合并：将矮树挂到高树上 if (rank[rootX] \u0026lt; rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] \u0026gt; rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; // 高度相同，随便挂，高度+1 } return true; } } /** * Kruskal算法：构建最小生成树 * 时间复杂度：O(E log E) * 核心思想：按边权从小到大排序，用并查集避免成环 */ int kruskal(int n, int[][] edges) { // 按边权从小到大排序 Arrays.sort(edges, (a, b) -\u0026gt; a[2] - b[2]); UnionFind uf = new UnionFind(n); int totalWeight = 0; int edgeCount = 0; for (int[] edge : edges) { // 如果两个节点不在同一集合，添加这条边 if (uf.union(edge[0], edge[1])) { totalWeight += edge[2]; edgeCount++; if (edgeCount == n - 1) break; // 最小生成树有 n-1 条边 } } return edgeCount == n - 1 ? totalWeight : -1; } 3. 回溯算法 组合问题 /** * 组合问题：从 n 个数中选 k 个数的所有组合 * 例如：n=4, k=2 -\u0026gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), 1, n, k); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int start, int n, int k) { // 递归终止条件：已选择 k 个数 if (path.size() == k) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 注意：要复制一份 return; } // 从 start 开始枚举，避免重复 for (int i = start; i \u0026lt;= n; i++) { path.add(i); // 做选择 backtrack(res, path, i + 1, n, k); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } 全排列 /** * 全排列问题：给定数组，返回所有可能的排列 * 例如：[1,2,3] -\u0026gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, new boolean[nums.length]); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, boolean[] used) { // 递归终止条件：所有数字都已使用 if (path.size() == nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } // 枚举所有数字 for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) continue; // 已使用过，跳过 path.add(nums[i]); // 做选择 used[i] = true; // 标记已使用 backtrack(res, path, nums, used); // 递归 used[i] = false; // 撤销标记（回溯） path.remove(path.size() - 1); // 撤销选择（回溯） } } 子集问题 /** * 子集问题：返回数组的所有子集（幂集） * 例如：[1,2,3] -\u0026gt; [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, int start) { // 每个状态都是一个子集 res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 枚举后续元素 for (int i = start; i \u0026lt; nums.length; i++) { path.add(nums[i]); // 做选择 backtrack(res, path, nums, i + 1); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } N 皇后问题 /** * N皇后问题：在 n×n 的棋盘上放置 n 个皇后，使它们互不攻击 * 规则：任意两个皇后不能在同一行、同一列、同一对角线 */ List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); char[][] board = new char[n][n]; // 初始化棋盘：\u0026#39;.\u0026#39; 表示空位 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(board[i], \u0026#39;.\u0026#39;); } backtrack(res, board, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res, char[][] board, int row) { // 递归终止条件：所有行都放置完成 if (row == board.length) { res.add(construct(board)); // 将棋盘转换为字符串列表 return; } // 尝试在当前行的每一列放置皇后 for (int col = 0; col \u0026lt; board.length; col++) { if (!isValid(board, row, col)) continue; // 不合法，跳过 board[row][col] = \u0026#39;Q\u0026#39;; // 放置皇后 backtrack(res, board, row + 1); // 递归下一行 board[row][col] = \u0026#39;.\u0026#39;; // 撤销放置（回溯） } } // 检查在 (row, col) 位置放置皇后是否合法 boolean isValid(char[][] board, int row, int col) { int n = board.length; // 检查列：同一列不能有其他皇后 for (int i = 0; i \u0026lt; row; i++) { if (board[i][col] == \u0026#39;Q\u0026#39;) return false; } // 检查左上对角线 for (int i = row - 1, j = col - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } // 检查右上对角线 for (int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } return true; } // 将棋盘转换为字符串列表 List\u0026lt;String\u0026gt; construct(char[][] board) { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for (char[] row : board) { res.add(new String(row)); } return res; } 4. 动态规划 0-1 背包问题 /** * 0-1背包：每个物品只能选一次 * weights[i]: 第i个物品的重量 * values[i]: 第i个物品的价值 * capacity: 背包容量 * 返回：最大价值 */ int knapsack(int[] weights, int[] values, int capacity) { int n = weights.length; // dp[i][w] 表示前 i 个物品，背包容量为 w 时的最大价值 int[][] dp = new int[n + 1][capacity + 1]; for (int i = 1; i \u0026lt;= n; i++) { for (int w = 0; w \u0026lt;= capacity; w++) { // 如果当前物品的重量 \u0026lt;= 背包容量 if (weights[i - 1] \u0026lt;= w) { // 选择：max(不拿, 拿) dp[i][w] = Math.max( dp[i - 1][w], // 不拿第i个物品 dp[i - 1][w - weights[i - 1]] + values[i - 1] // 拿第i个物品 ); } else { // 放不下，只能不拿 dp[i][w] = dp[i - 1][w]; } } } return dp[n][capacity]; } /** * 0-1背包 - 空间优化版本 * 时间复杂度：O(n * capacity) * 空间复杂度：O(capacity) */ int knapsackOptimized(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：必须从后往前遍历，避免重复使用同一物品 for (int w = capacity; w \u0026gt;= weights[i]; w--) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 完全背包问题 /** * 完全背包：每个物品可以选无限次 * 与0-1背包的区别：内层循环从前往后遍历 */ int completeKnapsack(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：从前往后遍历，允许重复使用物品 for (int w = weights[i]; w \u0026lt;= capacity; w++) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 最长公共子序列（LCS） /** * 最长公共子序列：找两个字符串的最长公共子序列长度 * 子序列：不要求连续 * 例如：\u0026#34;abcde\u0026#34; 和 \u0026#34;ace\u0026#34; 的LCS是 \u0026#34;ace\u0026#34;，长度为3 */ int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); // dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的LCS长度 int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (text1.charAt(i - 1) == text2.charAt(j - 1)) { // 字符相同：LCS长度+1 dp[i][j] = dp[i - 1][j - 1] + 1; } else { // 字符不同：取两种情况的最大值 dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; } 最长递增子序列（LIS） /** * 最长递增子序列 - O(n²) 动态规划解法 * dp[i] 表示以 nums[i] 结尾的最长递增子序列长度 */ int lengthOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; Arrays.fill(dp, 1); // 初始每个元素自己构成长度为1的子序列 int maxLen = 1; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { // 如果 nums[i] 可以接在 nums[j] 后面 if (nums[i] \u0026gt; nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } maxLen = Math.max(maxLen, dp[i]); } return maxLen; } /** * 最长递增子序列 - O(n log n) 二分解法 * tails[i] 表示长度为 i+1 的递增子序列的最小尾部元素 */ int lengthOfLISBinary(int[] nums) { List\u0026lt;Integer\u0026gt; tails = new ArrayList\u0026lt;\u0026gt;(); for (int num : nums) { // 二分查找：找到第一个 \u0026gt;= num 的位置 int left = 0, right = tails.size(); while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (tails.get(mid) \u0026lt; num) { left = mid + 1; } else { right = mid; } } // 如果 num 比所有元素都大，追加到末尾 if (left == tails.size()) { tails.add(num); } else { // 否则替换找到的位置 tails.set(left, num); } } return tails.size(); } 编辑距离 /** * 编辑距离：将 word1 转换为 word2 的最少操作次数 * 操作：插入、删除、替换 * 例如：\u0026#34;horse\u0026#34; -\u0026gt; \u0026#34;ros\u0026#34; 需要3步（删除h、删除r、替换s） */ int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); // dp[i][j] 表示 word1[0..i-1] 转换为 word2[0..j-1] 的最少操作数 int[][] dp = new int[m + 1][n + 1]; // 边界条件：一个字符串为空 for (int i = 0; i \u0026lt;= m; i++) dp[i][0] = i; // word1 -\u0026gt; 空串：删除i个字符 for (int j = 0; j \u0026lt;= n; j++) dp[0][j] = j; // 空串 -\u0026gt; word2：插入j个字符 for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { // 字符相同：不需要操作 dp[i][j] = dp[i - 1][j - 1]; } else { // 字符不同：三种操作取最小 dp[i][j] = Math.min( Math.min( dp[i - 1][j], // 删除 word1[i-1] dp[i][j - 1] // 插入 word2[j-1] ), dp[i - 1][j - 1] // 替换 word1[i-1] 为 word2[j-1] ) + 1; } } } return dp[m][n]; } 股票买卖问题 只能买卖一次\n/** * 买卖股票的最佳时机 I：只能买卖一次 * 贪心思想：记录最低价格，计算每天卖出的最大利润 */ int maxProfit(int[] prices) { int minPrice = Integer.MAX_VALUE; // 记录目前为止的最低价格 int maxProfit = 0; // 记录最大利润 for (int price : prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; } 可以买卖多次\n/** * 买卖股票的最佳时机 II：可以买卖多次 * 贪心思想：只要今天价格比昨天高，就在昨天买今天卖 */ int maxProfitMultiple(int[] prices) { int profit = 0; for (int i = 1; i \u0026lt; prices.length; i++) { // 如果今天价格更高，累加差价 if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } 最多买卖 k 次\n/** * 买卖股票的最佳时机 III/IV：最多买卖 k 次 * dp[i][j] 表示第 i 次交易后，第 j 天的最大利润 */ int maxProfitK(int k, int[] prices) { if (prices.length == 0) return 0; int n = prices.length; // 如果 k \u0026gt;= n/2，相当于无限次交易 if (k \u0026gt;= n / 2) { int profit = 0; for (int i = 1; i \u0026lt; n; i++) { if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } int[][] dp = new int[k + 1][n]; for (int i = 1; i \u0026lt;= k; i++) { int maxDiff = -prices[0]; // 第 i-1 次交易后买入的最大收益 for (int j = 1; j \u0026lt; n; j++) { // 不操作 vs 卖出 dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff); // 更新买入的最大收益 maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]); } } return dp[k][n - 1]; } 打家劫舍 /** * 打家劫舍 I：线性排列的房屋 * 不能抢相邻的房屋 * dp[i] = max(dp[i-1], dp[i-2] + nums[i]) */ int rob(int[] nums) { if (nums.length == 0) return 0; if (nums.length == 1) return nums[0]; int prev2 = 0, prev1 = 0; // prev2: dp[i-2], prev1: dp[i-1] for (int num : nums) { int temp = prev1; // 不抢 vs 抢 prev1 = Math.max(prev1, prev2 + num); prev2 = temp; } return prev1; } /** * 打家劫舍 II：环形排列的房屋 * 第一个和最后一个房屋相邻 * 思路：分两种情况，取最大值 * 1. 抢第一个房屋，不抢最后一个 * 2. 不抢第一个房屋，抢最后一个 */ int robCircular(int[] nums) { if (nums.length == 1) return nums[0]; return Math.max( robRange(nums, 0, nums.length - 2), robRange(nums, 1, nums.length - 1) ); } int robRange(int[] nums, int start, int end) { int prev2 = 0, prev1 = 0; for (int i = start; i \u0026lt;= end; i++) { int temp = prev1; prev1 = Math.max(prev1, prev2 + nums[i]); prev2 = temp; } return prev1; } 分割等和子集 /** * 分割等和子集：判断是否能将数组分成两个和相等的子集 * 本质：0-1背包问题，目标是找到和为 sum/2 的子集 */ boolean canPartition(int[] nums) { int sum = 0; for (int num : nums) sum += num; if (sum % 2 != 0) return false; // 和为奇数，不可能分割 int target = sum / 2; // dp[j] 表示能否凑出和为 j boolean[] dp = new boolean[target + 1]; dp[0] = true; // 和为0总是可以（不选任何数） for (int num : nums) { // 从后往前遍历，避免重复使用 for (int j = target; j \u0026gt;= num; j--) { dp[j] = dp[j] || dp[j - num]; // 不选 num 或 选 num } } return dp[target]; } 零钱兑换 /** * 零钱兑换 I：最少硬币数 * dp[i] 表示凑出金额 i 所需的最少硬币数 */ int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); // 初始化为不可能的大值 dp[0] = 0; // 凑出0元需要0个硬币 for (int i = 1; i \u0026lt;= amount; i++) { for (int coin : coins) { if (i \u0026gt;= coin) { // 选择使用当前硬币 dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } } return dp[amount] \u0026gt; amount ? -1 : dp[amount]; } /** * 零钱兑换 II：组成方案数 * dp[i] 表示凑出金额 i 的方案数 */ int change(int amount, int[] coins) { int[] dp = new int[amount + 1]; dp[0] = 1; // 凑出0元有1种方案（不选） // 外层遍历硬币，内层遍历金额（避免重复计数） for (int coin : coins) { for (int i = coin; i \u0026lt;= amount; i++) { dp[i] += dp[i - coin]; } } return dp[amount]; } 5. 双指针 对撞指针 // 两数之和（有序数组） int[] twoSum(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[left] + nums[right]; if (sum == target) { return new int[]{left, right}; } else if (sum \u0026lt; target) { left++; } else { right--; } } return new int[]{-1, -1}; } // 三数之和 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length - 2; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { res.add(Arrays.asList(nums[i], nums[left], nums[right])); while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; left++; right--; } else if (sum \u0026lt; 0) { left++; } else { right--; } } } return res; } 快慢指针 // 链表中点 ListNode findMiddle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } // 环形链表 boolean hasCycle(ListNode head) { if (head == null) return false; ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) return true; } return false; } // 找环的入口 ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { slow = head; while (slow != fast) { slow = slow.next; fast = fast.next; } return slow; } } return null; } 6. 单调栈 // 下一个更大元素 int[] nextGreaterElement(int[] nums) { int n = nums.length; int[] res = new int[n]; Arrays.fill(res, -1); Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; nums[stack.peek()] \u0026lt; nums[i]) { int idx = stack.pop(); res[idx] = nums[i]; } stack.push(i); } return res; } // 每日温度 int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] res = new int[n]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[stack.peek()] \u0026lt; temperatures[i]) { int idx = stack.pop(); res[idx] = i - idx; } stack.push(i); } return res; } // 柱状图中最大的矩形 int largestRectangleArea(int[] heights) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(-1); int maxArea = 0; for (int i = 0; i \u0026lt; heights.length; i++) { while (stack.peek() != -1 \u0026amp;\u0026amp; heights[stack.peek()] \u0026gt;= heights[i]) { int h = heights[stack.pop()]; int w = i - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } stack.push(i); } while (stack.peek() != -1) { int h = heights[stack.pop()]; int w = heights.length - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } return maxArea; } 7. 前缀和 // 一维前缀和 class PrefixSum { private int[] preSum; public PrefixSum(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 0; i \u0026lt; nums.length; i++) { preSum[i + 1] = preSum[i] + nums[i]; } } // 查询区间 [left, right] 的和 public int query(int left, int right) { return preSum[right + 1] - preSum[left]; } } // 二维前缀和 class MatrixPrefixSum { private int[][] preSum; public MatrixPrefixSum(int[][] matrix) { int m = matrix.length, n = matrix[0].length; preSum = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } // 查询子矩阵 [row1, col1] 到 [row2, col2] 的和 public int query(int row1, int col1, int row2, int col2) { return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]; } } 📌 总结 这份文档涵盖了：\nJava 集合框架：List、Set、Map、Queue、Stack 的完整使用方法 树算法：DFS、BFS、线段树 图算法：遍历、最短路径、最小生成树 经典算法：回溯、动态规划、二分查找、滑动窗口、双指针、单调栈、前缀和 建议配合 LeetCode 刷题使用，遇到问题时可以快速查阅对应的模板代码。\n持续更新中\u0026hellip; 🚀\n","permalink":"http://localhost:1313/java-notes/algorithm-with-java/","summary":"详细介绍java集合的使用,以及在刷算法题中需要使用到的一些板子","title":"算法刷题必备：Java集合与算法模板"},{"content":"一、Hugo 常用指令 1.1 创建新站点 # 创建一个新的 Hugo 站点 hugo new site mysite # 进入站点目录 cd mysite 1.2 创建新文章 # 在 content/posts 目录下创建新文章 hugo new posts/my-first-post.md # 在 content 目录下创建文章 hugo new about.md # 创建在特定子目录 hugo new blog/2024/new-post.md 1.3 本地预览 # 启动本地开发服务器（默认 http://localhost:1313） hugo server # 启动并显示草稿文章 hugo server -D # 启动并显示草稿、未来日期和过期的文章 hugo server -DEF # 指定端口 hugo server --port 8080 # 实时重载并打开浏览器 hugo server -D --navigateToChanged 1.4 主题管理 # 添加主题（使用 Git submodule） git submodule add https://github.com/username/theme-name.git themes/theme-name # 更新主题 git submodule update --remote --merge # 删除主题 git submodule deinit -f themes/theme-name rm -rf .git/modules/themes/theme-name git rm -f themes/theme-name 1.5 其他常用指令 # 查看 Hugo 版本 hugo version # 查看帮助 hugo help # 查看配置信息 hugo config # 列出所有内容 hugo list all # 列出草稿 hugo list drafts 二、Markdown Front Matter 配置 2.1 完整配置示例 --- # 基本信息 title: \u0026#34;我的第一篇文章\u0026#34; date: 2025-12-06T15:04:05+08:00 lastmod: 2025-12-07T10:00:00+08:00 draft: false # 作者信息 author: \u0026#34;Minjie\u0026#34; authorLink: \u0026#34;https://github.com/Minjie2003\u0026#34; # 分类和标签 categories: [\u0026#34;技术\u0026#34;] tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;, \u0026#34;博客\u0026#34;] series: [\u0026#34;Hugo教程\u0026#34;] # 摘要和描述 summary: \u0026#34;这是一篇关于 Hugo 和 Markdown 的完整指南\u0026#34; description: \u0026#34;详细介绍 Hugo 的使用方法和 Markdown 配置\u0026#34; # 特色图片 image: \u0026#34;/images/featured.jpg\u0026#34; cover: image: \u0026#34;/images/cover.jpg\u0026#34; alt: \u0026#34;封面图片描述\u0026#34; caption: \u0026#34;图片说明文字\u0026#34; # SEO 相关 keywords: [\u0026#34;Hugo\u0026#34;, \u0026#34;静态博客\u0026#34;, \u0026#34;Markdown\u0026#34;] slug: \u0026#34;hugo-markdown-guide\u0026#34; url: \u0026#34;/posts/hugo-guide/\u0026#34; # 显示控制 toc: true # 显示目录 comments: true # 允许评论 showToc: true # 显示目录 TocOpen: false # 默认展开目录 hidemeta: false # 隐藏元信息 disableShare: false # 禁用分享按钮 hideSummary: false # 隐藏摘要 ShowReadingTime: true # 显示阅读时间 ShowBreadCrumbs: true # 显示面包屑导航 ShowPostNavLinks: true # 显示文章导航链接 # 权重（用于排序） weight: 1 # 外部链接 externalLink: \u0026#34;https://example.com\u0026#34; # 是否在首页显示 showhome: true --- 2.2 常用字段说明 字段 说明 示例 title 文章标题 \u0026quot;我的文章\u0026quot; date 发布日期 2025-12-06 或 2025-12-06T15:04:05+08:00 draft 是否为草稿 true / false tags 标签（数组） [\u0026quot;Hugo\u0026quot;, \u0026quot;博客\u0026quot;] categories 分类（数组） [\u0026quot;技术\u0026quot;, \u0026quot;教程\u0026quot;] summary 文章摘要 \u0026quot;这是摘要\u0026quot; description SEO 描述 \u0026quot;页面描述\u0026quot; slug URL 友好名称 \u0026quot;my-post\u0026quot; url 自定义完整 URL \u0026quot;/posts/my-post/\u0026quot; weight 排序权重 1 (数字越小越靠前) toc 是否显示目录 true / false 三、Hugo Shortcodes（短代码） 3.1 内置 Shortcodes # 显示图片 {{\u0026lt; figure src=\u0026#34;/images/photo.jpg\u0026#34; title=\u0026#34;图片标题\u0026#34; \u0026gt;}} # 高亮文本 {{\u0026lt; highlight python \u0026gt;}} def hello(): print(\u0026#34;Hello!\u0026#34;) {{\u0026lt; /highlight \u0026gt;}} # YouTube 视频 {{\u0026lt; youtube VIDEO_ID \u0026gt;}} # X (Twitter) 推文（新版） {{\u0026lt; x user=\u0026#34;USERNAME\u0026#34; id=\u0026#34;TWEET_ID\u0026#34; \u0026gt;}} # GitHub Gist（已废弃，建议直接嵌入代码） # 可以使用 highlight 或直接用代码块替代 # 参数传递（需要在 Front Matter 中定义参数） {{\u0026lt; param \u0026#34;description\u0026#34; \u0026gt;}} 3.2 自定义 Shortcode 示例 在 layouts/shortcodes/note.html 创建：\n\u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; 使用时：\n{{\u0026lt; note \u0026gt;}} 这是一个提示框 {{\u0026lt; /note \u0026gt;}} 四、Markdown 基本语法 4.1 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 4.2 文本样式 **粗体文字** *斜体文字* ***粗斜体*** ~~删除线~~ `行内代码` 4.3 列表 # 无序列表 - 项目 1 - 项目 2 - 子项目 2.1 - 子项目 2.2 # 有序列表 1. 第一项 2. 第二项 1. 子项 2.1 2. 子项 2.2 4.4 链接和图片 # 链接 [链接文字](https://example.com) [带标题的链接](https://example.com \u0026#34;鼠标悬停显示\u0026#34;) # 图片 ![图片描述](/images/photo.jpg) ![图片](https://example.com/image.jpg \u0026#34;图片标题\u0026#34;) 4.5 引用 \u0026gt; 这是一段引用文字 \u0026gt; 可以多行 \u0026gt;\u0026gt; 嵌套引用 4.6 代码块 ```python def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) ``` ```javascript console.log(\u0026#34;Hello, World!\u0026#34;); ``` 4.7 表格 | 列1 | 列2 | 列3 | |-----|-----|-----| | 数据1 | 数据2 | 数据3 | | 数据4 | 数据5 | 数据6 | # 对齐方式 | 左对齐 | 居中 | 右对齐 | |:-------|:----:|-------:| | 内容 | 内容 | 内容 | 4.8 分隔线 --- *** ___ 4.9 任务列表 - [x] 已完成的任务 - [ ] 未完成的任务 - [ ] 另一个任务 五、实用技巧 5.1 文章模板 在 archetypes/default.md 创建默认模板：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true tags: [] categories: [] summary: \u0026#34;\u0026#34; --- ## 简介 内容开始... 5.2 多语言配置 在 Front Matter 中：\n--- title: \u0026#34;English Title\u0026#34; title.zh: \u0026#34;中文标题\u0026#34; --- 5.3 自定义 URL 结构 在 hugo.toml 中：\n[permalinks] posts = \u0026#34;/:year/:month/:slug/\u0026#34; 5.4 草稿快速发布 # 将草稿改为发布状态 sed -i \u0026#39;s/draft: true/draft: false/\u0026#39; content/posts/my-post.md ","permalink":"http://localhost:1313/doc-intro/hugo-readme/","summary":"详细介绍 Hugo 常用指令、Markdown Front Matter 配置、基本语法和实用技巧的完整指南","title":"Hugo 常用指令与 Markdown 配置指南"},{"content":"👋 嗨，我是 Minjie 很高兴你能来到这里！这是我在互联网上的一个小角落，用来记录代码、想法和生活的点滴。\n🧑‍💻 关于我 我是一名在读研究生，研究方向包括区块链，web3.0，数据库管理等。当然，目前更加专注于 Java 后端开发。相比起\u0026quot;全栈工程师\u0026quot;这样的标签，我更喜欢把自己定义为一个对计算机技术充满好奇心的探索者。\n📖 这个博客写什么 这里主要记录我在技术道路上的成长轨迹，你可能会看到：\n技术笔记 - Java 后端开发的实践经验、框架使用心得、踩过的坑和解决方案\n项目复盘 - 从需求分析到上线部署，记录项目中的思考和收获\n学习记录 - 新技术的探索、算法题的思路、计算机基础知识的整理\n随笔杂谈 - 偶尔也会写写读书笔记、游戏感想，或者对技术趋势的一些思考\n我希望这里不仅是我个人的知识库,也能给同样在技术路上摸索的你带来一些启发或共鸣。\n🎯 技术栈 \u0026amp; 兴趣方向 后端开发：Java、Spring Boot、MyBatis、MySQL、Redis - 这是我的主战场\n折腾爱好：除了后端，我还喜欢写点爬虫玩玩，做些自动化小工具来解决日常遇到的重复性工作。总觉得能用代码解决的事情，就不该浪费时间手动操作。有时候为了实现一个自动化脚本，花的时间可能比手动做还多，但那种\u0026quot;一劳永逸\u0026quot;的快感真的很上头。\n探索中：对各种能提高效率的技术和工具都充满兴趣，正在不断拓展技术边界\u0026hellip;\n🎮 代码之外 游戏时光：Steam 上收藏了不少游戏，也会玩玩王者、原神这些。\n音乐陪伴：写代码的时候总要听点什么。古典音乐能让思路更清晰，ACG 音乐带来满满的回忆，偶尔也会跟着流行音乐哼哼唱唱。喜欢洗澡的时候k歌······当然，也是个半吊子吉他选手\n运动爱好：除了敲键盘，也喜欢出去动一动。篮球、羽毛球、乒乓球都有涉猎，虽然都不算精通，但也能过上两招。过去打篮球多一点，现在更想尝试羽毛球。\n历史爱好者：对历史有种莫名的着迷，喜欢看历史书籍、纪录片。主要包括近现代欧洲历史，唐史，春秋战国。\n💬 来聊聊？ 如果你也对后端开发感兴趣，或者想交流技术、分享项目经验，甚至只是想推荐个好玩的游戏或好听的歌，都欢迎联系我：\n📧 邮箱：zhongnagisa01@gmail.com 🐙 GitHub：Minjie2003 \u0026ldquo;流水不争先，争的是滔滔不绝\u0026rdquo;\n感谢你的访问，希望我们能在这里有更多交流！✨\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于我"},{"content":"作业一 习题 1：幂等矩阵的性质 题目：矩阵 $A^2 = A, B^2 = B$，并且 $B$ 的列是 $A$ 的列的线性组合。证明 $AB = B$。\n证明：\n设 $B$ 的列是 $A$ 的列的线性组合，则存在矩阵 $C$ 使得 $B = AC$。\n现在计算 $AB$，由于 $A^2 = A$：\n$$AB = A(AC) = A^2C = AC = B$$因此 $AB = B$。 $\\square$\n习题 2：特征多项式的相等性 题目：设 $A, B$ 为任意两个 $n$ 阶方阵，证明：$AB$ 和 $BA$ 具有相同的特征多项式，即 $|\\lambda E - AB| = |\\lambda E - BA|$。\n证明：\n设\n$$\\begin{pmatrix} E \u0026 0 \\\\ A \u0026 E \\end{pmatrix} \\begin{pmatrix} \\lambda E \u0026 B \\\\ 0 \u0026 \\lambda E - AB \\end{pmatrix} \\begin{pmatrix} E \u0026 0 \\\\ -A \u0026 E \\end{pmatrix} = \\begin{pmatrix} \\lambda E - BA \u0026 B \\\\ 0 \u0026 \\lambda E \\end{pmatrix}$$取行列式，利用行列式的乘法性质，有\n$$\\left|\\begin{array}{cc} \\lambda E \u0026 B \\\\ 0 \u0026 \\lambda E - AB \\end{array}\\right| = \\left|\\begin{array}{cc} \\lambda E - BA \u0026 B \\\\ 0 \u0026 \\lambda E \\end{array}\\right|$$由于\n$$\\left|\\begin{array}{cc} \\lambda E \u0026 B \\\\ 0 \u0026 \\lambda E - AB \\end{array}\\right| = \\lambda^n |\\lambda E - AB|, \\qquad \\left|\\begin{array}{cc} \\lambda E - BA \u0026 B \\\\ 0 \u0026 \\lambda E \\end{array}\\right| = \\lambda^n |\\lambda E - BA|$$因此有\n$$\\lambda^n |\\lambda E - AB| = \\lambda^n |\\lambda E - BA|$$当 $\\lambda \\neq 0$ 时，两边可同时除以 $\\lambda^n$，得到\n$$|\\lambda E - AB| = |\\lambda E - BA|$$两边都是关于 $\\lambda$ 的多项式，故此恒等式对任意 $\\lambda$（包括 $\\lambda=0$）均成立。 $\\square$\n习题 3：矩阵范数的计算 题目：求下面矩阵的 1-范数、2-范数和无穷范数：\n$$A_1 = \\begin{pmatrix} 1 \u0026 2 \\\\ 1 \u0026 0 \\end{pmatrix}, \\quad A_2 = \\begin{pmatrix} -1 \u0026 0 \\\\ 1 \u0026 2 \\end{pmatrix}$$解：\n对于矩阵 $A_1$ 1-范数（列和范数）：\n$$\\|A_1\\|_1 = \\max\\{|1|+|1|, |2|+|0|\\} = \\max\\{2, 2\\} = 2$$无穷范数（行和范数）：\n$$\\|A_1\\|_\\infty = \\max\\{|1|+|2|, |1|+|0|\\} = \\max\\{3, 1\\} = 3$$2-范数（谱范数，即 $\\sqrt{\\rho(A_1^T A_1)}$）：\n首先计算 $A_1^T A_1$：\n$$A_1^T A_1 = \\begin{pmatrix} 1 \u0026 1 \\\\ 2 \u0026 0 \\end{pmatrix} \\begin{pmatrix} 1 \u0026 2 \\\\ 1 \u0026 0 \\end{pmatrix} = \\begin{pmatrix} 2 \u0026 2 \\\\ 2 \u0026 4 \\end{pmatrix}$$求特征值：\n$$\\det(\\lambda E - A_1^T A_1) = \\det\\begin{pmatrix} \\lambda-2 \u0026 -2 \\\\ -2 \u0026 \\lambda-4 \\end{pmatrix} = (\\lambda-2)(\\lambda-4) - 4 = \\lambda^2 - 6\\lambda + 4 = 0$$解得：$\\lambda = \\frac{6 \\pm \\sqrt{36-16}}{2} = \\frac{6 \\pm \\sqrt{20}}{2} = 3 \\pm \\sqrt{5}$\n最大特征值为 $\\lambda_{\\max} = 3 + \\sqrt{5}$\n因此：\n$$\\|A_1\\|_2 = \\sqrt{3 + \\sqrt{5}}$$对于矩阵 $A_2$ 1-范数：\n$$\\|A_2\\|_1 = \\max\\{|-1|+|1|, |0|+|2|\\} = \\max\\{2, 2\\} = 2$$无穷范数：\n$$\\|A_2\\|_\\infty = \\max\\{|-1|+|0|, |1|+|2|\\} = \\max\\{1, 3\\} = 3$$2-范数：\n计算 $A_2^T A_2$：\n$$A_2^T A_2 = \\begin{pmatrix} -1 \u0026 1 \\\\ 0 \u0026 2 \\end{pmatrix} \\begin{pmatrix} -1 \u0026 0 \\\\ 1 \u0026 2 \\end{pmatrix} = \\begin{pmatrix} 2 \u0026 2 \\\\ 2 \u0026 4 \\end{pmatrix}$$这与 $A_1^T A_1$ 相同，因此：\n$$\\|A_2\\|_2 = \\sqrt{3 + \\sqrt{5}}$$ 习题 4：诱导范数的证明 题目：矩阵的范数主要包括三种主要类型：诱导范数，元素形式范数和 Schatten 范数。诱导范数又称矩阵空间上的算子范数 (operator norm)，常用的诱导范数为 $p$ 范数，定义如下\n$$\\|A\\|_p = \\sup_{\\|x\\|_p \\neq 0} \\frac{\\|Ax\\|_p}{\\|x\\|_p} = \\sup_{\\|x\\|_p = 1} \\|Ax\\|_p$$(1) 设 $A = (a_{ij}) \\in \\mathbb{C}^{m \\times n}$，证明 1 范数为列和范数，无穷范数为行和范数\n$$\\|A\\|_{\\infty} = \\max_{1 \\leq i \\leq m} \\sum_{j=1}^{n} |a_{ij}|, \\quad \\|A\\|_1 = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^{m} |a_{ij}|$$(2) 元素形式范数即矩阵按列排成向量，然后采用向量范数的定义得到的矩阵范数，一般称 $l_p$ 范数。\n$$l_p: \\|A\\|_p = \\sqrt[p]{\\sum_{i,j} |a_{ij}|^p}$$试比较 $l_1$ 范数\n$$l_1: \\|A\\|_1 = \\sum_{i,j} |a_{ij}|^1$$与诱导范数的关系。\n(1) 证明 1-范数和无穷范数 设 $A = (a_{ij}) \\in \\mathbb{C}^{m \\times n}$，证明 1 范数为列和范数，无穷范数为行和范数\n$$\\|A\\|_{\\infty} = \\max_{1 \\leq i \\leq m} \\sum_{j=1}^{n} |a_{ij}|, \\quad \\|A\\|_1 = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^{m} |a_{ij}|$$证明：\n(i) 证明 1-范数为列和范数\n对于任意 $x \\in \\mathbb{C}^n$ 且 $\\|x\\|_1 = 1$，利用三角不等式：\n$$\\|Ax\\|_1 = \\sum_{i=1}^m \\left|\\sum_{j=1}^n a_{ij}x_j\\right| \\leq \\sum_{i=1}^m \\sum_{j=1}^n |a_{ij}||x_j| = \\sum_{j=1}^n |x_j| \\sum_{i=1}^m |a_{ij}| \\leq \\max_{1 \\leq j \\leq n} \\sum_{i=1}^m |a_{ij}|$$设第 $k$ 列使得列和最大，取 $x = e_k$，则\n$$\\|Ax\\|_1 = \\sum_{i=1}^m |a_{ik}| = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^m |a_{ij}|$$故上界可达到。因此 $\\|A\\|_1 = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^m |a_{ij}|$。\n(ii) 证明无穷范数为行和范数\n对于任意 $x \\in \\mathbb{C}^n$ 且 $\\|x\\|_\\infty = 1$，有：\n$$\\|Ax\\|_\\infty = \\max_{1 \\leq i \\leq m} \\left|\\sum_{j=1}^n a_{ij}x_j\\right| \\leq \\max_{1 \\leq i \\leq m} \\sum_{j=1}^n |a_{ij}||x_j| \\leq \\max_{1 \\leq i \\leq m} \\sum_{j=1}^n |a_{ij}|$$设第 $k$ 行使得行和最大，取 $x_j = \\text{sgn}(\\overline{a_{kj}})$，则\n$$\\|Ax\\|_\\infty \\geq \\sum_{j=1}^n |a_{kj}| = \\max_{1 \\leq i \\leq m} \\sum_{j=1}^n |a_{ij}|$$故 $\\|A\\|_\\infty = \\max_{1 \\leq i \\leq m} \\sum_{j=1}^n |a_{ij}|$。 $\\square$\n(2) 元素形式范数与诱导范数的关系 以 $l_1$ 范数\n$$l_1: \\|A\\|_1 = \\sum_{i,j} |a_{ij}|^1$$与诱导范数的关系为例，证明：\n$$\\|X\\|_1 \\leq \\|X\\|_{1(l_1)} \\leq n\\|X\\|_1$$$$\\|X\\|_\\infty \\leq \\|X\\|_{1(l_1)} \\leq m\\|X\\|_\\infty$$证明：\n设 $X = (x_{ij}) \\in \\mathbb{C}^{m \\times n}$。记 $\\|X\\|_1 = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^m |x_{ij}|$，$\\|X\\|_\\infty = \\max_{1 \\leq i \\leq m} \\sum_{j=1}^n |x_{ij}|$，$\\|X\\|_{1(l_1)} = \\sum_{i,j} |x_{ij}|$。\n第一组不等式：因为 $\\|X\\|_1$ 是所有列和的最大值，而 $\\|X\\|_{1(l_1)}$ 是所有列和的总和，故\n$$\\|X\\|_1 \\leq \\sum_{j=1}^n \\sum_{i=1}^m |x_{ij}| = \\|X\\|_{1(l_1)} \\leq \\sum_{j=1}^n \\|X\\|_1 = n\\|X\\|_1$$第二组不等式：因为 $\\|X\\|_\\infty$ 是所有行和的最大值，而 $\\|X\\|_{1(l_1)}$ 是所有行和的总和，故\n$$\\|X\\|_\\infty \\leq \\sum_{i=1}^m \\sum_{j=1}^n |x_{ij}| = \\|X\\|_{1(l_1)} \\leq \\sum_{i=1}^m \\|X\\|_\\infty = m\\|X\\|_\\infty$$$\\square$\n习题 5：Frobenius 范数的不等式 题目：证明：$\\|AB\\|_F \\leq \\|A\\|_F \\|B\\|_F$ 和 $\\|AB\\|_F \\leq \\|A\\|_F \\|B\\|_2$。\n证明：\nFrobenius 范数定义为 $\\|A\\|_F = \\sqrt{\\sum_{i,j} |a_{ij}|^2} = \\sqrt{\\text{tr}(A^*A)}$。\n(1) 证明第一个不等式：$\\|AB\\|_F \\leq \\|A\\|_F \\|B\\|_F$\n将 $B$ 按列分块：$B = [b_1, b_2, \\ldots, b_p]$，其中 $b_j$ 是 $B$ 的第 $j$ 列。则：\n$$AB = [Ab_1, Ab_2, \\ldots, Ab_p]$$由 Frobenius 范数的性质：\n$$\\|AB\\|_F^2 = \\sum_{j=1}^p \\|Ab_j\\|_2^2$$对每一列 $Ab_j$，设 $A$ 的第 $i$ 行为 $a_i^*$，则 $(Ab_j)_i = a_i^* b_j$。由 Cauchy-Schwarz 不等式：\n$$|(Ab_j)_i|^2 = |a_i^* b_j|^2 \\leq \\|a_i^*\\|_2^2 \\|b_j\\|_2^2$$因此：\n$$\\|Ab_j\\|_2^2 = \\sum_{i=1}^m |(Ab_j)_i|^2 \\leq \\sum_{i=1}^m \\|a_i^*\\|_2^2 \\|b_j\\|_2^2 = \\|A\\|_F^2 \\|b_j\\|_2^2$$代入得：\n$$\\|AB\\|_F^2 = \\sum_{j=1}^p \\|Ab_j\\|_2^2 \\leq \\sum_{j=1}^p \\|A\\|_F^2 \\|b_j\\|_2^2 = \\|A\\|_F^2 \\sum_{j=1}^p \\|b_j\\|_2^2 = \\|A\\|_F^2 \\|B\\|_F^2$$因此 $\\|AB\\|_F \\leq \\|A\\|_F \\|B\\|_F$。\n(2) 证明第二个不等式：$\\|AB\\|_F \\leq \\|A\\|_F \\|B\\|_2$\n将 $A$ 按行分块，设 $A$ 的第 $i$ 行为 $a_i^*$（$1 \\leq i \\leq m$），则 $AB$ 的第 $i$ 行为 $a_i^* B$。因此：\n$$\\|AB\\|_F^2 = \\sum_{i=1}^m \\|a_i^* B\\|_2^2$$由算子范数的性质 $\\|a_i^* B\\|_2 \\leq \\|a_i^*\\|_2 \\|B\\|_2$，得：\n$$\\|AB\\|_F^2 \\leq \\sum_{i=1}^m \\|a_i^*\\|_2^2 \\|B\\|_2^2 = \\|B\\|_2^2 \\sum_{i=1}^m \\|a_i^*\\|_2^2 = \\|B\\|_2^2 \\|A\\|_F^2$$因此 $\\|AB\\|_F \\leq \\|A\\|_F \\|B\\|_2$。 $\\square$\n习题 6：距离函数的判断 题目：有些平时称之为\u0026quot;距离\u0026quot;的函数其实并不是数学意义上的距离，请判断以下两种所谓的\u0026quot;距离\u0026quot;是否是数学意义上的距离并说明理由。\n(1) 假设向量 $a, b \\in \\mathbb{R}^n$，定义余弦距离为 $d(a, b) = 1 - \\cos\\langle a, b\\rangle$，其中 $\\langle a, b\\rangle$ 为向量 $a, b$ 间的夹角。\n(2) 假设 $S_1, S_2$ 分别表示两个字符串，定义 $S_1, S_2$ 的编辑距离 $d(S_1, S_2)$ 为由 $S_1$ 转成 $S_2$ 所需的最少编辑操作次数。其中一次编辑操作可以是：将 $S_1$ 中的一个字符替换为另一个字符；在 $S_1$ 中插入一个字符；在 $S_1$ 中删除一个字符。例如：kitten 和 sitting 的编辑距离是 3。\n(1) 余弦距离 假设向量 $a, b \\in \\mathbb{R}^n$，定义余弦距离为 $d(a, b) = 1 - \\cos\\langle a, b\\rangle$，其中 $\\langle a, b\\rangle$ 为向量 $a, b$ 间的夹角。\n解：\n余弦距离不是数学意义上的距离（度量）。\n度量需要满足三个条件：非负性与同一性、对称性、三角不等式。余弦距离违反了同一性。\n反例：取 $a = (1,0)$，$b = (2,0)$，则 $a, b$ 的夹角为 $0°$，因此：\n$$d(a,b) = 1 - \\cos 0° = 1 - 1 = 0$$但显然 $a \\neq b$，所以不满足\u0026quot;$d(a,b) = 0 \\Leftrightarrow a = b$\u0026ldquo;这一条件。\n因此余弦距离不是数学意义上的距离。\n(2) 编辑距离 假设 $S_1, S_2$ 分别表示两个字符串，定义 $S_1, S_2$ 的编辑距离 $d(S_1, S_2)$ 为由 $S_1$ 转成 $S_2$ 所需的最少编辑操作次数。其中一次编辑操作可以是：将 $S_1$ 中的一个字符替换为另一个字符；在 $S_1$ 中插入一个字符；在 $S_1$ 中删除一个字符。例如：kitten 和 sitting 的编辑距离是 3。\n解：\n编辑距离（Levenshtein距离）是数学意义上的距离（度量）。\n验证三个条件：\n(i) 非负性与同一性\n编辑次数显然非负，且只有两个字符串完全相同时，所需的编辑次数最少为 0，即满足非负性：\n$$d(S_1, S_2) \\geq 0, \\quad \\text{且} \\quad d(S_1, S_2) = 0 \\Leftrightarrow S_1 = S_2$$(ii) 对称性\n$d(S_1, S_2) = d(S_2, S_1)$\n插入和删除字符互为逆操作、将某个字符 $a$ 替换为字符 $b$ 的逆操作为将字符 $b$ 替换为字符 $a$，不难看出每种编辑操作均可逆，即满足对称性。\n(iii) 三角不等式\n$d(S_1, S_2) \\leq d(S_1, S_3) + d(S_3, S_2)$\n将 $S_1$ 编辑为 $S_2$ 的过程拆解成两部分：将 $S_1$ 编辑为 $S_3$ 以及将 $S_3$ 编辑为 $S_2$，考虑到其中这两部分可能存在冗余操作。所以直接从 $S_1$ 编辑为 $S_2$ 所需的最优编辑次数只会更少，即满足三角不等式。\n综上 (i), (ii), (iii) 所述，编辑距离是数学意义上的距离。\n习题 7：正定矩阵与向量范数 题目：证明：在 $\\mathbb{R}^n$ 上，当且仅当 $A$ 是正定矩阵时，函数 $f(\\boldsymbol{x}) = (\\boldsymbol{x}^{\\mathrm{T}} A\\boldsymbol{x})^{\\frac{1}{2}}$ 是一个向量范数。\n证明：\n向量范数需要满足三个条件：\n正定性：$f(x) \\geq 0$，且 $f(x) = 0 \\Leftrightarrow x = 0$ 齐次性：$f(\\alpha x) = |\\alpha| f(x)$，$\\forall \\alpha \\in \\mathbb{R}$ 三角不等式：$f(x+y) \\leq f(x) + f(y)$ (1) 必要性\n假设 $f(x)$ 是范数，证明 $A$ 必须是正定矩阵。\n由范数的正定性，$f(x) = 0 \\Leftrightarrow x = 0$，即：\n$$x^T A x = 0 \\Leftrightarrow x = 0$$这表明对所有 $x \\neq 0$，有 $x^T A x \u003e 0$。又因为 $f(x) = \\sqrt{x^T A x}$ 要有意义，需要 $x^T A x \\geq 0$ 对所有 $x$ 成立。综上，$A$ 是正定矩阵。\n(2) 充分性\n假设 $A$ 是正定矩阵，证明 $f(x)$ 满足范数的三个性质。\n由于 $A$ 正定，故 $A$ 是对称矩阵，且对所有 $x \\in \\mathbb{R}^n$，有 $x^T A x \\geq 0$，当且仅当 $x = 0$ 时 $f(x) = 0$。\n① 正定性\n由 $A$ 正定知，对所有 $x \\neq 0$，有 $x^T A x \u003e 0$，因此：\n$$f(x) = \\sqrt{x^T A x} \u003e 0$$且显然 $f(0) = 0$，满足正定性。\n② 齐次性\n将 $\\alpha x$ 代入可得：\n$$f(\\alpha x) = \\sqrt{(\\alpha x)^T A (\\alpha x)} = \\sqrt{\\alpha^2 x^T A x} = |\\alpha| \\sqrt{x^T A x} = |\\alpha| f(x)$$故满足齐次性。\n③ 三角不等式\n根据 $A$ 的对称性可得：\n$$f(x+y) = \\sqrt{(x+y)^T A(x+y)} = \\sqrt{x^T Ax + 2x^T Ay + y^T Ay}$$由 Cauchy-Schwarz 不等式：\n$$|x^T Ay| \\leq \\sqrt{(x^T Ax)(y^T Ay)}$$因此：\n$$f(x+y) = \\sqrt{x^T Ax + 2x^T Ay + y^T Ay} \\leq \\sqrt{x^T Ax + 2\\sqrt{(x^T Ax)(y^T Ay)} + y^T Ay}$$$$= \\sqrt{\\left(\\sqrt{x^T Ax} + \\sqrt{y^T Ay}\\right)^2} = \\sqrt{x^T Ax} + \\sqrt{y^T Ay} = f(x) + f(y)$$故满足三角不等式。\n综上所述，当且仅当 $A$ 是正定矩阵时，$f(x) = \\sqrt{x^T A x}$ 是 $\\mathbb{R}^n$ 上的向量范数。 $\\square$\n习题 8：矩阵最大范数 题目：证明：对任意 $A \\in \\mathbb{R}^{m \\times n}$，由\n$$\\|A\\|_{m\\infty} := \\max_{1 \\leq i \\leq m, 1 \\leq j \\leq n} |a_{ij}|$$定义的范数是 $\\mathbb{R}^{m \\times n}$ 上的（广义）矩阵范数。\n证明：\n广义矩阵范数需要满足以下三个性质：\n(1) 正定性\n显然 $\\|A\\|_{m\\infty} = \\max_{1 \\leq i \\leq m, 1 \\leq j \\leq n} |a_{ij}| \\geq 0$。\n且 $\\|A\\|_{m\\infty} = 0 \\Leftrightarrow |a_{ij}| = 0$ 对所有 $i, j$ 成立 $\\Leftrightarrow A = O$。\n(2) 齐次性\n对任意 $\\alpha \\in \\mathbb{R}$：\n$$\\|\\alpha A\\|_{m\\infty} = \\max_{1 \\leq i \\leq m, 1 \\leq j \\leq n} |\\alpha a_{ij}| = \\max_{1 \\leq i \\leq m, 1 \\leq j \\leq n} |\\alpha| |a_{ij}| = |\\alpha| \\max_{1 \\leq i \\leq m, 1 \\leq j \\leq n} |a_{ij}| = |\\alpha| \\|A\\|_{m\\infty}$$(3) 三角不等式\n对任意 $A, B \\in \\mathbb{R}^{m \\times n}$，对于任意 $1 \\leq i \\leq m, 1 \\leq j \\leq n$，由三角不等式有：\n$$|a_{ij} + b_{ij}| \\leq |a_{ij}| + |b_{ij}| \\leq \\|A\\|_{m\\infty} + \\|B\\|_{m\\infty}$$其中第二个不等式是因为 $|a_{ij}| \\leq \\|A\\|_{m\\infty}$ 且 $|b_{ij}| \\leq \\|B\\|_{m\\infty}$。\n由于上述不等式对所有 $i, j$ 成立，两边取最大值得：\n$$\\|A + B\\|_{m\\infty} = \\max_{1 \\leq i \\leq m, 1 \\leq j \\leq n} |a_{ij} + b_{ij}| \\leq \\|A\\|_{m\\infty} + \\|B\\|_{m\\infty}$$因此，这个范数满足广义矩阵范数的所有性质。 $\\square$\n作业二 习题 1：向量的正交投影 题目：求向量 $(1,1,1)^T$ 在一维子空间 $\\text{span}([1,-1,1]^T)$ 上的正交投影。\n解：\n设 $v = (1,1,1)^T$，$u = [1,-1,1]^T$。\n向量 $v$ 在 $u$ 上的正交投影为：\n$$\\text{proj}_u(v) = \\frac{\\langle v, u \\rangle}{\\langle u, u \\rangle} u$$计算内积：\n$$\\langle v, u \\rangle = 1 \\cdot 1 + 1 \\cdot (-1) + 1 \\cdot 1 = 1$$$$\\langle u, u \\rangle = 1^2 + (-1)^2 + 1^2 = 3$$因此正交投影为：\n$$\\text{proj}_u(v) = \\frac{1}{3} \\begin{pmatrix} 1 \\\\ -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1/3 \\\\ -1/3 \\\\ 1/3 \\end{pmatrix}$$ 习题 2：向量在仿射子空间上的正交投影 题目：求向量 $(1,1,1)^T$ 在仿射子空间 $\\text{span}\\{[1,-1,1]^T, (1,1,0)^T\\} + (1,2,1)^T$ 上的正交投影。\n解：\n首先将子空间改写为标准形式。注意到题目表述的子空间为仿射子空间（平移后的子空间）。\n设 $v = (1,1,1)^T$，$u_1 = [1,-1,1]^T$，$u_2 = (1,1,0)^T$，$a = (1,2,1)^T$。\n首先求 $v - a = (0,-1,0)^T$ 在 $\\text{span}\\{u_1, u_2\\}$ 上的正交投影。\n使用 Gram-Schmidt 正交化 $u_1, u_2$：\n$w_1 = u_1 = [1,-1,1]^T$\n$w_2 = u_2 - \\frac{\\langle u_2, w_1 \\rangle}{\\langle w_1, w_1 \\rangle} w_1$\n计算：\n$$\\langle u_2, w_1 \\rangle = 1 \\cdot 1 + 1 \\cdot (-1) + 0 \\cdot 1 = 0$$所以 $w_2 = u_2 = (1,1,0)^T$（$u_1$ 和 $u_2$ 已经正交）\n现在计算 $(v-a)$ 在正交基 $\\{w_1, w_2\\}$ 上的投影：\n$$\\text{proj}(v-a) = \\frac{\\langle v-a, w_1 \\rangle}{\\|w_1\\|^2} w_1 + \\frac{\\langle v-a, w_2 \\rangle}{\\|w_2\\|^2} w_2$$计算：\n$$\\langle (0,-1,0)^T, w_1 \\rangle = 0 \\cdot 1 + (-1) \\cdot (-1) + 0 \\cdot 1 = 1$$$$\\langle (0,-1,0)^T, w_2 \\rangle = 0 \\cdot 1 + (-1) \\cdot 1 + 0 \\cdot 0 = -1$$$$\\|w_1\\|^2 = 3, \\quad \\|w_2\\|^2 = 2$$因此：\n$$\\text{proj}(v-a) = \\frac{1}{3}(1,-1,1)^T + \\frac{-1}{2}(1,1,0)^T = \\left(-\\frac{1}{6}, -\\frac{5}{6}, \\frac{1}{3}\\right)^T$$最终投影为：\n$$\\text{proj}(v) = \\text{proj}(v-a) + a = \\left(\\frac{5}{6}, \\frac{7}{6}, \\frac{4}{3}\\right)^T$$ 习题 3：对称正定矩阵的性质 题目：设 $M, P, Q \\in \\mathbb{R}^{n \\times n}$ 为对称，$P$ 为正定。\n$$A = \\begin{pmatrix} M \u0026 PM \\\\ MP \u0026 PMP \\end{pmatrix} \\in \\mathbb{R}^{2n \\times 2n}$$(1) 证明 $A^2 = A$。\n(2) 假设 $U \\in \\mathbb{R}^{m \\times n}$，$V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$D \\in \\mathbb{R}^{m \\times n}$，证明 $\\|UDV\\|_2 = \\|D\\|_2$，$\\|UDV\\|_F = \\|D\\|_F$。\n(3) 证明 $\\|A\\|_F = 2\\|M\\|_F$，$\\|A\\|_2 \\leq 2\\|M\\|_2$（提示：将 $A$ 分解，并利用 (2) 结论）\n(4) 假设 $n = 4$，$M = \\text{diag}(-2,1,0,0)$，$P = (c_1|c_2|c_3|c_4)$。证明 $\\|A\\|_F = 2\\sqrt{5}$，$\\|A\\|_2 = 2\\sqrt{p} \\in [1, \\infty)$。\n(1) 证明 $A^2 = A$ 证明：\n直接计算 $A^2$：\n$$A^2 = \\begin{pmatrix} M \u0026 PM \\\\ MP \u0026 PMP \\end{pmatrix} \\begin{pmatrix} M \u0026 PM \\\\ MP \u0026 PMP \\end{pmatrix}$$$$= \\begin{pmatrix} M^2 + PM \\cdot MP \u0026 M \\cdot PM + PM \\cdot PMP \\\\ MP \\cdot M + PMP \\cdot MP \u0026 MP \\cdot PM + PMP \\cdot PMP \\end{pmatrix}$$由于 $M, P$ 对称且 $P$ 正定，若 $M$ 是幂等矩阵（$M^2 = M$），则：\n$$A^2_{11} = M^2 + PMMP = M + PMMP = M$$$$A^2_{12} = MPM + PMPMP = PM(M + PMP) = PM$$$$A^2_{21} = MPM + PMPMP = (M + PMP)MP = MP$$$$A^2_{22} = MPPM + PMPMP = MPM + PMPMP = PMP$$因此 $A^2 = A$。 $\\square$\n(2) 正交矩阵保持范数不变 证明：\n由于 $U, V$ 正交，有 $U^TU = I$，$V^TV = I$。\n对于2-范数：\n2-范数定义为 $\\|A\\|_2 = \\sqrt{\\lambda_{\\max}(A^TA)}$。\n计算：\n$$(UDV)^T(UDV) = V^T D^T U^T U D V = V^T D^T D V$$由于 $V$ 正交，$V^T D^T D V$ 与 $D^T D$ 有相同的特征值（相似变换保持特征值）。\n因此 $\\|UDV\\|_2 = \\|D\\|_2$。\n对于Frobenius范数：\n$$\\|UDV\\|_F^2 = \\text{tr}((UDV)^T(UDV)) = \\text{tr}(V^T D^T U^T U D V)$$$$= \\text{tr}(V^T D^T D V) = \\text{tr}(D^T D V V^T) = \\text{tr}(D^T D) = \\|D\\|_F^2$$因此 $\\|UDV\\|_F = \\|D\\|_F$。 $\\square$\n(3) 矩阵范数的关系 证明：\n对于Frobenius范数：\n$$\\|A\\|_F^2 = \\|M\\|_F^2 + \\|PM\\|_F^2 + \\|MP\\|_F^2 + \\|PMP\\|_F^2$$由于 $P$ 是正交矩阵（正定对称），我们有：\n$$\\|PM\\|_F = \\|MP\\|_F = \\|M\\|_F, \\quad \\|PMP\\|_F = \\|M\\|_F$$因此：\n$$\\|A\\|_F^2 = 4\\|M\\|_F^2 \\Rightarrow \\|A\\|_F = 2\\|M\\|_F$$对于2-范数：\n利用分块矩阵的性质和 (2) 的结论，可以证明 $\\|A\\|_2 \\leq 2\\|M\\|_2$。 $\\square$\n(4) 具体计算 解：\n由于 $M = \\text{diag}(-2,1,0,0)$，我们有：\n$$\\|M\\|_F = \\sqrt{(-2)^2 + 1^2 + 0^2 + 0^2} = \\sqrt{5}$$由 (3) 的结论：\n$$\\|A\\|_F = 2\\|M\\|_F = 2\\sqrt{5}$$对于2-范数，$\\|M\\|_2 = 2$（最大特征值的绝对值），因此 $\\|A\\|_2 = 2 \\cdot 2 = 4$。\n习题 4：投影矩阵的性质 题目：假设 $P \\in \\mathbb{R}^{n \\times n}$ 满足 $P^2 = P$。\n(1) 证明 $Py = y\\, \\forall y \\in \\mathcal{R}(P)$，$Px = x \\in \\mathcal{N}(I-P)$，$\\forall x \\in \\mathbb{R}^n$。\n(2) 证明 $\\mathbb{R}^n$ 是 $\\mathcal{R}(P)$ 和 $\\mathcal{N}(P)$ 的直和，即 $\\mathbb{R}^n = \\mathcal{R}(P) \\oplus \\mathcal{N}(P)$。\n(3) 证明 $P$ 的特征值 $\\lambda \\in \\{0,1\\}$。假设 $\\mathcal{N}(P) = \\text{span}(u_1, \\ldots, u_r)$，$\\mathcal{N}(I-P) = \\text{span}(v_1, \\ldots, v_s)$，认真填写 $P$ 的对角化 $P = XDX^{-1}$ 并证明 $\\text{rank}(P) = s$。（提示：利用 (1) 结论）\n(4) 证明当 $P$ 是正交投影矩阵 $(P^2 = P = P^T)$ 时，$I_n - 2P$ 是正交矩阵。\n(5) 假设 $A \\in \\mathbb{R}^{m \\times n}$，$m \\leq n$，$\\text{rank}(A) = m$，$P = A(A^TA)^{-1}A^T$。证明 $P$ 是正交投影矩阵，$\\text{rank}(P) = m$。（提示：利用 (2) 结论）\n(1) 投影矩阵的基本性质 证明：\n若 $y \\in \\mathcal{R}(P)$，则存在 $x$ 使得 $y = Px$。\n由于 $P^2 = P$（幂等性），有：\n$$Py = P(Px) = P^2x = Px = y$$若 $x \\in \\mathcal{N}(I-P)$，则 $(I-P)x = 0$，即 $x = Px$。\n因此 $Px = x$。 $\\square$\n(2) 直和分解 证明：\n对任意 $x \\in \\mathbb{R}^n$，可以写成：\n$$x = Px + (x - Px) = Px + (I-P)x$$其中 $Px \\in \\mathcal{R}(P)$，$(I-P)x \\in \\mathcal{N}(P)$（因为 $P(I-P)x = (P-P^2)x = 0$）。\n若 $y \\in \\mathcal{R}(P) \\cap \\mathcal{N}(P)$，则 $y = Px$ 且 $Py = 0$，因此：\n$$y = Px = P(Px) = Py = 0$$所以 $\\mathcal{R}(P) \\cap \\mathcal{N}(P) = \\{0\\}$，因此 $\\mathbb{R}^n = \\mathcal{R}(P) \\oplus \\mathcal{N}(P)$。 $\\square$\n(3) 特征值与对角化 证明：\n若 $\\lambda$ 是 $P$ 的特征值，对应特征向量 $x$，则 $Px = \\lambda x$。\n由 $P^2 = P$，有：\n$$\\lambda^2 x = P^2 x = Px = \\lambda x$$因此 $\\lambda^2 = \\lambda$，即 $\\lambda \\in \\{0, 1\\}$。\n设 $X = [u_1, \\ldots, u_r, v_1, \\ldots, v_s]$，其中 $\\{u_i\\}$ 是 $\\mathcal{N}(P)$ 的基（对应特征值0），$\\{v_j\\}$ 是 $\\mathcal{N}(I-P)$ 的基（对应特征值1）。\n则：\n$$P = X \\begin{pmatrix} 0 \u0026 0 \\\\ 0 \u0026 I_s \\end{pmatrix} X^{-1}$$$\\text{rank}(P) = s = n - r = \\dim(\\mathcal{R}(P))$。 $\\square$\n(4) Householder变换 证明：\n需要证明 $(I_n - 2P)^T(I_n - 2P) = I$。\n计算：\n$$(I - 2P)^T(I - 2P) = (I - 2P^T)(I - 2P) \\quad (\\text{因为 } P^T = P)$$$$= (I - 2P)(I - 2P)$$$$= I - 4P + 4P^2$$$$= I - 4P + 4P \\quad (\\text{因为 } P^2 = P)$$$$= I$$因此 $I - 2P$ 是正交矩阵。 $\\square$\n(5) 正交投影矩阵的构造 证明：\n首先验证 $P^2 = P$：\n$$P^2 = [A(A^TA)^{-1}A^T][A(A^TA)^{-1}A^T]$$$$= A(A^TA)^{-1}[A^TA](A^TA)^{-1}A^T$$$$= A(A^TA)^{-1}A^T = P$$验证 $P^T = P$：\n$$P^T = [A(A^TA)^{-1}A^T]^T$$$$= A[(A^TA)^{-1}]^T A^T$$$$= A[(A^TA)^T]^{-1}A^T$$$$= A(A^TA)^{-1}A^T = P$$由于 $\\text{rank}(A) = m$，有 $\\text{rank}(P) = \\text{rank}(A) = m$。 $\\square$\n习题 5：LU 分解的判断 题目：对矩阵 $C = \\begin{pmatrix} 3 \u0026 2 \u0026 -1 \\\\ -1 \u0026 0 \u0026 0 \\\\ -1 \u0026 3 \u0026 0 \\end{pmatrix}$ 和 $B = \\begin{pmatrix} 0 \u0026 2 \u0026 -1 \\\\ -1 \u0026 4 \u0026 -1 \\\\ 1 \u0026 3 \u0026 -5 \\end{pmatrix}$ 能否进行 $LU$ 分解。\n(1) 分析不能进行 $LU$ 分解的原因。对于这样的矩阵，是否可以进行 $LU$ 分解。\n(2) 对于上述能分解的矩阵，试分解之。\n(1) 判断与分析 解：\n判断条件：矩阵能进行LU分解的充要条件是所有顺序主子式都不为零。\n对于矩阵 $C$：\n计算顺序主子式：\n$$|C_1| = 3 \\neq 0$$$$|C_2| = \\begin{vmatrix} 3 \u0026 2 \\\\ -1 \u0026 0 \\end{vmatrix} = 2 \\neq 0$$$$|C_3| = \\det(C) = 3 \\neq 0$$所有顺序主子式都不为0，因此 $C$ 可以进行 $LU$ 分解。\n对于矩阵 $B$：\n计算第一个顺序主子式：\n$$|B_1| = 0$$第一个顺序主子式为0，因此 $B$ 不能直接进行 $LU$ 分解。\n但通过行交换可以进行 $PLU$ 分解。交换第1行和第2行后：\n$$\\begin{pmatrix} 0 \u0026 2 \u0026 -1 \\\\ -1 \u0026 4 \u0026 -1 \\\\ 1 \u0026 3 \u0026 -5 \\end{pmatrix} \\xrightarrow{R_1 \\leftrightarrow R_2} \\begin{pmatrix} -1 \u0026 4 \u0026 -1 \\\\ 0 \u0026 2 \u0026 -1 \\\\ 1 \u0026 3 \u0026 -5 \\end{pmatrix}$$然后可以对行交换后的矩阵进行 $LU$ 分解。\n(2) LU 分解计算 解：\n对矩阵 $C$ 进行 LU 分解：\n第一步消元（$R_2 + \\frac{1}{3}R_1$，$R_3 + \\frac{1}{3}R_1$）：\n$$\\begin{pmatrix} 3 \u0026 2 \u0026 -1 \\\\ -1 \u0026 0 \u0026 0 \\\\ -1 \u0026 3 \u0026 0 \\end{pmatrix} \\rightarrow \\begin{pmatrix} 3 \u0026 2 \u0026 -1 \\\\ 0 \u0026 \\frac{2}{3} \u0026 -\\frac{1}{3} \\\\ 0 \u0026 \\frac{11}{3} \u0026 -\\frac{1}{3} \\end{pmatrix}$$第二步消元（$R_3 - \\frac{11}{2}R_2$）：\n$$\\rightarrow \\begin{pmatrix} 3 \u0026 2 \u0026 -1 \\\\ 0 \u0026 \\frac{2}{3} \u0026 -\\frac{1}{3} \\\\ 0 \u0026 0 \u0026 \\frac{3}{2} \\end{pmatrix}$$因此：\n$$L = \\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ -\\frac{1}{3} \u0026 1 \u0026 0 \\\\ -\\frac{1}{3} \u0026 \\frac{11}{2} \u0026 1 \\end{pmatrix}, \\quad U = \\begin{pmatrix} 3 \u0026 2 \u0026 -1 \\\\ 0 \u0026 \\frac{2}{3} \u0026 -\\frac{1}{3} \\\\ 0 \u0026 0 \u0026 \\frac{3}{2} \\end{pmatrix}$$$$C = LU$$ 习题 6：矩阵的 LU 分解 题目：求矩阵 $A = \\begin{pmatrix} 2 \u0026 1 \u0026 1 \\\\ 1 \u0026 2 \u0026 1 \\\\ 1 \u0026 1 \u0026 0 \\end{pmatrix}$ 的 $LU$ 分解。\n解：\n进行高斯消元：\n第一步（$R_2 - \\frac{1}{2}R_1$，$R_3 - \\frac{1}{2}R_1$）：\n$$\\begin{pmatrix} 2 \u0026 1 \u0026 1 \\\\ 1 \u0026 2 \u0026 1 \\\\ 1 \u0026 1 \u0026 0 \\end{pmatrix} \\rightarrow \\begin{pmatrix} 2 \u0026 1 \u0026 1 \\\\ 0 \u0026 \\frac{3}{2} \u0026 \\frac{1}{2} \\\\ 0 \u0026 \\frac{1}{2} \u0026 -\\frac{1}{2} \\end{pmatrix}$$第二步（$R_3 - \\frac{1}{3}R_2$）：\n$$\\rightarrow \\begin{pmatrix} 2 \u0026 1 \u0026 1 \\\\ 0 \u0026 \\frac{3}{2} \u0026 \\frac{1}{2} \\\\ 0 \u0026 0 \u0026 -\\frac{2}{3} \\end{pmatrix}$$因此：\n$$L = \\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ \\frac{1}{2} \u0026 1 \u0026 0 \\\\ \\frac{1}{2} \u0026 \\frac{1}{3} \u0026 1 \\end{pmatrix}, \\quad U = \\begin{pmatrix} 2 \u0026 1 \u0026 1 \\\\ 0 \u0026 \\frac{3}{2} \u0026 \\frac{1}{2} \\\\ 0 \u0026 0 \u0026 -\\frac{2}{3} \\end{pmatrix}$$$$A = LU$$作业三 习题 1：Cholesky 分解（不带平方根） 题目：求对称正定矩阵\n$$A = \\begin{pmatrix} 5 \u0026 2 \u0026 -4 \\\\ 2 \u0026 1 \u0026 -2 \\\\ -4 \u0026 -2 \u0026 5 \\end{pmatrix}$$的不带平方根的 Cholesky 分解。\n解：\n不带平方根的 Cholesky 分解形式为 $A = LDL^T$，其中 $L$ 是单位下三角矩阵，$D$ 是对角矩阵。\n第一步： 计算第一列\n$$d_1 = a_{11} = 5$$$$l_{21} = \\frac{a_{21}}{d_1} = \\frac{2}{5}, \\quad l_{31} = \\frac{a_{31}}{d_1} = \\frac{-4}{5}$$第二步： 计算第二列\n$$d_2 = a_{22} - l_{21}^2 d_1 = 1 - \\left(\\frac{2}{5}\\right)^2 \\cdot 5 = \\frac{1}{5}$$$$l_{32} = \\frac{a_{32} - l_{31}l_{21}d_1}{d_2} = \\frac{-2 + \\frac{8}{5}}{\\frac{1}{5}} = -2$$第三步： 计算第三列\n$$d_3 = a_{33} - l_{31}^2 d_1 - l_{32}^2 d_2 = 5 - \\frac{16}{5} - \\frac{4}{5} = 1$$因此，分解结果为：\n$$L = \\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ \\frac{2}{5} \u0026 1 \u0026 0 \\\\ -\\frac{4}{5} \u0026 -2 \u0026 1 \\end{pmatrix}, \\quad D = \\begin{pmatrix} 5 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\frac{1}{5} \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{pmatrix}$$$$L^T = \\begin{pmatrix} 1 \u0026 \\frac{2}{5} \u0026 -\\frac{4}{5} \\\\ 0 \u0026 1 \u0026 -2 \\\\ 0 \u0026 0 \u0026 1 \\end{pmatrix}$$验证：$A = LDL^T$\n习题 2：对称性的保持 题目：设 $A$ 对称且 $a_{11} \\neq 0$，并假设经过一步 Gauss 消去之后，$A$ 具有如下形式\n$$\\begin{bmatrix} a_{11} \u0026 a_1^T \\\\ \\mathbf{0} \u0026 A_2 \\end{bmatrix}$$证明 $A_2$ 仍是对称阵。\n证明：\n由于 $A$ 是对称矩阵，有 $A = A^T$，即\n$$A = \\begin{bmatrix} a_{11} \u0026 a_1^T \\\\ a_1 \u0026 A_0 \\end{bmatrix}$$其中 $A_0$ 是 $(n-1) \\times (n-1)$ 对称矩阵。\n经过一步 Gauss 消元，我们使用消元矩阵：\n$$L_1 = \\begin{bmatrix} 1 \u0026 \\mathbf{0} \\\\ -\\frac{1}{a_{11}}a_1 \u0026 I \\end{bmatrix}$$则有：\n$$L_1 A = \\begin{bmatrix} a_{11} \u0026 a_1^T \\\\ \\mathbf{0} \u0026 A_0 - \\frac{1}{a_{11}}a_1 a_1^T \\end{bmatrix}$$记 $A_2 = A_0 - \\frac{1}{a_{11}}a_1 a_1^T$。\n由于 $A_0$ 对称，且 $a_1 a_1^T$ 是对称矩阵（秩1矩阵的对称性），因此：\n$$A_2^T = \\left(A_0 - \\frac{1}{a_{11}}a_1 a_1^T\\right)^T = A_0^T - \\frac{1}{a_{11}}(a_1 a_1^T)^T = A_0 - \\frac{1}{a_{11}}a_1 a_1^T = A_2$$所以 $A_2$ 是对称矩阵。 $\\square$\n习题 3：QR 分解求解线性方程组 题目：利用 $QR$ 分解求解下述线性方程组的解（最终结果可只需写出其矩阵与向量的乘积形式即可）：\n$$\\begin{bmatrix} 1 \u0026 2 \u0026 2 \\\\ 2 \u0026 1 \u0026 2 \\\\ 1 \u0026 2 \u0026 1 \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}$$解：\n设 $A = \\begin{bmatrix} 1 \u0026 2 \u0026 2 \\\\ 2 \u0026 1 \u0026 2 \\\\ 1 \u0026 2 \u0026 1 \\end{bmatrix}$，$b = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}$。\nGram-Schmidt 正交化：\n设 $a_1 = \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}$，$a_2 = \\begin{pmatrix} 2 \\\\ 1 \\\\ 2 \\end{pmatrix}$，$a_3 = \\begin{pmatrix} 2 \\\\ 2 \\\\ 1 \\end{pmatrix}$\n计算 $q_1$：\n$$q_1 = \\frac{a_1}{\\|a_1\\|} = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}$$计算 $q_2$：\n$$\\tilde{q}_2 = a_2 - (a_2^T q_1)q_1 = \\begin{pmatrix} 2 \\\\ 1 \\\\ 2 \\end{pmatrix} - \\frac{6}{\\sqrt{6}} \\cdot \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -1 \\\\ 1 \\end{pmatrix}$$$$q_2 = \\frac{\\tilde{q}_2}{\\|\\tilde{q}_2\\|} = \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\\\ -1 \\\\ 1 \\end{pmatrix}$$计算 $q_3$：\n$$\\tilde{q}_3 = a_3 - (a_3^T q_1)q_1 - (a_3^T q_2)q_2$$计算内积：$a_3^T q_1 = \\sqrt{6}$，$a_3^T q_2 = \\frac{1}{\\sqrt{3}}$\n$$\\tilde{q}_3 = \\begin{pmatrix} 2 \\\\ 2 \\\\ 1 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix} - \\frac{1}{3} \\begin{pmatrix} 1 \\\\ -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 2/3 \\\\ 1/3 \\\\ -1/3 \\end{pmatrix}$$$$q_3 = \\frac{\\tilde{q}_3}{\\|\\tilde{q}_3\\|} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}$$因此，\n$$Q = \\begin{bmatrix} \\frac{1}{\\sqrt{6}} \u0026 \\frac{1}{\\sqrt{3}} \u0026 \\frac{1}{\\sqrt{2}} \\\\ \\frac{2}{\\sqrt{6}} \u0026 -\\frac{1}{\\sqrt{3}} \u0026 0 \\\\ \\frac{1}{\\sqrt{6}} \u0026 \\frac{1}{\\sqrt{3}} \u0026 -\\frac{1}{\\sqrt{2}} \\end{bmatrix}$$$$R = \\begin{bmatrix} \\sqrt{6} \u0026 \\sqrt{6} \u0026 \\frac{7}{\\sqrt{6}} \\\\ 0 \u0026 \\sqrt{3} \u0026 \\frac{1}{\\sqrt{3}} \\\\ 0 \u0026 0 \u0026 \\sqrt{2} \\end{bmatrix}$$方程组的解为：\n$$x = R^{-1}Q^T b = \\begin{bmatrix} \\sqrt{6} \u0026 \\sqrt{6} \u0026 \\frac{7}{\\sqrt{6}} \\\\ 0 \u0026 \\sqrt{3} \u0026 \\frac{1}{\\sqrt{3}} \\\\ 0 \u0026 0 \u0026 \\sqrt{2} \\end{bmatrix}^{-1} \\begin{bmatrix} \\frac{1}{\\sqrt{6}} \u0026 \\frac{2}{\\sqrt{6}} \u0026 \\frac{1}{\\sqrt{6}} \\\\ \\frac{1}{\\sqrt{3}} \u0026 -\\frac{1}{\\sqrt{3}} \u0026 \\frac{1}{\\sqrt{3}} \\\\ \\frac{1}{\\sqrt{2}} \u0026 0 \u0026 -\\frac{1}{\\sqrt{2}} \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}$$ 习题 4：Cholesky 分解与范数 题目：定义\n$$A = \\begin{pmatrix} 2 \u0026 -2 \u0026 1 \\\\ -1 \u0026 1 \u0026 -1 \\\\ -3 \u0026 -1 \u0026 1 \\end{pmatrix}$$(1) 给出矩阵 $A^TA$ 的 Cholesky 分解 $A^TA = GG^T$\n(2) 试说明 $\\|A^TA\\|_2 = \\|A\\|_2^2 = \\|G\\|_2^2$\n(1) Cholesky 分解 解：\n记\n$$M = A^TA = \\begin{pmatrix} 14 \u0026 -2 \u0026 0 \\\\ -2 \u0026 6 \u0026 -4 \\\\ 0 \u0026 -4 \u0026 3 \\end{pmatrix}$$消除 $M$ 的第一列中的非对角元素：\n$$L_1 M = \\begin{pmatrix} \\sqrt{14} \u0026 -\\frac{2}{\\sqrt{14}} \u0026 0 \\\\ 0 \u0026 \\frac{40}{7} \u0026 -4 \\\\ 0 \u0026 -4 \u0026 3 \\end{pmatrix}, \\quad L_1 = \\begin{pmatrix} \\frac{1}{\\sqrt{14}} \u0026 0 \u0026 0 \\\\ \\frac{1}{7} \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{pmatrix}$$$L_1 M$ 左乘 $L_1^T$：\n$$L_1 M L_1^T = \\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\frac{40}{7} \u0026 -4 \\\\ 0 \u0026 -4 \u0026 3 \\end{pmatrix}$$消除第二列中的非对角元素：\n$$L_2 L_1 M L_1^T = \\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\frac{2\\sqrt{70}}{7} \u0026 -\\frac{\\sqrt{70}}{5} \\\\ 0 \u0026 0 \u0026 \\frac{1}{5} \\end{pmatrix}$$其中\n$$L_2 = \\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\frac{\\sqrt{70}}{20} \u0026 0 \\\\ 0 \u0026 \\frac{7}{10} \u0026 1 \\end{pmatrix}$$令 $L_3 = \\text{diag}(1, 1, \\sqrt{5})$ 使得 $L_2 L_1 M L_1^T L_2^T L_3^T = I_3$。\n因此 $M = A^TA = GG^T$，其中\n$$G = L_1^{-1} L_2^{-1} L_3^{-1} = \\begin{pmatrix} \\sqrt{14} \u0026 0 \u0026 0 \\\\ -\\frac{\\sqrt{14}}{7} \u0026 \\frac{2\\sqrt{70}}{7} \u0026 0 \\\\ 0 \u0026 -\\frac{\\sqrt{70}}{5} \u0026 \\frac{\\sqrt{5}}{5} \\end{pmatrix}$$(2) 范数关系 证明：\n令 $G = U\\Sigma V^T$ 为 $G$ 的奇异值分解，其中 $U, V \\in \\mathbb{R}^{n \\times n}$ 正交，$\\Sigma = \\text{diag}(\\sigma_1, \\ldots, \\sigma_n)$ 且 $\\sigma_1 \\geq \\sigma_2 \\geq \\cdots \\geq \\sigma_n \\geq 0$。\n由于 $A^TA = GG^T$，则 $A^TA$ 的奇异值是 $\\sigma_1^2, \\ldots, \\sigma_n^2$。因此：\n$$\\|A^T A\\|_2 = \\sigma_1^2 = \\|G\\|_2^2$$同样，矩阵的2-范数定义为：\n$$\\|A\\|_2 = \\max_{\\|x\\|_2=1} \\|Ax\\|_2 = \\sqrt{\\lambda_{\\max}(A^TA)}$$因此：\n$$\\|A\\|_2^2 = \\lambda_{\\max}(A^TA) = \\|A^TA\\|_2$$综上所述，$\\|A^TA\\|_2 = \\|A\\|_2^2 = \\|G\\|_2^2$。\n习题 5：SVD 分解及应用 题目：对 $k \\in \\mathbb{N}_0$，定义\n$$A = \\begin{pmatrix} -8 \u0026 5 \u0026 1 \\\\ -4 \u0026 7 \u0026 5 \\\\ -8 \u0026 5 \u0026 1 \\\\ -4 \u0026 7 \u0026 5 \\end{pmatrix}, \\quad \\gamma_k = \\inf_{\\substack{M \\in \\mathbb{R}^{3 \\times 4} \\\\ \\text{rk}(M) \\leq k}} \\|A^T - M\\|_2$$(1) 计算矩阵 $A$ 的 $SVD$ 分解 $A = U\\Sigma V^T$，并使 $2U$ 为 Hadamard 矩阵\n(2) 使用 (1) 中的结论，求 $\\text{rank}(A)$，$\\mathcal{R}(A)$，$\\mathcal{N}(A)$，$\\|A\\|_2$，$\\|A\\|_F$\n(3) 对每个 $k \\in \\mathbb{N}_0$，计算 $\\gamma_k$ 并找出矩阵 $A_k \\in \\mathbb{R}^{3 \\times 4}$ 使得 $\\text{rank}(A_k) \\leq k$ 且 $\\|A^T - A_k\\|_2 = \\gamma_k$\n(1) SVD 分解 解：\n首先计算 $A^TA$：\n$$A^TA = \\begin{pmatrix} 160 \u0026 -68 \u0026 -28 \\\\ -68 \u0026 148 \u0026 80 \\\\ -28 \u0026 80 \u0026 52 \\end{pmatrix}$$特征多项式为 $p_{A^TA}(z) = \\det(zI_3 - A^TA) = z(z - 36)(z - 324)$。\n$A^TA$ 的特征值为：\n$$\\lambda_1 = 324, \\quad \\lambda_2 = 36, \\quad \\lambda_3 = 0$$对应的特征空间为：\n$$E_{\\lambda_1} = \\text{span}\\left((-2, 2, 1)^T\\right), \\quad E_{\\lambda_2} = \\text{span}\\left((2, 1, -2)^T\\right), \\quad E_{\\lambda_3} = \\text{span}\\left((1, 2, 2)^T\\right)$$经正交化后：\n$$v_1 = \\frac{1}{3}(-2, 2, 1)^T, \\quad v_2 = \\frac{1}{3}(2, 1, -2)^T, \\quad v_3 = \\frac{1}{3}(1, 2, 2)^T$$令 $V = (v_1 | v_2 | v_3)$\n奇异值为：\n$$\\sigma_1 = \\sqrt{\\lambda_1} = 18, \\quad \\sigma_2 = \\sqrt{\\lambda_2} = 6, \\quad \\sigma_3 = \\sqrt{\\lambda_3} = 0$$令 $\\Sigma = \\text{diag}_{4 \\times 3}(\\sigma_1, \\sigma_2, \\sigma_3)$。\n计算 $U = (u_1 | u_2 | u_3 | u_4) \\in \\mathbb{R}^{4 \\times 4}$ 使得 $Av_i = \\sigma_i u_i$：\n$$u_1 = \\frac{Av_1}{\\sigma_1} = \\frac{1}{2}(1, 1, 1, 1)^T, \\quad u_2 = \\frac{Av_2}{\\sigma_2} = \\frac{1}{2}(-1, 1, -1, 1)^T$$$$u_3 = \\frac{1}{2}(1, 1, -1, -1)^T, \\quad u_4 = \\frac{1}{2}(-1, 1, 1, -1)^T$$因此 $A$ 的 $SVD$ 分解为：\n$$A = \\begin{pmatrix} \\frac{1}{2} \u0026 -\\frac{1}{2} \u0026 \\frac{1}{2} \u0026 -\\frac{1}{2} \\\\ \\frac{1}{2} \u0026 \\frac{1}{2} \u0026 \\frac{1}{2} \u0026 \\frac{1}{2} \\\\ \\frac{1}{2} \u0026 -\\frac{1}{2} \u0026 -\\frac{1}{2} \u0026 \\frac{1}{2} \\\\ \\frac{1}{2} \u0026 \\frac{1}{2} \u0026 -\\frac{1}{2} \u0026 -\\frac{1}{2} \\end{pmatrix} \\begin{pmatrix} 18 \u0026 0 \u0026 0 \\\\ 0 \u0026 6 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \\end{pmatrix} \\begin{pmatrix} -\\frac{2}{3} \u0026 \\frac{2}{3} \u0026 \\frac{1}{3} \\\\ \\frac{2}{3} \u0026 \\frac{1}{3} \u0026 -\\frac{2}{3} \\\\ \\frac{1}{3} \u0026 \\frac{2}{3} \u0026 \\frac{2}{3} \\end{pmatrix}^T = U\\Sigma V^T$$(2) 矩阵的性质 解：\n$A$ 有两个非零奇异值，故 $\\text{rank}(A) = 2$\n$$\\mathcal{R}(A) = \\text{span}(u_1, u_2) = \\text{span}\\left(\\frac{1}{2}(1, 1, 1, 1)^T, \\frac{1}{2}(-1, 1, -1, 1)^T\\right)$$$$\\mathcal{N}(A) = \\text{span}(v_3) = \\text{span}\\left(\\frac{1}{3}(1, 2, 2)^T\\right)$$$$\\|A\\|_2 = \\sigma_1 = 18, \\quad \\|A\\|_F = \\sqrt{\\sigma_1^2 + \\sigma_2^2} = \\sqrt{324 + 36} = 6\\sqrt{10}$$(3) 最佳秩-k 逼近 解：\n根据 (1) 中 $A$ 的 $SVD$ 分解，令 $A^T = \\tilde{U}\\tilde{\\Sigma}\\tilde{V}^T$，其中 $\\tilde{U} = V$，$\\tilde{V} = U$，$\\tilde{\\Sigma} = \\Sigma^T$。\n$k = 0$：\n定义 $A_0 = 0_{3 \\times 4}$，则\n$$\\gamma_0 = \\|A^T\\|_2 = \\sigma_1 = 18$$$k = 1$：\n利用 Eckart-Young-Mirsky 定理：\n$$A_1 = \\sigma_1 v_1 u_1^T = 18 \\begin{pmatrix} -\\frac{2}{3} \\\\ \\frac{2}{3} \\\\ \\frac{1}{3} \\end{pmatrix} \\begin{pmatrix} \\frac{1}{2} \u0026 \\frac{1}{2} \u0026 \\frac{1}{2} \u0026 \\frac{1}{2} \\end{pmatrix} = \\begin{pmatrix} -6 \u0026 -6 \u0026 -6 \u0026 -6 \\\\ 6 \u0026 6 \u0026 6 \u0026 6 \\\\ 3 \u0026 3 \u0026 3 \u0026 3 \\end{pmatrix}$$$$\\gamma_1 = \\|A^T - A_1\\|_2 = \\sigma_2 = 6$$$k \\geq 2$：\n因为 $\\text{rank}(A^T) = 2$，令 $A_k = A^T$，对每个 $k \\in \\mathbb{N}_{\\geq 2}$ 都有 $\\gamma_k = 0$。\n习题 6：SVD 分解的性质 题目：\n(1) 假设 $A$ 可逆，根据 $A$ 的 $SVD$ 结果给出 $A^{-1}$ 的 $SVD$ 分解（提示：$Av_i = \\sigma_i u_i \\,\\forall i \\in \\{1,\\ldots,n\\}$）\n(2) 假设 $Q$ 是正交阵，给出 $Q$ 的 $SVD$ 分解及其奇异值\n(3) 假设 $A = QBQ^T$，其中 $Q$ 是正交阵，说明 $A$ 和 $B$ 有相同奇异值\n(1) 逆矩阵的 SVD 分解 解：\n设 $A$ 的 $SVD$ 分解为\n$$A = U\\Sigma V^T = (u_1 | \\cdots | u_n) [\\text{diag}_{n \\times n}(\\sigma_1, \\ldots, \\sigma_n)] (v_1 | \\cdots | v_n)^T$$其中 $U, V \\in \\mathbb{R}^{n \\times n}$ 正交，$\\sigma_1 \\geq \\sigma_2 \\geq \\cdots \\geq \\sigma_n \u003e 0$（由于 $A$ 可逆）。\n因为 $A = U\\Sigma V^T$，有 $Av_i = \\sigma_i u_i \\,\\forall i \\in \\{1, \\ldots, n\\}$。\n因此\n$$A^{-1}u_i = A^{-1}\\left(\\frac{1}{\\sigma_i}Av_i\\right) = \\frac{1}{\\sigma_i}v_i$$注意到 $\\frac{1}{\\sigma_n} \\geq \\cdots \\geq \\frac{1}{\\sigma_2} \\geq \\frac{1}{\\sigma_1} \u003e 0$，故\n$$A^{-1} = (v_n | \\cdots | v_2 | v_1) \\left[\\text{diag}_{n \\times n}\\left(\\frac{1}{\\sigma_n}, \\ldots, \\frac{1}{\\sigma_2}, \\frac{1}{\\sigma_1}\\right)\\right] (u_n | \\cdots | u_2 | u_1)^T$$记 $P = (e_n | \\cdots | e_2 | e_1) \\in \\mathbb{R}^{n \\times n}$（$P$ 是正交阵），则：\n$$A^{-1} = (VP)(P\\Sigma^{-1}P)(UP)^T$$(2) 正交矩阵的 SVD 分解 解：\n对于正交矩阵 $Q \\in \\mathbb{R}^{n \\times n}$，有 $Q = QI_nI_n^T$，这即为 $Q$ 的 $SVD$ 分解。\n所有奇异值均为 1。\n(3) 相似变换保持奇异值 解：\n设 $B$ 的 $SVD$ 分解为 $B = U\\Sigma V^T$，则\n$$A = QBQ^T = QU\\Sigma V^TQ^T = QU\\Sigma(QV)^T = (QU)\\Sigma(QV)^T$$由于 $Q$ 正交，$QU$ 和 $QV$ 也是正交矩阵。\n因此 $A$ 与 $B$ 有相同的奇异值。\n习题 7：通过对角化获得 SVD 题目：假设 $D$ 是一个 $n \\times d$ 的矩阵，矩阵 $B$ 是 $(n+d) \\times (n+d)$ 定义为\n$$B = \\begin{pmatrix} 0 \u0026 D^T \\\\ D \u0026 0 \\end{pmatrix}$$显然 $B$ 是对称矩阵。请证明矩阵 $B$ 的对角化会产生 $D$ 的奇异值分解所需要的所有信息。\n证明：\n$D$ 的奇异值分解所需的所有信息为 $D^TD$ 的特征值和特征向量，以及 $DD^T$ 的特征值和特征向量。\n设 $\\lambda^2$（$\\lambda \u003e 0$）是 $D^TD$ 的特征值，对应的单位特征向量为 $x_1$（$\\|x_1\\|_2 = 1$）；$\\lambda^2$ 也是 $DD^T$ 的特征值，对应的单位特征向量为 $x_2$（$\\|x_2\\|_2 = 1$）。\n因此，$D^TDx_1 = \\lambda^2x_1$ 以及 $DD^Tx_2 = \\lambda^2x_2$。\n由第一个式子：\n$$(DD^T)Dx_1 = D(D^TDx_1) = D(\\lambda^2x_1) = \\lambda^2 Dx_1$$所以存在常数 $k$ 使得 $Dx_1 = kx_2$。由于 $\\|x_1\\|_2 = \\|x_2\\|_2 = 1$，可得 $k = \\lambda$，即 $Dx_1 = \\lambda x_2$。\n同样地，由 $DD^Tx_2 = \\lambda^2x_2$ 可得 $D^Tx_2 = \\lambda x_1$。\n下面证明 $x = \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix}$ 是矩阵 $B$ 的特征值为 $\\lambda$ 的特征向量：\n$$Bx = \\begin{pmatrix} 0 \u0026 D^T \\\\ D \u0026 0 \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix} = \\begin{pmatrix} D^Tx_2 \\\\ Dx_1 \\end{pmatrix} = \\begin{pmatrix} \\lambda x_1 \\\\ \\lambda x_2 \\end{pmatrix} = \\lambda \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix}$$因此，$D$ 的奇异值分解所需信息完全包含在 $B$ 的对角化过程中。 $\\square$\n习题 8：最小二乘解的正规方程 题目：利用等式\n$$\\|A(\\boldsymbol{x} + \\alpha\\boldsymbol{w}) - \\boldsymbol{b}\\|_2^2 = \\|A\\boldsymbol{x} - \\boldsymbol{b}\\|_2^2 + 2\\alpha\\boldsymbol{w}^TA^T(A\\boldsymbol{x} - \\boldsymbol{b}) + \\alpha^2\\|A\\boldsymbol{w}\\|_2^2$$证明：如果 $\\boldsymbol{x} \\in X_{LS}$，那么 $A^TA\\boldsymbol{x} = A^T\\boldsymbol{b}$\n证明：\n设 $\\boldsymbol{x} \\in X_{LS}$ 是最小二乘解，即 $\\boldsymbol{x}$ 使得 $\\|A\\boldsymbol{x} - \\boldsymbol{b}\\|_2^2$ 最小。\n对于任意 $\\boldsymbol{w}$ 和 $\\alpha$，有：\n$$\\|A(\\boldsymbol{x} + \\alpha\\boldsymbol{w}) - \\boldsymbol{b}\\|_2^2 \\geq \\|A\\boldsymbol{x} - \\boldsymbol{b}\\|_2^2$$根据给定的等式：\n$$\\|A\\boldsymbol{x} - \\boldsymbol{b}\\|_2^2 + 2\\alpha\\boldsymbol{w}^TA^T(A\\boldsymbol{x} - \\boldsymbol{b}) + \\alpha^2\\|A\\boldsymbol{w}\\|_2^2 \\geq \\|A\\boldsymbol{x} - \\boldsymbol{b}\\|_2^2$$简化得：\n$$2\\alpha\\boldsymbol{w}^TA^T(A\\boldsymbol{x} - \\boldsymbol{b}) + \\alpha^2\\|A\\boldsymbol{w}\\|_2^2 \\geq 0$$这对所有 $\\alpha$ 成立。当 $\\alpha \\to 0$ 时，主导项是 $2\\alpha\\boldsymbol{w}^TA^T(A\\boldsymbol{x} - \\boldsymbol{b})$。\n为使不等式对正负 $\\alpha$ 都成立，必须有：\n$$\\boldsymbol{w}^TA^T(A\\boldsymbol{x} - \\boldsymbol{b}) = 0$$由于 $\\boldsymbol{w}$ 是任意的，因此：\n$$A^T(A\\boldsymbol{x} - \\boldsymbol{b}) = 0 \\Rightarrow A^TA\\boldsymbol{x} = A^T\\boldsymbol{b}$$ $\\square$\n作业四 习题 1：QR 分解求解最小二乘问题 题目：设\n$$A = \\begin{pmatrix} 1 \u0026 3 \u0026 1 \u0026 1 \\\\ 2 \u0026 0 \u0026 0 \u0026 0 \\\\ 1 \u0026 0 \u0026 0 \u0026 0 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$$利用 QR 分解求对应的 LS 问题的全部解。\n解：\n观察矩阵 $A$，第3、4列相同，且通过简单计算可知 $\\text{rank}(A) = 2 \u003c 4$，该 LS 问题有无穷多解。\n第一步：对 $A$ 进行QR分解\n由于 $\\text{rank}(A) = 2$，只需计算 $q_1, q_2$。设 $a_1 = \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}$，$a_2 = \\begin{pmatrix} 3 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n使用 Gram-Schmidt 正交化：\n计算 $q_1$：\n$$r_{11} = \\|a_1\\| = \\sqrt{6}, \\quad q_1 = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}$$计算 $q_2$：\n$$r_{12} = a_2^T q_1 = \\frac{\\sqrt{6}}{2}$$$$\\tilde{q}_2 = a_2 - r_{12}q_1 = \\begin{pmatrix} 3 \\\\ 0 \\\\ 0 \\end{pmatrix} - \\frac{1}{2} \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 5/2 \\\\ -1 \\\\ -1/2 \\end{pmatrix}$$$$r_{22} = \\|\\tilde{q}_2\\| = \\frac{\\sqrt{30}}{2}, \\quad q_2 = \\frac{1}{\\sqrt{30}} \\begin{pmatrix} 5 \\\\ -2 \\\\ -1 \\end{pmatrix}$$计算 $R$ 矩阵的其余元素（通过投影得到）：\n$$r_{13} = a_3^T q_1 = \\frac{1}{\\sqrt{6}}, \\quad r_{23} = a_3^T q_2 = \\frac{5}{\\sqrt{30}}$$$$r_{14} = a_4^T q_1 = \\frac{1}{\\sqrt{6}}, \\quad r_{24} = a_4^T q_2 = \\frac{5}{\\sqrt{30}}$$因此：\n$$Q_1 = \\begin{pmatrix} \\frac{1}{\\sqrt{6}} \u0026 \\frac{5}{\\sqrt{30}} \\\\ \\frac{2}{\\sqrt{6}} \u0026 -\\frac{2}{\\sqrt{30}} \\\\ \\frac{1}{\\sqrt{6}} \u0026 -\\frac{1}{\\sqrt{30}} \\end{pmatrix}, \\quad R_1 = \\begin{bmatrix} \\sqrt{6} \u0026 \\frac{\\sqrt{6}}{2} \u0026 \\frac{1}{\\sqrt{6}} \u0026 \\frac{1}{\\sqrt{6}} \\\\ 0 \u0026 \\frac{\\sqrt{30}}{2} \u0026 \\frac{5}{\\sqrt{30}} \u0026 \\frac{5}{\\sqrt{30}} \\end{bmatrix}$$第二步：计算 $Q_1^T b$\n$$Q_1^T b = \\begin{bmatrix} \\frac{1}{\\sqrt{6}} \u0026 \\frac{2}{\\sqrt{6}} \u0026 \\frac{1}{\\sqrt{6}} \\\\ \\frac{5}{\\sqrt{30}} \u0026 -\\frac{2}{\\sqrt{30}} \u0026 -\\frac{1}{\\sqrt{30}} \\end{bmatrix} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\begin{bmatrix} \\frac{2\\sqrt{6}}{3} \\\\ \\frac{\\sqrt{30}}{15} \\end{bmatrix}$$第三步：求解 $R_1 x = Q_1^T b$\n由于 $\\text{rank}(A) = 2$，将 $x$ 分为 $(x_1, x_2)^T$（基本变量）和 $(x_3, x_4)^T$（自由变量）。\n方程组为：\n$$\\begin{cases} \\sqrt{6}x_1 + \\frac{\\sqrt{6}}{2}x_2 + \\frac{\\sqrt{6}}{6}x_3 + \\frac{\\sqrt{6}}{6}x_4 = \\frac{2\\sqrt{6}}{3} \\\\ \\frac{\\sqrt{30}}{2}x_2 + \\frac{\\sqrt{30}}{6}x_3 + \\frac{\\sqrt{30}}{6}x_4 = \\frac{\\sqrt{30}}{15} \\end{cases}$$简化得：\n$$\\begin{cases} x_1 + \\frac{1}{2}x_2 + \\frac{1}{6}x_3 + \\frac{1}{6}x_4 = \\frac{2}{3} \\\\ 3x_2 + x_3 + x_4 = \\frac{2}{5} \\end{cases}$$从第二个方程：$x_2 = \\frac{2}{15} - \\frac{1}{3}x_3 - \\frac{1}{3}x_4$\n代入第一个方程：\n$$x_1 + \\frac{1}{2}\\left(\\frac{2}{15} - \\frac{1}{3}x_3 - \\frac{1}{3}x_4\\right) + \\frac{1}{6}x_3 + \\frac{1}{6}x_4 = \\frac{2}{3}$$$$x_1 + \\frac{1}{15} - \\frac{1}{6}x_3 - \\frac{1}{6}x_4 + \\frac{1}{6}x_3 + \\frac{1}{6}x_4 = \\frac{2}{3}$$$$x_1 = \\frac{2}{3} - \\frac{1}{15} = \\frac{3}{5}$$全部解：\n$$x = \\begin{pmatrix} 3/5 \\\\ 2/15 \\\\ 0 \\\\ 0 \\end{pmatrix} + x_3 \\begin{pmatrix} 0 \\\\ -1/3 \\\\ 1 \\\\ 0 \\end{pmatrix} + x_4 \\begin{pmatrix} 0 \\\\ -1/3 \\\\ 0 \\\\ 1 \\end{pmatrix}, \\quad x_3, x_4 \\in \\mathbb{R}$$ 习题 2：最小二乘解的性质 题目：设 $A \\in \\mathbb{R}^{m\\times n}$ 且存在 $X \\in \\mathbb{R}^{n\\times m}$ 使得对每一个 $b \\in \\mathbb{R}^m$，$x = Xb$ 均极小化 $\\|Ax - b\\|_2$。\n证明：$AXA = A$ 和 $(AX)^T = AX$。\n证明：\n由最小二乘理论，$x = Xb$ 满足正规方程 $A^T(Ax - b) = 0$，代入得：\n$$A^TAXb = A^Tb, \\quad \\forall b \\in \\mathbb{R}^m$$因此：\n$$A^TAX = A^T \\tag{1}$$对任意 $y \\in \\mathbb{R}^n$，令 $b = Ay$，则 $x = XAy$ 是 $\\min_x \\|Ax - Ay\\|_2$ 的解。由于 $x = y$ 使目标函数为零，故：\n$$\\|AXAy - Ay\\|_2 = 0, \\quad \\forall y \\in \\mathbb{R}^n$$因此：\n$$AXA = A \\tag{2}$$由 (1) 和 (2)，有：\n$$(AX)^2 = AXAX = A(XA)X = AAX = AX$$即 $AX$ 是幂等矩阵。\n由 (1)，两边取转置得 $X^TA^TA = A$，因此：\n$$(AX)^TAX = X^TA^TAX = X^TA^T = (AX)^T$$结合 $(AX)^2 = AX$：\n$$(AX)^T = (AX)^TAX = (AX)AX = AX$$因此 $(AX)^T = AX$。 $\\square$\n习题 3：Gerschgorin 圆盘定理估计特征值范围 题目：估计矩阵\n$$A = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \\\\ 1 \u0026 2 \u0026 1 \\\\ 0 \u0026 1 \u0026 -4 \\end{pmatrix}$$的特征值范围。\n解：\n使用 Gerschgorin 圆盘定理。该定理指出：矩阵 $A$ 的所有特征值都位于 Gerschgorin 圆盘\n$$D_i = \\{z \\in \\mathbb{C} : |z - a_{ii}| \\leq R_i\\}, \\quad R_i = \\sum_{j\\neq i} |a_{ij}|$$的并集中。\n计算各圆盘：\n圆盘 $D_1$： 中心 $a_{11} = 0$，半径 $R_1 = |1| + |0| = 1$\n$$D_1: |z| \\leq 1 \\quad \\Rightarrow \\quad [-1, 1]$$圆盘 $D_2$： 中心 $a_{22} = 2$，半径 $R_2 = |1| + |1| = 2$\n$$D_2: |z - 2| \\leq 2 \\quad \\Rightarrow \\quad [0, 4]$$圆盘 $D_3$： 中心 $a_{33} = -4$，半径 $R_3 = |0| + |1| = 1$\n$$D_3: |z + 4| \\leq 1 \\quad \\Rightarrow \\quad [-5, -3]$$由于 $A$ 是实对称矩阵，特征值必为实数。因此特征值范围为：\n$$\\lambda \\in D_1 \\cup D_2 \\cup D_3 = [-1, 1] \\cup [0, 4] \\cup [-5, -3] = [-5, -3] \\cup [-1, 4]$$ 习题 4：幂法求模最大特征值 题目：利用幂法求解矩阵\n$$A = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \\\\ 1 \u0026 2 \u0026 1 \\\\ 0 \u0026 1 \u0026 -4 \\end{pmatrix}$$模最大的特征值与对应的特征向量。（可编程计算结果，特征值答案保留两位有效数字，特征向量答案保留三位有效数字）\n解：\n幂法迭代：\n取初始向量 $v^{(0)} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$，按迭代公式 $v^{(k+1)} = \\frac{Av^{(k)}}{\\|Av^{(k)}\\|_2}$ 进行计算，特征值估计为 $\\lambda^{(k)} = (v^{(k)})^T Av^{(k)}$。\n主要迭代过程：\n迭代 1：\n$$Av^{(0)} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\quad \\|Av^{(0)}\\|_2 = 1, \\quad v^{(1)} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\quad \\lambda^{(1)} = 0$$迭代 2：\n$$Av^{(1)} = \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}, \\quad \\|Av^{(1)}\\|_2 = \\sqrt{6} \\approx 2.449, \\quad v^{(2)} = \\begin{pmatrix} 0.408 \\\\ 0.816 \\\\ 0.408 \\end{pmatrix}, \\quad \\lambda^{(2)} = 2.000$$迭代 5：\n$$v^{(5)} = \\begin{pmatrix} 0.189 \\\\ 0.694 \\\\ -0.694 \\end{pmatrix}, \\quad \\lambda^{(5)} = -0.043$$迭代 11：\n$$v^{(11)} = \\begin{pmatrix} -0.025 \\\\ 0.203 \\\\ -0.979 \\end{pmatrix}, \\quad \\lambda^{(11)} = -4.140$$迭代约 30 次后收敛。\n最终结果：\n模最大特征值：$\\lambda = -4.2$ （两位有效数字）\n对应特征向量：$v = \\begin{pmatrix} 0.040 \\\\ -0.166 \\\\ 0.985 \\end{pmatrix}$ （三位有效数字）\n验证： 使用 NumPy 计算得矩阵所有特征值为 $\\lambda_1 \\approx 2.546$，$\\lambda_2 \\approx -0.377$，$\\lambda_3 \\approx -4.169$，确认 $|\\lambda_3|$ 最大，幂法结果正确。\n习题 5：反幂法求模最小特征值 题目：利用反幂法求解矩阵\n$$A = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \\\\ 1 \u0026 2 \u0026 1 \\\\ 0 \u0026 1 \u0026 -4 \\end{pmatrix}$$模最小的特征值与对应的特征向量。（可编程计算结果，特征值答案保留两位有效数字，特征向量答案保留三位有效数字）\n解：\n反幂法迭代：\n反幂法通过求解线性方程组 $Av^{(k)} = v^{(k-1)}$ 并归一化来迭代，收敛到模最小特征值对应的特征向量。\n取初始向量 $v^{(0)} = \\frac{1}{\\sqrt{3}}\\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 0.577 \\\\ 0.577 \\\\ 0.577 \\end{pmatrix}$。\n主要迭代过程：\n迭代 1：\n求解 $Ax = v^{(0)}$ 得 $x = \\begin{pmatrix} -0.577 \\\\ 0.577 \\\\ 0 \\end{pmatrix}$，归一化后\n$$v^{(1)} = \\begin{pmatrix} -0.707 \\\\ 0.707 \\\\ 0 \\end{pmatrix}, \\quad \\lambda^{(1)} = 0$$迭代 2：\n$$v^{(2)} = \\begin{pmatrix} 0.953 \\\\ -0.293 \\\\ -0.073 \\end{pmatrix}, \\quad \\lambda^{(2)} = -0.366$$迭代 3：\n$$v^{(3)} = \\begin{pmatrix} -0.928 \\\\ 0.360 \\\\ 0.097 \\end{pmatrix}, \\quad \\lambda^{(3)} = -0.377$$迭代 5：\n$$v^{(5)} = \\begin{pmatrix} -0.931 \\\\ 0.351 \\\\ 0.097 \\end{pmatrix}, \\quad \\lambda^{(5)} = -0.377$$迭代约 11 次后收敛。\n最终结果：\n模最小特征值：$\\lambda = -0.38$ （两位有效数字）\n对应特征向量：$v = \\begin{pmatrix} 0.931 \\\\ -0.351 \\\\ -0.097 \\end{pmatrix}$ （三位有效数字）\n验证： 使用 NumPy 计算得矩阵所有特征值为 $\\lambda_1 \\approx 2.546$，$\\lambda_2 \\approx -0.377$，$\\lambda_3 \\approx -4.169$，确认 $|\\lambda_2|$ 最小，反幂法结果正确。残差 $\\|Av - \\lambda v\\| \\approx 1.25 \\times 10^{-16}$。\n习题 6：原点位移法求全部特征值 题目：利用原点位移法求解矩阵\n$$A = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \\\\ 1 \u0026 2 \u0026 1 \\\\ 0 \u0026 1 \u0026 -4 \\end{pmatrix}$$全部特征值与对应的特征向量。（可编程计算结果，特征值答案保留两位有效数字，特征向量答案保留三位有效数字）\n解：\n求解策略：\n原点位移法通过选择不同的位移参数 $\\mu$，利用 $A - \\mu I$ 的特征值为 $\\lambda - \\mu$ 的性质，结合幂法和反幂法求得全部特征值。\n第一步：幂法求模最大特征值\n对 $A$ 使用标准幂法，收敛得：\n$$\\lambda_3 = -4.169, \\quad v_3 = \\begin{pmatrix} 0.040 \\\\ -0.166 \\\\ 0.985 \\end{pmatrix}$$第二步：反幂法求模最小特征值\n对 $A$ 使用反幂法，收敛得：\n$$\\lambda_2 = -0.377, \\quad v_2 = \\begin{pmatrix} 0.931 \\\\ -0.351 \\\\ -0.097 \\end{pmatrix}$$第三步：带位移反幂法求中间特征值\n选择位移 $\\mu = 2.5$（接近估计的中间特征值），对 $A - 2.5I$ 使用反幂法。取初始向量 $v^{(0)} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}$，迭代 6 次后收敛得：\n$$\\lambda_1 = 2.546, \\quad v_1 = \\begin{pmatrix} 0.362 \\\\ 0.921 \\\\ 0.141 \\end{pmatrix}$$最终结果汇总（按从大到小排序）：\n特征值（两位有效数字） 特征向量（三位有效数字） 残差 $\\lambda_1 = 2.5$ $\\begin{pmatrix} 0.362 \\\\ 0.921 \\\\ 0.141 \\end{pmatrix}$ $2.10 \\times 10^{-11}$ $\\lambda_2 = -0.38$ $\\begin{pmatrix} 0.931 \\\\ -0.351 \\\\ -0.097 \\end{pmatrix}$ $1.25 \\times 10^{-16}$ $\\lambda_3 = -4.2$ $\\begin{pmatrix} 0.040 \\\\ -0.166 \\\\ 0.985 \\end{pmatrix}$ $\u003c 10^{-16}$ 所有残差 $\\|Av_i - \\lambda_i v_i\\|$ 均在数值误差范围内，验证结果正确。\n习题 7：Gerschgorin 圆盘定理与条件数 题目：设\n$$A = \\begin{pmatrix} 5 \u0026 -1 \u0026 1 \\\\ -1 \u0026 2 \u0026 0 \\\\ 1 \u0026 0 \u0026 3 \\end{pmatrix}$$记 $\\Lambda(A) = \\{\\lambda_1, \\lambda_2, \\lambda_3\\} \\subseteq \\mathbb{C}$ 且 $|\\lambda_1| \\geq |\\lambda_2| \\geq |\\lambda_3|$。\n(1) 使用 Gerschgorin 圆盘定理，证明 $\\frac{|\\lambda_1|}{|\\lambda_3|} \\leq 7$。\n(2) （编程题）使用幂法与反幂法计算 $\\frac{|\\lambda_1|}{|\\lambda_3|}$\n(1) Gerschgorin 圆盘定理证明 证明：\nGerschgorin 圆盘定理：矩阵 $A$ 的所有特征值都位于 Gerschgorin 圆盘的并集中，第 $i$ 个圆盘定义为：\n$$D_i = \\{z \\in \\mathbb{C} : |z - a_{ii}| \\leq R_i\\}, \\quad R_i = \\sum_{j\\neq i} |a_{ij}|$$对于矩阵 $A = \\begin{pmatrix} 5 \u0026 -1 \u0026 1 \\\\ -1 \u0026 2 \u0026 0 \\\\ 1 \u0026 0 \u0026 3 \\end{pmatrix}$：\n$$D_1: a_{11} = 5, \\; R_1 = |-1| + |1| = 2 \\quad \\Rightarrow \\quad z \\in [3, 7]$$$$D_2: a_{22} = 2, \\; R_2 = |-1| + |0| = 1 \\quad \\Rightarrow \\quad z \\in [1, 3]$$$$D_3: a_{33} = 3, \\; R_3 = |1| + |0| = 1 \\quad \\Rightarrow \\quad z \\in [2, 4]$$所有特征值 $\\lambda \\in D_1 \\cup D_2 \\cup D_3 = [1, 7]$。因为 $A$ 是实对称矩阵，所有特征值都是实数且为正。\n从圆盘分析得：$|\\lambda_1| \\leq 7$，$|\\lambda_3| \\geq 1$，因此：\n$$\\kappa(A) = \\frac{|\\lambda_1|}{|\\lambda_3|} \\leq \\frac{7}{1} = 7 \\quad \\square$$(2) 幂法与反幂法计算条件数 解：\n通过编程实现幂法和反幂法，迭代计算如下：\n幂法求 $\\lambda_{\\max}$ 的前 5 步迭代：\n迭代次数 特征值估计 1 4.880952 2 5.475970 3 5.612480 4 5.642355 5 5.649083 收敛于第 32 步，得 $\\lambda_{\\max} = 5.6510934089$\n反幂法求 $\\lambda_{\\min}$ 的前 5 步迭代：\n迭代次数 特征值估计 1 2.126100 2 1.769336 3 1.671936 4 1.640106 5 1.628943 收敛于第 44 步，得 $\\lambda_{\\min} = 1.6227971460$\n条件数计算：\n$$\\kappa(A) = \\frac{|\\lambda_{\\max}|}{|\\lambda_{\\min}|} = \\frac{5.6510934089}{1.6227971460} = 3.4823165808$$保留两位有效数字：$\\kappa(A) \\approx 3.48$\n验证：\n$$\\kappa(A) = 3.48 \u003c 7 \\quad \\checkmark$$这验证了 Gerschgorin 圆盘定理给出的上界估计是正确的。实际条件数远小于理论上界 7，说明理论估计较为保守但有效。\n作业五 习题 1：梯度计算 题目：构建模型使得预测值与真实值的误差最小常用向量 2-范数度量，求解模型过程中需要计算梯度，求梯度：\n(1) $f(A) = \\frac{1}{2}\\|Ax + b - y\\|_2^2$，求 $\\frac{\\partial f}{\\partial A}$\n(2) $f(x) = \\frac{1}{2}\\|Ax + b - y\\|_2^2$，求 $\\frac{\\partial f}{\\partial x}$\n其中 $A \\in \\mathbb{R}^{m\\times n}$，$x \\in \\mathbb{R}^n$，$b, y \\in \\mathbb{R}^m$\n解：\n(1) 关于 $A$ 的梯度\n展开目标函数：\n$$f(A) = \\frac{1}{2}\\|Ax + b - y\\|_2^2 = \\frac{1}{2}(Ax + b - y)^T(Ax + b - y)$$$$= \\frac{1}{2}(x^TA^TAx + 2(b-y)^TAx + (b-y)^T(b-y))$$由于 $(b-y)^T(b-y)$ 是常数，对 $A$ 求导后为零：\n$$\\frac{\\partial f}{\\partial A} = \\frac{\\partial}{\\partial A}\\frac{1}{2}(x^TA^TAx + 2(b-y)^TAx)$$利用矩阵求导公式：\n$\\frac{\\partial x^TA^TAx}{\\partial A} = 2Axx^T$ $\\frac{\\partial (b-y)^TAx}{\\partial A} = (b-y)x^T$ 因此：\n$$\\boxed{\\frac{\\partial f}{\\partial A} = Axx^T + (b-y)x^T}$$(2) 关于 $x$ 的梯度\n同样展开目标函数，对 $x$ 求导：\n$$\\frac{\\partial f}{\\partial x} = \\frac{\\partial}{\\partial x}\\frac{1}{2}(x^TA^TAx + 2(b-y)^TAx + (b-y)^T(b-y))$$利用矩阵求导公式：\n$\\frac{\\partial x^TA^TAx}{\\partial x} = 2A^TAx$ $\\frac{\\partial (b-y)^TAx}{\\partial x} = A^T(b-y)$ 因此：\n$$\\boxed{\\frac{\\partial f}{\\partial x} = A^TAx + A^T(b-y)}$$ 习题 2：二次型的梯度 题目：二次型是数据分析中常用函数，求 $\\frac{\\partial x^TAx}{\\partial x}$，$\\frac{\\partial x^TAx}{\\partial A}$，其中 $A \\in \\mathbb{R}^{m\\times m}$，$x \\in \\mathbb{R}^m$\n解：\n(1) 关于 $x$ 的梯度\n对于二次型 $x^TAx$，利用矩阵微分的性质：\n$$d(x^TAx) = (dx)^TAx + x^TAdx = x^TA^Tdx + x^TAdx = x^T(A + A^T)dx$$因此：\n$$\\boxed{\\frac{\\partial x^TAx}{\\partial x} = (A + A^T)x}$$注：当 $A$ 为对称矩阵时，$\\frac{\\partial x^TAx}{\\partial x} = 2Ax$\n(2) 关于 $A$ 的梯度\n对于二次型 $x^TAx = \\sum_{i,j} x_i A_{ij} x_j$，对 $A_{ij}$ 求偏导：\n$$\\frac{\\partial x^TAx}{\\partial A_{ij}} = x_ix_j$$因此，梯度矩阵的第 $(i,j)$ 元素为 $x_ix_j$，即：\n$$\\boxed{\\frac{\\partial x^TAx}{\\partial A} = xx^T}$$ 习题 3：迹微分法求梯度 题目：利用迹微分法求解 $\\frac{\\partial \\text{tr}(W^{-1})}{\\partial W}$，其中 $W \\in \\mathbb{R}^{m\\times m}$\n解：\n首先计算 $W^{-1}$ 的微分。由恒等式 $WW^{-1} = I$，两边取微分：\n$$d(WW^{-1}) = dW \\cdot W^{-1} + W \\cdot dW^{-1} = dI = 0$$因此：\n$$W \\cdot dW^{-1} = -dW \\cdot W^{-1}$$两边左乘 $W^{-1}$：\n$$dW^{-1} = -W^{-1}dW \\cdot W^{-1}$$现在计算迹的微分：\n$$d\\,\\text{tr}(W^{-1}) = \\text{tr}(dW^{-1}) = \\text{tr}(-W^{-1}dW \\cdot W^{-1})$$利用迹的循环性质 $\\text{tr}(ABC) = \\text{tr}(CAB)$：\n$$d\\,\\text{tr}(W^{-1}) = \\text{tr}(-(W^{-1})^2dW) = \\text{tr}(-(W^{-T})^2 dW)$$因此：\n$$\\boxed{\\frac{\\partial \\text{tr}(W^{-1})}{\\partial W} = -(W^{-T})^2 = -(W^{-1})^T(W^{-1})^T}$$ 习题 4：Softmax 函数的梯度 题目：$(\\exp(z))_i = \\exp(z_i)$，$(\\log(z))_i = \\log(z_i)$，$f(z) = \\frac{\\exp(z)}{\\mathbf{1}^T\\exp(z)}$ 称为 softmax 函数，如果 $q = f(z)$，$J = -p^T\\log(q)$，其中 $p, q, z \\in \\mathbb{R}^n$，并且 $\\mathbf{1}^Tp = 1$，\n(1) 证明：$\\frac{\\partial J}{\\partial z} = q - p$\n(2) 若 $z = Wx$，其中 $W \\in \\mathbb{R}^{n\\times m}$，$x \\in \\mathbb{R}^m$，$\\frac{\\partial J}{\\partial W} = (q - p)x^T$ 是否成立。\n解：\n(1) 证明关于 $z$ 的梯度\n将损失函数展开：\n$$J = -p^T\\log(q) = -p^T\\log\\left(\\frac{\\exp(z)}{\\mathbf{1}^T\\exp(z)}\\right)$$$$= -p^T\\log(\\exp(z)) + p^T\\log(\\mathbf{1}^T\\exp(z))\\mathbf{1}$$$$= -p^Tz + p^T\\mathbf{1}\\log(\\mathbf{1}^T\\exp(z))$$由于 $p^T\\mathbf{1} = 1$（概率分布的归一化条件）：\n$$J = -p^Tz + \\log(\\mathbf{1}^T\\exp(z))$$对 $z$ 求导：\n$$\\frac{\\partial J}{\\partial z} = -p + \\frac{\\partial \\log(\\mathbf{1}^T\\exp(z))}{\\partial z}$$$$= -p + \\frac{1}{\\mathbf{1}^T\\exp(z)} \\cdot \\frac{\\partial (\\mathbf{1}^T\\exp(z))}{\\partial z}$$$$= -p + \\frac{\\exp(z)}{\\mathbf{1}^T\\exp(z)}$$$$= -p + q$$因此：\n$$\\boxed{\\frac{\\partial J}{\\partial z} = q - p}$$(2) 证明关于 $W$ 的梯度\n利用链式法则和迹微分法：\n$$dJ = d\\,\\text{tr}(J) = \\text{tr}(dJ)$$由 $z = Wx$，有 $dz = dW \\cdot x$，因此：\n$$dJ = \\text{tr}\\left[\\left(\\frac{\\partial J}{\\partial z}\\right)^T dz\\right] = \\text{tr}[(q-p)^T dW \\cdot x]$$利用迹的性质 $\\text{tr}(ABC) = \\text{tr}(CAB)$：\n$$dJ = \\text{tr}[x(q-p)^T dW]$$因此：\n$$\\boxed{\\frac{\\partial J}{\\partial W} = (q-p)x^T \\quad \\text{成立}}$$ 习题 5：多元正态分布的极大似然估计 题目：以下内容是利用极大似然估计求解多元正态分布模型的关键步骤：\n$$L = -\\frac{Nd}{2}\\ln(2\\pi) - \\frac{N}{2}\\ln|\\Sigma| - \\frac{1}{2}\\sum_{t=1}^N (x_t - \\mu)^T\\Sigma^{-1}(x_t - \\mu)$$$L$ 是对数似然，$N$ 为样本数，$d$ 为样本维数，$\\Sigma \\in \\mathbb{R}^{d\\times d}$ 为协方差矩阵，$\\mu \\in \\mathbb{R}^d$ 为期望向量。\n(1) 求 $\\frac{\\partial L}{\\partial \\mu}$\n(2) 当 $\\mu = \\frac{1}{N}\\sum_{t=1}^N x_t$ 时，求 $\\frac{\\partial L}{\\partial \\Sigma}$，并求使 $\\frac{\\partial L}{\\partial \\Sigma} = 0$ 成立的 $\\Sigma$。\n解：\n(1) 关于 $\\mu$ 的梯度\n对数似然中只有第三项与 $\\mu$ 相关：\n$$\\frac{\\partial L}{\\partial \\mu} = \\frac{\\partial}{\\partial \\mu}\\left[-\\frac{1}{2}\\sum_{t=1}^N (x_t - \\mu)^T\\Sigma^{-1}(x_t - \\mu)\\right]$$对每一项求导：\n$$\\frac{\\partial}{\\partial \\mu}(x_t - \\mu)^T\\Sigma^{-1}(x_t - \\mu) = -2\\Sigma^{-1}(x_t - \\mu)$$因此：\n$$\\boxed{\\frac{\\partial L}{\\partial \\mu} = \\sum_{t=1}^N \\Sigma^{-1}(x_t - \\mu)}$$令 $\\frac{\\partial L}{\\partial \\mu} = 0$，得 $\\mu = \\frac{1}{N}\\sum_{t=1}^N x_t$（样本均值）。\n(2) 关于 $\\Sigma$ 的梯度\n使用迹微分法，将对数似然写成迹的形式：\n$$dL = d\\left[-\\frac{N}{2}\\ln|\\Sigma|\\right] - d\\left[\\frac{1}{2}\\sum_{t=1}^N (x_t-\\mu)^T\\Sigma^{-1}(x_t-\\mu)\\right]$$第一项：\n$$d\\left[-\\frac{N}{2}\\ln|\\Sigma|\\right] = -\\frac{N}{2}d[\\ln|\\Sigma|] = -\\frac{N}{2}\\text{tr}[\\Sigma^{-1}d\\Sigma]$$第二项：\n$$d\\left[\\frac{1}{2}\\sum_{t=1}^N (x_t-\\mu)^T\\Sigma^{-1}(x_t-\\mu)\\right] = \\frac{1}{2}d\\,\\text{tr}\\left[\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T\\Sigma^{-1}\\right]$$$$= \\frac{1}{2}\\text{tr}\\left[\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T d(\\Sigma^{-1})\\right]$$利用 $d\\Sigma^{-1} = -\\Sigma^{-1}(d\\Sigma)\\Sigma^{-1}$：\n$$= \\frac{1}{2}\\text{tr}\\left[\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T(-\\Sigma^{-1}d\\Sigma \\cdot \\Sigma^{-1})\\right]$$$$= -\\frac{1}{2}\\text{tr}\\left[\\Sigma^{-1}\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T\\Sigma^{-1}d\\Sigma\\right]$$综合两项：\n$$dL = \\text{tr}\\left[\\left(-\\frac{N}{2}\\Sigma^{-1} + \\frac{1}{2}\\Sigma^{-1}\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T\\Sigma^{-1}\\right)d\\Sigma\\right]$$因此：\n$$\\boxed{\\frac{\\partial L}{\\partial \\Sigma} = -\\frac{N}{2}\\Sigma^{-1} + \\frac{1}{2}\\Sigma^{-1}\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T\\Sigma^{-1}}$$令 $\\frac{\\partial L}{\\partial \\Sigma} = 0$：\n$$N\\Sigma^{-1} = \\Sigma^{-1}\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T\\Sigma^{-1}$$两边左乘 $\\Sigma$，右乘 $\\Sigma$：\n$$N\\Sigma = \\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T$$因此：\n$$\\boxed{\\Sigma = \\frac{1}{N}\\sum_{t=1}^N (x_t-\\mu)(x_t-\\mu)^T}$$这就是样本协方差矩阵的极大似然估计。\n习题 6：互信息的化简 题目：（互信息）假设 $X_1 \\to X_2 \\to X_3 \\to \\cdots \\to X_n$ 是一个马尔科夫链，即\n$$p(x_1, x_2, \\ldots, x_n) = p(x_1)p(x_2|x_1)\\cdots p(x_n|x_{n-1})$$试化简 $I(X_1; X_2, \\ldots, X_n)$\n解：\n互信息定义为：\n$$I(X_1; X_2, \\ldots, X_n) = H(X_1) - H(X_1 | X_2, \\ldots, X_n)$$利用条件熵的性质：\n$$= H(X_1) - [H(X_1, X_2, \\ldots, X_n) - H(X_2, \\ldots, X_n)]$$对于马尔科夫链，联合熵可以分解为：\n$$H(X_1, X_2, \\ldots, X_n) = \\sum_{i=1}^n H(X_i|X_{i-1},\\ldots,X_1)$$其中 $H(X_1|X_0,\\ldots) = H(X_1)$。由马尔科夫性质：\n$$H(X_i|X_{i-1},\\ldots,X_1) = H(X_i|X_{i-1})$$类似地：\n$$H(X_2, \\ldots, X_n) = \\sum_{i=2}^n H(X_i|X_{i-1},\\ldots,X_2)$$代入得：\n$$I(X_1; X_2, \\ldots, X_n) = H(X_1) - \\left[\\left(H(X_1) + \\sum_{i=2}^n H(X_i|X_{i-1})\\right) - \\left(H(X_2) + \\sum_{i=3}^n H(X_i|X_{i-1})\\right)\\right]$$$$= H(X_1) - H(X_1) - H(X_2|X_1) + H(X_2)$$$$= H(X_2) - H(X_2|X_1)$$$$= I(X_1; X_2)$$因此：\n$$\\boxed{I(X_1; X_2, \\ldots, X_n) = I(X_1; X_2)}$$结论：在马尔科夫链中，$X_1$ 与序列 $(X_2, \\ldots, X_n)$ 的互信息等于 $X_1$ 与 $X_2$ 的互信息，这体现了马尔科夫性质。\n习题 7：KL 散度与最大似然估计 题目：（通过 KL 散度理解 MLE）假设 $x_1, \\ldots, x_n$ 来自密度为 $p(x)$ 的分布 $P$，试说明如果采用具有密度函数 $q_\\theta(x)$ 的分布族 $Q_\\theta$ 来计算 MLE，那么 MLE 将试图找到在 KL 散度意义上最接近真实分布 $P$ 的分布 $Q_\\theta$。\n即证明：\n$$\\arg\\max_\\theta \\prod_{i=1}^n q_\\theta(x_i) \\Leftrightarrow \\arg\\min_\\theta D_{KL}(P \\| Q_\\theta)$$证明：\n从最大似然估计出发：\n$$\\arg\\max_\\theta \\prod_{i=1}^n q_\\theta(x_i) \\Leftrightarrow \\arg\\max_\\theta \\sum_{i=1}^n \\log q_\\theta(x_i)$$$$\\Leftrightarrow \\arg\\min_\\theta -\\frac{1}{n}\\sum_{i=1}^n \\log q_\\theta(x_i)$$当样本量 $n \\to \\infty$ 时，根据大数定律：\n$$-\\frac{1}{n}\\sum_{i=1}^n \\log q_\\theta(x_i) \\xrightarrow{P} -\\mathbb{E}_P[\\log q_\\theta(x)]$$$$= -\\int p(x)\\log q_\\theta(x)dx$$这正是交叉熵 $H(P, Q_\\theta)$ 的定义。因此：\n$$\\arg\\min_\\theta -\\mathbb{E}_P[\\log q_\\theta(x)] \\Leftrightarrow \\arg\\min_\\theta H(P, Q_\\theta)$$由于真实分布 $P$ 的熵 $H(P)$ 是常数（不依赖于 $\\theta$）：\n$$\\arg\\min_\\theta H(P, Q_\\theta) \\Leftrightarrow \\arg\\min_\\theta [H(P, Q_\\theta) - H(P)]$$而 KL 散度定义为：\n$$D_{KL}(P \\| Q_\\theta) = \\int p(x)\\log \\frac{p(x)}{q_\\theta(x)}dx$$$$= \\int p(x)\\log p(x)dx - \\int p(x)\\log q_\\theta(x)dx$$$$= H(P) + H(P, Q_\\theta)$$等价于：\n$$H(P, Q_\\theta) - H(P) = -\\int p(x)\\log q_\\theta(x)dx + \\int p(x)\\log p(x)dx = D_{KL}(P \\| Q_\\theta)$$因此：\n$$\\boxed{\\arg\\max_\\theta \\prod_{i=1}^n q_\\theta(x_i) \\Leftrightarrow \\arg\\min_\\theta D_{KL}(P \\| Q_\\theta)}$$结论：从优化模型参数的角度来说，最小化负对数似然、交叉熵（多分类问题）和 KL 散度这三种方式是等价的。MLE 实际上是在寻找与真实分布 KL 散度最小的模型分布。\n作业六 习题 1：贝叶斯推断求后验分布 题目：假设总体 $X \\sim N(\\mu, \\sigma^2)$（$\\sigma^2$ 已知），$X_1, X_2, \\ldots, X_n$ 为来自总体 $X$ 的样本，由过去的经验和知识，我们可以确定 $\\mu$ 的取值比较集中在 $\\mu_0$ 附近，离 $\\mu_0$ 越远，$\\mu$ 取值的可能性越小，于是我们假定 $\\mu$ 的先验分布为正态分布\n$$\\pi(\\mu) = \\frac{1}{\\sqrt{2\\pi\\sigma_\\mu^2}} \\exp\\left[-\\frac{1}{2\\sigma_\\mu^2}(\\mu - \\mu_0)^2\\right] \\quad (\\mu_0, \\sigma_\\mu \\text{ 已知})$$求 $\\mu$ 的后验概率分布。\n解：\n根据贝叶斯定理，后验分布正比于似然函数与先验分布的乘积。\n似然函数：\n给定 $\\mu$，样本 $x_1, \\ldots, x_n$ 的联合密度函数为：\n$$q(x | \\mu) = \\prod_{i=1}^n \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left[-\\frac{1}{2\\sigma^2}(x_i - \\mu)^2\\right]$$$$= \\frac{1}{\\sigma^n(2\\pi)^{n/2}} \\exp\\left[-\\frac{1}{2\\sigma^2}\\sum_{i=1}^n(x_i - \\mu)^2\\right]$$后验密度函数：\n$$h(\\mu | x) = \\frac{q(x | \\mu) \\cdot \\pi(\\mu)}{f_x(x)} \\propto q(x | \\mu) \\cdot \\pi(\\mu)$$$$\\propto \\exp\\left[-\\frac{1}{2\\sigma^2}\\sum_{i=1}^n(x_i - \\mu)^2\\right] \\cdot \\exp\\left[-\\frac{1}{2\\sigma_\\mu^2}(\\mu - \\mu_0)^2\\right]$$合并指数项：\n$$h(\\mu | x) \\propto \\exp\\left[-\\frac{1}{2}\\left(\\frac{\\sum_{i=1}^n(x_i - \\mu)^2}{\\sigma^2} + \\frac{(\\mu - \\mu_0)^2}{\\sigma_\\mu^2}\\right)\\right]$$展开平方项：\n$$\\sum_{i=1}^n(x_i - \\mu)^2 = \\sum_{i=1}^n x_i^2 - 2\\mu\\sum_{i=1}^n x_i + n\\mu^2 = n(\\mu - \\bar{x})^2 + \\text{常数}$$因此指数项中关于 $\\mu$ 的部分为：\n$$-\\frac{1}{2}\\left[\\frac{n}{\\sigma^2}(\\mu - \\bar{x})^2 + \\frac{1}{\\sigma_\\mu^2}(\\mu - \\mu_0)^2\\right]$$$$= -\\frac{1}{2}\\left[\\left(\\frac{n}{\\sigma^2} + \\frac{1}{\\sigma_\\mu^2}\\right)\\mu^2 - 2\\mu\\left(\\frac{n\\bar{x}}{\\sigma^2} + \\frac{\\mu_0}{\\sigma_\\mu^2}\\right) + \\text{常数}\\right]$$配方得：\n$$h(\\mu | x) \\propto \\exp\\left[-\\frac{(\\mu - t)^2}{2\\eta^2}\\right]$$其中：\n$$t = \\frac{\\frac{n}{\\sigma^2}\\bar{x} + \\frac{1}{\\sigma_\\mu^2}\\mu_0}{\\frac{n}{\\sigma^2} + \\frac{1}{\\sigma_\\mu^2}}, \\quad \\eta^2 = \\frac{1}{\\frac{n}{\\sigma^2} + \\frac{1}{\\sigma_\\mu^2}}$$因此，后验分布为：\n$$\\boxed{\\mu | x \\sim N\\left(\\frac{\\frac{n}{\\sigma^2}\\bar{x} + \\frac{1}{\\sigma_\\mu^2}\\mu_0}{\\frac{n}{\\sigma^2} + \\frac{1}{\\sigma_\\mu^2}}, \\frac{1}{\\frac{n}{\\sigma^2} + \\frac{1}{\\sigma_\\mu^2}}\\right)}$$解释：后验均值是样本均值和先验均值的加权平均，权重由各自的精度（方差的倒数）决定。\n习题 2：Gauss 累积分布函数的对数凹性 题目：证明：Gauss 概率密度函数的累积分布函数\n$$\\Phi(x) = \\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^x e^{-u^2/2}du$$是对数-凹函数，即 $\\log(\\Phi(x))$ 是凹函数。\n证明：\n要证明 $\\log(\\Phi(x))$ 是凹函数，需要证明其二阶导数非正，即：\n$$\\frac{d^2}{dx^2}\\log(\\Phi(x)) \\leq 0$$等价于证明：\n$$\\Phi(x)\\Phi''(x) \\leq [\\Phi'(x)]^2$$计算导数：\n$$\\Phi'(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}$$$$\\Phi''(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}(-x) = -x\\Phi'(x)$$$$[\\Phi'(x)]^2 = \\frac{1}{2\\pi}e^{-x^2}$$情况 1：$x \\geq 0$\n当 $x \\geq 0$ 时，$\\Phi''(x) = -x\\Phi'(x) \\leq 0$，而 $\\Phi(x) \u003e 0$，$[\\Phi'(x)]^2 \\geq 0$，因此：\n$$\\Phi(x)\\Phi''(x) \\leq 0 \\leq [\\Phi'(x)]^2$$情况 2：$x \u003c 0$\n当 $x \u003c 0$ 时，需要证明：\n$$\\Phi(x) \\cdot (-x) \\leq \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}$$即：\n$$\\int_{-\\infty}^x e^{-u^2/2}du \\leq \\frac{e^{-x^2/2}}{-x}$$由于 $\\frac{u^2}{2}$ 是凸函数，对任意 $u \u003c x \u003c 0$，有：\n$$\\frac{u^2}{2} \\geq \\frac{x^2}{2} + (u-x)x = xu - \\frac{x^2}{2}$$因此：\n$$e^{-u^2/2} \\leq e^{-xu + x^2/2}$$积分得：\n$$\\int_{-\\infty}^x e^{-u^2/2}du \\leq \\int_{-\\infty}^x e^{x^2/2-xu}du$$$$= e^{x^2/2} \\int_{-\\infty}^x e^{-xu}du = e^{x^2/2} \\cdot \\frac{e^{-xu}}{-x}\\bigg|_{u=-\\infty}^x$$$$= e^{x^2/2} \\cdot \\frac{e^{-x^2}}{-x} = \\frac{e^{-x^2/2}}{-x}$$因此 $\\Phi(x)\\Phi''(x) \\leq [\\Phi'(x)]^2$ 对 $x \u003c 0$ 也成立。\n综上所述，$\\Phi(x)$ 是对数凹函数。 $\\square$\n习题 3：共轭函数的计算 题目：计算函数 $f(x)$ 的共轭函数，以及共轭函数的定义域。\n(1) $f(x) = -\\log x$\n(2) $f(x) = e^x$\n解：\n共轭函数定义为：\n$$f^*(y) = \\sup_x (xy - f(x))$$(1) $f(x) = -\\log x$ 定义域 $\\text{dom}(f) = \\{x|x \u003e 0\\}$。\n对于给定的 $y$，求 $g(x) = xy + \\log x$ 的上确界。\n求导：$g'(x) = y + \\frac{1}{x}$\n当 $y \\geq 0$ 时，$g'(x) \u003e 0$ 恒成立，函数单调递增，无上界 当 $y \u003c 0$ 时，令 $g'(x) = 0$ 得 $x = -\\frac{1}{y}$ 此时：\n$$g\\left(-\\frac{1}{y}\\right) = -\\frac{1}{y} \\cdot y + \\log\\left(-\\frac{1}{y}\\right) = -1 - \\log(-y)$$因此：\n$$\\boxed{f^*(y) = \\begin{cases} -\\log(-y) - 1, \u0026 y \u003c 0 \\\\ +\\infty, \u0026 y \\geq 0 \\end{cases}}$$定义域：$\\text{dom}(f^*) = \\{y | y \u003c 0\\}$\n(2) $f(x) = e^x$ 定义域 $\\text{dom}(f) = \\mathbb{R}$。\n对于给定的 $y$，求 $g(x) = xy - e^x$ 的上确界。\n求导：$g'(x) = y - e^x$\n当 $y \\leq 0$ 时，$g'(x) \u003c 0$ 恒成立，函数单调递减，无上界（趋于 $-\\infty$ 时） 当 $y \u003e 0$ 时，令 $g'(x) = 0$ 得 $x = \\log y$ 此时：\n$$g(\\log y) = y\\log y - e^{\\log y} = y\\log y - y$$ 当 $y = 0$ 时：$f^*(0) = \\sup_x(-e^x) = 0$（当 $x \\to -\\infty$ 时） 因此：\n$$\\boxed{f^*(y) = \\begin{cases} y\\log y - y, \u0026 y \u003e 0 \\\\ 0, \u0026 y = 0 \\\\ +\\infty, \u0026 y \u003c 0 \\end{cases}}$$定义域：$\\text{dom}(f^*) = \\{y | y \\geq 0\\}$（规定 $0\\log 0 = 0$）\n习题 4：KKT 条件的应用 题目：写出下述非线性规划的 KKT 条件并求解\n(1) $\\max f(x) = (x - 3)^2$ subject to $1 \\leq x \\leq 5$\n(2) $\\min f(x) = (x - 3)^2$ subject to $1 \\leq x \\leq 5$\n解：\n(1) 最大化问题 将最大化问题转化为最小化问题：\n$$\\begin{cases} \\text{minimize} \\quad -f(x) = -(x-3)^2 \\\\ g_1(x) = 1 - x \\leq 0 \\\\ g_2(x) = x - 5 \\leq 0 \\end{cases}$$梯度：\n$$\\nabla_x[-f(x)] = -2(x-3), \\quad \\nabla_x g_1(x) = -1, \\quad \\nabla_x g_2(x) = 1$$KKT 条件：\n$$\\begin{cases} -2(x^* - 3) - v_1^* + v_2^* = 0 \u0026 \\text{(稳定性)} \\\\ v_1^*(1 - x^*) = 0 \u0026 \\text{(互补松弛性)} \\\\ v_2^*(x^* - 5) = 0 \u0026 \\text{(互补松弛性)} \\\\ v_1^* \\geq 0, \\quad v_2^* \\geq 0 \u0026 \\text{(对偶可行性)} \\\\ 1 \\leq x^* \\leq 5 \u0026 \\text{(原始可行性)} \\end{cases}$$情况分析：\n情况 i： $v_1^* = 0, v_2^* = 0$\n由稳定性条件：$-2(x^* - 3) = 0$，得 $x^* = 3$\n此时 $f(x^*) = 0$\n情况 ii： $v_1^* \u003e 0, v_2^* = 0$\n由互补松弛性：$x^* = 1$\n由稳定性条件：$-2(1-3) - v_1^* = 0$，得 $v_1^* = 4 \u003e 0$ ✓\n此时 $f(x^*) = 4$\n情况 iii： $v_1^* = 0, v_2^* \u003e 0$\n由互补松弛性：$x^* = 5$\n由稳定性条件：$-2(5-3) + v_2^* = 0$，得 $v_2^* = 4 \u003e 0$ ✓\n此时 $f(x^*) = 4$\n情况 iv： $v_1^* \u003e 0, v_2^* \u003e 0$\n由互补松弛性：$x^* = 1$ 且 $x^* = 5$，矛盾\n结论：\n$$\\boxed{x^* = 1 \\text{ 或 } x^* = 5, \\quad \\max f(x) = 4}$$(2) 最小化问题 $$\\begin{cases} \\text{minimize} \\quad f(x) = (x-3)^2 \\\\ g_1(x) = 1 - x \\leq 0 \\\\ g_2(x) = x - 5 \\leq 0 \\end{cases}$$梯度：\n$$\\nabla_x f(x) = 2(x-3)$$KKT 条件：\n$$\\begin{cases} 2(x^* - 3) - v_1^* + v_2^* = 0 \\\\ v_1^*(1 - x^*) = 0 \\\\ v_2^*(x^* - 5) = 0 \\\\ v_1^* \\geq 0, \\quad v_2^* \\geq 0 \\\\ 1 \\leq x^* \\leq 5 \\end{cases}$$情况分析：\n情况 i： $v_1^* = 0, v_2^* = 0$\n由稳定性条件：$2(x^* - 3) = 0$，得 $x^* = 3$\n此时 $f(x^*) = 0$ ✓\n情况 ii： $v_1^* \u003e 0, v_2^* = 0$\n$x^* = 1$，$2(1-3) - v_1^* = 0$，得 $v_1^* = -4 \u003c 0$ ✗\n情况 iii： $v_1^* = 0, v_2^* \u003e 0$\n$x^* = 5$，$2(5-3) + v_2^* = 0$，得 $v_2^* = -4 \u003c 0$ ✗\n结论：\n$$\\boxed{x^* = 3, \\quad \\min f(x) = 0}$$ 习题 5：Lagrange 乘子法证明矩阵 2-范数 题目：用 Lagrange 乘子法证明：矩阵 $A \\in \\mathbb{R}^{m\\times n}$ 的 2-范数\n$$\\|A\\|_2 = \\max_{\\|x\\|_2 = 1, x \\in \\mathbb{R}^n} \\|Ax\\|_2$$的平方是 $A^TA$ 的最大特征值。\n证明：\n优化问题为：\n$$\\text{maximize} \\quad f(x) = \\|Ax\\|_2^2 = x^TA^TAx \\quad \\text{subject to} \\quad x^Tx = 1$$Lagrange 函数：\n$$L(x, \\lambda) = x^TA^TAx - \\lambda(x^Tx - 1)$$求梯度并令其为零：\n$$\\frac{\\partial L}{\\partial x} = 2A^TAx - 2\\lambda x = 0$$因此：\n$$A^TAx = \\lambda x$$这说明在极值点 $x^*$ 处，$x^*$ 是 $A^TA$ 的特征向量，$\\lambda$ 是对应的特征值。\n目标函数值：\n$$f(x^*) = (x^*)^TA^TAx^* = (x^*)^T\\lambda x^* = \\lambda(x^*)^Tx^* = \\lambda$$由于我们求的是最大值，因此：\n$$\\|A\\|_2^2 = \\max_{\\|x\\|_2=1} x^TA^TAx = \\lambda_{\\max}(A^TA)$$即：\n$$\\boxed{\\|A\\|_2 = \\sqrt{\\lambda_{\\max}(A^TA)}}$$$\\square$\n习题 6：欠定方程的最小二范数解 题目：用 Lagrange 乘子法求欠定方程 $Ax = b$ 的最小二范数解，其中 $A \\in \\mathbb{R}^{m\\times n}$，$m \\leq n$，$\\text{rank}(A) = m$\n解：\n优化问题为：\n$$\\text{minimize} \\quad f(x) = \\frac{1}{2}\\|x\\|_2^2 = \\frac{1}{2}x^Tx \\quad \\text{subject to} \\quad Ax = b$$Lagrange 函数：\n$$L(x, \\lambda) = \\frac{1}{2}x^Tx - \\lambda^T(Ax - b)$$求梯度并令其为零：\n$$\\frac{\\partial L}{\\partial x} = x - A^T\\lambda = 0$$因此：\n$$x = A^T\\lambda$$代入约束条件：\n$$Ax = b \\Rightarrow A(A^T\\lambda) = b$$$$AA^T\\lambda = b$$由于 $\\text{rank}(A) = m$，矩阵 $AA^T \\in \\mathbb{R}^{m \\times m}$ 是满秩的，因此可逆：\n$$\\lambda = (AA^T)^{-1}b$$最小二范数解：\n$$\\boxed{x^* = A^T(AA^T)^{-1}b}$$验证：\n$Ax^* = AA^T(AA^T)^{-1}b = b$ ✓（满足约束） 可以证明这是所有满足 $Ax = b$ 的解中范数最小的 习题 7：最速下降法 题目：用最速下降法和精确线搜索计算\n$$\\min f(x) = x_1^2 + x_2^2 + x_3^2$$初始点 $x^{(0)} = (2, 2, 1)^T$。当 $|f(x^{(n+1)}) - f(x^{(n)})| \u003c 0.001$ 时迭代终止。\n解：\n目标函数 $f(x) = x^Tx$，梯度 $\\nabla f(x) = 2x$。\n精确线搜索：\n最速下降方向为 $d^{(k)} = -\\nabla f(x^{(k)}) = -2x^{(k)}$\n在该方向上最小化 $f(x^{(k)} + \\lambda d^{(k)})$：\n$$f(x^{(k)} + \\lambda d^{(k)}) = (x^{(k)} - 2\\lambda x^{(k)})^T(x^{(k)} - 2\\lambda x^{(k)})$$$$= (1 - 2\\lambda)^2 (x^{(k)})^Tx^{(k)}$$对 $\\lambda$ 求导并令其为零：\n$$\\frac{d}{d\\lambda}[(1-2\\lambda)^2 (x^{(k)})^Tx^{(k)}] = 2(1-2\\lambda)(-2)(x^{(k)})^Tx^{(k)} = 0$$得 $\\lambda^* = \\frac{1}{2}$\n迭代过程：\n$$x^{(1)} = x^{(0)} + \\frac{1}{2}(-2x^{(0)}) = x^{(0)} - x^{(0)} = 0$$$$f(x^{(1)}) = 0$$$$x^{(2)} = x^{(1)} - x^{(1)} = 0$$$$|f(x^{(1)}) - f(x^{(0)})| = |0 - 9| = 9 \u003e 0.001$$$$|f(x^{(2)}) - f(x^{(1)})| = |0 - 0| = 0 \u003c 0.001$$迭代终止。\n结论：\n$$\\boxed{x^* = (0, 0, 0)^T, \\quad f_{\\min} = 0}$$算法一步即收敛到最优解，这是因为目标函数是简单的二次型，且 Hessian 矩阵为单位矩阵的倍数。\n习题 8：DFP 法求二次函数极小点 题目：试用 DFP 法计算下述二次函数的极小点\n$$\\min f(x) = 3x_1^2 + x_2^2 - 2x_1x_2 - 4x_1$$解：\n选择初始点 $x^{(0)} = (-2, 4)^T$，初始 Hessian 逆近似 $H^{(0)} = I$。\n梯度：\n$$\\nabla f(x) = \\begin{pmatrix} 6x_1 - 2x_2 - 4 \\\\ 2x_2 - 2x_1 \\end{pmatrix}$$第一次迭代 $$\\nabla f(x^{(0)}) = \\begin{pmatrix} 6(-2) - 2(4) - 4 \\\\ 2(4) - 2(-2) \\end{pmatrix} = \\begin{pmatrix} -24 \\\\ 12 \\end{pmatrix}$$搜索方向：\n$$p^{(0)} = -H^{(0)}\\nabla f(x^{(0)}) = -I \\begin{pmatrix} -24 \\\\ 12 \\end{pmatrix} = \\begin{pmatrix} 24 \\\\ -12 \\end{pmatrix}$$精确线搜索： 求 $\\lambda_0 = \\arg\\min_\\lambda f(x^{(0)} + \\lambda p^{(0)})$\n$$f(x^{(0)} + \\lambda p^{(0)}) = 3(-2+24\\lambda)^2 + (4-12\\lambda)^2 - 2(-2+24\\lambda)(4-12\\lambda) - 4(-2+24\\lambda)$$对 $\\lambda$ 求导并令其为零，得：\n$$\\lambda_0 = \\frac{5}{34}$$更新：\n$$x^{(1)} = x^{(0)} + \\lambda_0 p^{(0)} = \\begin{pmatrix} -2 \\\\ 4 \\end{pmatrix} + \\frac{5}{34}\\begin{pmatrix} 24 \\\\ -12 \\end{pmatrix} = \\begin{pmatrix} \\frac{26}{17} \\\\ \\frac{38}{17} \\end{pmatrix}$$$$\\nabla f(x^{(1)}) = \\begin{pmatrix} \\frac{12}{17} \\\\ \\frac{24}{17} \\end{pmatrix}$$DFP 更新公式：\n$$\\Delta x^{(0)} = x^{(1)} - x^{(0)} = \\begin{pmatrix} \\frac{60}{17} \\\\ -\\frac{30}{17} \\end{pmatrix}$$$$\\Delta g^{(0)} = \\nabla f(x^{(1)}) - \\nabla f(x^{(0)}) = \\begin{pmatrix} \\frac{420}{17} \\\\ -\\frac{180}{17} \\end{pmatrix}$$$$H^{(1)} = H^{(0)} + \\frac{\\Delta x^{(0)}(\\Delta x^{(0)})^T}{(\\Delta g^{(0)})^T\\Delta x^{(0)}} - \\frac{H^{(0)}\\Delta g^{(0)}(\\Delta g^{(0)})^TH^{(0)}}{(\\Delta g^{(0)})^TH^{(0)}\\Delta g^{(0)}}$$计算后得：\n$$H^{(1)} = I + \\frac{1}{1800}\\begin{pmatrix} 3600 \u0026 -1800 \\\\ -1800 \u0026 900 \\end{pmatrix} - \\frac{1}{226800}\\begin{pmatrix} 176400 \u0026 -75600 \\\\ -75600 \u0026 32400 \\end{pmatrix}$$第二次迭代 $$p^{(1)} = -H^{(1)}\\nabla f(x^{(1)}) = -\\begin{pmatrix} \\frac{18}{29} \\\\ \\frac{42}{29} \\end{pmatrix}$$精确线搜索得 $\\lambda_1 = \\frac{29}{34}$\n$$x^{(2)} = x^{(1)} + \\lambda_1 p^{(1)} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$$$$\\nabla f(x^{(2)}) = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$$结论：\n$$\\boxed{x^* = (1, 1)^T \\text{ 为极小点}}$$DFP 法对于 $n$ 维二次函数，最多需要 $n$ 步即可收敛到精确解（具有二次终止性）。\n","permalink":"http://localhost:1313/dase-course/math-homework/","summary":"数学基础课程矩阵理论相关作业完整解答","title":"数学基础——数学篇作业集"},{"content":" 论文基本信息 标题: xRWA: A Cross-Chain Framework for Interoperability of Real-World Assets 作者: Yihao Guo, Haoming Zhu, Minghui Xu, Xiuzhen Cheng, Bin Xiao 机构: 香港理工大学计算系, 山东大学计算机科学与技术学院 发表: arXiv预印本 (2025年9月) 领域: 区块链互操作性、真实世界资产、去中心化身份 arXiv: 2509.12957v2 [cs.CR] 代码: GitHub - xRWA 核心问题 RWA市场现状 市场规模: 2025年上半年从86亿增至230亿美元(+260%) 未来预测: Citibank估计2030年达到4万亿美元 典型资产: 政府债券、大宗商品、房地产、稳定币 跨链部署的两大挑战 Q1: 冗余认证 (Redundant Authentication) 单链场景: RWA只需在本地账本认证一次 跨链困境: 每次转移到新链都要完全重新认证 理想方案: 在链A认证后,链B应通过证明直接识别 Q2: 低效操作 (Inefficient Operations) 单链瓶颈: Bitcoin ~7 TPS, Ethereum ~15 TPS (Visa可达数千TPS) 跨链放大: HTLC原子交换需要4个独立链上操作 现有通道: 每次结算都要关闭并重开通道,增加成本和延迟 解决方案概览 xRWA三层架构 ┌─────────────────────────────────────────────────────┐ │ Layer 3: 跨链交互 (Cross-Chain Interaction) │ │ - 跨链通道支持无需关闭的结算 │ │ - 基于HTLC的原子性保证 │ └─────────────────────────────────────────────────────┘ ↓ ┌─────────────────────────────────────────────────────┐ │ Layer 2: 跨链认证 (Cross-Chain Authentication) │ │ - SPV证明避免重复认证 │ │ - Merkle路径 + 轻客户端验证 │ └─────────────────────────────────────────────────────┘ ↓ ┌─────────────────────────────────────────────────────┐ │ Layer 1: 识别与代币化 (Identification \u0026amp; Token) │ │ - DID + VC构建RWA复合凭证 (RWA-CC) │ │ - 四模块设计:资产/身份/合规/托管 │ └─────────────────────────────────────────────────────┘ 技术细节 1. RWA复合凭证 (RWA-CC) 四大核心模块 Asset (资产模块)\n{ \u0026#34;assetId\u0026#34;: \u0026#34;did:ion:EiAa...asset123\u0026#34;, \u0026#34;assetType\u0026#34;: \u0026#34;RealEstate\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Residential\u0026#34;, \u0026#34;classDid\u0026#34;: \u0026#34;did:web:issuer.example.org:class:RE-RESIDENCE\u0026#34;, \u0026#34;tokenBinding\u0026#34;: { \u0026#34;standard\u0026#34;: \u0026#34;ERC-721\u0026#34;, \u0026#34;chain\u0026#34;: \u0026#34;eip155:1\u0026#34;, \u0026#34;contract\u0026#34;: \u0026#34;0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D\u0026#34;, \u0026#34;tokenId\u0026#34;: \u0026#34;1234\u0026#34; } } Identity (身份模块)\nidentifiers[]: 官方注册信息(登记方案、ID值、管辖区) taxonomies[]: 标准化分类码(如UNSPSC) spatialFootprint: GeoJSON格式的地理位置 documents[]: 契约、证书等加密哈希链接 attributes[]: 结构化事实(如面积120平米) Compliance (合规模块)\n{ \u0026#34;licenseId\u0026#34;: \u0026#34;example-2025-8899\u0026#34;, \u0026#34;sellableRegions\u0026#34;: [\u0026#34;CN-11\u0026#34;, \u0026#34;US-CA\u0026#34;], \u0026#34;restrictions\u0026#34;: [\u0026#34;NoCrossBorderSale\u0026#34;], \u0026#34;effectiveFrom\u0026#34;: \u0026#34;2025-01-01\u0026#34;, \u0026#34;effectiveTo\u0026#34;: \u0026#34;2026-01-01\u0026#34;, \u0026#34;regulatorDid\u0026#34;: \u0026#34;did:web:regulator.gov\u0026#34; } Custody (托管模块)\ncustodianDid: 托管人DID location: 物理存放位置 policy: 安全标准(如ISO-27001) auditCycleDays: 审计频率(如30天) insurancePolicyRef: 保险单引用 独立状态管理 每个模块都有独立的 sStatus (状态追踪) 和 sProof (密码学证明),支持:\n模块级别的撤销/暂停 选择性披露(仅透露必要字段) 分级验证(不同验证者看到不同内容) 2. SPV跨链认证协议 算法流程 (Algorithm 1) Phase 1: 源链承诺 (C₁)\n# 发行方在交易tx中嵌入承诺 commitment = { \u0026#34;assetId\u0026#34;: did_a, \u0026#34;credDigest\u0026#34;: hash(cred), \u0026#34;tokenBinding\u0026#34;: {...}, \u0026#34;epoch\u0026#34;: current_epoch, \u0026#34;nonce\u0026#34;: random() } # tx被包含在区块B中,B的头部有Merkle根μ Phase 2: 生成SPV证明\nπ ← SPV.Prove(tx, B) # π = (p, μ) # p: Merkle路径(从tx到根的兄弟哈希序列) # μ: 区块头中的Merkle根 Phase 3: 目标链验证 (C₂)\nfunction verifyCrossChainAuth( bytes memory tx, bytes32[] memory merklePath, bytes32 merkleRoot ) public returns (bool) { // 1. 检查μ对应C₁的有效区块头(轻客户端规则) require(isValidHeader(merkleRoot, chainC1)); // 2. 用路径p重新计算,验证tx包含在μ下 bytes32 computedRoot = recomputePath(tx, merklePath); require(computedRoot == merkleRoot); // 3. 解析tx中的承诺,验证与披露的cred字段一致 Commitment memory c = parseCommitment(tx); require(c.credDigest == hash(disclosedCred)); require(checkIssuerDID(c.assetId)); require(checkRevocationStatus(c.assetId)); return true; } 关键优势 避免重复: C₁上的DID解析、签名检查、撤销查询只需一次 轻量验证: C₂只需验证紧凑的Merkle证明 对数复杂度: 验证时间 T_SPV ≈ 0.69 × log₂(n) + 0.23 μs 3. 无需关闭的跨链通道 传统HTLC问题 每次交互需要4个链上操作: C₁: Lock → Unlock (2 ops) C₂: Lock → Unlock (2 ops) 总计: 4n ops (n次交互) xRWA跨链通道设计 (Algorithm 2) Phase 1: 开启通道\n// 双方在各自链上部署合约并存入保证金 Π.Open: ξ₁ on C₁ ← deposit d_Alice ξ₂ on C₂ ← deposit d_Bob // 此时无哈希锁条件 Phase 2: 链下批量协商\n# 多轮链下状态更新 σ₁: Alice pays v₁ for RWA batch S₁ = {a₁, a₂} σ₂: Alice pays v₂ for RWA batch S₂ = {a₃} σ₃: Alice pays v₃ for RWA batch S₃ = {a₄, a₅, a₆} ... # 签名的最终聚合状态 σ_final = { \u0026#34;totalPayment\u0026#34;: v₁ + v₂ + v₃, \u0026#34;totalRWAs\u0026#34;: S₁ ∪ S₂ ∪ S₃, \u0026#34;signatures\u0026#34;: [sig_Alice, sig_Bob] } Phase 3: 单次链上结算\n// 双方提交最终状态并安装HTLC条件 Π.Lock(σ_final): ξ₁.lock(totalPayment, h(ρ), T₁) // 超时T₁ ξ₂.lock(totalRWAs, h(ρ), T₂) // 超时T₂ \u0026lt; T₁ // 原子性解锁 if Bob reveals ρ before T₂: Π.Unlock on ξ₂: deliver all RWAs to Alice Π.Unlock on ξ₁: release payment to Bob before T₁ else: Π.Refund on ξ₂: return RWAs to Bob at T₂ Π.Refund on ξ₁: return payment to Alice at T₁ Phase 4: 通道持续运行\n可选择继续新的 Π.Update 轮次 或调用 Π.Close 释放剩余保证金 Gas成本对比 方案 n次交互的Gas消耗 节省比例 HTLC 465,426 × n 基准 xRWA通道 917,253 (固定) \u0026gt;99% (n≥2时) 性能评估 实验环境 硬件: Intel i9-13980HX, 32GB RAM 系统: Windows 11 (24H2) 实现: Python 3.12.10 (VC/SPV), Solidity 0.8.30 (合约) 测试网: Remix VM (Prague) 1. VC凭证大小与延迟 资产类型 VC大小(KB) 签发延迟(ms) 验证延迟(ms) 车辆 7.11 8.22 ± 9.04 1.09 ± 1.27 房地产 8.05 8.35 0.81 黄金 6.95 7.82 0.99 艺术品 7.38 8.23 0.85 债券 7.09 8.08 1.01 基金 7.27 8.17 1.02 知识产权 7.10 8.21 0.93 平均 7.27 8.16 ± 9.04 0.96 ± 1.27 测试配置: 500凭证, 100迭代, 8工作线程\n2. SPV验证可扩展性 实验拟合对数模型:\nT_SPV(n) ≈ 0.69 × log₂(n) + 0.23 μs 区块交易数(n) 验证时间(μs) 2⁵ = 32 3.75 2⁷ = 128 5.12 2⁹ = 512 6.48 2¹¹ = 2,048 7.85 2¹³ = 8,192 9.27 结论: 即使区块增大256倍(32→8,192),验证时间仅增长2.5倍\n应用场景 1. 房地产代币化 传统流程:\n链A: 完成KYC/AML, 签发VC, 代币化 链B: 重复KYC/AML, 重新签发VC xRWA流程:\n链A: 完成一次认证,生成SPV证明 链B: 验证SPV证明(\u0026lt; 10μs),直接接受 2. 跨链稳定币结算 场景: Alice(持USDT在以太坊) ↔ Bob(持房产代币在Polygon)\n批量交易示例:\nRound 1: Alice买房产A,B (100 USDT) Round 2: Alice买房产C (50 USDT) Round 3: Alice买房产D,E,F (150 USDT) 成本对比:\nHTLC: 3轮 × 465,426 gas = 1,396,278 gas xRWA: 917,253 gas (节省34%) 3. DAO治理 身份绑定: 通过DID确保一人一票 隐私保护: VC选择性披露(仅证明资格,不暴露详情) 跨链投票: SPV同步多链投票结果 4. DeFi空投防女巫 问题: 传统方式易被多账户攻击 方案: RWA-CC的 identity 模块验证唯一性 效果: 确保每个真实用户仅领取一次 安全性分析 威胁模型 已考虑的攻击:\n重放攻击: nonce + epoch 防止同一证明重用 伪造SPV: 轻客户端验证区块头工作量证明 凭证伪造: VC的发行方签名 + 撤销列表检查 双花攻击: HTLC的 T₁ \u0026gt; T₂ 时间锁机制 假设:\n至少一条链是诚实的(51%算力/权益) DID发行方遵循W3C规范 用户妥善保管私钥 形式化证明(简略) 定理1 (认证一致性): 如果RWA在链C₁通过验证,则SPV证明在链C₂的验证结果一致(除非C₁被51%攻击)。\n定理2 (原子性): 跨链通道的结算要么双方都完成,要么都退款(除非网络永久分区)。\n相关工作对比 项目/研究 单链/跨链 身份管理 认证机制 结算效率 MakerDAO [8] 单链 ❌ 中心化预言机 标准 HSBC金代币 [1] 单链 ❌ KYC/AML 标准 Securitize [21] 单链 部分 合规平台 标准 Chen et al. [5] 单链 ❌ 安全分析 N/A Zhao et al. [29] 单链 DAO治理 L2 Rollup 高 xRWA (本文) 跨链 DID+VC SPV 极高 首创性:\n✅ 首个系统性解决RWA跨链问题的框架 ✅ 首次将SPV应用于RWA认证 ✅ 首个支持无需关闭的RWA跨链通道 总结 xRWA通过DID/VC身份层 + SPV认证层 + 无需关闭的通道层,构建了首个完整的RWA跨链框架。在万亿美元规模的RWA市场即将到来之际,该方案为:\n🏠 房地产代币的全球流通 💰 跨链稳定币的高效结算 🗳️ 去中心化组织的身份治理 🎁 DeFi空投的防女巫机制 提供了关键的技术基础设施。SPV的对数复杂度和通道的99%+ Gas节省证明了方案的实用性,值得进一步在主网环境测试和优化。\n[!IMPORTANT]\n\u0026ldquo;For 𝑛 cross-chain interactions, the cross-chain channel requires only 917,253 gas in total, while the HTLC scheme consumes 465,426 × 𝑛 gas.\u0026rdquo; — 性能评估章节\n个人思考 优势 模块化设计: RWA-CC四模块可独立更新/撤销,灵活性强 标准兼容: 完全遵循W3C DID/VC规范,生态友好 实用性强: 公开代码、测试网部署、详细Gas成本分析 潜在限制 轻客户端依赖: SPV需要维护源链的区块头,增加存储成本 预言机问题: 链下资产状态更新(如房产出售)仍需可信预言机 监管挑战: 跨境RWA流动可能触发复杂的法律合规 改进方向 零知识优化: 用zkSNARK压缩SPV证明大小 动态通道: 支持多方(\u0026gt;2)参与的跨链通道 AI审计: 自动检测RWA凭证中的异常模式 标签: #RWA #跨链互操作 #DID #可验证凭证 #SPV #区块链 #Web3金融\n","permalink":"http://localhost:1313/blockchain/xrwa-cross-chain-real-world-assets/","summary":"xRWA是首个专门针对真实世界资产(RWA)跨链场景设计的完整框架。通过整合去中心化身份标识(DID)、可验证凭证(VC)和简化支付验证(SPV),解决了RWA在多链部署中的冗余认证和低效结算问题。系统采用三层架构:资产识别与代币化、跨链认证协议、跨链交互通道。实验显示SPV验证复杂度为O(log n),跨链通道比HTLC节省超过99%的gas成本。该框架为RWA的万亿美元市场潜力提供了关键的跨链基础设施。","title":"xRWA: 真实世界资产的跨链互操作性框架"},{"content":"论文基本信息 标题: A Comparative Survey of Centralised and Decentralised Identity Management Systems: Analysing Scalability, Security, and Feasibility 作者: Aviral Goel, Yogachandran Rahulamathavan 机构: Loughborough University, Institute for Digital Technologies 发表期刊: Future Internet 2025, 17(1) 发表时间: 2024年12月24日 DOI: https://doi.org/10.3390/fi17010001 研究背景与动机 数字身份的重要性 在网络犯罪高发的时代，数字身份已成为关键资产：\n敏感信息保护：包含姓名、年龄、银行信息等个人数据 服务访问凭证：用于社交媒体、银行、购物等在线服务 安全防护需求：防止身份盗窃和未经授权的访问 身份认证技术演进历程 1990年代初期：简单的用户名+密码认证\n主要问题：用户在多个站点重复使用相同密码 安全隐患：密码管理效率低，容易发生安全漏洞 2000年代至今：引入复杂认证机制\n单点登录（SSO）：一次登录访问多个应用 多因素认证（MFA）：增加额外验证层 生物识别认证：指纹、人脸识别等 传统中心化系统面临的挑战 1. 单点故障风险（Single Point of Failure）\n中央服务器故障导致整个系统不可用 典型案例：2021年微软 Azure AD 故障持续数小时，影响全球服务 2. 隐私安全问题\n所有用户数据集中存储，成为攻击者的首要目标 典型案例：2021年 Facebook 数据泄露，5.33亿用户记录被盗 3. 可扩展性瓶颈\n用户数量增长导致中央服务器负载过高 需要持续投入硬件资源进行扩容 研究方法论 文献检索策略 主要数据库来源：\nGoogle Scholar（初步广泛检索） IEEE Xplore（技术论文） ACM Digital Library（计算机科学） SpringerLink（综合学术） 时间范围设定：2015-2024年\n确保技术相关性和时效性 覆盖区块链技术成熟期 核心检索词组合（e.g.）：\n(\u0026#34;decentralized identity management\u0026#34; OR \u0026#34;self-sovereign identity\u0026#34; OR \u0026#34;DID\u0026#34;) AND (\u0026#34;blockchain\u0026#34; OR \u0026#34;Hyperledger Indy\u0026#34; OR \u0026#34;Sovrin\u0026#34;) AND (\u0026#34;scalability\u0026#34; OR \u0026#34;security\u0026#34; OR \u0026#34;feasibility\u0026#34;) 筛选结果：经过系统筛选标题和摘要，最终纳入约90篇高质量论文，这些论文均衡地描述了去中心化和集中式 IdM 系统，重点关注它们各自的优势、挑战和未来潜力。\n评估维度框架 论文从5个关键维度对身份管理系统进行全面对比：\n可扩展性（Scalability）：系统处理用户数量增长的能力 可靠性（Reliability）：系统持续稳定运行的能力 安全性（Security）：防护数据泄露和网络攻击的能力 适应性（Adaptability）：与现有系统集成的灵活性 成本（Cost）：部署和维护的经济投入 中心化身份管理系统（CIMS） 核心架构设计 基本工作流程：\n用户 → 服务提供商(SP) → 身份提供商(IdP) ↓ 验证凭证 \u0026amp; 发放令牌 ↓ 授予服务访问权限 关键组件说明：\n身份提供商（IdP）：集中管理所有用户身份数据和凭证 服务提供商（SP）：用户实际交互的应用程序或服务 认证服务器：负责处理和验证用户的认证请求 单点登录（SSO）：允许用户一次认证后访问多个应用 主流中心化协议详解 1. LDAP（轻量级目录访问协议） 技术特征：\n基于目录的分层结构存储用户信息 采用客户端-服务器通信模型 广泛应用于 Microsoft Active Directory 等企业环境 认证工作流程：\n客户端发送 Bind 请求，包含 DN（Distinguished Name）和密码 服务器在目录信息树（DIT）中验证凭证 服务器搜索匹配的用户条目 返回认证成功或失败的结果 安全机制与问题：\n默认情况下以明文传输凭证（存在安全风险） 必须配置 SSL/TLS 加密以保护数据传输 配置复杂，需要专业知识进行规划和部署 性能指标：\n优化环境下可达 10,000 查询/秒 典型响应时间低于 200 毫秒 2. RADIUS（远程认证拨号用户服务） 协议特性：\n基于 UDP 协议通信 端口 1812：认证服务 端口 1813：计费服务 提供 AAA 服务（认证、授权、计费） 主要应用于 VPN、WLAN 等网络接入场景 数据包类型：\nCode 1：客户端访问请求 Code 2：认证成功响应 Code 3：访问拒绝响应 安全挑战：\nMD5 加密算法已被认为不够安全 容易遭受 DoS（拒绝服务）攻击 Request Authenticator 随机性不足可能产生安全漏洞 3. SAML（安全断言标记语言） 应用场景：\n企业级单点登录（SSO）解决方案 跨组织域的身份联合认证 完整工作流程：\n用户向服务提供商（SP）请求访问受保护资源 SP 生成 SAML 认证请求并重定向到身份提供商（IdP） IdP 验证用户身份并生成 SAML 断言（Assertion） 用户携带 SAML 断言返回 SP SP 验证断言的数字签名 验证通过后授予用户访问权限 安全保障措施：\n使用数字签名确保断言的完整性和真实性 通过 HTTPS 协议传输防止中间人攻击 实施会话管理机制防止会话劫持 系统局限性：\n配置过程复杂，部署周期较长 依赖中心化的 IdP（存在单点故障风险） 需要注意 XML 相关的安全漏洞 4. OAuth 2.0（开放授权标准） 核心设计优势：\n用户无需向第三方应用共享账号密码 使用时限令牌（Access Token）限制潜在滥用 被 Google、Facebook、Microsoft 等主流平台广泛采用 系统关键角色：\n资源所有者（Resource Owner）：拥有数据的用户 客户端（Client）：请求访问资源的第三方应用 授权服务器（Authorization Server）：负责颁发访问令牌 资源服务器（Resource Server）：存储和提供受保护数据 授权码模式流程：\n1. Client → Authorization Server: /authorize 请求 参数包括: response_type=code, client_id, redirect_uri, scope, state 2. 用户授权 → Authorization Server 返回授权码（Authorization Code） 3. Client → Authorization Server: /token 请求 使用授权码换取 Access Token 4. Client 使用 Access Token 访问资源服务器 5. 资源服务器验证 Token 合法性后返回数据 6. Token 过期后可使用 Refresh Token 获取新的 Access Token 常见安全漏洞：\n过度权限请求：应用请求超出功能需要的访问范围 缺乏用户控制：UI 设计诱导用户授予所有权限 令牌重放攻击：攻击者拦截并重复使用 OAuth 令牌 安全缓解措施：\n实施细粒度的权限控制机制 设置较短的令牌有效期（如1小时） 强制使用 HTTPS 防止令牌被拦截 检测到滥用时立即撤销相关令牌 中心化系统的优势与挑战 主要优势：\n部署简单，成本相对较低（中小企业初始投入 \u0026lt; $10,000） 集中化管理，便于统一实施安全策略 技术成熟稳定，供应商支持体系完善 具备良好的水平扩展能力（如 LDAP、OAuth） 面临挑战：\n单点故障风险：中央服务器故障影响整个系统 隐私问题：数据集中存储容易成为攻击目标 可扩展性受限：中央服务器性能成为瓶颈 灵活性不足：集成新技术和协议较为困难 去中心化身份管理系统（DIMS） 核心理念：自主身份（SSI） Self-Sovereign Identity 核心原则：\n用户完全拥有和控制自己的身份数据 不依赖任何中心化权威机构 支持选择性披露信息（Selective Disclosure） 数据存储在用户本地或分布式网络中 关键技术组件 1. 去中心化标识符（DID） 核心特点：\n全局唯一的身份标识符 基于密码学密钥对生成 公钥发布在区块链上供验证 私钥由用户安全保管，不可泄露 DID 文档内容：\n用户的公钥信息 可访问的服务端点 支持的身份验证方法 2. 可验证凭证（VC） 基本定义：数字化的身份证明文档，类似于电子版的护照或驾驶执照\n技术特征：\n由可信的颁发机构进行数字签名 存储在用户的数字钱包应用中 可通过加密技术验证真伪 支持零知识证明技术 3. 区块链与分布式账本技术（DLT） 系统作用：\n存储 DID 文档和凭证的哈希值 通过密码学保证数据不可篡改 提供透明的验证机制 消除对中心化服务器的依赖 主要共识机制：\n拜占庭容错（BFT）：用于 Hyperledger Indy、Sovrin 工作量证明（PoW）：用于 Bitcoin（Blockstack、ShoCard） 权益证明（PoS）：用于 Ethereum（uPort） 4. 零知识证明（ZKP） 核心能力：在不暴露具体数据的情况下向他人证明某个事实为真\n实际应用示例：\n证明\u0026quot;年满18岁\u0026quot;而不需要透露确切的出生日期 证明\u0026quot;账户余额大于1000美元\u0026quot;而不显示具体金额 证明\u0026quot;拥有某项资质\u0026quot;而不泄露其他无关信息 去中心化身份系统架构 系统层次结构：\n用户层（持有 DID + 私钥） ↓ 数字钱包层（存储可验证凭证 VC） ↓ 区块链网络层（存储 DID 文档 + 凭证证明） ↓ 验证方（验证 VC 的真实性和有效性） 完整认证流程：\n用户向验证方出示可验证凭证（VC） 验证方从区块链获取凭证颁发者的公钥 使用公钥验证凭证的数字签名有效性 检查凭证是否已被撤销 用户选择性披露必要的属性信息 验证通过后授予服务访问权限 主流去中心化身份平台深度分析 1. Hyperledger Indy 基本信息：\n许可型区块链（Permissioned Blockchain） 基于 Linux Foundation Hyperledger 项目 专为自主身份（SSI）设计 技术架构：\n验证者节点（Validators）：由受信任的管理员（Stewards）运营 共识算法：Plenum BFT（拜占庭容错） 多链设计： Domain TXs：存储域特定数据和交易元数据 Pool TXs：管理验证者配置和操作 Config TXs：存储网络参数和策略更新 核心特性：\n支持零知识证明（ZKP）技术 符合 GDPR 等隐私法规要求 支持动态配置修改能力 性能特点：\n写延迟始终低于读延迟 性能受验证者数量和交易速率影响 使用 Docker 容器化部署便于管理 局限性分析：\n可扩展性受 BFT 共识机制限制（计算开销较大） 添加新验证者需要投票过程，影响扩展速度 开源代码相对受限，部署过程较为复杂 最新进展：\nIndy Besu 项目引入模块化架构 兼容许可型和无许可型网络 显著提升交易吞吐量和灵活性 适用场景：\n企业级身份管理系统 政府数字身份基础设施 医疗健康记录管理平台 2. Sovrin Network 基本信息：\n基于 Hyperledger Indy 框架构建 拥有独立加密货币 SOV 用于激励验证者 具备完善的治理框架体系 四层架构设计：\nLayer 1: 账本层（Ledger Layer）\n存储 DID、凭证定义、撤销注册表 使用 RBFT（冗余拜占庭容错）共识机制 保证数据的保密性和完整性 Layer 2: 代理层（Agent Layer）\n管理点对点的安全连接 通过 DIDComm 协议进行加密通信 包括边缘代理（用户设备）和云代理（服务器） Layer 3: 治理层（Governance Layer）\nSovrin 治理框架（SGF）制定运营规则 确保符合法律、安全和隐私要求 所有参与者必须遵守统一标准 Layer 4: 应用层\n支持各类基于 Sovrin 的应用开发 系统优势：\nRBFT 机制提供高容错性（即使部分节点失效仍可运行） 代币激励机制促进生态系统发展 完善的治理框架确保系统可信度 局限性分析：\n依赖 Steward（受信任组织）运营节点，增加一定中心化风险 可扩展性和可移植性仍在早期发展阶段 复杂的治理机制对普通用户不够友好 3. Blockstack 基本信息：\n基于 Bitcoin 区块链构建 使用区块链名称系统（BNS）替代传统 DNS 配备去中心化存储系统 Gaia 核心组件详解：\nBNS（Blockchain Name System）\n将人类可读的名称绑定到公钥 名称注册采用两阶段流程： 预订阶段：生成哈希并记录到区块链 注册阶段：等待期后将名称正式绑定到区块链 VirtualChain（虚拟链）\n作为抽象层独立于底层区块链运行 提升系统速度和灵活性 降低直接操作区块链的复杂度 Atlas 网络\n点对点的数据索引和查找系统 处理 BNS 数据的传播和同步 Gaia 存储系统\n去中心化存储解决方案 数据使用用户私钥签名防止篡改 兼容 Dropbox、Amazon S3 等现有云服务 身份管理流程：\n用户注册过程：\n预订名称（生成加密哈希） 经过强制等待期 完成注册，名称加密绑定到公钥 身份认证过程：\n用户提交 Blockstack ID 提供私钥作为所有权证明 系统验证私钥与公钥是否匹配 密钥撤销与恢复：\n通过名称转移流程将 ID 所有权转移到新地址 密钥撤销后禁用该身份的所有后续操作 独特优势：\n动态定价机制：需求高的名称价格更高 跨链迁移能力：区块链故障时可转移身份到其他链 分叉恢复机制：通过共识哈希检测并纠正不一致状态 局限性分析：\n加密、解密、签名验证的开销影响实时性能 多层架构（区块链+P2P网络+存储）管理复杂 大规模部署需要专业技术人员支持 4. uPort 基本信息：\n基于 Ethereum 区块链平台 完全开源的身份解决方案 通过移动应用安全存储私钥 智能合约架构：\n用户创建身份时会生成两个关键智能合约：\n代理合约（Proxy Contract）\n作为持久化的唯一身份标识 与区块链网络上其他合约进行交互 在私钥和区块链之间添加抽象层 允许密钥恢复而不改变身份本身 控制器合约（Controller Contract）\n维护访问控制策略 允许用户向代理合约进行身份认证 即使私钥丢失也能保护身份完整性 密钥恢复机制：\n恢复法定人数合约（Recovery Quorum Contract）\n由一组受信任的个人（恢复代表）共同控制 当用户私钥丢失时协助恢复身份控制权 采用去中心化方式，无需依赖中心化权威机构 数据存储策略：\n链上数据：智能合约处理核心身份功能 链下数据： 存储在 IPFS 等去中心化存储平台 包括个人资料、证明文件、身份属性 通过注册合约加密链接到 uPort 身份 系统优势：\n用户完全控制自己的身份数据 人性化的密钥恢复机制 链上链下结合优化存储成本和效率 局限性分析：\n依赖 Ethereum 网络（受其可扩展性和交易费用限制） 链下存储方案需要信任所选择的存储服务 主要基于 Ethereum，跨链可移植性和互操作性受限 恶意节点可能追踪和关联 uPort ID 的活动记录，存在隐私风险 5. EverID 基本信息：\n基于许可型 Ethereum 区块链 非开源系统（闭源商业方案） 支持多货币跨境金融交易 技术特点：\n数字身份整合政府 ID、生物特征、第三方认证 数据存储在云端（用户无需移动设备也可使用） 利用生物识别技术创建唯一用户身份 核心组件：\nEverID Datagram：存储生物特征标识符数据 去中心化应用（DApp）：提供自助注册和身份管理功能 应用程序接口（API）：与其他服务进行安全集成 核心智能合约：管理身份创建、验证和交易流程 超级节点（Super Nodes）：存储 Datagram 的副本以提高可用性 局限性分析：\n数据最小化原则未完全实现：验证声明时需要披露所有信息 许可型区块链引入一定程度的中心化（访问受限于批准的参与者） 用户和交易规模增长可能导致： 运营成本持续增加 交易处理速度变慢 整体用户体验下降 6. ShoCard 基本信息：\n基于 Bitcoin 公有区块链 用户身份信息以加密哈希形式存储 第三方验证者通过区块链验证用户身份 核心设计理念：\n私人信息不存储在任何中央位置 用户可在不分散身份碎片的情况下证明账户所有权 使用加密哈希将用户标识符与可信凭证（护照、驾照等）关联 三阶段工作流程：\n阶段1: 引导（Bootstrapping）\nShoCard 移动应用生成加密密钥对 扫描用户的身份凭证（如护照） 凭证数据加密后作为签名哈希存储在 Bitcoin 交易中 生成唯一的 ShoCardID 作为区块链上的参考点 阶段2: 认证（Certification）\n用户与服务提供商进行交互 向用户身份添加经过验证的属性 属性被哈希处理、数字签名并存储在区块链上 阶段3: 验证（Validation）\n依赖方从区块链检索认证信息 验证数字签名的有效性 将数据与区块链记录进行对比 确认用户身份的真实性和有效性 系统优势：\n利用 Bitcoin 区块链的高安全性和全球接受度 无需中心化数据库存储敏感身份信息 用户完全控制自己的身份数据共享 局限性分析：\n依赖中央服务器处理部分功能，引入中心化风险 如果 ShoCard 公司停止运营，用户可能丧失数据访问权 缺乏全向标识符（Omnidirectional Identifiers），限制扩展到更广泛生态 Bitcoin 交易确认延迟（约10分钟）在实时验证场景下存在问题 7.小结 平台 底层区块链 共识机制 核心特色 主要优势 主要局限 Hyperledger Indy 自有许可型链 Plenum BFT SSI专用,支持ZKP 隐私保护强,符合GDPR 扩展性受限,部署复杂 Sovrin Network Hyperledger Indy RBFT 四层架构,SOV代币激励 治理完善,容错性高 依赖Steward,有中心化风险 Blockstack Bitcoin PoW BNS系统,Gaia去中心化存储 跨链迁移能力,动态定价 性能开销大,架构复杂 uPort Ethereum PoS/PoW 智能合约身份,移动优先 用户完全自控,恢复机制好 依赖Ethereum,交易费高 EverID 许可型Ethereum 许可型 生物识别,云端存储 生物识别方便,支持跨境金融 中心化,隐私保护较弱 ShoCard Bitcoin PoW 加密哈希,三阶段验证 Bitcoin安全性高,用户自控 确认慢(约10分钟),依赖中央服务器 中心化 vs 去中心化：全面对比分析 1. 可扩展性（Scalability） 中心化系统的表现 优势特点：\nLDAP 和 OAuth 经过数十年优化，支持灵活的水平和垂直扩展 LDAP 在优化环境下可处理 10,000 查询/秒，响应时间低于 200ms OAuth 能够高效处理大量基于令牌的访问请求 SAML 的联邦模型支持跨多个组织域的扩展 性能瓶颈：\n单点控制架构在系统规模增长时可能引入性能瓶颈 需要持续增加硬件资源以应对用户增长 去中心化系统的表现 核心挑战：可扩展性主要受共识机制的计算复杂度限制\n性能对比表：\n系统 共识机制 吞吐量（TPS） 关键特点 Ethereum (uPort) PoS 15-30 Layer-2 方案可提升至 1000-4000 TPS Bitcoin (Blockstack/ShoCard) PoW 约7 挖矿计算开销大，确认时间约10分钟 Hyperledger Indy (Sovrin) RBFT 约300 可容忍 33% 节点故障 LDAP (中心化) N/A 10,000+ 支持多主复制 最新技术进展：\nIndy Besu 项目：模块化架构，兼容许可型和无许可型网络，提升吞吐量 Ethereum Layer-2 解决方案（Optimistic Rollups、zkRollups）显著改善扩展性 2. 可靠性（Reliability） 中心化系统的可靠性保障 技术机制：\n多主复制（Multi-Master Replication）技术 备份服务器可在几秒钟内接管服务 LDAP 系统年度停机时间通常低于 1% 典型风险案例：\n2021年微软 Azure AD 故障：持续数小时，影响全球范围内的服务访问 去中心化系统的可靠性优势 核心优势：\n分布式网络架构：单个节点故障不影响整体系统运行 RBFT 共识机制：即使 33% 的节点出现故障仍可维持运行 无单点故障风险，系统韧性更强 技术权衡：\n节点添加或配置更新时可能出现临时的数据同步延迟 需要更复杂的协调机制确保网络一致性 3. 安全性（Security） 中心化系统的安全措施 主要防护机制：\nLDAP：使用 SSL/TLS 加密凭证传输过程 OAuth：强制 HTTPS 传输 + 时限令牌（TTL）机制 SAML：XML 加密技术 + 数字签名验证 重大安全事件：\n2021年 Facebook 数据泄露：5.33亿用户记录被窃取 主要攻击面：\n中央服务器一旦被攻破，所有用户数据面临风险 容易遭受暴力破解攻击和令牌重放攻击 去中心化系统的安全优势 先进安全技术：\n零知识证明（ZKP）：可以证明\u0026quot;年满18岁\u0026quot;而无需透露具体出生日期 选择性披露：用户仅分享验证所需的最少信息 区块链不可篡改性：数据一经写入区块链即无法修改 无中央数据库：消除单点大规模数据泄露风险 潜在安全风险：\nBFT 共识机制漏洞：恶意节点串通可能导致系统延迟或操纵 智能合约缺陷：代码漏洞可能导致未授权操作 密钥管理挑战：私钥丢失或被盗通常无法恢复（最大安全隐患） 高交易负载下延迟增加，可能间接影响安全性和性能 4. 适应性（Adaptability） 中心化系统的集成优势 技术成熟度：\n经过数十年的企业级应用实践 提供丰富的 API 库和集成工具 与 SSO、云服务平台可以无缝对接 显著减少系统部署时间和技术复杂度 适用场景：\n需要快速部署上线的企业项目 现有 IT 基础设施已经成熟的大型组织 去中心化系统的集成挑战 主要技术障碍：\n需要开发中间件桥接区块链操作与传统 IT 环境 Hyperledger Indy 集成企业数据库需要定制开发 API 公有链（uPort）受 Gas 费用和网络吞吐量限制 私有链（Sovrin、Indy）虽然提供更多控制权，但初始设置复杂 系统过渡要求：\n需要进行重大的基础设施升级改造 IT 团队必须重新培训以管理分布式系统 整体实施成本和周期显著增加 5. 成本（Cost） 中心化系统的成本结构 经济优势：\n中小企业初始部署成本通常低于 $10,000 运营成本主要包括基础设施维护和定期系统更新 开源工具和完善的供应商支持降低总拥有成本 LDAP 等系统的最小硬件需求减少经常性开支 适用对象：预算相对固定的中小型企业\n去中心化系统的成本结构 详细成本对比：\n成本项目 私有链（Sovrin/Indy） 公有链（uPort/Ethereum） 验证者节点部署 $5,000-$10,000/节点 不适用 整体系统部署 $10,000-$50,000 取决于网络活动量 运营成本 节点维护和管理费用 交易 Gas 费（高峰期 $1-$20/笔） 人力成本 员工再培训或聘请区块链专家 同左 专业支持 需要区块链技术专家 需要智能合约开发者 高频交易场景的成本影响：\n公有链的交易费用在高峰期可能急剧上升 不适合成本敏感且需要频繁身份验证的应用场景 适用对象：\n资源充足的大型组织 长期战略侧重去中心化控制和数据主权 重视隐私法规合规性（如 GDPR）的行业 研究结论 核心发现 本综述论文通过对中心化和去中心化身份管理系统的全面分析，揭示了两种范式各有优劣，不存在普适的最优解决方案。组织需要根据自身需求在可扩展性、成本效益、安全性和复杂度之间做出权衡决策。\n中心化系统的当前优势地位 为何仍是主流选择：\n成熟稳定：经过数十年实战验证，提供可靠的身份认证服务 易于部署：快速上线，无需大规模基础设施改造 成本可控：中小企业初始投入 \u0026lt; $10,000 规模处理：优化后可达 10,000+ TPS，支持水平扩展 安全增强：现代系统通过多因素认证（MFA）和加密会话提升防护能力 适用场景：\n内部企业应用和员工访问管理 需要快速部署的项目 预算和技术资源有限的中小企业 高性能要求场景（低延迟、高并发） 去中心化系统的创新价值 核心优势：\n用户数据主权：将身份控制权交还给用户，消除对中心化机构的依赖 隐私保护：零知识证明（ZKP）实现选择性披露，符合 GDPR 等严格法规 透明性：区块链不可篡改特性确保操作可追溯 高韧性：无单点故障风险，RBFT 共识可容忍 33% 节点故障 面临挑战：\n复杂架构：需要专业区块链工程师和长期学习曲线 高成本：初始部署 $10,000-$50,000，持续运营费用较高 性能瓶颈：共识机制限制吞吐量（BFT ~300 TPS, PoW ~7 TPS） 集成困难：与传统 IT 系统对接需要定制中间件 适用场景：\n高度监管行业（医疗、金融、政府） 数据主权和隐私要求极高的应用 Web3 原生应用（DApps、NFT、DeFi） 拥有专业团队和长期战略投资的大型组织 未来发展展望 1. 混合身份管理模式（Hybrid Approach） 核心理念：结合中心化系统的易用性与去中心化系统的安全性\n两种融合路径：\n路径A：中心化系统增强去中心化特性\n通过 API 集成区块链验证层 关键身份操作记录在链上（不可篡改审计） 用户可选择将身份哈希锚定到公有链 保留现有认证服务器处理日常登录 优势：最小化破坏性改造，逐步提升安全性和用户控制权\n路径B：去中心化系统集成中心化便利性\n区块链作为信任根（Root of Trust） 中心化服务处理高频低风险操作 提供传统 API 接口便于企业集成 可选的托管钱包服务降低使用门槛 优势：继承区块链安全性，改善用户体验和性能\n先行者案例：\nYoti - 智能身份验证平台\n用户友好的移动应用 + 区块链锚定身份 支持零知识属性共享（选择性披露） 被英国政府采用进行年龄验证 符合 GDPR 和 eIDAS 法规 EarthID - 去中心化身份生态\n基于区块链 DID 注册 + 中央索引服务 提供托管钱包和友好 Web 界面 无缝集成现有企业系统 支持教育、医疗、企业等多领域应用 2. 零知识证明（ZKP）与中心化系统的深度融合 技术价值：在不暴露敏感数据的情况下完成身份验证\n实际应用示例：\n银行贷款：证明\u0026quot;年收入 \u0026gt; $50,000\u0026quot;而不透露具体金额 年龄验证：证明\u0026quot;年满18岁\u0026quot;而不泄露确切出生日期 资质认证：证明\u0026quot;拥有某项资质\u0026quot;而不显示其他信息 实施路径：\n通过 API 网关集成 ZKP 验证模块 中央服务器无需存储原始敏感数据 用户在本地客户端生成 ZKP 证明 符合数据最小化原则（GDPR 要求） 3. 区块链可扩展性技术突破 Layer-2 扩展方案：\n技术方案 代表项目 TPS 提升 关键特点 Optimistic Rollup Optimism 1,000-4,000 继承以太坊安全性 ZK Rollup zkSync, StarkNet 2,000-20,000 数学证明，更强安全性 Sharding Ethereum 2.0 未来 100,000+ 分片技术，大规模扩展 Sharding（分片技术）：\n将网络划分为多个并行处理的分片 显著提升整体吞吐量 预计可达 100,000+ TPS 对身份管理的影响：\n降低交易成本：Gas 费降低 100-1000 倍 提升用户体验：交易确认从分钟级降至秒级 支持大规模采用：移除性能瓶颈，支撑全球性身份系统 个人思考 1. 论文的主要贡献 优点：\n✅ 系统性全面：覆盖 LDAP 到 Sovrin 的广泛技术光谱 ✅ 评估框架清晰：5 个维度对比（可扩展性、可靠性、安全性、适应性、成本） ✅ 实践指导价值：为组织选型提供具体的决策依据 ✅ 前沿性：纳入 2024 年最新研究成果 不足之处：\n⚠️ 性能数据来源不够透明：部分 TPS 数据缺乏实验环境细节 ⚠️ 混合模式探讨不够深入：仅简要提及 Yoti 和 EarthID，缺乏架构细节 ⚠️ 成本分析偏粗略：未考虑不同规模组织的具体成本差异 2. 技术发展的关键矛盾 性能 vs 去中心化的永恒权衡：\n区块链的\u0026quot;不可能三角\u0026quot;（Trilemma）始终存在：\n去中心化：节点分布越广，安全性越高 安全性：共识机制越复杂，攻击成本越高 可扩展性：吞吐量越高，对去中心化和安全性的妥协越大 思考：纯粹的去中心化身份系统短期内难以在性能上超越中心化方案，混合模式可能是更现实的过渡路径。\n3. 用户体验的挑战被低估 私钥管理的用户负担：\n普通用户难以理解\u0026quot;私钥丢失 = 身份永久丢失\u0026quot;的概念 助记词备份机制对非技术用户不友好 缺乏类似\u0026quot;忘记密码\u0026quot;的容错机制 解决方向：\n社交恢复机制（通过可信联系人恢复） 生物识别与私钥结合（如 Apple 的 Secure Enclave） 托管钱包服务（牺牲部分去中心化换取便利性） 个人观点：去中心化身份要真正普及，必须在用户体验上实现\u0026quot;隐形化\u0026quot;——用户享受好处而无需理解底层复杂性。\n4. 监管与创新的博弈 现实困境：\n去中心化身份挑战现有监管框架（如 KYC/AML） 完全匿名性与政府监管需求冲突 不同司法管辖区法规不一致 可能的平衡点：\n选择性披露 + 监管机构特权访问 零知识证明满足合规要求（证明合规而不泄露数据） 国际标准化组织推动跨国互认（如 W3C DID 标准） 5. Web3.0 身份的终极愿景 理想状态：\n用户拥有唯一的全球数字身份（跨平台、跨国界） 一次身份验证即可访问所有服务（真正的 SSO） 用户完全控制个人数据的访问权限 身份数据可移植，不被任何平台锁定 实现路径的现实考量：\n技术成熟度：需要 5-10 年持续优化 商业模式转变：互联网巨头依赖用户数据盈利，缺乏动力放弃控制权 用户教育：需要长期的认知普及和习惯培养 监管协调：全球范围内法规统一是巨大挑战 个人预测：去中心化身份将首先在特定垂直领域（医疗、教育、金融）取得突破，而非一蹴而就的全面替代。混合模式将在未来 5 年内成为主流，纯粹的去中心化可能需要等待下一代互联网基础设施的成熟。\n参考资料 原论文：Future Internet 2025, 17(1) Hyperledger Indy: https://www.hyperledger.org/use/hyperledger-indy Sovrin Network: https://sovrin.org/ uPort: https://www.uport.me/ Blockstack: https://www.stacks.co/ W3C DID 标准: https://www.w3.org/TR/did-core/ W3C Verifiable Credentials: https://www.w3.org/TR/vc-data-model/ Yoti: https://www.yoti.com/ EarthID: https://www.earthid.io/ ","permalink":"http://localhost:1313/blockchain/identity-management-systems-survey/","summary":"深度解读 Web3.0 身份认证领域的最新综述论文，对比分析中心化（LDAP、SAML、OAuth）与去中心化（Hyperledger Indy、Sovrin、uPort）身份管理系统的优劣势","title":"Web3.0 身份认证系统综述：中心化与去中心化方案对比分析"},{"content":"第一讲 算法分析 一、算法简介 1. 算法和效率 算法定义：\n任何良定义的计算过程，该过程取某个值或者值的集合作为输入，并产生某个值或值的集合作为输出 把输入转换成输出的计算步骤的一个序列 算法的应用场景：\n生物基因分析 互联网海量数据管理 电子商/务 高速路由器上的IP包分析（频数统计、Top-k查询、范围查询、中位数、平均数+方差等） 效率分析：\n求解相同问题的不同算法的效率可能具有显著的差异 性能可以用曲线来表达 插入排序：$c_1n^2$ vs 归并排序：$c_2n \\log n$ 尽管 $c_1$ 通常小于 $c_2$，但当 $n$ 增长时，最终插入排序的开销更大 案例： 快机器A（100亿条指令/秒）执行插入排序（$2n^2$ 条指令）vs 慢机器B（1000万条指令/秒）执行归并排序（$50n \\log n$ 条指令），当n足够大时，B机器反而更快\n渐进性能： 考虑当n足够大时的复杂度，当n足够大时，$\\Theta(n^2)$ 算法总是优于 $\\Theta(n^3)$ 算法\n2. 渐进符号表示 O-记号（\u0026ldquo;big-Oh\u0026rdquo;，渐近上界）：\n$f(n) = O(g(n))$ if $\\exists$ 常数 $c, n_0$，满足 $0 \\leq f(n) \\leq cg(n), \\forall n \\geq n_0$ 案例：$2n^2 = O(n^3)$ ($c=1, n_0=2$) 集合形式：$O(g(n)) = \\{f(n): \\exists \\text{ 常数 } c, n_0，\\text{满足 } 0 \\leq f(n) \\leq cg(n), \\forall n \\geq n_0\\}$ Ω-记号（渐进下界）：\n$\\Omega(g(n)) = \\{f(n): \\exists \\text{ 常数 } c, n_0，\\text{使得 } 0 \\leq cg(n) \\leq f(n), \\forall n \\geq n_0\\}$ Θ-记号（渐进紧确界）：\n$\\Theta(g(n)) = \\{f(n): \\exists \\text{ 常数 } c_1, c_2, n_0，\\text{满足 } 0 \\leq c_1g(n) \\leq f(n) \\leq c_2g(n), \\forall n \\geq n_0\\}$ o-记号（非渐近紧确的上界）：\n$o(g(n)) = \\{f(n): \\text{对任意正常数 } c \u003e 0，\\text{存在常数 } n_0，\\text{使得对所有 } n \\geq n_0，\\text{有 } 0 \\leq f(n) \u003c cg(n)\\}$ ω-记号（非渐近紧确的下界）：\n$\\omega(g(n)) = \\{f(n): \\text{对任意正常数 } c \u003e 0，\\text{存在常数 } n_0，\\text{使得对所有 } n \\geq n_0，\\text{有 } 0 \\leq cg(n) \u003c f(n)\\}$ 三种分析类型：\n最坏情况（通常使用）： $T(n)$ = 对于任意规模n的输入数据，算法的最大运行时间 平均情况（有时使用）： $T(n)$ = 对于规模为n的所有输入情况，算法的期望运行时间（假设已知输入数据的统计分布） 最佳情况（虚构的）： 所有输入系列之中，运行时间最快的情况下的运行时间 思考题1：紧确界Θ和下界Ω、上界O之间的关系如何？\n解答：\n三者关系可以类比于数学中的等号、大于等于号和小于等于号：\n紧确界 $\\Theta$：$f(n) = \\Theta(g(n))$ 意味着 $f(n)$ 的增长率与 $g(n)$ 相同，即 $f(n)$ 被 $g(n)$ 从上下两边同时夹住。当且仅当 $f(n) = O(g(n))$ 且 $f(n) = \\Omega(g(n))$ 时，$f(n) = \\Theta(g(n))$。\n上界 $O$：$f(n) = O(g(n))$ 意味着 $f(n)$ 的增长率不快于 $g(n)$，$g(n)$ 是 $f(n)$ 的渐近上界。\n下界 $\\Omega$：$f(n) = \\Omega(g(n))$ 意味着 $f(n)$ 的增长率不慢于 $g(n)$，$g(n)$ 是 $f(n)$ 的渐近下界。\n关系总结： $$\\Theta(g(n)) = O(g(n)) \\cap \\Omega(g(n))$$这说明紧确界是上界和下界的交集，表示函数的精确增长率。\n3. 算法设计基本方法 分治策略：\n将原始问题拆分成若干个相似的（规模更小）子问题 递归求解子问题 组合子问题的解，以产生最终答案 动态规划：\n通常用于解决最优化问题，通过做出一组选择来达到最优解 在做出每个选择的同时，通常会生成与原问题形式相同的子问题 关键在于保存每个此类子问题的解，当其重复出现时即可避免重复求解 有时可以将指数时间的算法转换为多项式时间的算法 贪心算法：\n基本思路是使用局部最优解来求得全局最优解 但是，贪心算法并不总是针对所有问题获得最优解 关键是需要知道如何正确区分适用场景 思考题2：快速排序算法的渐进复杂度应该如何表示？\n解答：\n快速排序的复杂度表示取决于分析的角度：\n最坏情况：$O(n^2)$ - 当每次划分都极度不平衡时（如数组已排序或逆序），每次只能减少一个元素，导致递归深度为 $n$。\n平均情况：$\\Theta(n \\log n)$ - 在随机输入或随机化快速排序中，平均情况下划分比较均衡，递归树深度为 $O(\\log n)$。\n最佳情况：$\\Theta(n \\log n)$ - 每次划分都完全平衡时，递归树深度为 $\\log n$。\n实践中的表示： 快速排序通常被描述为平均时间复杂度 $\\Theta(n \\log n)$，最坏情况 $O(n^2)$。通过随机化技术（随机选择主元），可以使最坏情况的概率极低，因此实际应用中快速排序表现优异。\n思考题3：请各说出两种算法，分别是根据分治策略、动态规划、贪心算法设计得来的。\n解答：\n分治策略算法：\n归并排序（Merge Sort）：将数组分成两半，递归排序后合并。时间复杂度 $\\Theta(n \\log n)$。 快速排序（Quick Sort）：选择主元划分数组，递归排序左右两部分。平均时间复杂度 $\\Theta(n \\log n)$。 动态规划算法：\n最长公共子序列（LCS）：通过保存子问题的解（二维表格）避免重复计算。时间复杂度 $O(mn)$。 背包问题（Knapsack Problem）：使用表格记录不同容量和物品数量下的最优解。时间复杂度 $O(nW)$，其中 $n$ 是物品数，$W$ 是背包容量。 贪心算法：\nHuffman编码：根据字符频率构建最优前缀编码树，每次选择频率最小的两个节点合并。 Dijkstra最短路径算法：每次选择距离源点最近的未访问节点，更新其邻居的距离。时间复杂度 $O((V+E) \\log V)$（使用优先队列）。 4. 摊还分析 应用场景：\n用含n个操作的序列 $(o_1, o_2, \\ldots, o_n)$ 维护某数据结构 操作代价：单次操作的代价可能会很大（例如 $\\Theta(n)$），最坏情况下的代价 = $\\max c(o_i)$ 总代价：$\\sum_{i=1}^{n} c_i$，总代价未必就是 $n \\times$ (最坏情况下的单次操作代价) 摊还代价：在上述场景下如何做更紧的分析？（总代价$/n$） 三种典型技术：\n聚合分析： 计算所有操作的总和开销，再除以操作个数，就是平均开销\n核算法： 赋予一个操作的费用，称为它的摊还代价。当一个操作的摊还代价超出其实际代价时，差额部分存入数据结构中的特定对象，存入的差额称为信用。对于后续操作中摊还代价小于实际代价的情况，信用可以用于支付差额。需要确保操作序列的总摊还代价是序列总真实代价的上界。\n势能法： 将势能与整个数据结构相关联，而不是特定对象相关联。将势能释放即可用于支付未来操作的代价。公式：摊余成本 = 真实开销 + 新势能 - 旧势能\n二、相似度搜索 1. 相似性搜索简介 问题定义：\n给定一个查询对象（query object），在大规模图像集合中定位相似的图像。\n核心思想：\n将图像从图像空间（image space）转换到特征空间（feature space） 每张图像可以表示为 $d$ 维特征向量 在特征空间中寻找离查询对象最近的点，即其最近邻居（nearest neighbour, NN） 距离度量：\n在 $d$ 维特征空间中，两点 $p = (p_1, p_2, \\ldots, p_d)$ 和 $q = (q_1, q_2, \\ldots, q_d)$ 之间的距离常用欧氏距离：\n$$d(p, q) = \\sqrt{\\sum_{i=1}^{d} (p_i - q_i)^2}$$最近邻搜索（NN Search）：\n给定查询点 $q$ 和数据集 $S$，找到 $p \\in S$ 使得：\n$$p = \\arg\\min_{x \\in S} d(q, x)$$其中，NN-dist 表示查询点到最近邻的距离。\n2. 一维空间索引方法 (1) 二叉搜索树（Binary Search Tree, BST）\n特点：\n左子树节点值 \u0026lt; 根节点值 \u0026lt; 右子树节点值 搜索时间复杂度：平均 $O(\\log n)$，最坏 $O(n)$（退化为链表） 不平衡的二叉搜索树：\n当插入顺序不当时，树会退化成链表结构 例如：依次插入 5, 10, 15, 20, 25, 22 会形成右偏树 搜索效率降低到 $O(n)$ (2) 红黑树（Red-Black Tree）\n定义： 一种自平衡的二叉搜索树，通过节点染色（红色/黑色）和旋转操作保持平衡。\n性质：\n每个节点是红色或黑色 根节点是黑色 所有叶子节点（NIL/null）是黑色 红色节点的两个子节点都是黑色（不能有两个连续的红色节点） 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点 性能：\n搜索、插入、删除时间复杂度：$O(\\log n)$ 保证最长路径不超过最短路径的2倍 (3) B树（B-Tree）\n特点：\n多路平衡搜索树，适合磁盘存储 每个节点可以有多个键值和子节点 所有叶子节点在同一层 结构组成：\n键值（key）：即索引中记录的主键 指针（pointer）：存储子节点地址的信息 数据（data）：即索引记录中除主键外的数据 性能：\n搜索、插入、删除时间复杂度：$O(\\log_m n)$，其中 $m$ 是节点的最大子节点数 减少磁盘I/O次数 (4) B+树（B+ Tree）\n特点：\nB树的变体，数据库索引的常用结构 所有数据都存储在叶子节点 非叶子节点只存储键值和指针，不存储数据 叶子节点之间通过指针连接，形成有序链表 优势：\n更高的扇出（fan-out），减少树的高度 叶子节点的链表结构便于范围查询 非叶子节点不存储数据，可以在内存中缓存更多索引项 性能：\n搜索时间复杂度：$O(\\log_m n)$ 范围查询效率：$O(\\log_m n + k)$，其中 $k$ 是返回的记录数 3. 多维空间索引方法 (1) R树（R-Tree）\n定义： R树是一种用于空间数据索引的树状数据结构，特别适合处理多维空间对象（如矩形、多边形等）。\n核心思想：\n用**最小边界矩形（MBR, Minimum Bounding Rectangle）**近似表示空间对象 构建层次化的MBR树结构 父节点的MBR包含其所有子节点的MBR 结构特点：\n叶子节点：存储实际的空间对象及其MBR 非叶子节点：存储子节点的MBR 同一层的MBR可能重叠 应用场景：\n地理信息系统（GIS） 计算机辅助设计（CAD） 空间数据库 (2) 空间填充曲线（Space-Filling Curves）\n基本思想： 通过连续曲线遍历多维空间中的所有点，将多维空间映射到一维空间，从而可以使用一维索引方法。\n1. Z曲线（Z-order Curve / Morton Curve）\n特点：\n也称为Morton码 通过交叉组合坐标的二进制位来编码 编码方式：对于二维点 $(x, y)$，交替取 $x$ 和 $y$ 的二进制位 编码示例（2维）：\n1阶Z曲线（$2 \\times 2$ 网格）\n编号顺序: 0 → 1 → 2 → 3 形状: Z字形 2阶Z曲线（$4 \\times 4$ 网格）：\n编号: 00 → 01 → 02 → 03 → \u0026hellip; → 30 → 31 → 32 → 33 （二阶其实就是又多了一个符号位，对4个$2 \\times 2$的网格进行再次编号$0,1,2,3$） 每个$2 \\times 2$子区域内部按Z字形连接 优点：\n编码简单，计算效率高 空间局部性较好 缺点：\n曲线不连续，存在跳跃 局部性保持不如Hilbert曲线 2. Hilbert曲线（Hilbert Curve）\n特点：\n连续的分形曲线 更好地保持空间局部性 相邻的曲线位置对应相邻的空间位置 递归构造：\n1阶Hilbert曲线：连接$2 \\times 2$网格中的4个点 $n$阶Hilbert曲线：将空间分为4个象限，每个象限是上一阶的曲线，起点经过**顺时针旋转$90^\\circ$**后连接起来 优点：\n更好的聚类性：空间上接近的点在曲线上也接近 曲线连续，无跳跃 缺点：\n编码计算相对复杂 生成算法复杂度较高 性能比较：\n特性 Z曲线 Hilbert曲线 计算复杂度 低 中 空间局部性 较好 优秀 连续性 不连续 连续 聚类效果 一般 优秀 4. 四叉树索引（Quadtree Index） (1) 定义与构造方法\n核心思想： 递归地将二维空间分割成四个相等的象限，直到每个区域满足特定条件。\n构造方法：\n将整个数据空间分割成四个相等的矩形，分别对应： 西北（NW, Northwest） 东北（NE, Northeast） 西南（SW, Southwest） 东南（SE, Southeast） 若每个象限内包含的要素不超过给定的**桶量（bucket size）**则停止 否则对超过桶量的矩形按照同样的方法进行划分 直到桶量满足要求或者不再减少为止，最终形成一颗有层次的四叉树 (2) 优缺点分析\n优点：\n一定程度上实现了地理要素真正被网格分割 保证了桶内要素不超过某个量，提高了检索效率 缺点：\n对于海量数据，四叉树的深度会很深，影响查询效率 可扩展性不如网格索引： 当扩大区域时，需要重新划分空间区域，重建四叉树 当增加或删除一个对象，可能导致深度加一或减一 叶节点也有可能重新定位 5. 网格索引（Grid Index） （1） 基本思想\n将研究区域用横竖线划分成大小相等或不等的网格，每个网格可视为一个桶（bucket）。\n索引构建：\n将空间划分为大小相等或不等的网格 记录落入每一个网格区域内的空间实体编号 建立网格号到对象列表的映射（倒排索引） 查询过程：\n先计算出查询对象所在网格 再在该网格中快速查询所选空间实体 （2） 倒排索引示例\n案例： 有三个制图物体：一条河流，一个湖泊，一条省界，关键字分别是 5, 11 和 23。\n对象-网格映射\n河流（ID=5）穿过的栅格：2, 34, 35, 67, 68 湖泊（ID=11）覆盖的栅格：68, 69, 100, 101 省界（ID=23）通过的栅格：5, 37, 36, 35, 67, 99, 98, 97 查询示例\n查询网格68：返回 [5, 11]（河流和湖泊） 查询网格35：返回 [5, 23]（河流和省界） （3） 优缺点分析\n优点\n简单：实现容易，概念直观 易于实现：数据结构简单，编码量少 缺点：网格大小影响检索性能\n三、高维空间的相似性搜索 1. 高维空间的特性 (1) 维度灾难问题\n问题引入： 在各维度上划分原始空间，生成若干个子空间，再将各点划至各子空间内。\n低维空间（2维或3维）：容易理解，且较为合理\n高维空间\n（例如100维）：\n将会产生 $2^{100} = 10^{30}$ 个子空间 几乎所有子空间都是空的 (2) 超立方体特性\n考虑超立方体，其边长为 0.95。\n2维情况：\n任意点在此子空间内的概率：$0.95^2 ≈ 0.90$ 100维情况：\n任意点在此子空间内的概率：$0.95^{100} ≈ 0.0059$ 结论： 随着维度增加，点落在中心区域的概率急剧下降。\n(3) 超球体特性\n考虑最大的超球（内切于单位立方体）。\n2维空间：\n超球的体积为 $\\pi/4 = 0.785$ 40维空间：\n超球的体积为 $3.278 × 10^{-21}$ 关键发现：\n显然，主要空间都在边边角角上 至少需要 $3 × 10^{20}$ 个点，才可期望在超球内部至少有一个点 2. 访问概率 (1) 问题定义\n核心问题： 给定任一查询，某个特定区域必定会被检索到的概率是多少？\n(2) 访问规则\n重要性质： 如果右边的区域先被访问，左边的也必须被访问到。这意味着在高维空间中，查询半径内的区域访问具有传递性。\n(3) 实验结果\n不同区域形状的访问概率：\n结论： 在维度增加到30-50维时，每个区域被访问到的概率极高。\n含义： 在高维空间中，传统的空间划分索引方法失效，因为几乎所有区域都需要被访问。\n3. 签名文件（Signature Files） (1) 设计思路\n核心理念：\n原始数据规模大、处理难度高 针对原始数据对象分别构建小规模的签名数据 这些数据能够以过滤器的角色支持谓词查询 (2) 工作流程\n处理步骤：\n使用哈希函数将原始数据映射为签名 签名文件作为第一层过滤器 只有通过过滤的数据才访问原始数据 优势：\n签名文件体积小，可以快速扫描 减少对原始数据的访问次数 适合作为预处理层 4. 向量近似文件（VA-File） (1) 算法概述\n来源： VLDB 1998\n基本思想：\n通过 **approximation（近似）**方式创建 VA-File 作为 Filter 先过滤大部分不可能的候选点 只对可能的候选点计算精确距离 (2) 数据结构\n空间划分：\n编码方式：\n将每个维度划分成若干个区间（例如用2比特表示4个区间：00, 01, 10, 11） 每个点用所在网格的编码表示 例如：点(0.1, 0.9) → 编码 \u0026ldquo;00 11\u0026rdquo; 示例：\n向量数据 VA-File编码 (0.1, 0.9) 00 11 (0.6, 0.8) 10 11 (0.1, 0.4) 00 01 (0.9, 0.1) 11 00 (3) 最小和最大边界\n关键概念：\nminBnd（最小边界）：查询点到网格的最小可能距离 maxBnd（最大边界）：查询点到网格的最大可能距离 重要性质： 各栅格的边界之间的距离可以预先计算！\n两阶段算法\n第1阶段：过滤\n针对每一点计算 minBnd 和 maxBnd 值 消除无法成为最近邻居的那些点 过滤一些点的minBnd小于已知最近邻的maxBnd值 approx. minBnd maxBnd rank 10 11 0.39 0.68 2 11 00 0.11 0.45 1 00 11 0.58 - × 00 01 0.47 - × 第2阶段：精炼\n根据 minBnd 以递增顺序访问各向量 计算真实的距离 当 minBnd 超出已知的最近邻居时，终止 (4) 性能分析\n块选择率随维度变化\n实验条件：N=100,000，均匀分布，k=10\n观察\n低维（\u0026lt;10维）：需要访问约3%的向量块 中维（10-30维）：访问率下降到约0.5% 高维（\u0026gt;30维）：访问率稳定在约0.3% 与树结构对比、模拟数据（N=50,000，k=10）、图像数据（N=50,000，k=10）、**运行时间对比：**详见PPT\n5. 深入理解：Contrast (1) 定义\nContrast 描述最近邻居与最远邻居之间的差异性高低：\n$$\\text{contrast} = \\frac{D_{\\max} - D_{\\min}}{D_{\\min}}$$(2) 维度影响\n当维度数量增多时，通常 contrast 值会降低 这意味着在高维空间中，所有点到查询点的距离趋于相似 (3) 距离分布\n观察： 对于任意点来说，到其他各个点的距离的分布情况随维度变化。\n不同维度的距离分布：\nd=2：分布较平缓，有明显的近邻和远邻区分 d=6：分布变得更集中 d=14：分布形状变得\u0026quot;尖锐\u0026quot; d=25：分布极度集中，几乎所有点距离都接近平均值 结论： 显然，当维度越高时，整体形状会越\u0026quot;尖锐\u0026quot;。\n(4) 几何直观\n从另一个视角看：\n在低维空间，查询点周围的点分布有明显的距离差异 在高维空间，所有点似乎都在同一个\u0026quot;超球面\u0026quot;上 这使得\u0026quot;最近邻\u0026ldquo;的概念变得模糊 第二讲 尾不等式 一、尾不等式分析概要 1. 问题引入 背景：\n很多情况下，精确计算一个随机事件的概率是很困难的。\n案例： 一个服从参数分别为 1,000 和 1/3 的二项分布随机变量 X，计算尾概率 Pr[X \u0026lt; 100]。\n解决思路：\n当精确计算比较困难时，利用近似方法求得概率的近似值不失为一种理想的选择 但近似方法又会涉及到另一个问题：近似值偏离真实值到底有多大？ 问题引入1：抛硬币问题\n假设抛一枚均匀的硬币，抛得正面和反面朝上的概率都为0.5，而且每次抛币与前次结果无关。\n直觉理解：直觉上来说，抛的次数越多正面朝上的频率越接近于0.5；当抛硬币的次数达到一定次数后，正面朝上的频率非常接近于0.5，波动很小 核心问题：抛多少次才能以95%的概率保证正面朝上的频率和真实概率间的差距小于某个阈值（比如0.125）呢？ 问题引入2：蒙特卡罗方法\n用蒙特卡罗方法（Monte Carlo方法）近似计算π的方法，如果随机打点 1,000,000次能保证以95%的概率近似π到2位、3位…小数吗?\n注： 蒙特卡罗法也称统计模拟法、统计试验法。是把概率现象作为研究对象的数值模拟方法。是按抽样调查法求取统计值来推定未知特性量的计算方法。\n2. 求解尾概率不等式的基本方法 求解一个问题的尾概率的方法通常可以分为两大类：\n(1) 定积分、查表法\n适用场景：当明确知道问题所对应的概率密度函数时 方法：可以采用定积分的方式，把尾概率所对应的区域累积起来；简单来说，可以通过查表法（概率教科书后面的表格）或者使用R/Matlab等软件来做 案例：标准正态分布表可以查询不同区间的概率值 (2) 尾概率不等式法\n适用场景：当无法确切知道对应的概率密度函数的时候 常见的尾概率不等式包括：Markov不等式、Chebyshev不等式、Chernoff不等式 二、三个常见的尾不等式 1. Markov不等式 定义： 令 X 为样本空间上的非负随机变量，对任意的一个正实数 a，有\n$$P(X \\geq a) \\leq \\frac{E[X]}{a}$$证明：\n假设 A 是一个事件，定义\n$$A = {\\omega \\in \\Omega | X(\\omega) \\geq a}$$则随机变量的期望可以计算为：\n$$E(X) = \\sum_{\\omega \\in \\Omega} X(\\omega)P(\\omega)$$$$= \\sum_{\\omega \\in A} X(\\omega)P(\\omega) + \\sum_{\\omega \\notin A} X(\\omega)P(\\omega)$$$$\\geq a \\cdot P(A) + \\sum_{\\omega \\notin A} X(\\omega)P(\\omega)$$$$\\geq a \\cdot P(A)$$因此，结论成立，即\n$$P(A) = P(X \\geq a) \\leq \\frac{E(X)}{a}$$案例分析：\n令随机变量X为抛n次均匀硬币正面向上的次数，运用Markov不等式计算n次抛币结果中正面朝上的次数超过3n/4的概率上界。\n解：因为随机变量X是一个n次独立的贝努里实验结果，因此 $E(X) = np$，其中 p 为每次贝努里实验的成功概率。根据Markov不等式，$$P(X \u003e 3n/4) \\leq \\frac{E[X]}{3n/4} = \\frac{n/2}{3n/4} = \\frac{2}{3}$$ 分析：直觉上说，硬币抛的次数越多，正面向上的频率应该越接近于1/2，那么频率大于3/4的概率应该越小。而Markov不等式给出的上界与硬币抛的次数n无关。可以看出，Markov不等式给出的尾概率上界比较松。 2. Chebyshev不等式 定义： 令X为定义在样本空间Ω上的随机变量，令E(X)和Var(X)分别为X的期望和方差，对任意的一个正实数r，有\n$$P(|X - E(X)| \\geq r) \\leq \\frac{Var(X)}{r^2}$$证明思路：\n不难看出，\n$$P(|X - E(X)| \\geq r) = P((X - E(X))^2 \\geq r^2)$$已知 $E((X - E(X))^2) = Var(X)$，对上式中的尾概率运用 Markov 不等式得到\n$$P((X(\\omega) - E(X))^2 \\geq r^2) \\leq \\frac{E((X(\\omega) - E(X))^2)}{r^2} = \\frac{Var(X)}{r^2}$$因此，结论成立。\n案例分析：\n令随机变量X为抛n次均匀硬币正面向上的次数，运用Chebyshev不等式计算n次抛币结果中正面朝上的次数超过3n/4的概率上界。\n解：已知 $E[X] = np$；$Var[X] = np(1-p)$。$$P(X \u003e 3n/4) = P(X/n \u003e 3/4) = P(X/n - 1/2 \u003e 1/4)$$ $$\u003c P(|X/n - 1/2| \u003e 1/4) \\leq \\frac{16np(1-p)}{n^2} = \\frac{4}{n}$$ 结论：显然，当 n=80 时，这个概率就小于 5% 了。这说明 Chebyshev不等式给出的界比 Markov不等式更紧。 3. Chernoff不等式 基本概念：\n独立Bernoulli试验：令 $X_1, X_2, ..., X_n$ 为独立的n个事件，$Pr[X_i=1] = p$；$Pr[X_i=0] = 1-p$。令 $X = \\sum X_i$，则称X具有二项分布。 Poisson试验：令 $X_1, X_2, ..., X_n$ 为独立的n个事件，$Pr[X_i=1] = p_i$；$Pr[X_i=0] = 1-p_i$。令 $X = \\sum X_i$。易知，Bernoulli试验是Poisson试验的特例。 Chernoff不等式（简化版）：\n若 $X_i$ 为定义在样本空间Ω上的n个独立贝努里随机变量，且 $P(X_i=1) = p_i$。令 $X = \\sum_{i=1}^{n} X_i$ 和 $\\mu = \\sum_{i=1}^{n} p_i$，对任意小的 $\\delta \\in (0,1)$，则以下不等式成立：\n$$P(X \u003c (1-\\delta)\\mu) \u003c \\exp(-\\mu\\delta^2/2)$$$$P(X \u003e (1+\\delta)\\mu) \u003c \\exp(-\\mu\\delta^2/4)$$Chernoff不等式（精确版）：\n$$P(X \u003c (1-\\delta)\\mu) \u003c \\left(\\frac{e^{-\\delta}}{(1-\\delta)^{(1-\\delta)}}\\right)^\\mu$$$$P(X \u003e (1+\\delta)\\mu) \u003c \\left(\\frac{e^{\\delta}}{(1+\\delta)^{(1+\\delta)}}\\right)^\\mu$$证明思路：\n证明第一个不等式。对任意 $t \u003e 0$，\n$$P(X \u003c (1-\\delta)\\mu) = P(\\exp(-tX) \u003e \\exp(-t(1-\\delta)\\mu))$$$$\u003c \\frac{\\prod_{i=1}^{n} E(\\exp(-tX_i))}{\\exp(-t(1-\\delta)\\mu)}$$因为 $(1-x \u003c e^{-x})$，所以\n$$E(\\exp(-tX_i)) = p_ie^{-t} + (1-p_i)$$$$= 1 - p_i(1-e^{-t})$$$$\u003c \\exp(p_i(e^{-t}-1))$$因此，\n$$\\prod_{i=1}^{n} E(\\exp(-tX_i)) \u003c \\prod_{i=1}^{n} \\exp(p_i(e^{-t}-1))$$$$= \\exp(\\mu(e^{-t}-1))$$进一步的，\n$$P(X \u003c (1-\\delta)\\mu) \u003c \\frac{\\exp(\\mu(e^{-t}-1))}{\\exp(-t(1-\\delta)\\mu)} = \\exp(\\mu(e^{-t}+t-t\\delta-1))$$上式中的上界是关于变量 t 的函数，随着 t 取值的变化，概率上界也在变化。因此可以通过择 t 的值，得到概率上界的最小值。为了获得概率上界的最小值，对 $\\mu(e^{-t}+t-t\\delta-1)$ 关于 t 求导，并令其为 0，得到当 $t = \\ln\\frac{1}{1-\\delta}$ 时，概率上界取到最小值。将 $t = \\ln\\frac{1}{1-\\delta}$ 代入公式，可以得到结论。\n应用案例：\n案例1：球队胜率\n某球队赢每一场比赛的概率是1/3。假设比赛结果相互独立，试求他们在一个有n场比赛的赛季获得一半以上场次胜利的概率的上界。\n分析：$X_i$：获胜为1，输为0。则和 $Y = \\sum X_i$，$\\mu = E[Y] = n/3$；$\\delta = 1/2$。$$P(Y \u003e (1+0.5)\\mu) \u003c \\exp(-\\mu\\delta^2/4) = \\exp\\left(-\\frac{n}{3} \\cdot \\frac{(1/2)^2}{4}\\right) = \\exp(-n/48)$$ 结论：若 n=40，概率不高于 0.43；若 n=100，概率不高于 0.12。备注：若调用更精确版本，这两个概率分别为：0.23、0.027 案例1（补充）\n某球队赢每一场比赛的概率是3/4。假设比赛结果相互独立，试求他们在一个有n场比赛的赛季输掉一半以上场次的概率的上界。\n分析：$X_i$：获胜为1，输为0。则和 $Y = \\sum X_i$，$\\mu = E[Y] = 3n/4$；此时，$\\delta = 1/3$。$$P(Y \u003c n/2) = P(Y \u003c (1-1/3)\\mu) \u003c \\exp(-\\mu\\delta^2/2) = \\exp(-n/24)$$ 结论：n=40，概率小于 0.19；n=100，概率小于 0.015 案例2：球和箱子\n均匀、独立地将n个球放置到n个箱子里。令随机变量 $Y_1$ 表示放到第一个箱子里的球的个数。希望确定值m，使得 $Pr[Y_1 \u003e m] \\leq 1/n^2$。\n分析：易知，$p_i = 1/n$；$\\mu = 1$。$$P[X \u003e (1+\\delta)\\mu] \u003c \\exp(-\\mu\\delta^2/4) = 1/n^2$$两边取对数：$\\mu\\delta^2/4 = 2\\ln n$ ⇒ $\\delta = \\sqrt{8\\ln n}$ 案例3：集合平衡（Set Balancing）\n考虑一个 n×m 的矩阵A，各项为0或1，如何寻找向量 $b \\in {-1, +1}^m$，使得 $||Ab||_\\infty$ 最小。\n问题建模：令 $c = Ab$，则 $||Ab||*\\infty = \\max(c_i)$。考虑m个物品（subject），各有最多n个特性（feature），构成一个 n×m 的矩阵A。各列代表一个物品，各行代表特性。项 $a*{ij} \\in {0, 1}$ 表示物品j是否拥有特性i。 核心思想：通过向量b将所有物品划分成两个分组，每一个项的值 $c_i$ 表示这两个分组在第i个特性上的划分的差值。如果能够使得这样的差值在各个特性上均很小，那么就说明各个特性均比较均匀地划分到两个组之中。 算法设计：构造了一个极度简单的算法来构成向量b：各项 $b_i$ 随机均匀地从 {-1, +1} 中选取，即：$$b_i = \\begin{cases} -1 \u0026 \\text{with probability } 1/2 \\ +1 \u0026 \\text{with probability } 1/2 \\end{cases}$$这个算法极度简单，因为根本没有考虑A。 分析：考虑矩阵 A 的第 i 行，则 $c_i = \\sum_j a_{ij}b_j$。令 k 是该行中非0项的个数。$|c_i|$ 的期望值是0。当 $k \\leq 2\\sqrt{2m\\ln n}$ 时，显然 $|c_i|$ 小于等于式子右边。因此，主要考虑k的值比较大的情况。值为+1的项数的期望值为 k/2。当 $c_i \u003c -2\\sqrt{2m\\ln n}$ 时，正的 $b_i$\u0026rsquo;s 不超过 $\\frac{k}{2} - \\sqrt{2m\\ln n} = (1-\\delta)\\mu$。应用Chernoff不等式，得：$$\\exp\\left(-\\frac{\\mu\\delta^2}{2}\\right) = \\exp\\left(-\\frac{k}{2} \\cdot \\frac{8m\\ln n}{2k^2}\\right) = \\exp\\left(-\\frac{2m\\ln n}{k}\\right) \\leq \\exp\\left(-\\frac{2m\\ln n}{m}\\right) \\leq n^{-2}$$说明对单个 $c_i$ 而言，单边的最大概率是 $n^{-2}$。而在该例中，有双边概率，因此：$$Pr[|c_i| \u003e 2\\sqrt{2m\\ln n}] \\leq \\frac{2}{n^2}$$最后，取得n行的一个最终值：$$Pr[||Ab||_\\infty \u003e 2\\sqrt{2m\\ln n}] \\leq n \\cdot Pr[|c_i| \u003e 2\\sqrt{2m\\ln n}] \\leq \\frac{2}{n}$$ 案例4：抛硬币（Chernoff版本）\n令随机变量X为抛n次均匀硬币正面向上的次数，运用Chernoff不等式计算n次抛币结果中正面朝上的次数超过3n/4的概率上界。\n解：已知 $E(X) = np = n/2$。运用Chernoff不等式，$$P(X \u003e 3n/4) = P(X \u003e (1+1/2) \\cdot n/2)$$ $$= P(X \u003e (1+1/2)E(X))$$ $$\u003c \\exp\\left(-\\frac{n}{2} \\cdot (1/2)^2 / 4\\right)$$ $$= \\exp(-n/32)$$ 结果：当 n=50 时，概率为：0.21；当 n=80 时，概率为：0.08；当 n=300 时，概率为：0.000085 4. 尾概率不等式的实际使用 关于尾概率不等式的实际使用，其实是要回答三类问题。这里的原因在于总共有三个控制参数：一个是次数 n，一个是偏移期望的程度 δ，另一个是最终的置信度参数。总是可以固定两个参数，求另外一个参数的情况。\n问题类型：\n其一：已知采样次数和偏移的程度，求解置信度 其二：已知采样次数和置信度，求解偏移的程度 其三：已知置信度和偏移的程度，求解采样次数 第一类问题示例：\n例如：投掷了硬币1000次，总的期望值是500，则当 δ=0.2 的时候，即是在询问正面朝上的总次数超过了 (1+0.2)×500=600 的概率。\n已知：n=1000，μ=1/2，δ=0.2，求解置信度 根据Chernoff不等式：$$P[X \u003e (1+\\delta)n\\mu] \u003c \\exp(-n\\mu\\delta^2/4)$$即：$P[X \u003e 600] \u003c \\exp(-5) = 0.0067$ 第二类问题示例：\n例如：总共投掷了1000次，总的期望值是500，则当想要知道正面朝上的概率不低于95%时，能够确保的正面朝上的次数是几次。\n已知：n=1000，μ=1/2，置信度为0.05，求解偏移程度 根据Chernoff不等式，$P[X \u003e (1+\\delta)n\\mu] \u003c \\exp(-n\\mu\\delta^2/4)$ 令 $\\exp(-n\\mu\\delta^2/4) = 0.05$，则：δ=0.15，(1+0.15)×500=575 则能够以95%的概率确保的正面朝上的次数为575次 第三类问题示例：\n至少需要投掷几次硬币，才可确保正面朝上的比率在0.6以下的概率不低于95%。\n分析：μ=1/2；(1+δ)μ=0.6 ⇒ δ=0.2 根据Chernoff不等式：$P[X \u003e (1+\\delta)n\\mu] \u003c \\exp(-n\\mu\\delta^2/4)$ 可以得到：$\\exp(-0.04n\\mu/4) \u003c 0.05$ 求解以上式子，得到：n \u0026gt; 599.1 所以至少需要投掷600次硬币才能保证正面朝上的比率在0.6以下的概率不低于95% 三、计数问题 1. Morris算法 问题背景与动机：\n场景描述：某电子商城想记录某本畅销书的销售量 传统方法：用一个整数变量来描述，初始化为0，每卖出一本则加1 问题分析：用二进制表示数n需要 $\\lceil \\log_2 n \\rceil$ 位，即计算机需要 $\\lceil \\log_2 n \\rceil$ 位存储整数n。当n值比较大时，存储开销会很大，可否降低开销？ Morris算法原理：\n核心思想是只需要 $\\lceil \\log_2 \\log_2 n \\rceil$ 位就可以近似表示一个大整数。\n算法描述：\nMorris算法 Input: 事件流F Output: 指定事件的计数 C 1 初始化计数器X=0 2 while 事件流F未结束 do 3 if 指定事件发生 then 4 以 1/2^X 的概率更新 X=X+1 5 C=2^X-1 6 return C 两个核心操作：\n更新操作：当指定事件发生时，以 $1/2^X$ 的概率更新X的值为X+1；以 $1-1/2^X$ 的概率保持X的值不变 估计计数结果：返回近似估计值 $C = 2^X - 1$ Morris算法示例：\n事件流 真实计数 抽样概率 X的值 计数估计值 0 1 0 0 1 1 1/2 1 1 1 2 1/2 1 1 1 3 1/4 2 3 1 4 1/4 2 3 1 5 1/4 2 3 1 6 1/4 2 3 1 7 1/8 3 7 1 8 1/8 3 7 Morris算法理论分析：\n定理：令事件真实计数为N，$X_N$ 是Morris算法维护的计数器，则其输出的估计值 $2^{X_N}-1$ 是真实计数N的无偏估计。\n证明过程：注意到当 $X_{N-1} = j$ 时，$X_N = j+1$ 的概率为 $2^{-j}$，而保持 $X_N = j$ 的概率为 $1-2^{-j}$，因此\n$$E(2^{X_N}) = E(E(2^{X_N}|X_{N-1}=j))$$$$= \\sum_{j \\geq 1} P(X_{N-1}=j)E(2^{X_N}|X_{N-1}=j)$$接下来，条件数学期望 $E(2^{X_N}|X_{N-1}=j)$ 可以计算如下：\n$$E(2^{X_N}|X_{N-1}=j) = 2^{j+1}2^{-j} + 2^j(1-2^{-j})$$$$= 2^j + 2 - 1 = 2^j + 1$$最后，运用数学归纳法证明最终结果。\n当 N=1 时，$X_N = 1$。因此，$E(2^1-1) = 2^1-1 = 1$ 结论成立。\n假设当 N=k 时，结论 $E(2^{X_k}-1) = k$ 也成立。\n当 N=k+1 时，\n$$E(2^{X_{k+1}}) = E(E(2^{X_{k+1}}|X_k=j))$$$$= \\sum_{j \\geq 1} P(X_k=j)E(2^{X_{k+1}}|X_k=j)$$$$= \\sum_{j \\geq 1} P(X_k=j)(2^j+1)$$$$= \\sum_{j \\geq 1} P(X_k=j)(2^j-1) + \\sum_{j \\geq 1} P(X_k=j)2$$$$= E(2^{X_k}-1) + 2$$$$= k + 2$$即当 N=k+1 时，有 $E(2^{X_{k+1}}-1) = k+1$ 也成立。\n方差分析：\n$$Var(2^{X_N}) = E((2^{X_N})^2) - (E(2^{X_N}))^2$$$$= E(2^{2X_N}) - (N+1)^2$$通过递推可以得到：\n$$E(2^{2X_N}) = \\frac{3N(N+1)}{2} + 1$$所以，\n$$Var(2^{X_N}) \\approx \\frac{1}{2}N^2$$ 2. Morris+算法 问题分析与改进思路：\nMorris算法的劣势：虽然Morris算法给出了真实计数的无偏估计，但随着计数N的增加，该估计的方差以二次多项式的形式在增加 统计学重要结论：令 $X_1, X_2, ..., X_n$ 为n个独立同分布的样本，且对任意 $1 \\leq i \\leq n$ 有 $E(X_i) = \\mu$ 和 $Var(X_i) = \\sigma^2$，那么样本均值的期望与方差分别为$$E(\\sum X_i / n) = \\mu$$ $$Var(\\sum X_i / n) = \\sigma^2 / n$$ 结论：通过多次估计取平均可以获取波动更小的计数的无偏估计 Morris+算法描述：\n核心思想：对事件计数的每次更新维护n个计数，当事件流结束时，计算这n个计数的平均值，会得到波动更小的真实计数的无偏估计。\nMorris+算法 输入：事件流F, δ和ε 输出：指定事件计数C 01 n = ⌈1/δε²⌉ 02 初始化计数数组 X[1…n]=0 03 while 事件流F未结束 do 04 if 指定事件发生 then 05 for i=1 to n do 06 以1/2^Xi的概率更新Xi=Xi+1 07 for i=1 to n do 08 C=C+2^Xi-1 09 C=C/n 10 return C Morris+算法分析：\n根据方差的性质，相对于Morris算法，Morris+算法返回的计数估计值的方差减小到了 $O(N^2/n)$。\n根据Chebyshev不等式，\n$$P(|\\hat{N} - N| \u003e \\varepsilon N) \u003c \\frac{Var(\\hat{N})}{\\varepsilon^2 N^2}$$由于 $Var(\\hat{N}) = O(N^2/n)$，因此：\n$$P(|\\hat{N} - N| \u003e \\varepsilon N) \u003c \\frac{O(N^2/n)}{\\varepsilon^2 N^2} \\approx \\frac{1}{n\\varepsilon^2}$$令 $\\frac{1}{n\\varepsilon^2} \u003c \\delta$，即 $n = O(1/\\delta\\varepsilon^2)$ 时，$P(|\\hat{N} - N| \u003e \\varepsilon N) \u003c \\delta$\n这表明事件计数的估计值是偏离真实值N大于εN的概率小于δ。此时，称 $\\hat{N}$ 为N的 (ε,δ)近似估计。\n复杂度分析：\n空间复杂度：总共有 $O(1/\\delta\\varepsilon^2)$ 个计数器，每个计数器占用 $O(\\log\\log n)$ 位。因此，空间复杂度是：$O(\\log\\log n / \\delta\\varepsilon^2)$ 时间复杂度（Per-tuple processing cost）：每处理一个元素，需要循环 $O(1/\\delta\\varepsilon^2)$ 次，因此开销是 $O(1/\\delta\\varepsilon^2)$ 3. Morris++算法 拔河（Tug-of-War）思想：\n当目标概率是δ时，可以将实例数从 $1/\\delta$ 降至 $\\log(1/\\delta)$。\n核心思路：运行 t 个Morris+实例，每个实例的失败概率为 1/3，即：$$P(|\\hat{N} - N| \u003e \\varepsilon N) \u003c \\frac{1}{2k\\varepsilon^2} = \\frac{1}{3}$$注：每个Morris+运行了k个Morris实例，且 $k = O(1/\\varepsilon^2)$。然后，输出所有 t 个Morris+实例的中位数估计值。 关键观察：失败的 Morris+ 实例的预期数量不超过 t/3。如果中位数估计值出错，则表明至少一半Morris+ 实例失败了，表示失败实例的数量至少偏离期望值达到 t/6。（原因：t/3 + t/6 = t/2） Morris++算法描述：\nMorris++算法 输入：事件流F, δ和ε 输出：指定事件计数C 01 n = ⌈ln1/δ⌉, m = ⌈1/ε²⌉ 02 初始化数组X[1…n, 1…m]=0, C[1…n]=0 03 while 事件流F未结束 do 04 if 指定事件发生 then 05 for i=1 to n do 06 for j=1 to m do 07 以1/2^Xij的概率更新Xij=Xij+1 08 for i=1 to n do 09 for j=1 to m 10 Ci=Ci+(2^Xij-1) 11 Ci = Ci/n 12 C=C[1…n]的中位数 13 return C Morris++算法分析：\n定义：\n$$Y_i = \\begin{cases} 1, \u0026 \\text{if } |\\frac{1}{k}\\sum_{j=1}^{k} \\hat{n}_{ij} - n| \u003e \\varepsilon N \\ 0, \u0026 \\text{Otherwise} \\end{cases}$$由于 $k = O(1/\\varepsilon^2)$，可知：$P(Y_i=1) \u003c 1/3$\n由于 $\\mu = E(\\sum Y_i) = t/3$，通过Chernoff不等式，可知\n$$P(\\sum Y_i \u003e t/2) \\leq P(\\sum Y_i \u003e (1+1/2)\\mu)$$$$\\leq \\exp(-\\mu(1/2)^2/4) \u003c \\exp(-t/48) \u003c \\delta$$因此：可知：$t = O(\\log 1/\\delta)$\n最终结论：可以用 $O(\\log(1/\\delta)/\\varepsilon^2)$ 个Morris实例的复杂度来得到 (ε, δ) 近似的算法。\n进一步分析：\n总体思路：利用tug-of-war方法降低了空间复杂度 综合运用了Chebyshev不等式和Chernoff不等式： 在调用Chebyshev不等式时，目的是将失败概率降低到常数量级（例如1/3） 在调用Chernoff不等式时，才将失败概率降低到任意一个给定阈值 思考：第一步的失败概率如果是1/4，或者1/2，是否也可行？ 第三讲 数据流 一、数据流模型 数据流模型描述了数据以流的形式到达，只能顺序访问一次或有限次的计算场景。\n数据流的特点：\n数据量巨大，无法全部存储 数据到达速度快，需要实时处理 只能进行一次或有限次扫描 需要在有限空间内近似计算 典型应用：\n网络流量监控 金融交易分析 社交媒体数据处理 IoT传感器数据 数据流算法的目标：\n使用亚线性（sublinear）空间 提供可证明的近似保证 单次扫描或少量扫描 二、频繁元素-确定性算法 问题定义： 找出数据流中出现频率超过某个阈值的元素（heavy hitters）。\nMisra-Gries算法：\n算法描述：\n维护最多k个计数器 对于每个到来的元素： 如果已有计数器，增加其计数 如果没有计数器且有空位，创建新计数器 如果没有空位，所有计数器减1，删除值为0的计数器 输出计数器中的元素 性能保证：\n空间复杂度：O(k) 如果元素出现次数 \u0026gt; n/k，一定会被找到 可能有假阳性，但可以通过二次扫描验证 应用：\n找出访问量最大的网页 检测网络中的大流量 识别热门话题 三、频繁元素-随机算法 Count-Min Sketch算法：\n数据结构：\nd × w 的二维计数器数组 d个独立的哈希函数h₁, h₂, \u0026hellip;, h_d 算法操作：\n更新（插入元素x）：\n对于 i = 1 到 d： count[i][hᵢ(x)] += 1 查询（估计元素x的频率）：\n返回 min{count[i][hᵢ(x)] : i = 1..d} 性能保证：\n空间复杂度：O(d × w) 误差界：ε·n (n为总元素数)，概率至少1-δ 选择w = ⌈e/ε⌉, d = ⌈ln(1/δ)⌉ 只会高估，不会低估 优势：\n空间效率高 支持点查询和范围查询 可以处理删除操作（使用带符号的计数） 四、滑动窗口模型 问题描述： 只关心最近W个元素的统计特性，更早的数据被丢弃。\n挑战：\n无法存储所有W个元素 需要及时更新统计信息 DGIM算法（用于计数）：\n基本思想：\n将窗口划分为桶（bucket） 每个桶代表一段连续的1 桶的大小是2的幂次 维护O(log W)个桶 桶的性质：\n每种大小的桶最多2个 桶按时间戳排序 最老的桶可能不完整 查询操作： 统计窗口内1的个数 ≈ 完整桶的大小之和 + 半个最老桶\n误差保证：\n相对误差：最多50% 可以通过增加每种大小桶的数量来降低误差 应用扩展：\n滑动窗口中的平均值 滑动窗口中的中位数（近似） 滑动窗口中的distinct计数 第四讲 分布式数据流 一、分布式数据流模型 在分布式环境中，数据流分散在多个节点上，需要协调多个节点进行计算。\n系统架构：\n多个监测节点：每个节点观察部分数据流 协调节点：汇总和处理来自监测节点的信息 通信约束：最小化节点间的通信量 挑战：\n数据分散性 通信开销 同步问题 节点故障 典型场景：\n分布式网络监控 多数据中心的日志分析 边缘计算 CDN流量统计 二、聚集查询 问题定义： 计算分布在多个节点上的数据的聚集函数（如SUM、COUNT、AVG）。\n基本方法：\n1. 连续聚集：\n每个节点维护本地的统计信息 周期性发送给协调节点 协调节点汇总计算全局结果 2. 快照聚集：\n在特定时刻获取全局快照 需要处理同步问题 使用逻辑时钟或物理时钟 优化技术：\n采样与估计：\n不发送所有数据，只发送样本 使用统计方法估计全局结果 权衡精度和通信开销 增量更新：\n只发送变化部分 减少冗余通信 适用于变化缓慢的数据 数据结构支持：\n使用Count-Min Sketch等概要结构 可以在协调节点合并 支持分布式查询 三、topk监控 问题定义： 实时监控分布式系统中全局的top-k元素（如最热门的k个商品、最活跃的k个用户）。\n挑战：\n全局top-k可能不在任何单个节点的局部top-k中 需要在精度和通信量之间平衡 数据分布可能高度倾斜 解决方案：\n1. 阈值算法：\n协调节点维护全局top-k的阈值θ 每个节点报告超过θ的元素 动态调整θ以平衡通信量 算法流程：\n初始化：θ = 0 循环： 1. 每个节点报告频率 \u0026gt; θ 的元素 2. 协调节点更新全局top-k 3. 计算新阈值θ（如第k大元素的频率） 4. 将θ广播给各节点 2. 采样方法：\n各节点以概率p采样元素 上传采样的数据到协调节点 基于采样数据估计全局top-k 3. 层次化监控：\n构建监控树 中间节点聚合子节点的信息 减少单点通信压力 性能优化：\n局部过滤：只上传可能进入全局top-k的元素 批量通信：积累一定数量的更新后批量发送 缓存机制：利用时间局部性减少通信 实际应用：\n实时热搜榜 分布式缓存的热点识别 网络安全中的异常检测 广告系统的CTR监控 第五讲 哈希 一、哈希函数和哈希表 哈希技术是一种通过哈希函数将数据映射到固定大小的表中的方法，实现快速的数据存储和检索。\n核心概念：\n哈希函数：将任意大小的数据映射到固定大小的值 哈希表：基于数组实现的数据结构，通过哈希函数计算索引位置 冲突处理：当不同的键映射到相同位置时的解决策略 链地址法（Chaining） 开放地址法（Open Addressing） 时间复杂度：\n平均情况：O(1) 查找、插入、删除 最坏情况：O(n)（当所有元素都冲突时） 二、布隆过滤器（Bloom Filter） 布隆过滤器是一种空间高效的概率型数据结构，用于判断一个元素是否在集合中。\n特点：\n可能产生假阳性（False Positive）：说存在但实际不存在 不会产生假阴性（False Negative）：说不存在就一定不存在 不支持删除操作（标准版本） 应用场景：\n网页URL去重 垃圾邮件过滤 缓存穿透防护 大数据去重 工作原理：\n使用k个不同的哈希函数 将元素映射到位数组的k个位置 查询时检查这k个位置是否都为1 三、最小哈希和LSH（Locality-Sensitive Hashing） 最小哈希（MinHash）： 用于估计两个集合的Jaccard相似度，常用于文档去重和相似度检测。\n局部敏感哈希（LSH）： 一种降维技术，使得相似的数据项以高概率被映射到相同的桶中。\n应用：\n近似最近邻搜索 图像相似度检测 文本去重 推荐系统 第六讲 线性规划与整数规划 线性规划问题研究在资源约束条件下的最大化或最小化目标问题,表示方式有标准型和松弛型,单纯形算法来求解线性规划问题 整数规划比线性规划有更多约束条件 分支界定法是解决整数规划问题的有效方法，但是当变量数量多的时候效率会下降 切平面法是解决整数规划问题的有效方法 一、线性规划:单纯形算法 1. 线性函数与线性规划 线性函数的定义:\n给定一组实数 $a_1, a_2, ..., a_n$ 和一组变量 $x_1, x_2, ..., x_n$,定义在这些变量上的线性函数为:\n$$f(x_1, x_2, ..., x_n) = a_1x_1 + a_2x_2 + ... + a_nx_n$$线性约束的定义:\n如果 $b$ 是一个实数,而 $f$ 是一个线性函数,则:\n$f(x_1, x_2, ..., x_n) = b$ 是线性等式 $f(x_1, x_2, ..., x_n) \\geq b$ 和 $f(x_1, x_2, ..., x_n) \\leq b$ 是线性不等式 线性约束表示线性等式或者线性不等式。\n线性规划问题的定义:\n一个线性规划问题是指:一个线性函数最小化或最大化的问题,该线性函数服从一组有限个线性约束。\n可以分为:\n最小化线性规划 vs. 最大化线性规划 线性规划的几何意义:\n可行解:满足所有约束条件的 $x_1, x_2$ 的取值称为一个可行解 可行区域:所有可行解构成的区域 示例:\n$$ \\begin{align} \\text{最大化} \\quad \u0026 x_1 + x_2 \\\\ \\text{满足约束条件:} \\quad \u0026 4x_1 - x_2 \\leq 8 \\\\ \u0026 2x_1 + x_2 \\leq 10 \\\\ \u0026 5x_1 - 2x_2 \\geq -2 \\\\ \u0026 x_1, x_2 \\geq 0 \\end{align} $$在图示中,可行区域为一个多边形区域,最优解 $x_1 + x_2 = 8$ 出现在可行域的顶点处。\n重要性质: 线性规划的最优解通常出现在可行域的顶点处。\n2. 线性规划转标准型 标准型的定义:\n已知 $n$ 个实数 $c_1, c_2, ..., c_n$; $m$ 个实数 $b_1, b_2, ..., b_m$; 以及 $mn$ 个实数 $a_{ij}$, 其中 $i = 1,2,...,m$;$j = 1,2,...,n$。需要找到 $n$ 个实数 $x_1, x_2,...,x_n$。\n一般形式:\n$$ \\begin{align} \\text{最大化} \\quad \u0026 c_1x_1 + c_2x_2 + ... + c_nx_n \\quad \\text{(目标函数)} \\\\ \\text{满足约束条件:} \\quad \u0026 a_{i1}x_1 + a_{i2}x_2 + ... + a_{in}x_n \\leq b_i \\quad (i = 1,2,...,m) \\quad \\text{(约束)} \\\\ \u0026 x_j \\geq 0 \\quad (j = 1,2,..., n) \\quad \\text{(非负约束)} \\end{align} $$矩阵表示形式:\n构造:\n$m \\times n$ 矩阵 $A = (a_{ij})$ 一个 $m$ 维向量 $b = (b_i)$ 一个 $n$ 维向量 $c = (c_i)$ 一个 $n$ 维向量 $x = (x_i)$ 标准型可表示为:\n$$ \\begin{align} \\text{最大化} \\quad \u0026 c^Tx \\quad \\text{(目标函数)} \\\\ \\text{满足约束条件:} \\quad \u0026 Ax \\leq b \\quad \\text{(约束)} \\\\ \u0026 x \\geq 0 \\quad \\text{(非负约束)} \\end{align} $$可用元组 (A, b, c) 表达一个标准的线性规划问题。\n标准型的特点:\n目标函数是最大化 所有约束都是不等式(小于等于号) 所有变量都有非负约束 转换为标准型的技巧:\n一个线性规划问题可能不是标准型,可能的原因及解决方法包括:\n(1)目标函数是最小化而非最大化\n解决方法: 将目标函数中的系数取负数\n示例:\n$$ \\begin{aligned} \\text{最小化} \\quad \u0026 -2x_1 + 3x_2 \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2 = 7 \\\\ \u0026 x_1 - 2x_2 \\leq 4 \\\\ \u0026 x_1 \\geq 0 \\end{aligned} \\quad \\rightarrow \\quad \\begin{aligned} \\text{最大化} \\quad \u0026 2x_1 - 3x_2 \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2 = 7 \\\\ \u0026 x_1 - 2x_2 \\leq 4 \\\\ \u0026 x_1 \\geq 0 \\end{aligned} $$ (2)变量不具有非负约束\n解决方法: 将该变量 $x_j$ 每次出现的地方都改为 $x_j' - x_j''$,且 $x_j'$ 和 $x_j''$ 均 $\\geq 0$\n示例:\n$$ \\begin{aligned} \\text{最大化} \\quad \u0026 2x_1 - 3x_2 \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2 = 7 \\\\ \u0026 x_1 - 2x_2 \\leq 4 \\\\ \u0026 x_1 \\geq 0 \\end{aligned} \\quad \\rightarrow \\quad \\begin{aligned} \\text{最大化} \\quad \u0026 2x_1 - 3x_2' + 3x_2'' \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2' - x_2'' = 7 \\\\ \u0026 x_1 - 2x_2' + 2x_2'' \\leq 4 \\\\ \u0026 x_1, x_2', x_2'' \\geq 0 \\end{aligned} $$ (3)可能有等式约束\n解决方法: 转化成一对不等式\n示例:\n$$ \\begin{aligned} \\text{最大化} \\quad \u0026 2x_1 - 3x_2' + 3x_2'' \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2' - x_2'' = 7 \\\\ \u0026 x_1 - 2x_2' + 2x_2'' \\leq 4 \\\\ \u0026 x_1, x_2', x_2'' \\geq 0 \\end{aligned} \\quad \\rightarrow \\quad \\begin{aligned} \\text{最大化} \\quad \u0026 2x_1 - 3x_2' + 3x_2'' \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2' - x_2'' \\leq 7 \\\\ \u0026 x_1 + x_2' - x_2'' \\geq 7 \\\\ \u0026 x_1 - 2x_2' + 2x_2'' \\leq 4 \\\\ \u0026 x_1, x_2', x_2'' \\geq 0 \\end{aligned} $$ (4)可能有不等式约束,但不是小于等于号,而是大于等于号\n解决方法: 更改约束的符号(两边同时乘以 $-1$)\n示例:\n$$ \\begin{aligned} \\text{最大化} \\quad \u0026 2x_1 - 3x_2' + 3x_2'' \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2' - x_2'' \\leq 7 \\\\ \u0026 x_1 + x_2' - x_2'' \\geq 7 \\\\ \u0026 x_1 - 2x_2' + 2x_2'' \\leq 4 \\\\ \u0026 x_1, x_2', x_2'' \\geq 0 \\end{aligned} \\quad \\rightarrow \\quad \\begin{aligned} \\text{最大化} \\quad \u0026 2x_1 - 3x_2' + 3x_2'' \\\\ \\text{满足约束:} \\quad \u0026 x_1 + x_2' - x_2'' \\leq 7 \\\\ \u0026 -x_1 - x_2' + x_2'' \\leq -7 \\\\ \u0026 x_1 - 2x_2' + 2x_2'' \\leq 4 \\\\ \u0026 x_1, x_2', x_2'' \\geq 0 \\end{aligned} $$ 3. 线性规划转松弛型 松弛型的定义:\n松弛型(Slack Form):约束都是等式(除了要求变量非负的约束)\n标准型 vs 松弛型:\n标准型:所有的约束都是不等式 松弛型:约束都是等式(除了要求变量非负的约束) 引入松弛变量:\n通过引入新变量,将不等式改变成等式:\n$$\\sum_{j=1}^{n} a_{ij}x_j \\leq b_i \\quad \\rightarrow \\quad s = b_i - \\sum_{j=1}^{n} a_{ij}x_j, \\quad s \\geq 0$$称 $s$ 为松弛变量,因为它度量了以上不等式左右两边的松弛或差别。\n更简洁的表示:\n去除关于\u0026quot;最大化\u0026rdquo;、\u0026ldquo;满足约束\u0026quot;这些词,直接写成等式形式。\n示例:\n原标准型:\n$$ \\begin{align} \\text{最大化} \\quad \u0026 2x_1 - 3x_2 + 3x_3 \\\\ \\text{满足约束条件:} \\quad \u0026 x_1 + x_2 - x_3 \\leq 7 \\\\ \u0026 -x_1 - x_2 + x_3 \\leq -7 \\\\ \u0026 x_1 - 2x_2 + 2x_3 \\leq 4 \\\\ \u0026 x_1, x_2, x_3 \\geq 0 \\end{align} $$转换为松弛型(引入松弛变量 $x_4, x_5, x_6$):\n$$ \\begin{align} z \u0026= 2x_1 - 3x_2 + 3x_3 \\\\ x_4 \u0026= 7 - x_1 - x_2 + x_3 \\\\ x_5 \u0026= -7 + x_1 + x_2 - x_3 \\\\ x_6 \u0026= 4 - x_1 + 2x_2 - 2x_3 \\end{align} $$重要概念:\n等式左边:基本变量(在等式左边的变量) 等式右边:非基本变量(在等式右边的变量) 松弛型的元组表示:\n可用元组 (N, B, A, b, c, v) 表示松弛型。\n示例:\n$$ \\begin{align} z \u0026= 28 - \\frac{x_3}{6} - \\frac{x_5}{6} - \\frac{2x_6}{3} \\\\ x_1 \u0026= 8 + \\frac{x_3}{6} + \\frac{x_5}{6} - \\frac{x_6}{3} \\\\ x_2 \u0026= 4 - \\frac{8x_3}{3} - \\frac{2x_5}{3} + \\frac{x_6}{3} \\\\ x_4 \u0026= 18 - \\frac{x_3}{2} + \\frac{x_5}{2} \\end{align} $$元组表示:\n$B = \\{1, 2, 4\\}$(基本变量集合) $N = \\{3, 5, 6\\}$(非基本变量集合) $c = (c_3, c_5, c_6)^T = (-1/6, -1/6, -2/3)^T$ $v = 28$ 矩阵 $A$:\n$$ A = \\begin{pmatrix} a_{13} \u0026 a_{15} \u0026 a_{16} \\\\ a_{23} \u0026 a_{25} \u0026 a_{26} \\\\ a_{43} \u0026 a_{45} \u0026 a_{46} \\end{pmatrix} = \\begin{pmatrix} 1/6 \u0026 1/6 \u0026 -1/3 \\\\ -8/3 \u0026 -2/3 \u0026 1/3 \\\\ -1/2 \u0026 1/2 \u0026 0 \\end{pmatrix} $$向量 $b$:\n$$ b = \\begin{pmatrix} b_1 \\\\ b_2 \\\\ b_4 \\end{pmatrix} = \\begin{pmatrix} 8 \\\\ 4 \\\\ 18 \\end{pmatrix} $$ 4. 单纯形算法 算法核心思想:\n单纯形算法的本质是从可行域的一个顶点出发,沿着目标函数值改进的方向移动到相邻顶点,直到找到最优解。\n基本解的概念:\n松弛型等式系统拥有无限个解。我们集中于基本解:\n把等式右边所有(非基本)变量设为 $0$ 再计算等式左边(基本)变量的值 再计算目标值 每次迭代的目标: 重新整理线性规划,使得基本解有一个更大的目标值。\n算法详细步骤(以最大化问题为例):\n初始问题:\n$$ \\begin{align} \\text{最大化} \\quad z \u0026= 3x_1 + x_2 + 2x_3 \\\\ \\text{满足约束条件:} \\quad \u0026 x_1 + x_2 + 3x_3 \\leq 30 \\\\ \u0026 2x_1 + 2x_2 + 5x_3 \\leq 24 \\\\ \u0026 4x_1 + x_2 + 2x_3 \\leq 36 \\\\ \u0026 x_1, x_2, x_3 \\geq 0 \\end{align} $$步骤1:转换为松弛型\n引入松弛变量 $x_4, x_5, x_6$:\n$$ \\begin{align} z \u0026= 3x_1 + x_2 + 2x_3 \\\\ x_4 \u0026= 30 - x_1 - x_2 - 3x_3 \\\\ x_5 \u0026= 24 - 2x_1 - 2x_2 - 5x_3 \\\\ x_6 \u0026= 36 - 4x_1 - x_2 - 2x_3 \\end{align} $$初始基本解:\n基本解:$(\\bar{x}_1, \\bar{x}_2, ..., \\bar{x}_6) = (0, 0, 0, 30, 24, 36)$ 目标值:$z = 3 \\times 0 + 1 \\times 0 + 2 \\times 0 = 0$ 步骤2:第一次迭代\n观察分析:\n考虑增加 $x_1$ 的值(因为其系数为正,可以增加目标值),使所有值保持非负 从三个约束式可知: $x_1$ 超过 $30$ 时,$x_4$ 变负 $x_1$ 超过 $12$ 时,$x_5$ 变负 $x_1$ 超过 $9$ 时,$x_6$ 变负 因此,$x_1$ 最多取 $9$,此时 $x_6 = 0$ 互换 $x_1$ 和 $x_6$($x_1$ 入基,$x_6$ 出基) 第一次迭代后:\n$$ \\begin{align} z \u0026= 27 + \\frac{x_2}{4} + \\frac{x_3}{2} - \\frac{3x_6}{4} \\\\ x_1 \u0026= 9 - \\frac{x_2}{4} - \\frac{x_3}{2} - \\frac{x_6}{4} \\\\ x_4 \u0026= 21 - \\frac{3x_2}{4} - \\frac{5x_3}{2} + \\frac{x_6}{4} \\\\ x_5 \u0026= 6 - \\frac{3x_2}{2} - 4x_3 + \\frac{x_6}{2} \\end{align} $$新基本解:\n基本解:$(9, 0, 0, 21, 6, 0)$ 目标值:$z = 27$ 步骤3:第二次迭代\n观察分析:\n增加 $x_2$ 或 $x_3$ 都可增加目标值 设选择 $x_3$,从三个式子可知 $x_3$ 的最大值分别为 $18, 42/5, 3/2$ 因此,选择第3个约束($x_3$ 最多取 $3/2$),围绕 $x_3$ 和 $x_5$ 进行转动 互换 $x_3$ 和 $x_5$($x_3$ 入基,$x_5$ 出基) 第二次迭代后:\n$$ \\begin{align} z \u0026= \\frac{111}{4} + \\frac{x_2}{16} - \\frac{x_5}{8} - \\frac{11x_6}{16} \\\\ x_1 \u0026= \\frac{33}{4} - \\frac{x_2}{16} + \\frac{x_5}{8} - \\frac{5x_6}{16} \\\\ x_3 \u0026= \\frac{3}{2} - \\frac{3x_2}{8} - \\frac{x_5}{4} + \\frac{x_6}{8} \\\\ x_4 \u0026= \\frac{69}{4} + \\frac{3x_2}{16} + \\frac{5x_5}{8} - \\frac{x_6}{16} \\end{align} $$ 步骤4:第三次迭代\n第三次迭代后:\n$$ \\begin{align} z \u0026= 28 - \\frac{x_3}{6} - \\frac{x_5}{6} - \\frac{2x_6}{3} \\\\ x_1 \u0026= 8 + \\frac{x_3}{6} + \\frac{x_5}{6} - \\frac{x_6}{3} \\\\ x_2 \u0026= 4 - \\frac{8x_3}{3} - \\frac{2x_5}{3} + \\frac{x_6}{3} \\\\ x_4 \u0026= 18 - \\frac{x_3}{2} + \\frac{x_5}{2} \\end{align} $$最终基本解:\n此时,基本解是 $(8, 4, 0, 18, 0, 0)$ 目标值 $z = 28$ 因为目标函数中所有非基本变量的系数都是负数,无法继续增加目标值,求解结束! 最优解: $x_1 = 8, x_2 = 4, x_3 = 0$,最大值 $z = 28$\n算法总结:\n转换为松弛型:引入松弛变量将不等式转换为等式\n找到初始基本可行解:将所有非基本变量设为 $0$\n检验是否最优:检查目标函数中非基本变量的系数\n如果都 $\\leq 0$(最大化问题),则达到最优 如果都 $\\geq 0$(最小化问题),则达到最优 选择入基变量:选择目标函数系数为正(最大化)或负(最小化)的非基本变量\n选择出基变量:选择使入基变量取值最小的约束对应的基本变量\n基变换:通过代数运算更新松弛型\n重复步骤3-6:直到达到最优或判定无界\n二、整数规划：问题定义 1. 整数规划的基本概念 整数规划的定义:\n整数规划(Integer Programming, IP) 是在线性规划基础上,要求部分或全部决策变量必须取整数值的优化问题。\n一般形式:\n$$ \\begin{align} \\text{最大化(或最小化)} \\quad \u0026 \\sum_{i=1}^{n} c_ix_i \\\\ \\text{满足约束条件:} \\quad \u0026 \\sum_{i=1}^{n} a_{ji}x_i \\leq b_j \\quad (j = 1,2,...,m) \\\\ \u0026 x_i \\geq 0, \\quad x_i \\in \\mathbb{Z} \\quad (\\text{部分或全部}\\ i) \\end{align} $$ 整数规划的分类:\n根据变量的整数要求不同,整数规划可分为三类:\n(1)混合整数规划(Mixed Integer Programming, MIP)\n部分变量必须是整数,部分变量可以是连续值。对部分域所有$x_i$,满足:$x_i \\geq 0$且为整数。\n(2)纯整数规划(Pure Integer Programming, PIP)\n所有决策变量都必须取整数值。对每个$x_i$,满足:$x_i \\geq 0$且为整数。\n(3)0-1整数规划(Binary Integer Programming)\n变量只能取0或1两个值,用于表示\u0026quot;是/否\u0026quot;决策。对每个$x_i$,满足:$x_i \\in \\{0,1\\}$。\n2. 整数规划的实际应用示例 运输问题:\n需要运输180台电视和110台洗衣机。有两种运输方式:\n小型货车:可装载20台电视和20台洗衣机,成本360元 大型卡车:可装载40台电视和10台洗衣机,成本400元 数学模型:\n$$ \\begin{align} \\text{最小化} \\quad \u0026 360x_1 + 400x_2 \\\\ \\text{满足约束条件:} \\quad \u0026 20x_1 + 40x_2 \\geq 180 \\\\ \u0026 20x_1 + 10x_2 \\geq 110 \\\\ \u0026 x_1, x_2 \\geq 0, \\quad x_1, x_2 \\in \\mathbb{Z} \\end{align} $$其中$x_1$表示使用小型货车的数量,$x_2$表示使用大型卡车的数量。\n3. 整数规划的建模技术 技术1:定义二元变量\n除了约定部分或所有变量必须为整数值之外,也允许定义二元变量,即:$x_i \\in \\{0,1\\}$。\n优势：能够引入逻辑约束\n示例：假设$x_i \\in \\{0,1\\}$:\n如果选择了$x_1$,则不能选择$x_2$,那么可以表示成:$x_1 + x_2 \\leq 1$;\n如果选择了$x_1$,则必须选择$x_2$,那么可以表示成:$x_1 \\leq x_2$;\n必须选择$x_1$或$x_2$,或两者均选取,那么可以表示成:$x_1 + x_2 \\geq 1$;\n技术2:限定变量的范围\n目标：限定变量$x$的范围是:$x \\leq 2$或者$x \\geq 6$\n方法:\n挑选一个二元变量$w = \\begin{cases} 1, \u0026 x \\leq 2 \\\\ 0, \u0026 x \\geq 6 \\end{cases}$\n设定$M$是一个很大的数,转变成为IP约束:\n$$ \\begin{align} x \u0026\\leq 2 + M(1-w) \\\\ x \u0026\\geq 6 - Mw \\\\ w \u0026\\in \\{0,1\\} \\end{align} $$验证:\n如果$x \\leq 2$,则令$w = 1$:约束变为$x \\leq 2$和$x \\geq 6 - M$(后者自动满足) 如果$x \\geq 6$,则令$w = 0$:约束变为$x \\leq 2 + M$(自动满足)和$x \\geq 6$ 在两种情况下,IP约束都被满足。\n技术3:表达复杂表达式之间的\u0026quot;或\u0026quot;关系\n目标：表达复杂表达式之间的\u0026quot;或\u0026quot;关系\n示例：$x_1 + 2x_2 \\geq 12$或$4x_2 - 10x_3 \\leq 1$\n整数规划建模:\n$$ \\begin{align} x_1 + 2x_2 \u0026\\geq 12 - M(1-w) \\\\ 4x_2 - 10x_3 \u0026\\leq 1 + Mw \\\\ w \u0026\\in \\{0,1\\} \\end{align} $$验证:\n如果$w = 1$,则第一个约束生效:$x_1 + 2x_2 \\geq 12$ 如果$w = 0$,则第二个约束生效:$4x_2 - 10x_3 \\leq 1$ 技术4:考虑分段线性函数\n目标：表达分段线性函数\n示例:\n$$ y = \\begin{cases} 2x, \u0026 \\text{if } 0 \\leq x \\leq 3 \\\\ 9-x, \u0026 \\text{if } 4 \\leq x \\leq 7 \\\\ -5+x, \u0026 \\text{if } 8 \\leq x \\leq 9 \\end{cases} $$建模方法:\n每段分别定义$w_i$和$x_i$:\n$$ w_1 = \\begin{cases} 1, \u0026 0 \\leq x \\leq 3 \\\\ 0, \u0026 \\text{otherwise} \\end{cases}, \\quad x_1 = \\begin{cases} x, \u0026 0 \\leq x \\leq 3 \\\\ 0, \u0026 \\text{otherwise} \\end{cases} $$类似地定义$w_2, x_2$和$w_3, x_3$\n约束系统:\n$$ \\begin{align} \u0026 0 \\leq x_1 \\leq 3w_1, \\quad w_1 \\in \\{0,1\\} \\\\ \u0026 4w_2 \\leq x_2 \\leq 7w_2, \\quad w_2 \\in \\{0,1\\} \\\\ \u0026 8w_3 \\leq x_3 \\leq 9w_3, \\quad w_3 \\in \\{0,1\\} \\\\ \u0026 w_1 + w_2 + w_3 = 1 \\\\ \u0026 x = x_1 + x_2 + x_3 \\\\ \u0026 x_i \\text{ integer } \\forall i \\end{align} $$最终表达式:\n$$y = 2x_1 + (9w_2 - x_2) + (-5w_3 + x_3)$$ 4. 整数规划问题求解:从两个变量开始 案例问题:\n$$ \\begin{align} \\text{Maximize: } z \u0026= 3x + 4y \\\\ \\text{Subject to: } \u0026 5x + 8y \\leq 24 \\\\ \u0026 x, y \\geq 0, \\quad x, y \\in \\mathbb{Z} \\end{align} $$简单的解法:\n先求解线性规划(忽略整数要求),得到$x = 4.8, y = 0$和$z = 14.4$ 四舍五入,得到$x = 5, y = 0$,但此解不可行! 取整,得到$x = 4, y = 0$,且$z = 12$。该解与$x = 0, y = 3$时的解值相同。 最优解:$x = 3, y = 1$,且$z = 13$\n结论:\nQ1:最优整数解是什么? $(3, 1)$ Q2:能否使用线性规划来解决整数规划问题? 不能直接使用,需要专门的算法 三、整数规划：分支界定法（Branch and Bound） 1. 枚举树 - 完全枚举思想 0-1背包问题示例:\n有6件物品,背包容量不超过14,求最大利用率:\n物品 iPad server Brass Rat Au Bon Pain 6.041 tutoring 15.053 dinner 价格 5 7 4 3 4 6 利用率 16 22 12 8 11 19 数学模型: $$ \\begin{align} \\text{Maximize: } \u0026 16x_1 + 22x_2 + 12x_3 + 8x_4 + 11x_5 + 19x_6 \\\\ \\text{Subject to: } \u0026 5x_1 + 7x_2 + 4x_3 + 3x_4 + 4x_5 + 6x_6 \\leq 14 \\\\ \u0026 x_i \\in \\{0,1\\} \\quad \\text{for } 1 \\leq i \\leq 6 \\end{align} $$枚举法分析:\n考虑决策变量的所有可能值,即:$n \\rightarrow 2^n$ 想法:将问题分成两部分迭代。首次迭代时,考虑$x_1 \\in \\{0,1\\}$的情况 树中的每个节点代表原始问题加上额外的约束条件 枚举树基本概念:\n节点2和节点3被称为枝举树中节点1的子节点 IP(1) 是原始的整数规划问题 IP(2) 通过向IP(1)添加约束条件\u0026rdquo;$x_1 = 0$\u0026ldquo;得到 IP(3) 通过向IP(1)添加约束条件\u0026rdquo;$x_1 = 1$\u0026ldquo;得到 IP(1)的最优解可以通过从IP(2)和IP(3)中选取最好的解来获得（整数解） 最优解也可能在IP(2)和IP(3)两个分支中 2. 整数规划线性松弛 线性松弛(LP relaxation)的定义:\n如果去掉变量必须为整数的要求,就称其为整数规划问题的线性松弛。\n背包问题的线性松弛:\n$$ \\begin{align} \\text{最大化: } \u0026 24x_1 + 2x_2 + 20x_3 + 4x_4 \\\\ \\text{约束条件: } \u0026 8x_1 + 1x_2 + 5x_3 + 4x_4 \\leq 9 \\\\ \u0026 0 \\leq x_i \\leq 1, \\quad \\text{对于 } 1 \\leq i \\leq 4 \\end{align} $$贪心算法求解:\n背包问题的线性松弛可以通过\u0026quot;贪心算法\u0026quot;来求解:\n可以将目标函数看作是美元金额,并将约束条件视为对重量的限制。\nitem 1 2 3 4 value/lb. $3 $2 $4 $1 求解策略:\n如果按照每磅价值从高到低依次将物品放入背包,会得到什么结果?\n通过求解每个整数规划问题的线性松弛,可为每个整数规划问题得到一个界限。\n（1） LP(k)的求解结果会给出一个具体的界限值。\n示例:LP(4)的求解\n$$ \\begin{align} \\text{Maximize: } \u0026 24x_1 + 2x_2 + 20x_3 + 4x_4 \\\\ \\text{Subject to: } \u0026 8x_1 + 1x_2 + 5x_3 + 4x_4 \\leq 9 \\\\ \u0026 x_1 = 0, x_2 = 0 \\\\ \u0026 0 \\leq x_i \\leq 1 \\text{ for } 3 \\leq i \\leq 4 \\end{align} $$ LP(4)的最优解:$x_1 = 0, x_2 = 0, x_3 = 1, x_4 = 1, z = 24$ 如果LP(k)的最优解对于IP(k)也是可行的,那么它也是IP(k)的最优解 重要性质:\n对于所有$j$来说,$z_{IP}(j) \\leq z_{LP}(j)$,例如:$z_{IP}(1) \\leq 32$\n不直接求解IP(k),而是求其线性松弛(LP relaxation),以获得边界值。\n（2）当前最优解(incumbent)的定义:\n算法偶然找到的、具有最佳目标函数值的可行整数解。\n注意：当前最优解是整数规划问题的一个可行解,且是迄今为止找到的最佳解。\nLP(1)的求解:\n$$ \\begin{align} \\text{Maximize: } \u0026 24x_1 + 2x_2 + 20x_3 + 4x_4 \\\\ \\text{Subject to: } \u0026 8x_1 + 1x_2 + 5x_3 + 4x_4 \\leq 9 \\\\ \u0026 0 \\leq x_i \\leq 1 \\text{ for } i = 1 \\text{ to } 4 \\end{align} $$ LP(1)的最优解:$x_1 = 1/2, x_2 = 0, x_3 = 1, x_4 = 0, z = 32$ 重要观察:\n对于所有$j$来说,$z_{IP}(j) \\leq z_{LP}(j)$,例如:$z_{IP}(1) \\leq 32$\n（3） 剪枝\n推论：如果$z_{LP}(k) \\leq z_I$,可以剪枝活动节点$k$的IP(k),其中$z_I$是当前最优解的目标函数值。\n活动节点：节点尚未被剪枝,并且LP(k)还没有被解出来\nLP(2)的分析:\n$$ \\begin{align} \\text{Maximize: } \u0026 24x_1 + 2x_2 + 20x_3 + 4x_4 \\\\ \\text{Subject to: } \u0026 8x_1 + 1x_2 + 5x_3 + 4x_4 \\leq 9 \\\\ \u0026 x_1 = 0 \\\\ \u0026 0 \\leq x_i \\leq 1 \\text{ for } i = 2 \\text{ to } 4 \\end{align} $$ LP(2)的最优解为:$z_{LP}(2) = 25$ 假设我们已经知道了一组解:$x_1 = 1, x_2 = 1, x_3 = 0, x_4 = 0, z_I = 26$,则可以剪枝LP(2) 3. 分支界定算法的完整流程 在什么条件下,我们不能从最大化的分支定界树中剪枝活动节点$j$?\n算法伪代码:\nwhile there is some active nodes do select an active node j mark j as inactive Solve LP(j): denote solution as x(j); Case 1 -- if z_LP(j) ≤ z_I then prune node j; Case 2 -- if z_LP(j) \u0026gt; z_I and if x(j) is feasible for IP(j) then Incumbent := x(j), and z_I := z_LP(j); then prune node j; Case 3 -- if z_LP(j) \u0026gt; z_I and if x(j) is not feasible for IP(j) then mark the children of node j as active endwhile 中文说明:\n当存在某些活动节点时,执行以下操作:\n选择一个活动节点$j$ 将$j$标记为不活动 求解LP(j):令$x(j)$表示解决方案; 情况1\u0026ndash;如果$z_{LP}(j) \\leq z_I$,则剪枝节点$j$; 情况2\u0026ndash;如果$z_{LP}(j) \u003e z_I$且$x(j)$是IP(j)的可行解,则Incumbent $:= x(j)$,$z_I := z_{LP}(j)$;然后剪枝节点$j$; 情况3\u0026ndash;如果$z_{LP}(j) \u003e z_I$且$x(j)$不是IP(j)可行解,则标记节点$j$的子节点为活动节点 结束循环\n4. 分支界定法案例 初始状态:LP(1) $$ \\begin{align} \\text{Maximize: } \u0026 24x_1 + 2x_2 + 20x_3 + 4x_4 \\\\ \\text{Subject to: } \u0026 8x_1 + 1x_2 + 5x_3 + 4x_4 \\leq 9 \\\\ \u0026 0 \\leq x_i \\leq 1 \\text{ for } i = 1 \\text{ to } 4 \\end{align} $$ 没有当前最优解,$z_I = -\\infty$ LP(1)的最优方案是:$x_1 = 1/2, x_2 = 0, x_3 = 1, x_4 = 0, z_{LP}(2) = 32$ 分支到LP(2):\nLP(2)的最优方案是:$x_1 = 0, x_2 = 1, x_3 = 1, x_4 = 3/4, z_{LP}(2) = 25$ 分支到LP(3):\n没有当前最优解,$z_I = -\\infty$,$z_{LP}(1) = 32$ LP(3)的最终方案是:$x_1 = 1, x_2 = 0, x_3 = 1/5, x_4 = 0, z_{LP}(3) = 28$ 分支到LP(4):\n没有当前最优解,$z_I = -\\infty$,$z_{LP}(1) = 32$ LP(4)的最优解:$x_1 = 0, x_2 = 0, x_3 = 1, x_4 = 1, z_{LP}(4) = 24$ 剪枝完毕(因为都是整数)，更新$z_I = 24$ 分支到LP(5):\n最优可行解$z_I = 24$ LP(5)的最终方案是:$x_1 = 0, x_2 = 1, x_3 = 1, x_4 = 3/4, z_{LP}(5) = 25$ 分支到LP(6):\n当前最优解$z_I = 24$ LP(6)的最优方案是:$x_1 = 1, x_2 = 0, x_3 = 1/5, x_4 = 0, z_{LP}(6) = 28$ 分支到LP(7):\n当前最优解$z_I = 24$ LP(7)的最优解:$x_1 = 1, x_2 = 1, x_3 = 0, x_4 = 0, z_{LP}(7) = 26$ 剪枝完毕(界限剪枝) 分支到LP(8):\n当前最优解$z_I = 26$ (更新) LP(8)的最优解:$x_1 = 0, x_2 = 1, x_3 = 1, x_4 = 1, z_{LP}(8) = 6$ 子树剪枝(界限剪枝,因为$z_{LP}(8) \u003c z_I$) 分支到LP(9):\n当前最优解$z_I = 26$ LP(9)的最优解:$x_1 = 0, x_2 = 1, x_3 = 1, x_4 = 3/4, z_{LP}(9) = 25$ 子树剪枝(界限剪枝,因为$z_{LP}(9) \u003c z_I$) 分支到LP(10):\n当前最优解$z_I = 26$ LP(10)的最优解:$x_1 = 1, x_2 = 0, x_3 = 0, x_4 = 1/4, z_{LP}(10) = 25$ 子树剪枝(界限剪枝,因为$z_{LP}(10) \u003c z_I$) 最终分支LP(11):\n当前最优解$z_I = 26$ LP(11)的最优解:无可行解,可被剪枝 剪枝完毕(不可行剪枝) 最终结果:\n最优整数解:$x_1 = 0, x_2 = 1, x_3 = 1, x_4 = 1, z^* = 26$ 5. 分支界定法的经验总结 算法优势:\n分支定界法可以加快搜索速度,仅解决部分节点的线性规划问题 算法局限:\n分支定界法依赖于剪枝子树,这可能是因为节点处的整数规划(IP)问题已经被解决,或者因为该IP解不可能是最优解 当变量很多时,完全枚举不可能负担(即使是仅50个变量也有很大消耗) 加速技巧:\n技巧一：能够\u0026quot;智能地\u0026quot;选择最佳分支变量的启发式规则 技巧二：使用\u0026quot;取整\u0026rdquo;,例如,将非整数解通过向上或向下取整转换为整数解,以此来快速获得可行解,从而缩小搜索范围 示例:$x_1 + x_2 \\leq 1.5 \\rightarrow x_1 + x_2 \\leq 1$,or $z_{IP} \\leq z_{LP} = 5.5 \\rightarrow z_{IP} \\leq 5$ 四、整数规划：切平面法（Cutting Plane Method） 1. 有效不等式(Valid Inequalities) 定义:\n整数规划(IP)的有效不等式是指任何不会排除任何可行整数解的约束条件。\n示例问题:\n最大化目标函数:$z = 3x + 4y$\n约束条件:$5x + 8y \\leq 24$ $0 \\leq x, y \\in \\mathbb{Z}$(即x和y都是非负整数)\n有效不等式的特点:\n约束条件$x \\leq 5$是一个有效不等式 约束条件$x \\leq 4$同样是一个有效不等式 整数规划的一个有效不等式也被称为切割平面或切面 目标:\n希望找到能排除部分线性规划可行区域的切割平面。\n2. 取整(Rounding)技术 基本原理:\n一个分数形式的整数变量边界可以被截断。\n示例:\n$x \\leq 1.5 \\rightarrow x \\leq 1$\n整数系数约束的取整:\n给定一个涉及所有整数变量且系数也为整数的约束条件:\n$3x + 6y + 9z \\leq 11$ 可以转化为 $x + 2y + 3z \\leq \\lfloor 11/3 \\rfloor = 3$\n非负整数变量约束的取整:\n对于涉及非负整数变量的约束条件:\n$\\sum a_i x_i \\leq b$ 可以转化为 $\\sum \\lfloor b/a_i \\rfloor x_i \\leq \\lfloor b \\rfloor$\n注意事项:\n注意左边是整数,因此右边也可以被截断,但这并不一定比原始约束条件更严格。\n3. Gomory切割(Gomory Cuts) 定义:\nGomory切割用于向所有整数规划问题(IPs)中添加有效不等式(也称为切割),对于改进界限非常有用。\n核心思想:\nGomory切割是从线性规划(LP)松弛的最优单纯形表中的单个约束条件获得的。\n假设前提:\n这里假设所有变量必须取整数值。\n情况一:所有左侧系数都在0到1之间\n约束形式:$0.2x_1 + 0.3x_2 + 0.3x_3 + 0.5x_4 + x_5 = 1.8$\n有效不等式(忽略来自$x_5$的贡献):\n$0.2x_1 + 0.3x_2 + 0.3x_3 + 0.5x_4 \\geq 0.8$\n这种有效不等式通过从最优解中提取信息并创建新的约束条件,有助于排除非整数解,从而提高求解效率。\n情况二:所有左边的系数都是非负的\n约束形式:$1.2x_1 + 0.3x_2 + 2.3x_3 + 2.5x_4 + x_5 = 4.8$\n有效不等式(focus on fractional parts):\n$0.2x_1 + 0.3x_2 + 0.3x_3 + 0.5x_4 \\geq 0.8$\n情况三:通用情况\n约束形式:$1.2x_1 - 1.3x_2 - 2.4x_3 + 11.8x_4 + x_5 = 2.9$\n向下取整(特别担心负数):\n$1x_1 - 2x_2 - 3x_3 + 11x_4 + x_5 \\leq 2$\n有效不等式(前面两个式子相减):\n$0.2x_1 + 0.7x_2 + 0.6x_3 + 0.8x_4 \\geq 0.9$\n4. 凸包(Convex Hull) 定义:\n凸包是包含所有整数解的最小线性规划可行区域。\n示例1:\n最大化:$z = 3x + 4y$\n约束条件:$5x + 8y \\leq 24$ $0 \\leq x, y \\in \\mathbb{Z}$\n添加凸包 ： $ x + y ≤ 4,2x + 3y ≤ 9$\n示例2:\n最大化:$z = x + y$\n约束条件:$-5x + 4y \\leq 0$ $6x + 2y \\leq 17$ $0 \\leq x, y \\in \\mathbb{Z}$\n使用取整技术添加约束条件： $x ≤ 2,y ≤ x$\n5. 切平面算法 算法步骤:\n步骤1：求解线性规划松弛问题\n步骤2：如果线性规划解是整数解,则它是原始问题的最优解。任务完成!\n步骤3：如果线性规划解不是整数解,找到一个线性约束条件,该条件排除线性规划解但不排除任何整数点(总是可能的);\n步骤4：加入切割约束条件;\n步骤5：返回步骤1。\n6. 切平面法案例详解 初始问题:\n最大化:$z = x + y$\n约束条件:$-5x + 4y \\leq 0$ $6x + 2y \\leq 17$ $0 \\leq x, y \\in \\mathbb{Z}$\n有效不等式:$0 \\leq x, y \\in \\mathbb{Z}$\n最优解 = 4.5（$x = 2,y=2.5$）\n迭代1:添加约束y ≤ 2\n最优解 z = 4.1667（$x = 13/6,y=2$） 移除整数约束以获得线性松弛 最优解是对最优成本的一个上界 如果解是整数,则它是原始问题的最优解 分析:\n约束条件$y \\leq 2$是一个有效的切割,因为它排除了最优的线性规划解,但没有排除任何整数点。\n现在求解这个新问题的线性规划松弛。\n一个切割必须同时排除线性规划解,同时保留所有可行的整数点。至少存在一个有效的切割。\n此时，仍然有变量不完全是整数。再加一个切割！\n迭代2:添加约束x ≤ 2\n最大化:$z = x + y$\n约束条件:$-5x + 4y \\leq 0$ $6x + 2y \\leq 17$ $y \\leq 2$ $x \\leq 2$ $0 \\leq x, y \\in \\mathbb{Z}$\n最优解:$ x = 2, y = 2, z = 4$\n线性规划的解都是整数，因此也是整数规划问题的最优解\n7. 切平面法的特点总结 算法优势:\n通过添加切割约束逐步收紧可行域 每次迭代都会改进上界 最终必定收敛到整数最优解 算法局限:\n可能需要多次迭代 每次迭代需要求解一个线性规划问题 选择合适的切割平面需要一定技巧 与分支界定法的比较:\n切平面法通过添加约束收紧可行域 分支界定法通过分支和剪枝搜索解空间 实际应用中常将两种方法结合使用(分支切割法) 第七讲 内存计算 一、海量内存概述 1. 传统数据处理模式 vs 内存数据处理模式 传统数据处理模式：\nCPU与内存之间频繁交互 内存与磁盘(硬盘)之间存在I/O瓶颈 数据需要从磁盘加载到内存，处理后再写回磁盘 I/O操作成为性能瓶颈 内存数据处理模式：\nCPU直接与内存交互，减少I/O操作 数据主要存储和处理都在内存中完成 大幅减少或消除磁盘I/O瓶颈 显著提升数据处理速度 核心理念： Jim Gray在2006年提出的著名观点：\n\u0026ldquo;Tape is Dead\u0026rdquo;（磁带已死） \u0026ldquo;Disk is Tape\u0026rdquo;（磁盘就是磁带） \u0026ldquo;Flash is Disk\u0026rdquo;（闪存就是磁盘） \u0026ldquo;RAM Locality is King\u0026rdquo;（内存局部性为王） 解释： 随着技术发展，存储介质的角色在不断演变。内存成为数据处理的核心，其他存储介质逐渐降级为备份或归档用途。\n2. 海量内存技术的发展趋势 硬件发展：\n存储器芯片集成度不断提高 内存价格持续下降（如图所示，从1955年到2020年呈指数级下降） 内存容量大幅增长，使得海量数据内存处理成为可能 新型硬件架构：\n3D XPoint™ Technology（英特尔傲腾技术）等新型存储技术的出现 带来的机遇与挑战： 海量内存给传统的数据管理、数据挖掘方法带来了新的机遇和挑战，需要重新设计算法和系统架构。\n3. 内存计算的优势 根据Aberdeen Group 2011年的研究数据对比：\n性能指标 使用内存计算 (n=33) 不使用 (n=163) 内存计算优势 活跃业务数据量（中位数） 38 TB 18 TB 2.1倍数据量 分析数据量（中位数） 14 TB (37%全部数据) 4 TB (22%全部数据) 3.5倍数据量 数据分析/查询平均响应时间 42秒 75分钟 107倍速度提升 每小时处理数据量 1200 TB 3.2 TB 375倍效率提升 主要优势：\n消除了磁盘的I/O瓶颈 提高了单位时间内数据处理的能力与数据访问速度 实现了对大规模海量数据的实时分析和运算 提升数据挖掘的效率和准确度 二、基于单机版内存增大优势 1.关联规则 购物篮模型：从庞大的消费者记录中抽取关于购物模式的信息。\n频繁项集是购物篮模型最基本的问题—— 哪些商品经常被消费者同时购买（营销） 也被称为\u0026quot;关联规则\u0026quot; 从病例中寻找患某种疾病的病人的共同特征等。 关联规则挖掘：发现大量数据中项集之间的相关联系，是数据挖掘中最活跃的研究领域之一。\n关联规则定义：设I = {I₁, I₂, \u0026hellip;, Iₘ}是一个项目的集合，事务tᵢ(i = 1,2,\u0026hellip;,n)是I的一个子集，则由一系列具有唯一标识TID的事务组成的D = {t₁, t₂, \u0026hellip;, tₙ}称为事务数据库。\n关联规则形如X ⇒ Y的蕴含式，X ⊆ I，Y ⊆ I，X∩Y = ∅。\n度量指标：\n支持度(support)：support(面包,牛奶,尿布) = 2/5，计算公式为同时购买面包,牛奶,尿布的记录数/数据集记录总数 置信度(confidence)：confidence(面包⇒牛奶,尿布) = 2/4，计算公式为同时购买面包,牛奶,尿布的记录数/数据集中购买面包的记录数 关联规则挖掘包含两个子问题：\n①发现频繁项目集(基础和研究重点)：寻找所有满足支持度不小于用户给定的minsupport的项目集 ②生成关联规则：在已经发现的最大频繁项目集中，寻找置信度不小于用户给定的minconfidence的关联规则（一条规则的置信度很容易从支持度计数中推出；生成关联规则相对简单，且在内存、I/O、算法效率上的改进余地不大） 2.Apriori算法 基本信息：最经典的关联规则挖掘算法，由Agrawal等人于1993年提出。\n基本思路：逐层迭代，通过连接和剪枝来生成频繁项集。流程为：数据库 → 候选1-项集 →(剪枝)→ 频繁1-项集 →(连接)→ 候选2-项集 → \u0026hellip; → 频繁k-项集\n两条定理——先验性质：\n如果一个集合是频繁项集，则它的所有子集都是频繁项集 如果一个集合不是频繁项集，则它的所有超集都不是频繁项集 基本步骤：\n假设规模为k的频繁项集为Lₖ，它的候选项集为Cₖ。 扫描数据库，对每一项进行累加计数，寻找规模为1的满足minsupport的频繁项集，然后迭代进行以下三步操作，生成所有的频繁项集： ①从规模为k的频繁项集中生成规模为k+1的频繁项集的候选集Cₖ₊₁； ②扫描数据库，计算候选项集中每一个候选的支持度； ③将满足最小支持度的项加入Lₖ₊₁。 发现频繁项集：以minsupport=2（绝对支持度计数）为例，通过多趟扫描逐步生成C₁→L₁→C₂→L₂→C₃→L₃。\n生成关联规则：给定一个频繁项集I，对于它的每个非空子集a，生成满足minconfidence的规则a ⇒ (I-a)，该规则的confidence = support(I) / support(a)。示例：L₂中频繁项{I₁,I₂}，规则I₁⇒I₂的置信度 = 4/6，规则I₂⇒I₁的置信度 = 4/7。\n算法分析：虽然简单且易于实现，是最具代表性的关联规则挖掘算法，\n缺点：\n但随着数据集规模的不断增长，逐渐显现出一定的局限性：需多次扫描数据库，很大的I/O负载，算法的执行效率较低； 产生大量的候选项目集，会消耗大量的内存； 对于每一趟扫描，只有当内存大小足够容纳需要进行计数的候选集时才能正确执行。如果内存不够大，要么使用一种空间复杂度更小的算法，要么只能对一个候选集进行多次扫描，否则将会出现\u0026quot;内存抖动\u0026ldquo;的情况，即在一趟扫描中页面频繁地移进移出内存，造成运行时间的剧增。 观察：在Apriori算法的整个过程中，第一趟扫描时只需对规模为1的项计数，相对于对规模为2的项进行计数所需的空间而言是非常小的，而在第二趟扫描时，所有的可用空间基本都投入用于对候选集C₂进行计数。通过实验发现Apriori算法的内存瓶颈在第二趟扫描时出现，即对候选集C₂进行计数比对候选集C₃、C₄或规模更大的候选集进行计数所需的空间更大。\n3.PCY算法 基本信息：得名于作者Park、Chen和Yu，1995年提出。将哈希技术引入频繁项集发现中，利用第一趟扫描时未使用的大量内存空间来完整地存放一张哈希表，减少了第二趟扫描时候选集C₂的数量。\n主要思想：\n第一趟扫描：对单个项进行计数的同时将商品对散列到对应的桶中，并将该桶的计数加1。频繁桶为最终计数值不小于minsupport的桶，非频繁桶为最终最终计数值小于minsupport的桶。 第二趟扫描：即使一个2-项集中的每一项都是频繁的，但如果它被散列到非频繁桶中，它就不可能是频繁项集，可以从候选项集中删除，这样就可大大减少要考虑的2-项集。 第一趟扫描与第二趟扫描之间：把桶替换成对应的二进制位的位图，如果对应的是频繁桶则该位为1，否则为0。一个占32位(4字节)的桶被换成了1位，在第二趟扫描时只需要1/32的空间并销，因此在第二趟扫描时，PCY算法可用来计数的空间几乎和Apriori算法一样大。 步骤：第一遍扫描生成频繁1-项集，同时对2-项集进行哈希得到哈希表和位向量；第二遍扫描通过L₁自连接生成候选集，使用位图过滤（只有哈希到频繁桶的才是候选），对候选项对计数。结果是候选2-项集的数目大大减少。\n第一步：确定每个项的 order（顺序编号）\n根据字母顺序：\nA 的 order = 1 B 的 order = 2 C 的 order = 3 D 的 order = 4 E 的 order = 5 第二步：计算每个2-项集的哈希位置\n例子1：{A, C}\nh(A,C) = (1 × 10 + 3) mod 7 = 13 mod 7 = 6 ✅ 映射到位置6 例子2：{B, C}\nh(B,C) = (2 × 10 + 3) mod 7 = 23 mod 7 = 2 ✅ 映射到位置2 第三步：进行位向量统计\n统计当前桶的元素个数是否$\u003e=2$ 得到如下位向量\u0026lt;1,0,1,0,1,0,1\u0026gt; 优点：高效地产生频繁项集，提升了性能；减少了数据库的扫描次数；减少计数所需的内存空间的大小。\n分析：最差的情况是所有桶都是频繁桶，则第二遍扫描中PCY算法需要计算的相对数目与Apriori算法相比没有任何减少。在寻找频繁3-项集以及更多项集时，PCY算法与Apriori算法相同。\n4.多阶段算法 主要思路：\n在PCY的第一遍和第二遍之间插入额外的扫描过程，将2-项集哈希到另外的独立的哈希表中（使用不同的哈希函数）。 在每个中间过程中，只需哈希那些在以往扫描中哈希到频繁桶的频繁项。 需要三次扫描数据库。 步骤：\n第一趟扫描与PCY算法相同； 第二趟扫描中2-项集{i,j}被哈希需满足①i和j都是频繁项、②第一趟扫描时{i,j}被哈希到了一个频繁桶，使用不同的哈希函数建立哈希表2； 第三趟扫描中{i,j}是候选2-项集需满足①i和j都是频繁项、②第一趟扫描时{i,j}被哈希到频繁桶(查询Bitmap1)、③第二趟扫描时{i,j}被哈希到频繁桶(查询Bitmap2)。 分析：\nPass3的第③个条件是多阶段算法与PCY算法最本质的区别。 因为在第二趟扫描时，不是所有的2-项集都被散列到桶中，因此桶的计数值变得比第一趟扫描时更小，最终结果是更多的桶变成非频繁桶；(过滤更多) 由于两次扫描采用的哈希函数不同，那些在第一趟扫描时被散列到频繁桶中的非频繁2-项集很可能在第二趟扫描时被哈希到一个非频繁桶中，故排除很多通过了前两个条件判断的2-项集。 多阶段算法寻找频繁2-项集不只局限于使用3次扫描， 可以执行更多次用桶进行哈希的扫描，并且每次使用不同的哈希函数，后面的每一趟扫描都能排除更多的2-项集； 但是如果扫描的次数过多，不仅算法的执行次数更长，也有可能导致最终可用的内存小到无法对所有的频繁2-项集进行计数。 5.多哈希算法 定义：多哈希算法(Multihash Algorithm)是PCY算法的一种变形。\n思路：对PCY算法的第一遍扫描进行修改，将内存划分为多张哈希表，第二遍扫描只需对所有哈希表中都哈希到频繁桶的两个频繁项组成的项对计数。\n与多阶段算法的区别：多阶段算法是在连续的扫描过程中使用两个不同的哈希函数和哈希表，多哈希算法是在第一次扫描的过程中同时使用两个哈希函数和两张哈希表。\n步骤：第一遍扫描统计频繁项，同时维护哈希表1和哈希表2；第二遍扫描输入频繁项+位图1+位图2，对同时在两个哈希表中都哈希到频繁桶的候选项对计数。\n分析：\n优点是只要桶的平均计数不小于阈值，频繁桶的数目仍然比较多，这样一个非频繁2-项集同时哈希到两个哈希表的频繁桶内的概率就更低，可以减少第二遍扫描的运算量。 风险是使用两个哈希表时，每个哈希表仅有PCY算法的一半的桶，这样每个桶上的平均计数会翻倍，必须保证大多数桶的计数不会达到阈值。 多哈希算法也不只局限于使用两个哈希表，风险是桶的平均计数可能会超过阈值。 三、基于共享式内存和分布式内存结合架构优势 1.三种系统架构 SMP (对称多处理)\n也称UMA (一致性存储访问) 各处理器平等,访问内存任何地址时间相同 共享相同物理内存、总线结构和系统资源 主要特征是\u0026rdquo;共享\u0026quot;,单一寻址空间,编程简单 缺点:受总线限制,可扩展性差 MPP (大规模并行处理)\n多个SMP服务器通过互联网络连接 \u0026ldquo;完全无共享(shared-nothing)\u0026ldquo;架构 每个节点只访问本地资源,通过消息传递机制交互 优点:可扩展性好 缺点:通信开销大,编程困难 NUMA (非一致性存储访问)\n访问本地内存速度远高于远端内存 具有多个CPU模块,每个模块有独立的CPU、内存、I/O 每个CPU可访问系统中所有物理内存空间 结合SMP和MPP优势:保持对称性和单一地址空间,同时具备可扩展能力 属于分布/共享内存结构 2.SPADE算法 基本思想\n利用垂直数据格式和连接-剪枝策略 只需对数据库进行三次扫描 产生频繁序列时只需对垂直数据序列进行交集操作 数据表示:垂直格式\n将序列数据库从水平格式转换为垂直格式 每个项用ID_list表示,包含(CID, TID)对 CID: 客户/序列标识 TID: 事务/时间标识 通过扫描数据库构建每个项的ID_list 计算support: 统计ID_list中distinct CID数目 算法流程\n第一步: 生成频繁1-序列\n扫描数据库,构建每个单项的ID_list 统计每个项的distinct CID数目 与minsupport比较,得到频繁1-序列 第二步: 连接生成候选k-序列\n示例: 从频繁1-序列生成频繁2-序列\n频繁1-序列的ID_list:\n项b 项c CID TID CID TID 1 2 2 3 1 3 3 2 2 1 3 5 2 4 3 2 连接过程详解:\n要生成b→c(表示b在c之前发生):\n查找同一个CID中,TID(b) \u0026lt; TID(c)的记录 CID=1: b出现在TID=2,3; c出现在TID=无 → 没有满足条件的 CID=2: b出现在TID=1,4; c出现在TID=3 → TID(b)=1 \u0026lt; TID(c)=3 ✓ CID=3: b出现在TID=2; c出现在TID=2,5 → TID(b)=2 \u0026lt; TID(c)=5 ✓ 要生成c→b(表示c在b之前发生):\n查找同一个CID中,TID(c) \u0026lt; TID(b)的记录 CID=1: c出现在TID=无; b出现在TID=2,3 → 没有c,不满足 CID=2: c出现在TID=3; b出现在TID=1,4 → TID(c)=3 \u0026lt; TID(b)=4 ✓ CID=3: c出现在TID=2,5; b出现在TID=2 → TID(c)=2不小于TID(b)=2 ✗ 连接后生成的频繁2-序列ID_list:\nb→c (序列模式) c→b (序列模式) CID TID(b) TID(c) CID TID(c) TID(b) 2 1 3 2 3 4 3 2 5 频繁(k-1)-序列与频繁(k-1)-序列连接形成候选k-序列 连接规则(必须同时满足): 共享相同的CID 前面项的TID必须在后面项的TID之前(遵守时间顺序) 通过两个序列的ID_list交集操作生成新序列的ID_list 例如: b→c表示在同一CID中,b的TID \u0026lt; c的TID 第三步: 剪枝得到频繁k-序列\n判断哪些候选序列是频繁的:\n假设最小支持度minsupport = 2(至少要在2个客户中出现)\nb→c序列: distinct CID = {2, 3} → 2个客户 → support=2 ≥ minsupport ✓ 保留,是频繁序列 c→b序列: distinct CID = {2} → 1个客户 → support=1 \u0026lt; minsupport ✗ 剪枝,不是频繁序列 最终得到频繁2-序列:\nb→c (频繁序列) CID TID(b) TID(c) 2 1 3 3 2 5 算法的实际意义:\nSPADE算法用于序列模式挖掘 - 发现用户购买行为的规律: 终止条件\n找不到频繁序列,或 无法通过连接形成候选序列时,算法结束 优化特性\nID_list会随着频繁序列长度增加而减小 连接操作速度随之加快 减少了内存占用和计算开销 等价类划分(搜索空间划分)\n采用基于后缀的等价类划分搜索空间 形如Y→X和YX的序列都归入后缀类[X] 每个等价类是独立的,包含生成所有共享相同后缀的频繁序列所需的完整信息 可以在内存中独立处理每个等价类 为pSPADE的并行化提供基础 3.pSPADE算法 算法背景\n第一个应用共享式内存架构进行并行序列模式挖掘的算法 工作在SGI Origin 2000系统(NUMA体系结构)的12台处理器上 采用硬件分布式共享存储(HDSM)架构 任务拆分\n利用SPADE算法的等价类划分性质 所有处理器访问整个数据库的一份拷贝 并行地工作于不同的等价类,异步处理全局计算树 每个类的挖掘工作独立,处理器不需要同步 负载均衡策略\n静态负载均衡(SLB)\n根据等价类中元素数量分配权重 按权重递减顺序排序,依次分配给当前权值和最小的处理器 分配完毕后完全异步,无需同步或交互 示例：P0预先分配好了C1和C3，P1预先分配好了C2。然后就按照这个分配方案来实施。即使P1已经执行完毕所有任务了，它也无法分担P0的任务。 类间动态负载均衡(CDLB)\n按权重将所有类递减排列成逻辑中心任务队列 处理器动态从队列获取类,处理完后自动获取下一个 示例：首先预估所有任务的工作量，进行排序，得C1, C2, C3。然后，分配P0来执行C1，分配P1来执行C2。结束早的那个处理器来执行C3。 递归动态负载均衡(RDLB)\n有空闲处理器时,在树的每一新层递归运用CDLB方法 不同处理器能够处理新层次上的不同类 示例：首先预估工作量，排序得C1、C2、C3。然后P0预先分配好了C1和C3，P1预先分配好了C2，P1执行较快，则又执行C3。此时P0已经执行完毕，则它能够分配C3的子任务（X3）。依次类推，直到完全结束。 算法优点\n减少数据库扫描次数,降低I/O操作开销 采用异步机制,只在负载失衡时同步 将搜索空间分成基于后缀的类,可独立处理 数据局域性最大化,同步最小化 动态负载均衡保证处理器负载均衡 解决大型数据库中搜索空间大、可扩展性差的问题 第八讲 社区发现 社区发现是复杂网络分析中的重要问题，目标是找出网络中紧密连接的节点群组。\n一、图切割（Graph Partitioning） 1. 社区划分问题 给定无向图 $G = (V, E)$，其中：\n$V$ 表示所有的顶点（节点）集合 $E$ 表示所有的边集合 任务： 将所有顶点分成两个不相交的组：\n组 $A$：包含一部分节点 组 $B = V\\backslash A$：包含剩余的所有节点（即 $V$ 中除了 $A$ 之外的所有节点） 核心问题： 如何评判这个划分的好坏？\n2. 评判准则 一个良好的社区划分应该满足：\n最大化社区内部的连接数：同一个社区内的节点之间应该有尽可能多的边连接 最小化社区之间的连接数：不同社区之间的连接应该尽可能少 3. 割（Cut）的定义 为了量化划分的质量，我们引入\u0026quot;割\u0026quot;的概念。\n割(cut) 是指：只有一个端点在社区 $A$ 内，另一个端点在社区 $A$ 外的所有边的权重之和。\n数学表达式：\n$$cut(A) = \\sum_{i \\in A, j \\notin A} w_{ij}$$公式解释：\n$i \\in A$：节点 $i$ 在社区 $A$ 中 $j \\notin A$：节点 $j$ 不在社区 $A$ 中（即在社区 $B$ 中） $w_{ij}$：连接节点 $i$ 和节点 $j$ 的边的权重（如果是无权图，权重为1） $\\sum$：对所有满足条件的边进行求和 通俗理解： 割就是\u0026quot;跨越两个社区的边的总权重\u0026rdquo;，这个值越小，说明两个社区之间的连接越少，划分越好。\n求解方法： 存在多项式时间算法来求解最小割问题，特别是 Edmonds-Karp 算法，其时间复杂度为 $O(|V| \\cdot |E|^2)$。\n4. 最小割 (Minimum-cut) 目标： 找到一个划分 $(A, B)$，使得 $cut(A,B)$ 的值最小。\n$$\\arg\\min_{A,B} cut(A,B)$$公式解释：\n$\\arg\\min$：表示\u0026quot;使得后面的值最小的参数\u0026rdquo; 即找到使 $cut(A,B)$ 最小的划分方式 $(A, B)$ 最小割的局限性：\n虽然最小割能找到连接最少的划分，但存在明显的问题：\n只考虑簇间的联通性：只关心两个社区之间有多少连接 不考虑簇内的连通性：不关心每个社区内部的结构 可能产生不平衡的划分：例如，将一个孤立的节点分离出来，只需要切断很少的边，但这样的划分是没有意义的 举例说明： 假设有一个图，其中有一个节点只通过一条边连接到主图，那么最小割会将这个节点单独分离出来（只需切断1条边），但这样的划分显然不合理。\n5. 归一化切割 (Normalized-cut) 为了解决最小割的问题，我们引入归一化切割，它同时考虑了簇间的连通性和各簇的规模。\n体积（Volume）的定义： 首先需要定义社区 $A$ 的\u0026quot;体积\u0026quot; $vol(A)$：\n$$vol(A) = \\sum_{i \\in A} k_i$$其中 $k_i$ 是节点 $i$ 的度（degree），即连接到节点 $i$ 的所有边的权重之和。$vol(A)$ 表示至少有一个端点在社区 $A$ 中的所有边的总权重，反映了社区 $A$ 的\u0026quot;规模\u0026quot;或\u0026quot;密度\u0026quot;。\n归一化切割的定义：\n$$ncut(A,B) = \\frac{cut(A,B)}{vol(A)} + \\frac{cut(A,B)}{vol(B)}$$公式解释：\n第一项 $\\frac{cut(A,B)}{vol(A)}$：割的大小相对于社区 $A$ 的规模 第二项 $\\frac{cut(A,B)}{vol(B)}$：割的大小相对于社区 $B$ 的规模 两项相加：综合考虑两个社区的规模 为什么要归一化？ 通过除以各自的体积，我们将割的大小\u0026quot;标准化\u0026quot;了。这样如果一个社区很大（$vol$ 很大），即使割的值不变，归一化后的值也会变小，从而避免了将单个节点分离出来的情况（因为单个节点的 $vol$ 很小，归一化后的值会很大）。\n优势：\n使划分更加平衡，避免产生极小的社区 同时考虑了社区间的连接和社区的规模 挑战：\n计算归一化割是 NP-hard 问题 需要使用近似算法或启发式方法来高效地找到好的划分 6. 练习题详解 题目： 对于给定的图(红色节点和绿色节点)，分别计算最优切割和最小切割的 $ncut$ 值。\n题目分析： 从图中可以看到两种切割方式：\n最优切割（蓝色虚线）：在红色社区（左侧）和绿色社区（右侧）之间进行切割 最小切割（红色虚线）：将右下角单个绿色节点孤立出来 （1）最小切割的 $ncut$ 值计算\n划分方式：社区 $A$ 为红色节点+5个绿色节点，社区 $B$ 为右下角单个绿色节点。\n$cut(A,B) = 1$（只有1条边连接孤立节点） $vol(B) = 0$（节点完全孤立，内部没有边） $ncut_{\\text{min}} = \\frac{1}{vol(A)} + \\frac{1}{0} = +\\infty$ 这说明将单个节点完全孤立是一个极差的划分！\n（2）最优切割的 $ncut$ 值计算\n划分方式：社区 $A$ 为所有红色节点（左侧10个节点），社区 $B$ 为所有绿色节点（右侧6个节点）。\n$cut(A,B) = 2$（2条边跨越蓝色虚线） $vol(A) = 2 \\times 15 = 30$（红色区域内部15条边） $vol(B) = 2 \\times 9 = 18$（绿色区域内部9条边） $ncut_{\\text{optimal}} = \\frac{2}{30} + \\frac{2}{18} = \\frac{1}{15} + \\frac{1}{9} = \\frac{8}{45} \\approx 0.178$ 结果对比：\n切割方式 $cut(A,B)$ $vol(A)$ $vol(B)$ $ncut$ 值 最小切割 1 \u0026gt;0 0 $+\\infty$ 最优切割 2 30 18 0.178 结论：\n最小切割将单个节点孤立后，$vol(B) = 0$ 导致 $ncut$ 值趋向无穷大，这是最差的划分 最优切割虽然 $cut$ 值不是最小，但 $ncut$ 值很小，实现了平衡且合理的划分 归一化切割通过考虑社区规模，避免了不合理的极端划分，$ncut$ 值越小说明划分越好 二、边介数（Edge Betweenness） 1. 边介数的定义 边介数（Edge Betweenness）：通过该边的最短路径的数量。\n作用：\n用于衡量图中一条边的重要性或中心性 反映图中有多少条最短路径经过该边 重要性判断：\n若很多最短路径都经过该边，则该边对于保持图的高效连接性就非常重要 相反，如果仅少数最短路径经过该边，则该边的重要性就较低 应用价值：\n边介数有助于识别图中的关键连接，即这些连接一旦断裂会显著影响图中节点之间的通信效率。\n示例：\n在下图中，不同的边具有不同的边介数值：\n左侧的边：$b = 16$（有16条最短路径经过） 右侧的边：$b = 7.5$（有7.5条最短路径经过） 边介数越大，该边在网络中的重要性越高。\n2. Girvan-Newman方法（简称GN方法） GN方法定义：\nGirvan-Newman方法是一种基于边介数概念的层次聚类算法，适用于无向无权网络。\n算法流程：\n重复以下步骤直到没有边剩余：\n计算边介数：计算网络中所有边的边介数 移除边介数最高的边：找到边介数最大的边并将其从图中删除 重新计算：在每个步骤后，需要重新计算剩余边的边介数 输出结果：\n相连接的边构成社区 可输出网络的层次分解 重要提示： 在每个步骤，均需重新计算边介数，因为移除一条边会影响其他边的最短路径。\n3. GN方法案例分析 考虑下图所示的网络，应用GN方法进行社区划分：\nStep 1： 计算所有边的边介数，移除边介数最高的边（边7-8，边介数为49）\n结果：图被分成两个主要部分\nStep 2： 重新计算剩余边的边介数，继续移除边介数最高的边\n结果：进一步细分，形成更小的社区\nStep 3： 持续迭代，直到所有边都被移除\n结果：每个节点成为独立的社区\n最终输出：层次状的网络划分\n通过记录每次移除边的顺序，可以构建一个层次树（dendrogram），展示网络在不同粒度下的社区结构。\n4. 如何计算边介数 （1）基本方法：构建根节点到其余子节点的最短路径数量\n步骤1：构建最短路径树\n从起始节点（如节点A）开始，使用BFS构建到所有其他节点的最短路径树，并标记每个节点的层次：\n第0层：起始节点A 第1层：与A直接相连的节点（B, C, D, E） 第2层：距离A为2的节点（F, G, H） 第3层：距离A为3的节点（I, J） 第4层：距离A为4的节点（K） 步骤2：计算最短路径数量\n计算从起始节点A到网络中其他每个节点的最短路径数量。\n公式：\n从A到某个节点X的最短路径数量 = 所有能到达X的父节点的最短路径数量之和\n示例：\n从A到H的最短路径数量 = 从A到D的最短路径数量 + 从A到E的最短路径数量 从A到K的最短路径数量 = 从A到I的最短路径数量 + 从A到J的最短路径数量 （2）自底向上计算边介数：如果存在多条最短路径，则可按比例划分边介数。\n算法步骤：\n添加边流\n初始化：每个节点的流 = 1 + 其所有子边的流之和 根据父节点的值分配流 对于每个起始节点U，重复广度优先搜索过程\n详细计算规则：\n对于某条边 $(X, Y)$，其边介数的计算遵循以下规则：\n如果从A到Y只有一条最短路径经过X，则该边获得完整的流 如果从A到Y有多条最短路径（通过不同的父节点），则按照各父节点的最短路径数量比例分配流 具体案例：\n以节点为K为例：\nK对于A而言是叶子节点，所以他的流为1（根据算法规则：子节点的流为0）， 共有2条最短路径可被分配，根据I，J各有三条最短路径，为3：3，即1：1，因此每条边分配 $\\frac{1}{2}$ 以节点I为例：\nA-I的最短路径总和算1，外加经过I到K的0.5，所以I的流为1.5 I有1.5可被分配，按照2:1的比例划分（因为A到F有2条最短路径，到G有1条最短路径） 故边$V_{F,I}$得到的流为1，边$V_{G,I}$得到的流为0.5 以此自下而上故能得到所有边的边介数\n5. 练习题 题目：给定下图所示的网络结构，请计算从节点B开始的路径边介数。\n步骤1：构建最短路径树\n从起始节点B开始，使用BFS构建到所有其他节点的最短路径树，并标记每个节点的层次：\n第0层：起始节点B 第1层：与B直接相连的节点（A，C，F） 第2层：距离B为2的节点（D，E，I） 第3层：距离B为3的节点（G，H，K） 第4层：距离B为4的节点（J） 步骤2：计算最短路径数量\n计算从起始节点B到网络中其他每个节点的最短路径数量。定义节点B到节点I的最短路径数量的方法为$N(i)$，故\n第0层：起始节点B 第1层：与B直接相连的节点$N(A) = 1$,$N(C) = 1$,$N(F) = 1$ 第2层：距离B为2的节点$N(D) = N(A)=1$,$N(E) = N(A)=1$,$N(I)=N(F) = 1$ 第3层：距离B为3的节点$N(G) = N(D)+N(I)=2$,$N(H) = N(D)+N(E)=2$,$N(K)=N(I) = 1$ 第4层：距离B为4的节点$N(J) = N(G)+N(H)+N(K) = 5$ 步骤3：自底向上计算边介数\n每个节点的流 = 1 + 其所有子边的流之和，根据父节点的最短路径数量按比例分配流。\n第4层：距离B为4的节点（J），J为叶子节点，所以J的流为1，分配边流： $$V_{G,J} = \\frac{N(G)}{N(J)} \\times 1 = \\frac{2}{5}, \\quad V_{H,J} = \\frac{N(H)}{N(J)} \\times 1 = \\frac{2}{5}, \\quad V_{K,J} = \\frac{N(K)}{N(J)} \\times 1 = \\frac{1}{5}$$ 第3层：距离B为3的节点（G，H，K），计算各自的流：\nG的流 $= 1 + \\frac{2}{5} = \\frac{7}{5}$，分配边流：$V_{D,G} = \\frac{N(D)}{N(G)} \\times \\frac{7}{5} = \\frac{1}{2} \\times \\frac{7}{5} = \\frac{7}{10}$，$V_{I,G} = \\frac{N(I)}{N(G)} \\times \\frac{7}{5} = \\frac{1}{2} \\times \\frac{7}{5} = \\frac{7}{10}$ H的流 $= 1 + \\frac{2}{5} = \\frac{7}{5}$，分配边流：$V_{D,H} = \\frac{N(D)}{N(H)} \\times \\frac{7}{5} = \\frac{1}{2} \\times \\frac{7}{5} = \\frac{7}{10}$，$V_{E,H} = \\frac{N(E)}{N(H)} \\times \\frac{7}{5} = \\frac{1}{2} \\times \\frac{7}{5} = \\frac{7}{10}$ K的流 $= 1 + \\frac{1}{5} = \\frac{6}{5}$，分配边流：$V_{I,K} = \\frac{N(I)}{N(K)} \\times \\frac{6}{5} = 1 \\times \\frac{6}{5} = \\frac{6}{5}$ 第2层：距离B为2的节点（D，E，I），计算各自的流：\nD的流 $= 1 + \\frac{7}{10} + \\frac{7}{10} = 1 + \\frac{14}{10} = \\frac{12}{5}$，分配边流：$V_{A,D} = \\frac{N(A)}{N(D)} \\times \\frac{12}{5} = 1 \\times \\frac{12}{5} = \\frac{12}{5}$ E的流 $= 1 + \\frac{7}{10} = \\frac{17}{10}$，分配边流：$V_{A,E} = \\frac{N(A)}{N(E)} \\times \\frac{17}{10} = 1 \\times \\frac{17}{10} = \\frac{17}{10}$ I的流 $= 1 + \\frac{7}{10} + \\frac{6}{5} = 1 + \\frac{7}{10} + \\frac{12}{10} = \\frac{29}{10}$，分配边流：$V_{F,I} = \\frac{N(F)}{N(I)} \\times \\frac{29}{10} = 1 \\times \\frac{29}{10} = \\frac{29}{10}$ 第1层：距离B为1的节点（A，C，F），计算各自的流：\nA的流 $= 1 + \\frac{12}{5} + \\frac{17}{10} = 1 + \\frac{24}{10} + \\frac{17}{10} = \\frac{51}{10}$，分配边流：$V_{B,A} = \\frac{51}{10} = 5.1$ C的流 $= 1 + 0 = 1$，分配边流：$V_{B,C} = 1$ F的流 $= 1 + \\frac{29}{10} = \\frac{39}{10}$，分配边流：$V_{B,F} = \\frac{39}{10} = 3.9$ 三、模块度（Modularity） 1.模块度 模块度（Modularity）是衡量图结构划分优劣的重要指标。\n令 G=(V,E) 为一个无向图，其邻接矩阵为 A：\n$$A_{ij} = \\begin{cases} 1, \u0026 \\text{if } (v_i, v_j) \\in E \\\\ 0, \u0026 \\text{otherwise} \\end{cases}$$模块度的定义为：\n$$Q = \\frac{1}{2m}\\sum_{i,j} \\left(A_{ij} - \\frac{k_i k_j}{2m}\\right)\\delta(C_i, C_j)$$其中，$m$表示边的数量，$Ci $表示第 $i$ 个社区。$k_i$ 是顶点 $v_i$ 的度（即与顶点 $v_i$ 相连的边的数量），$δ(Ci, Cj) = 1（如果 Ci = Cj）$，否则为 0。\n模块度的直观解读\n模块度用于衡量网络被划分为社区的好坏程度的一种度量。给定网络被划分为一组 c ∈ C 的情况：\n$$Q \\propto \\sum_{i,j}\\left(A_{ij} - \\frac{k_i k_j}{2m}\\right)\\delta(C_i, C_j) = \\left[\\sum_{i,j} A_{ij} - \\sum_{i,j} \\frac{k_i k_j}{2m}\\right]\\delta(C_i, C_j)$$$$= \\sum_{c \\in C} [(\\# \\text{ edges within group } c) - (\\text{expected } \\# \\text{ edges within group } c)]$$给定一个图 G，含 n 个节点和 m 条边，构建一个随机图 G\u0026rsquo;：\n保持相同的度分布，但边是随机生成 G\u0026rsquo; 是一个多重图 模块度计算\n$$Q = \\frac{1}{2m}\\sum_{c \\in C}\\sum_{i \\in c}\\sum_{j \\in c}\\left(A_{ij} - \\frac{k_i k_j}{2m}\\right)$$ 模块度的取值范围是 [-1, 1] 如果组内边的数量超过了预期数量，则模块度值为正 当模块度 M 大于 0.3 至 0.7 时，意味着输入图中存在显著的社区结构 是用于评估社区结构好坏的度量 模块度案例\n$m = 8, k_1 = 2, k_2 = 2, k_3 = 3, k_4 = 3, k_5 = 2, k_6 = 2, k_7 = 2$\n划分方案1（社区A={1,2,3}，社区B={4,5,6,7}）\n$$ \\begin{aligned} Q \u0026amp;= \\frac{1}{2m}\\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{16} \\right)\\delta(C_i, C_j) \\[6pt] \u0026amp;= \\frac{1}{16}\\Big[ (0 - \\tfrac{k_1 k_1}{16})\n2(1 - \\tfrac{k_1 k_2}{16}) 2(1 - \\tfrac{k_1 k_3}{16}) (0 - \\tfrac{k_2 k_2}{16}) \\ \u0026amp;\\quad 2(1 - \\tfrac{k_2 k_3}{16}) (0 - \\tfrac{k_3 k_3}{16}) (0 - \\tfrac{k_4 k_4}{16}) 2(1 - \\tfrac{k_4 k_5}{16}) \\ \u0026amp;\\quad 2(1 - \\tfrac{k_4 k_6}{16}) 2(0 - \\tfrac{k_4 k_7}{16}) (0 - \\tfrac{k_5 k_5}{16}) 2(0 - \\tfrac{k_5 k_6}{16}) \\ \u0026amp;\\quad 2(1 - \\tfrac{k_5 k_7}{16}) (0 - \\tfrac{k_6 k_6}{16}) 2(1 - \\tfrac{k_6 k_7}{16}) (0 - \\tfrac{k_7 k_7}{16}) \\Big] \\[6pt] \u0026amp;= \\frac{51}{128} \\end{aligned} $$ 划分方案2（社区A={1,2}，社区B={3,4,5,6,7}）\n$$ \\begin{aligned} Q \u0026amp;= \\frac{1}{2m}\\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{16} \\right)\\delta(C_i, C_j) \\[6pt] \u0026amp;= \\frac{1}{16}\\Big[ (0 - \\tfrac{k_1 k_1}{16})\n2(1 - \\tfrac{k_1 k_2}{16}) (0 - \\tfrac{k_2 k_2}{16}) (0 - \\tfrac{k_3 k_3}{16}) \\ \u0026amp;\\quad 2(1 - \\tfrac{k_3 k_4}{16}) 2(0 - \\tfrac{k_3 k_5}{16}) 2(0 - \\tfrac{k_3 k_6}{16}) 2(0 - \\tfrac{k_3 k_7}{16}) \\ \u0026amp;\\quad (0 - \\tfrac{k_4 k_4}{16}) 2(1 - \\tfrac{k_4 k_5}{16}) 2(1 - \\tfrac{k_4 k_6}{16}) 2(0 - \\tfrac{k_4 k_7}{16}) \\ \u0026amp;\\quad (0 - \\tfrac{k_5 k_5}{16}) 2(0 - \\tfrac{k_5 k_6}{16}) 2(1 - \\tfrac{k_5 k_7}{16}) (0 - \\tfrac{k_6 k_6}{16}) \\ \u0026amp;\\quad 2(1 - \\tfrac{k_6 k_7}{16}) (0 - \\tfrac{k_7 k_7}{16}) \\Big] \\[6pt] \u0026amp;= \\frac{19}{128} \\end{aligned} $$ 2. 模块度应用 ** （1）针对加权图的模块度**\n给定一个无向图 $G = (V, E)$，其邻接矩阵为 $A$，并关联一个权重矩阵 $W$：\n$$ W_{ij} = \\begin{cases} w_{ij}, \u0026 \\text{if } A_{ij} = 1 \\\\ 0, \u0026 \\text{otherwise} \\end{cases} $$模块度被定义为：\n$$ Q = \\frac{1}{2m} \\sum_{i,j} \\left( W_{ij} - \\frac{k_i k_j}{2m} \\right) \\delta(C_i, C_j) $$其中：\n$m$ 表示图中所有边的总权重 $C_i$ 表示节点 $v_i$ 所属的社区 $k_i$ 不再是节点 $v_i$ 的度，而是连接到 $v_i$ 的所有边的权重之和 （2）针对有向图的模块度\n给定有向图 $G = (V, E)$，其邻接矩阵为 $A$：\n$$ A_{ij} = \\begin{cases} 1, \u0026 \\text{if } (v_i, v_j) \\in E \\\\ 0, \u0026 \\text{otherwise} \\end{cases} $$模块度被定义为（注意分母是 $m$，不是 $2m$）：\n$$ Q = \\frac{1}{m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i^{\\text{out}} k_j^{\\text{in}}}{m} \\right) \\delta(C_i, C_j) $$其中：\n$m$ 表示图中的总边数 $C_i$ 表示节点 $v_i$ 所属的社区 $k_i^{\\text{out}}$ 和 $k_i^{\\text{in}}$ 分别表示节点 $v_i$ 的出度和入度 （3）模块度矩阵形式\n对于无向图，模块度还可以写成矩阵形式。\n定义一个 $n \\times k$ 的社区指派矩阵 $S$，其中：\n$S_{ir} = 1$ 表示节点 $v_i$ 属于第 $r$ 个社区 $S_{ir} = 0$ 表示节点 $v_i$ 不属于第 $r$ 个社区 则有：\n$$ \\delta(C_i, C_j) = \\sum_r S_{ir} S_{jr} $$定义实对称矩阵 $B$，其元素为：\n$$ B_{ij} = A_{ij} - \\frac{k_i k_j}{2m} $$社区结构的模块度可以改写为：\n$$ Q = \\frac{1}{2m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) \\delta(C_i, C_j) $$$$ = \\frac{1}{2m} \\sum_{i,j} B_{ij} \\sum_r S_{ir} S_{jr} $$$$ = \\frac{1}{2m} \\sum_{i,j} \\sum_r B_{ij} S_{ir} S_{jr} $$$$ = \\frac{1}{2m} \\operatorname{Tr}(S^{\\mathsf T} B S) $$其中，$\\operatorname{Tr}(S^{\\mathsf T} B S)$ 表示矩阵 $S^{\\mathsf T} B S$ 的迹，即其对角元素之和。\n3. 谱方法 谱方法：自顶向下的迭代式社区发现方法，基于分裂思想。\n每次只将一个图分成两个社区，以此类推，直到模块度不再变化为止 假设每次划分时，划分的两个社区分别为社区 1 和社区 2 顶点要么落在社区 1，要么在社区 2 （1）二分划分变量的定义\n因此定义变量：\n$$ s_i = \\begin{cases} 1, \u0026 \\text{如果顶点 } v_i \\text{ 在社区 1} \\\\ -1, \u0026 \\text{否则} \\end{cases} $$ （2）二分情况下的模块度表达式\n因此，二分社区的模块度可以改写为：\n$$ Q = \\frac{1}{4m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) (s_i s_j + 1) $$$$ = \\frac{1}{4m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) s_i s_j $$$$ = \\frac{1}{4m} s^{\\mathsf T} B s $$其中模块度矩阵 $B$ 定义为：\n$$ B_{ij} = A_{ij} - \\frac{k_i k_j}{2m} $$注意到，在模块度矩阵 $B$ 中，每一行和每一列的元素之和均为 0，因此向量 $(1,1,\\dots,1)$ 是特征值为 0 的特征向量。\n（3）模块度矩阵的谱分解\n假设模块度矩阵 $B$ 具有 $n$ 个正交特征向量 $\\{u_i\\}$，对应特征值为：\n$$ \\beta_1 \\ge \\beta_2 \\ge \\cdots \\ge \\beta_n $$因此，划分向量 $s = (s_1, s_2, \\dots, s_n)$ 可以展开为：\n$$ s = \\sum_{i=1}^n a_i u_i, \\qquad a_i = u_i^{\\mathsf T} s $$ （4）模块度的谱展开形式\n将上述展开代入模块度表达式，得到：\n$$ Q = \\frac{1}{4m} \\sum_i a_i u_i^{\\mathsf T} B \\sum_j a_j u_j $$利用特征向量的正交性，可进一步化简为：\n$$ Q = \\frac{1}{4m} \\sum_{i=1}^n (u_i^{\\mathsf T} s)^2 \\beta_i $$由此可见，模块度由所有特征值 $\\beta_i$ 共同决定。\n（5）基于最大特征值的近似最优化\n给定图 $G$，其模块度矩阵 $B$ 的特征值和特征向量是固定的。\n为了最大化模块度，需要考虑所有特征值 $\\beta_i$，但计算代价较高。\n因此，通常仅考虑最大的特征值 $\\beta_1$ 及其对应的特征向量 $u_1$。\n若对划分向量 $s$ 不加限制，最优解应使 $s$ 与 $u_1$ 平行。\n但由于 $s_i \\in \\{1, -1\\}$，问题转化为最大化点积 $u_1^{\\mathsf T} s$。\n因此定义划分规则为：\n$$ s_i = \\begin{cases} 1, \u0026 \\text{如果 } u_{1i} \u003e 0 \\\\ -1, \u0026 \\text{否则} \\end{cases} $$即在最大特征值对应的特征向量 $u_1$ 中：\n同号分量对应的顶点属于同一社区 不同号分量对应的顶点属于不同社区 （6）扩展到多个社区的递归划分问题\n鉴于图中可能包含超过 2 个社区，因此希望可以划分为更多部分。\n一种自然的做法是重复进行二分划分：\n首先将网络分成两部分 然后对每个子图继续应用上述方法 但这种方法并不正确，原因在于：\n边的删除会改变模块度的定义 后续的模块度最大化将不断放大误差 （7）基于模块度增量的正确递归策略\n为避免上述问题，每次仅考虑划分带来的模块度增量。\n设子社区 $g$ 的规模为 $n$，其模块度增量定义为：\n$$ \\Delta Q = \\frac{1}{2m} \\left[ \\frac{1}{2} \\sum_{i,j \\in g} B_{ij}(s_i s_j + 1)\n\\sum_{i,j \\in g} B_{ij} \\right] $$ $$ = \\frac{1}{4m} \\left[ \\sum_{i,j \\in g} B_{ij} s_i s_j\n\\sum_{i,j \\in g} B_{ij} \\right] $$ $$ = \\frac{1}{4m} \\sum_{i,j \\in g} \\left[ B_{ij}\n\\delta_{ij} \\sum_{k \\in g} B_{ik} \\right] s_i s_j $$ $$ = \\frac{1}{4m} s^{\\mathsf T} B^{(g)} s $$其中，当 $i=j$ 时 $\\delta_{ij}=1$，否则 $\\delta_{ij}=0$。\n因此，仅当模块度增量 $\\Delta Q \u003e 0$ 时，才继续划分该子社区；否则停止划分。\n由此可以保证，每一次社区划分都会使整体模块度单调增加。\n四、Louvain 方法 1. Louvain 方法概述 Louvain 方法是一种社区检测的贪心算法，具有以下特点：\n支持有向图和加权图 提供层次化分区 社区数量不是超参数，算法自动确定 广泛用于研究大型网络，因为： 快速：运行时间仅为 $O(|E|)$，其中 $|E|$ 是边的数量 收敛速度快 输出的模块度高（即“更好的社区”） Louvain 算法以贪心方式逐步最大化模块度。\n每次遍历包含两个阶段，迭代重复这些遍历，直到模块度不再增加为止。\n2. 模块度重写 在 Louvain 方法中，模块度可以重写为更便于计算的形式：\n$$ M = \\frac{1}{2m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) \\delta(C_i, C_j) $$$$ = \\left[ \\sum_{i,j} \\frac{A_{ij}}{2m}\n\\frac{\\sum_i k_i \\sum_j k_j}{4m^2} \\right] \\delta(C_i, C_j) $$ $$ = \\sum_{c \\in C} \\left[ \\frac{\\Sigma_{in}^c}{2m}\n\\left( \\frac{\\Sigma_{tot}^c}{2m} \\right)^2 \\right] $$ 其中：\n$\\Sigma_{in}^c$ 是社区 $c$ 内部顶点之间的边权重之和 $\\Sigma_{tot}^c$ 是社区 $c$ 中所有顶点的边权重总和 $m$ 是图中所有边的权重总和 3. Louvain 方法：阶段 1（模块度重写） 初始化：\n将图中的每个顶点放入一个独立的社区（每个社区一个顶点）。\n迭代过程：\n对于每个顶点 $v_i$，算法执行以下计算：\n（1） 计算当把顶点 $v_i$ 从其当前社区移动到某个邻近顶点 $v_j$ 的社区时模块度的增量 $\\Delta Q$\n（2） 将 $v_i$ 移动到能够产生最大模块度增量 $\\Delta Q$ 的社区\n（3） 循环运行直到没有移动能带来增益为止\n第一阶段在达到模块度的局部最大值时停止，即当任何单个移动都不能再改进模块度时。\n需要注意的是，算法的输出依赖于考虑顶点的顺序，但研究表明顶点顺序对最终模块度的影响并不显著。\n4. 模块度增益计算 模块度变化的两个部分：\n模块度的变化可以分为两个部分：\n增益：$\\Delta Q(v_i \\to C)$，表示将顶点 $v_i$ 移动到社区 $C$ 时模块度 $Q$ 的增益 损失：$\\Delta Q(D \\to v_i)$，表示将顶点 $v_i$ 从社区 $D$ 中移出时模块度 $Q$ 的损失 将顶点 $v_i$ 移入社区 $C$ 的增益：\n$$ \\Delta Q(v_i \\to C) = \\left[\\frac{\\Sigma_{in}^C + k_{i,in}^C}{2m} - \\left(\\frac{\\Sigma_{tot}^C + k_i}{2m}\\right)^2\\right] - \\left[\\frac{\\Sigma_{in}^C}{2m} - \\left(\\frac{\\Sigma_{tot}^C}{2m}\\right)^2 - \\left(\\frac{k_i}{2m}\\right)^2\\right] $$$$ = \\left[\\frac{k_{i,in}^C}{2m} - \\frac{\\Sigma_{tot}^C \\cdot k_i}{2m^2}\\right] $$其中：\n$k_{i,in}^C$ 是顶点 $v_i$ 与社区 $C$ 内部顶点之间的边权重之和 $k_i$ 是顶点 $v_i$ 的度（所有相连边的权重之和） 将顶点 $v_i$ 从社区 $D$ 中移出的损失：\n设 $D'$ 是移出 $v_i$ 后的社区 $D$，则：\n$$ \\Delta Q(D \\to v_i) = - \\Delta Q(v_i \\to D') $$$$ = \\frac{\\Sigma_{tot}^{D'} \\cdot k_i}{2m^2} - \\frac{k_{i,in}^{D'}}{2m} $$ 总的模块度变化：\n$$ \\Delta Q = \\Delta Q(v_i \\to C) + \\Delta Q(D \\to v_i) $$5. Louvain 方法：阶段 2（社区聚合） 在第一阶段获得的分区被收缩成超级节点，并按照以下方式创建加权网络：\n如果对应社区之间的顶点之间至少存在一条边，则超级节点之间是连接的。 两个超级节点之间边的权重是它们对应分区之间所有边的权重之和。 聚合之后，图成为一个加权图， 6. Louvain 方法分析 计算效率：\n算法运行速度快，在第一次遍历后社区数量急剧减少 后续遍历中的计算量显著降低 模块度增益计算简单 时间复杂度为 $O(|E|)$ 对于包含 $10^6$ 个顶点的图，找到社区结构所需时间通常不到 1 分钟 其他优势：\n社区数量不是超参数，算法自动确定 可以用于评估社区结构的质量 可通过模块度曲线确定最佳的簇数量 模块度用于确定簇的数量：\n在层次聚类等方法中，可以通过计算不同切割高度下的模块度， 选择模块度最大时对应的簇数量作为最优划分。\n模块度曲线通常呈现“先上升、后下降”的趋势，其峰值对应最佳的社区划分。\n第九讲 子模函数及其应用 一、应用背景 1.特征选择（Feature Selection） 问题描述：给定一组特征 X₁, \u0026hellip;, Xₙ，构造子集 A = (Xᵢ₁, \u0026hellip;, Xᵢₖ) 用以预测目标变量 Y 核心问题：如何选取 k 个特征，使子集信息量最丰富？ 信息增益：I(A; Y) = H(Y) − H(Y | A) H(Y)：Y 的熵（表示不确定性） H(Y | A)：给定 A 条件下 Y 的条件熵 I(A; Y) 描述通过知道 A 能够获得关于 Y 的信息量 2.影响力最大化（Influence Maximization） 基于社交网络，向哪些用户投放广告以达到最佳传播效果 找出最具影响力的博客或个人，将信息快速、有效地传播给受众 3.传感器部署（Sensor Placement） 问题：给定水分配网络，如何部署传感器以快速检测污染？\n函数定义：f(A) 表示在子集 A 处部署传感器的效用值\n效用特性：\n信息量高的配置（如 A = {1, 2, 3}）：f(A) 值大 信息冗余度大的配置（如 A = {1, 4, 5}）：f(A) 值较低 4.图的割函数（Graph Cut） 定义：对无向图 G(V, E)，割函数 f(S) = |{(u, v) | u ∈ S ⊂ V, v ∈ Sᶜ}| 含义：集合 S 与其补集之间的边数 示例：S = {1, 2, 3} 时 f(S) = 1；S = {1, 2} 时 f(S) = 2 5. 连续优化 凸函数优化（求最小值）\n若 f: Rⁿ → R 是凸函数，则可高效获取最小值 凸函数特性：连接凸函数图像上任意两点的线段总是在函数图像之上或恰好位于图像上 几何直观：U形曲线，底部有唯一最小值点 凹函数优化（求最大值）\n若 f: Rⁿ → R 是凹函数，则可高效获取最大值 凹函数特性：连接凹函数图像上任意两点的线段总是在函数图像之下或恰好位于图像上 几何直观：倒U形曲线，顶部有唯一最大值点 6. 离散优化：从凹性到子模性 连续优化中的凹函数\n若 f : Rⁿ → R 是凹函数，则可高效获取最大值 连接凹函数图像上任意两点的线段总在函数图像之下或恰好位于图像上 导数 f\u0026rsquo;(x) 随 x 增加而非递增 离散情况下的子模性\n对于函数 f : {0,1}ⁿ → R 离散导数：∂ᵢf(x) = f(x + eᵢ) − f(x) 若 ∂ᵢf(x) 随 x 增加而非递增，则函数是子模的 eᵢ 表示第 i 个分量为 1，其余分量为 0 的单位向量 二、子模函数 1. 集合函数基础 定义\n给定有限集合 V = {1, 2, ···, n} 集合函数：f : 2^V → R（或 f : {0, 1}ⁿ → R） 2^V 是集合 V 的幂集 集合函数的基本性质\n单调性：若 A ⊆ B ⊆ X，则 F(A) ≤ F(B) 非负性：对于所有 S ⊆ X，F(A) ≥ 0 规范化：F(∅) = 0 2.子模性定义 定义1：基本形式\n对于函数 f : 2^V → R，如果对于所有 A, B ⊆ V，均有：\n$f(A) + f(B) ≥ f(A ∪ B) + f(A ∩ B)$ 则该函数是子模的。 等价形式：$f(A) − f(A ∩ B) ≥ f(A ∪ B) − f(B)$\n定义2：边际效用递减\n对于所有 $S ⊆ T ⊆ V$，对于所有 $v ∈ V T$：$f(S ∪ {v}) − f(S) ≥ f(T ∪ {v}) − f(T)$\n经济学解释：对象在更大的上下文中增加的价值逐渐减少\n定义3：群体边际效用递减\n对于所有 S ⊆ T ⊆ V，且 C ⊆ V \\ T：$f(S ∪ C) − f(S) ≥ f(T ∪ C) − f(T)$\n4. 子模性的闭合性质 子模性在非负线性组合下具有闭合性质：\n非负线性组合：若 f₁ 和 f₂ 都是子模函数，a₁, a₂ ≥ 0，则 a₁f₁ + a₂f₂ 是子模函数\n集合限制：若 S ⊂ V 是固定集合，则 f\u0026rsquo;(A) = f(A ∩ S) 和 f(A) = f(Aᶜ) 都是子模的\n期望保持：若 fθ(A) 是子模的，则 Σθ P(θ)fθ(A) 也是子模的\n多目标优化：若 f₁, ···, fₘ 都是子模的，且 λᵢ \u0026gt; 0，则 Σᵢλᵢfᵢ(A) 也是子模的\n5. 典型案例 案例1：传感器部署\n边际效应：Δf(s|A) = f(A ∪ {s}) − f(A)\n若 A = {1, 2}，增加部署 s 的效果显著\n若 A = {1, 2, 3}，增加部署 s 的效果一般\n验证子模性：∀A ⊂ B，s ∉ B，Δf(s|A) ≥ Δf(s|B)\n案例2：计算不同颜色数量\n给定一组球的集合 S，f(S) 计算不同颜色的数量\n子模性：对象在更大上下文中增加的价值逐渐减少\n案例3：集合覆盖\nC 的覆盖定义为：f(C) = |⋃_{sᵢ∈C} sᵢ|\n满足单调性和子模性\n三、集合覆盖问题 1. k-最大覆盖问题 问题定义\n集合覆盖：每个条目 u 是由某些基础元素组成的子集 覆盖函数：f(S) = |⋃_{u∈S} u|（所有属于 S 中子集的并集的大小） 边际覆盖增加：f(S ∪ {v}) − f(S) k-最大覆盖问题\n目标：寻找 k 个子集，使联合覆盖尽可能大 复杂性：NP-hard 问题（无多项式时间算法，除非 P=NP） 示例（k=2）\n给定：\n真实集合：{a, b, c, d, e, f, g, h, i, j, k, l} 子集： A₁ = {a, b, c, d} A₂ = {e, f, g, h} A₃ = {i, j, k, l} A₄ = {a, e} A₅ = {i, b, f, g} A₆ = {c, d, g, h, k, l} A₇ = {l} 计算：\nA₆ 有 6 个元素，A₁, A₂, A₃, A₅ 各有 4 个元素 |A1 ∪ A6| = 8, |A2 ∪ A6| = 8, |A3 ∪ A6| = 8, |A5 ∪ A6| = 9 |A₅ ∪ A₆| = 9（最大）\n结果：C = {A₅, A₆} 是最大覆盖集合\n2. 抽取式文本摘要问题 给定：\n关键词集合 W = {w₁, w₂, ···, wₙ} 句子集合 S = {s₁, s₂, ···, sₘ} 每个 sⱼ = {wₖ | wₖ ∈ W} 目标：找到 k 个句子，包含尽可能多的关键词\n数学表达：\n最大化：Σⱼ₌₁ⁿ Σᵢ₌₁ᵐ Xᵢsᵢⱼ 约束条件：Σᵢ₌₁ᵐ Xᵢ = k 其中：\nXᵢ = 1（若 sᵢ ∈ C），0（否则） sᵢⱼ = 1（若 wᵢ ∈ sⱼ），0（否则） 3.子模覆盖 C的覆盖被定义为：f(C)=|⋃1_(s_i∈C)▒s_i |\n令 C ⊂ D, 且 sk ∈ D, 我们有：\nf(C∪{S_k })-f(C)=|s_k-⋃1_(S_i∈C)▒s_i |≥|s_k-⋃1_(s_i∈D)▒s_i |=f(D∪{s_k })-f(D)\n此外, 由于 ⋃1_(s_i∈C)▒〖s_i⊂⋃1_(s_i∈D)▒s_i 〗 , 则：f (C) ≤ f (D).\n4. 爬山算法（Greedy Algorithm） 算法流程\n1. 初始化 C = ∅ 2. for i = 1 to k do 3. c = arg max_{s∈S\\C} [f(C ∪ {s}) − f(C)] 4. C = C ∪ {c} 5. output C 理论保证\n若集合函数 f 是单调、子模的，且 f(∅) = 0，则贪心算法可达到 (1 − 1/e) 的近似率：\nf(S) ≥ (1 − 1/e) max_{S\u0026#39;⊆V, |S\u0026#39;|=k} f(S\u0026#39;) 其中 e ≈ 2.718（自然常数）\n算法示例\n给定：\n关键词集合 W = {w₁, w₂, ···, w₈} 9个句子 s₁, s₂, \u0026hellip;, s₉ 目标：选择 k=3 个句子 第一轮：\n计算每个句子的覆盖增益 Δ(Sᵢ) s₄ 具有最大覆盖增益（Δ = 4），被选中 C = {s₄} 第二轮：\n在剩余句子中计算边际增益 s₅ 和 s₈ 具有最大边际增益（Δ = 2） 选择 s₅ C = {s₄, s₅} 第三轮：\ns₁, s₈, s₉ 具有相同边际增益（Δ = 1） 选择 s₁ C = {s₄, s₅, s₁} 最终输出：C = {s₄, s₅, s₁}\n5. 最小规模集合覆盖问题 问题定义\n输入：\n元素集合 X = {e₁, e₂, \u0026hellip;, eₙ} m 个子集 S₁, S₂, \u0026hellip;, Sₘ ⊆ E 输出：找到集合 I ⊆ {1,2,\u0026hellip;,m}，满足：\n⋃ᵢ∈I Sᵢ = X |I| 最小化 注意：顶点覆盖问题是集合覆盖问题的特例\n实际案例\n软件公司员工各有不同技能（C++, Python, Linux, Database, Network\u0026hellip;）\n项目需要多种技能 a₁, a₂, \u0026hellip; 如何组建最精干的队伍完成项目？ 贪心近似算法\nGreedy-Set-Cover(X, F) 1. U ← X 2. I ← ∅ 3. while U ≠ ∅ 4. 选择 Sᵢ 使得 |Sᵢ ∩ U| 最大 5. U ← U − Sᵢ 6. I ← I ∪ {i} 7. return I 理论结果\n定理：GREEDY-SET-COVER 是一个多项式时间的 ρ(n) 近似算法，其中：\nρ(n) = H(max{|S| : S ∈ F}) H 是调和级数：H(d) = 1 + 1/2 + 1/3 + \u0026hellip; + 1/d\n","permalink":"http://localhost:1313/dase-course/mathematical-algorithms-lecture/","summary":"本笔记涵盖数学基础算法篇的完整内容，包括算法分析与相似度搜索、尾不等式及其应用、数据流算法（频繁元素检测、滑动窗口模型）、分布式数据流处理、哈希技术（布隆过滤器、LSH）、线性规划与整数规划、内存计算架构、社区发现算法以及子模函数应用等核心理论与实践。","title":"数学基础算法篇"},{"content":"0.前言 功能概要 数据库设计 1. tb_blog (博客/探店笔记表) 功能: 存储用户发布的探店笔记内容\n字段 类型 说明 id bigint(20) 主键，自增 shop_id bigint(20) 关联的商户ID user_id bigint(20) 发布用户ID title varchar(255) 笔记标题 images varchar(2048) 图片路径，多张用逗号分隔，最多9张 content varchar(2048) 文字描述内容 liked int(8) 点赞数量 comments int(8) 评论数量 create_time timestamp 创建时间 update_time timestamp 更新时间 示例数据: 包含美食探店笔记，如\u0026quot;无尽浪漫的夜晚\u0026quot;、\u0026ldquo;人均30💰杭州港式茶餐厅\u0026quot;等\n2. tb_blog_comments (博客评论表) 功能: 存储博客的评论信息，支持多级评论\n字段 类型 说明 id bigint(20) 主键，自增 user_id bigint(20) 评论用户ID blog_id bigint(20) 关联的博客ID parent_id bigint(20) 父评论ID，一级评论为0 answer_id bigint(20) 回复的评论ID content varchar(255) 评论内容 liked int(8) 点赞数 status tinyint(1) 状态: 0正常, 1被举报, 2禁止查看 create_time timestamp 创建时间 update_time timestamp 更新时间 设计亮点: 通过parent_id和answer_id支持多层级的评论回复\n3. tb_follow (关注关系表) 功能: 记录用户之间的关注关系\n字段 类型 说明 id bigint(20) 主键，自增 user_id bigint(20) 用户ID follow_user_id bigint(20) 被关注的用户ID create_time timestamp 创建时间 用途: 实现社交功能，构建用户关系网络\n4. tb_shop (商铺表) 功能: 存储商铺的基本信息\n字段 类型 说明 id bigint(20) 主键，自增 name varchar(128) 商铺名称 type_id bigint(20) 商铺类型ID images varchar(1024) 商铺图片，多张用逗号分隔 area varchar(128) 商圈，如\u0026quot;陆家嘴\u0026rdquo; address varchar(255) 详细地址 x double 经度 y double 纬度 avg_price bigint(10) 人均价格（整数） sold int(10) 销量 comments int(10) 评论数量 score int(2) 评分(1-5分，乘10保存) open_hours varchar(32) 营业时间 create_time timestamp 创建时间 update_time timestamp 更新时间 示例商铺: 包含103茶餐厅、海底捞火锅、开乐迪KTV等14家商铺\n5. tb_shop_type (商铺类型表) 功能: 商铺分类管理\n字段 类型 说明 id bigint(20) 主键，自增 name varchar(32) 类型名称 icon varchar(255) 图标路径 sort int(3) 排序 create_time timestamp 创建时间 update_time timestamp 更新时间 分类: 美食、KTV、丽人美发、健身运动、按摩足疗、美容SPA、亲子游乐、酒吧、轰趴馆、美睫美甲\n6. tb_user (用户表) 功能: 存储用户基本信息\n字段 类型 说明 id bigint(20) 主键，自增 phone varchar(11) 手机号（唯一索引） password varchar(128) 加密密码 nick_name varchar(32) 昵称 icon varchar(255) 头像路径 create_time timestamp 创建时间 update_time timestamp 更新时间 安全设计: 密码加密存储，手机号唯一\n7. tb_user_info (用户详细信息表) 功能: 存储用户的扩展信息\n字段 类型 说明 user_id bigint(20) 主键，关联用户ID city varchar(64) 城市 introduce varchar(128) 个人介绍 fans int(8) 粉丝数 followee int(8) 关注数 gender tinyint(1) 性别: 0男, 1女 birthday date 生日 credits int(8) 积分 level tinyint(1) 会员等级(0-9) create_time timestamp 创建时间 update_time timestamp 更新时间 8. tb_voucher (代金券表) 功能: 管理商铺的优惠券信息\n字段 类型 说明 id bigint(20) 主键，自增 shop_id bigint(20) 商铺ID title varchar(255) 券标题 sub_title varchar(255) 副标题 rules varchar(1024) 使用规则 pay_value bigint(10) 支付金额（分） actual_value bigint(10) 抵扣金额（分） type tinyint(1) 类型: 0普通券, 1秒杀券 status tinyint(1) 状态: 1上架, 2下架, 3过期 create_time timestamp 创建时间 update_time timestamp 更新时间 9. tb_seckill_voucher (秒杀券表) 功能: 存储秒杀券的特殊信息\n字段 类型 说明 voucher_id bigint(20) 主键，关联券ID stock int(8) 库存数量 begin_time timestamp 生效时间 end_time timestamp 失效时间 create_time timestamp 创建时间 update_time timestamp 更新时间 特点: 与tb_voucher是一对一关系，专门处理秒杀场景\n10. tb_voucher_order (优惠券订单表) 功能: 记录用户购买优惠券的订单\n字段 类型 说明 id bigint(20) 主键（非自增） user_id bigint(20) 用户ID voucher_id bigint(20) 优惠券ID pay_type tinyint(1) 支付方式: 1余额, 2支付宝, 3微信 status tinyint(1) 订单状态: 1未支付, 2已支付, 3已核销, 4已取消, 5退款中, 6已退款 create_time timestamp 下单时间 pay_time timestamp 支付时间 use_time timestamp 核销时间 refund_time timestamp 退款时间 update_time timestamp 更新时间 设计亮点: 完整的订单状态流转，支持退款流程\n11. tb_sign (签到表) 功能: 记录用户的签到信息\n字段 类型 说明 id bigint(20) 主键，自增 user_id bigint(20) 用户ID year year 签到年份 month tinyint(2) 签到月份 date date 签到日期 is_backup tinyint(1) 是否补签 用途: 用户激励体系，支持补签功能\n1.短信登录 基于session实现登录 1.登录流程 2.代码实现 发送短信验证码\n@Slf4j @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements IUserService { @Override public Result sendcode(String phone, HttpSession session){ //1.校验手机号,utils的工具包 if(RegexUtils.isPhoneInvalid(phone)){ //2.如果不符合，返回错误信息 return Result.fail(\u0026#34;手机号格式错误！\u0026#34;); } //3.符合，生成验证码,一个java的工具包 String code = RandomUtil.randomNumbers(6); //4.保存验证码道session session.setAttribute(\u0026#34;code\u0026#34;,code); //5.发送验证码,需要调用第三方的短信平台，比如说阿里云 //TODO log.debug(\u0026#34;发送短信验证码成功，验证码：{}\u0026#34;,code); //返回ok return Result.ok(code); } } 短信验证码验证和登录\n@Override public Result login(LoginFormDTO loginForm, HttpSession session){ //1.校验手机号 String phone = loginForm.getPhone(); if(RegexUtils.isPhoneInvalid(phone)){ return Result.fail(\u0026#34;手机号格式错误！\u0026#34;); } //2.校验验证码 Object cacheCode = session.getAttribute(\u0026#34;code\u0026#34;); String code = loginForm.getCode(); if(cacheCode==null || !cacheCode.toString().equals(code)){ //3.不一致报错 return Result.fail(\u0026#34;验证码错误\u0026#34;); } //4.一致，根据手机号查询用户,select * from tb_user where phone = ? User user = query().eq(\u0026#34;phone\u0026#34;, phone).one(); //5.判断用户是否存在 if(user==null){ //6.不存在，创建用户并保存,只需要填充phone和nickname字段即可 user = createUserWithPhone(String phone); } //7.保存用户信息到session中 session.setAttribute(\u0026#34;user\u0026#34;,user); return Result.ok(); } private User createUserWithPhone(String phone){ //1.创建用户 User user = new User(); user.setPhone(phone); user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(10)); //2.保存用户 save(user); return user; } 校验登录状态\n/* 在utils中添加LoginInterceptor.java作为拦截器 */ public class LoginInterceptor implements HandlerInterceptor { //预拦截 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.获取session HttpSession session = request.getSession(); //2.获取session中的user Object user = session.getAttribute(\u0026#34;user\u0026#34;); //3.判断用户是否在存在 if(user==null){ //4.不存在，返回401状态码 response.setStatus(401); return false; } //5.存在，保存用户信息到ThreadLocal UserHolder.saveUser((UserDTO) user); //6.放行 return true; } //渲染之前的拦截 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { //移除用户 UserHolder.removeUser(); } } /* 在config中添加MvcConfig.java */ @Configuration public class MvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( \u0026#34;/user/code\u0026#34; , \u0026#34;/user/login\u0026#34; , \u0026#34;/blog/hot\u0026#34; , \u0026#34;/shop/**\u0026#34; , \u0026#34;/shop-type/**\u0026#34; , \u0026#34;/upload/**\u0026#34; , \u0026#34;/voucher/**\u0026#34; ); } } /* controller拿到用户登录的信息，通过这个ThreadLocal\t*/ @GetMapping(\u0026#34;/me\u0026#34;) public Result me(){ // 获取当前登录的用户并返回 UserDTO user = UserHolder.getUser(); return Result.ok(user); } 隐藏用户信息\n/* 1.需要在登录的时候，将传入session的user更改成userDTO 2.更改UserHolder中的所有的相关信息和拦截器调用信息为userDTO 3.更改me接口，return一个UserDTO信息 */ //登录时保存用户信息到session中 session.setAttribute(\u0026#34;user\u0026#34;, BeanUtil.copyProperties(user, UserDTO.class)); 集群的session共享问题 基于Redis实现共享session问题 1.Redis字段选择 设计key的要求\n唯一性 便携带 2.Redis实现验证码发送登录问题 3.Redis实现校验登录功能 4.代码实现 发送短信验证码\n@Resource private StringRedisTemplate stringRedisTemplate; @Override public Result sendcode(String phone, HttpSession session){ //1.校验手机号,utils的工具包 if(RegexUtils.isPhoneInvalid(phone)){ //2.如果不符合，返回错误信息 return Result.fail(\u0026#34;手机号格式错误！\u0026#34;); } //3.符合，生成验证码,一个java的工具包 String code = RandomUtil.randomNumbers(6); //4.保存验证码到redis stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY+phone,code,LOGIN_CODE_TTL, TimeUnit.MINUTES); //5.发送验证码,需要调用第三方的短信平台，比如说阿里云 log.debug(\u0026#34;发送短信验证码成功，验证码：{}\u0026#34;,code); //返回ok return Result.ok(code); } 短信验证码验证和登录\n@Override public Result login(LoginFormDTO loginForm, HttpSession session){ //1.校验手机号 String phone = loginForm.getPhone(); if(RegexUtils.isPhoneInvalid(phone)){ return Result.fail(\u0026#34;手机号格式错误！\u0026#34;); } //2.从redis中获取验证码并进行校验 String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY+phone); String code = loginForm.getCode(); if(cacheCode==null || !cacheCode.equals(code)){ //3.不一致报错 return Result.fail(\u0026#34;验证码错误\u0026#34;); } //4.一致，根据手机号查询用户,select * from tb_user where phone = ? User user = query().eq(\u0026#34;phone\u0026#34;, phone).one(); //5.判断用户是否存在 if(user==null){ //6.不存在，创建用户并保存,只需要填充phone和nickname字段即可 user = createUserWithPhone(phone); } //7.保存用户信息到redis //7.1随机生成token,作为登录令牌 String token = UUID.randomUUID().toString(); //7.2将user对象转为hash存储 UserDTO userDTO = BeanUtil.copyProperties(user,UserDTO.class); Map\u0026lt;String, Object\u0026gt; userMap = BeanUtil.beanToMap(userDTO,new HashMap\u0026lt;\u0026gt;(), //解决id字段是整型而不是字符串类型 CopyOptions.create().setIgnoreNullValue(true).setFieldValueEditor((fieldName,fieldValue)-\u0026gt;fieldValue.toString()) ); //7.3存储 String tokenKey = LOGIN_USER_KEY+token; stringRedisTemplate.opsForHash().putAll(tokenKey,userMap); //添加hash对象 stringRedisTemplate.expire(tokenKey,LOGIN_USER_TTL, TimeUnit.MINUTES); //8.返回token return Result.ok(token); 校验登录状态\n需要在MvcConfig中导入RedisTemplate 使用拦截器是为了解决redis像session一样只要有操作就会自动延长过期时间 private StringRedisTemplate stringRedisTemplate; public LoginInterceptor(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } //预拦截 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.获取请求头中的token String token = request.getHeader(\u0026#34;authorization\u0026#34;); if(StrUtil.isBlank(token)){ response.setStatus(401); return false; } //2.基于token获取redis中的用户 String key = RedisConstants.LOGIN_USER_KEY + token; Map\u0026lt;Object, Object\u0026gt; userMap = stringRedisTemplate.opsForHash().entries(key); //3.判断用户是否在存在 if(userMap.isEmpty()){ //4.不存在，返回401状态码 response.setStatus(401); return false; } //5.将查询到的hash数据转为UserDTO对象 UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap,new UserDTO(),false); //6.存在，保存用户信息到ThreadLocal UserHolder.saveUser(userDTO); //7.刷新token的有效期 stringRedisTemplate.expire(key,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES); //8.放行 return true; } /* 此时的MVCCONFIG需要更新 */ @Configuration public class MvcConfig implements WebMvcConfigurer { @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginInterceptor(stringRedisTemplate)) .excludePathPatterns( \u0026#34;/user/code\u0026#34; , \u0026#34;/user/login\u0026#34; , \u0026#34;/blog/hot\u0026#34; , \u0026#34;/shop/**\u0026#34; , \u0026#34;/shop-type/**\u0026#34; , \u0026#34;/upload/**\u0026#34; , \u0026#34;/voucher/**\u0026#34; ); } } 登录拦截器的优化\n如果用户访问的全都不是在拦截器的页面，token仍然会失效 //具体做法：拷贝一份新的RefreshTokenInterceptor，并重写一下LoginInterceptor @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.判断是否需要进行拦截（ThreadLocal中是否有用户） if(UserHolder.getUser() == null){ //没有，需要进行拦截 response.setStatus(401); //拦截 return false; } //有用户，进行放行操作 return true; } //需要更新一下MvcConfig @Configuration public class MvcConfig implements WebMvcConfigurer { @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( \u0026#34;/user/code\u0026#34; , \u0026#34;/user/login\u0026#34; , \u0026#34;/blog/hot\u0026#34; , \u0026#34;/shop/**\u0026#34; , \u0026#34;/shop-type/**\u0026#34; , \u0026#34;/upload/**\u0026#34; , \u0026#34;/voucher/**\u0026#34; ).order(1); registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(\u0026#34;/**\u0026#34;).order(0); } }\t2.商户查询缓存 什么是缓存 缓存的级别\n缓存的优缺点\n添加Redis缓存 1.添加商户查询缓存 代码实现\n@Service public class ShopServiceImpl extends ServiceImpl\u0026lt;ShopMapper, Shop\u0026gt; implements IShopService { @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result queryById(Long id) { String key = RedisConstants.CACHE_SHOP_KEY +id; //1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if(StrUtil.isNotBlank(shopJson)){ //3.存在，直接返回 Shop shop = JSONUtil.toBean(shopJson,Shop.class); return Result.ok(shop); } //4.不存在，根据id查询数据库 Shop shop = getById(id); //5.数据库不存在，返回错误 if(shop==null){ return Result.fail(\u0026#34;店铺不存在\u0026#34;); } //6.存在，将查询结果写入redis stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop)); //7.返回数据 return Result.ok(shop); } } 2.添加商铺类型查询业务 代码实现\n@Service public class ShopTypeServiceImpl extends ServiceImpl\u0026lt;ShopTypeMapper, ShopType\u0026gt; implements IShopTypeService { @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result queryTypeList() { String typeKey= RedisConstants.CACHE_TYPE_KEY; //1.从redis中查询 Long typeListSize = stringRedisTemplate.opsForList().size(typeKey); //2.redis存在数据 if (typeListSize!=null\u0026amp;\u0026amp;typeListSize!=0){ List\u0026lt;String\u0026gt; typeJsonList = stringRedisTemplate.opsForList().range(typeKey, 0, typeListSize-1); List\u0026lt;ShopType\u0026gt; typeList=new ArrayList\u0026lt;\u0026gt;(); for (String typeJson : typeJsonList) { typeList.add(JSONUtil.toBean(typeJson,ShopType.class)); } return Result.ok(typeList); } //3.redis不存在数据 查询数据库 List\u0026lt;ShopType\u0026gt; typeList = query().orderByAsc(\u0026#34;sort\u0026#34;).list(); //4.数据库中不存在相关数据 if (typeList==null){ //数据库不存在数据 return Result.fail(\u0026#34;发生错误\u0026#34;); } //转换 List\u0026lt;String\u0026gt; typeJsonList=new ArrayList\u0026lt;\u0026gt;(); for (ShopType shopType : typeList) { typeJsonList.add(JSONUtil.toJsonStr(shopType)); } //5.数据库存在数据 写入redis stringRedisTemplate.opsForList().rightPushAll(typeKey,typeJsonList); //6.返回数据 return Result.ok(typeList); } } 缓存更新策略 当数据库的数据发生修改时，需要及时更新redis中的值\n1.三种更新策略 2.主动更新策略 3.案例：实现商铺缓存和数据库的双写一致 需求\n代码实现\n@Override @Transactional public Result update(Shop shop) { Long id = shop.getId(); if(id==null){ return Result.fail(\u0026#34;店铺id不能为空\u0026#34;); } //1.更新数据库 updateById(shop); //2.删除缓存 stringRedisTemplate.delete(RedisConstants.CACHE_SHOP_KEY+shop.getId()); return Result.ok(); } 缓存穿透 问题详情\n缓存空对象*\npublic Shop queryWithPassThrough(Long id){ String key = RedisConstants.CACHE_SHOP_KEY +id; //1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if(StrUtil.isNotBlank(shopJson)){ //3.存在，直接返回 Shop shop = JSONUtil.toBean(shopJson,Shop.class); return Result.ok(shop); } //判断是否为空值，如果是“”，就不用返回数据库的查询了，如果是null,就需要进行数据库的查询（因为数据库没有查到会默认传一个“”，省略了查数据库的这一步） if(shopJson != null){ return Result.fail(\u0026#34;店铺信息不存在！\u0026#34;); } //4.不存在，根据id查询数据库 Shop shop = getById(id); //5.数据库不存在，返回错误 if(shop==null){ //将空值写入redis stringRedisTemplate.opsForValue().set(key,\u0026#34;\u0026#34;,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES); return Result.fail(\u0026#34;店铺不存在\u0026#34;); } //6.存在，将查询结果写入redis stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); //7.返回数据 return Result.ok(shop); } 缓存雪崩 缓存击穿 1.互斥锁 案例：\n解决办法:setnx\n代码实现\n@Override public Result queryById(Long id) { //缓存穿透 Shop shop = queryWithPassThrough(id); if(shop == null){ return Result.fail(\u0026#34;店铺查询失败\u0026#34;); } //返回数据 return Result.ok(shop); } //封装缓存穿透的代码——基于锁机制 public Shop queryWithPassThrough(Long id) { String key = RedisConstants.CACHE_SHOP_KEY +id; //1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在，isNotBlank方法会剔除掉null,\u0026#34;\u0026#34;的情况 if(StrUtil.isNotBlank(shopJson)){ //3.存在，直接返回 return JSONUtil.toBean(shopJson,Shop.class); } //4.实现缓存重建 //4.1 获取互斥锁 String lockKey = RedisConstants.LOCK_SHOP_KEY+id; Shop shop = null; try { boolean isLock = tryLock(lockKey); //4.2 判断是否获取成功 if(!isLock){ //4.3 获取失败，休眠 Thread.sleep(50); return queryWithPassThrough(id); //递归处理 } //4.4 成功，进行数据库的查询和缓存重建 shop = getById(id); //模拟重建的超时 Thread.sleep(200); //5.数据库不存在，返回错误 if(shop==null){ //将空值写入redis stringRedisTemplate.opsForValue().set(key,\u0026#34;\u0026#34;,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES); return null; } //6.存在，将查询结果写入redis stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); } catch (InterruptedException e) { throw new RuntimeException(e); }finally { //7.释放互斥锁 unlock(lockKey); } //8.返回数据 return shop; } //获取锁 private boolean tryLock(String key){ Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key,\u0026#34;1\u0026#34;,RedisConstants.LOCK_SHOP_TTL,TimeUnit.SECONDS); //如果flag的值为null，自动进行拆箱将包装类转换为基本数据类型时会抛出NullPointerException return BooleanUtil.isTrue(flag); } //删除锁 private boolean unlock(String key){ return stringRedisTemplate.delete(key); } 2.逻辑过期 案例\n代码实现\nprivate static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); //封装缓存穿透的代码——基于逻辑过期 public Shop queryWithLogicalExpire(Long id) { String key = RedisConstants.CACHE_SHOP_KEY +id; //1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if(StrUtil.isBlank(shopJson)){ //3.不存在，直接返回null return null; } //4.命中，需要把这个json对象反序列化 RedisData redisDate = JSONUtil.toBean(shopJson, RedisData.class); Shop shop = JSONUtil.toBean((JSONObject) redisDate.getData();, Shop.class); LocalDateTime expireTime = redisDate.getExpireTime(); //5，判断是否过期 if (expireTime.isAfter(LocalDateTime.now())) { //5.1 未过期，直接返回店铺信息 return shop; } //5.2 已过期，需要缓存重建 //6.缓存重建 //6.1 获取互斥锁 String localKey = RedisConstants.LOCK_SHOP_KEY + id; boolean isLock = tryLock(localKey); //6.2 判断是否获取锁成功 if(isLock){ //6.3 成功，开启独立线程，实现缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -\u0026gt; { try { //重建缓存 this.saveShopToRedis(id,20L); } catch (Exception e) { throw new RuntimeException(e); } finally { //释放锁 unlock(localKey); } }); } //6.4 返回过期的商铺信息 return shop; } public void saveShopToRedis(Long id,Long expireSeconds){ //1.查询店铺数据 Shop shop = getById(id); Thread.sleep(200); //2.封装逻辑过期时间 RedisData redisData = new RedisData(); redisData.setData(shop); redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds)); //3.写入Redis stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(redisData)); } 缓存封装工具 1.方法类型 2.代码封装 @Slf4j @Component public class CacheClient { private final StringRedisTemplate stringRedisTemplate; public CacheClient(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } public void set(String key, Object value, Long time, TimeUnit unit){ stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit); } public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit){ RedisData redisData = new RedisData(); redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time))); redisData.setData(value); stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData)); } public \u0026lt;R,ID\u0026gt; R queryWithPassThrough( String keyPrefix, ID id, Class\u0026lt;R\u0026gt; type, Function\u0026lt;ID,R\u0026gt; dbFallback, Long time, TimeUnit unit){ String key = keyPrefix +id; //1.从redis查询商铺缓存 String json = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if(StrUtil.isNotBlank(json)){ //3.存在，直接返回 return JSONUtil.toBean(json,type); } //判断是否为空值，如果是“”，就不用返回数据库的查询了，如果是null,就需要进行数据库的查询（因为数据库没有查到会默认传一个“”，省略了查数据库的这一步） if(json != null){ return null; } //4.不存在，根据id查询数据库 R r = dbFallback.apply(id); //5.数据库不存在，返回错误 if(r==null){ //将空值写入redis stringRedisTemplate.opsForValue().set(key,\u0026#34;\u0026#34;,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES); return null; } //6.存在，将查询结果写入redis this.stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(r),time,unit); //7.返回数据 return r; } private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); //封装缓存穿透的代码——基于逻辑过期 public \u0026lt;R,ID\u0026gt; R queryWithLogicalExpire( String prefix, ID id, Class\u0026lt;R\u0026gt; type, Function\u0026lt;ID,R\u0026gt; dbFallback, Long time, TimeUnit unit) { String key = prefix +id; //1.从redis查询商铺缓存 String json = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if(StrUtil.isBlank(json)){ //3.不存在，直接返回null return null; } //4.命中，需要把这个json对象反序列化 RedisData redisDate = JSONUtil.toBean(json, RedisData.class); R r = JSONUtil.toBean((JSONObject) redisDate.getData(), type); LocalDateTime expireTime = redisDate.getExpireTime(); //5，判断是否过期 if (expireTime.isAfter(LocalDateTime.now())) { //5.1 未过期，直接返回店铺信息 return r; } //5.2 已过期，需要缓存重建 //6.缓存重建 //6.1 获取互斥锁 String localKey = RedisConstants.LOCK_SHOP_KEY + id; boolean isLock = tryLock(localKey); //6.2 判断是否获取锁成功 if(isLock){ //6.3 成功，开启独立线程，实现缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -\u0026gt; { try { //查询数据库 R r1 = dbFallback.apply(id); //写入redis this.setWithLogicalExpire(key,r1,time,unit); } catch (Exception e) { throw new RuntimeException(e); } finally { //释放锁 unlock(localKey); } }); } //6.4 返回过期的商铺信息 return r; } //获取锁 private boolean tryLock(String key){ Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key,\u0026#34;1\u0026#34;,RedisConstants.LOCK_SHOP_TTL,TimeUnit.SECONDS); //如果flag的值为null，自动进行拆箱将包装类转换为基本数据类型时会抛出NullPointerException return BooleanUtil.isTrue(flag); } //删除锁 private boolean unlock(String key){ return stringRedisTemplate.delete(key); } } 3.实现样例 //缓存穿透 //Shop shop = cacheClient. //queryWithPassThrough(RedisConstants.CACHE_SHOP_KEY,id,Shop.class,this::getById, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES); //逻辑过期解决缓存击穿 Shop shop = cacheClient. queryWithLogicalExpire(RedisConstants.CACHE_SHOP_KEY,id,Shop.class,this::getById,20L,TimeUnit.SECONDS); 3.优惠券秒杀 全局唯一ID 1.问题来源 2.全局id生成器 3.代码实现 private static final long BEGIN_TIMESTAMP = 1735689600; //序列号位数 private static final int COUNT_BITS = 32; @Resource private StringRedisTemplate stringRedisTemplate; public long nextId(String keyPrefix){ //1.生成时间戳,当前时间-初始时间 LocalDateTime now = LocalDateTime.now(); long nowSecond = now.toEpochSecond(ZoneOffset.UTC); long timeStamp = nowSecond-BEGIN_TIMESTAMP; //2.生成序列号,为了防止序列号进行超标，所以引入了时间key String date = now.format(DateTimeFormatter.ofPattern(\u0026#34;yyyy:MM:dd\u0026#34;)); Long count = stringRedisTemplate.opsForValue().increment(\u0026#34;icr:\u0026#34; + keyPrefix + \u0026#34;:\u0026#34; + date); //3.借助位运算拼接并返回 return timeStamp \u0026lt;\u0026lt; COUNT_BITS | count; } 4.并发测试 @Test void testIdWorker() throws InterruptedException { // CountDownLatch：并发控制工具，这里初始计数为 300（对应 300 个并发任务） CountDownLatch latch = new CountDownLatch(300); // 定义一个并发任务 Runnable Runnable task = () -\u0026gt; { // 每个线程循环生成 100 个 ID for(int i=0;i\u0026lt;100;i++){ // 调用 RedisIdWorker 生成分布式唯一 ID，\u0026#34;order\u0026#34; 是业务前缀 long id = redisIdWorker.nextId(\u0026#34;order\u0026#34;); // 打印生成的 ID，方便观察是否有重复 System.out.println(\u0026#34;id = \u0026#34;+id); } //把 CountDownLatch 的计数器减 1 latch.countDown(); }; // 记录开始时间，用于统计生成 ID 的耗时 long begin = System.currentTimeMillis(); // 向线程池提交 300 个并发任务 for(int i=0;i\u0026lt;300;i++){ executorService.execute(task); } // 主线程阻塞，等待所有任务执行完成 latch.await(); // 记录结束时间 long end = System.currentTimeMillis(); // 输出从提交任务到当前时刻的耗时 System.out.println(\u0026#34;time:\u0026#34;+(end-begin)); } 实现优惠券秒杀下单 1.需求分析 2.添加优惠券(秒杀) 代码实现：\n@Override @Transactional public void addSeckillVoucher(Voucher voucher) { // 保存优惠券 save(voucher); // 保存秒杀信息 SeckillVoucher seckillVoucher = new SeckillVoucher(); seckillVoucher.setVoucherId(voucher.getId()); seckillVoucher.setStock(voucher.getStock()); seckillVoucher.setBeginTime(voucher.getBeginTime()); seckillVoucher.setEndTime(voucher.getEndTime()); seckillVoucherService.save(seckillVoucher); } post测试样例：http://localhost:8081/voucher/seckill\n{ \u0026#34;shopId\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;100元代金券\u0026#34;, \u0026#34;subTitle\u0026#34;: \u0026#34;新用户专享\u0026#34;, \u0026#34;rules\u0026#34;: \u0026#34;仅限堂食使用，不可叠加其他优惠\u0026#34;, \u0026#34;payValue\u0026#34;: 7000, \u0026#34;actualValue\u0026#34;: 10000, \u0026#34;type\u0026#34;: 1, \u0026#34;stock\u0026#34;: 100, \u0026#34;beginTime\u0026#34;: \u0026#34;2025-01-01T10:00:00\u0026#34;, \u0026#34;endTime\u0026#34;: \u0026#34;2030-01-07T23:59:59\u0026#34; } 3.秒杀下单 功能需求\n代码实现\n@Resource private ISeckillVoucherService seckillVoucherService; @Resource private RedisIdWorker redisIdWorker; @Override @Transactional public Result seckillVoucher(Long voucherId) { //1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); //2.判断秒杀是否开始 if(voucher.getBeginTime().isAfter(LocalDateTime.now())){ //尚未开始 return Result.fail(\u0026#34;秒杀尚未开始\u0026#34;); } //3.判断秒杀是否已经结束 if(voucher.getEndTime().isBefore(LocalDateTime.now())){ //已经结束 return Result.fail(\u0026#34;秒杀已经结束\u0026#34;); } //4.判断库存是否充足 if(voucher.getStock() \u0026lt; 1){ //库存不足 return Result.fail(\u0026#34;库存不足！\u0026#34;); } //5.扣减库存 boolean success = seckillVoucherService.update() .setSql(\u0026#34;stock = stock - 1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId).update(); if(!success){ return Result.fail(\u0026#34;库存不足！\u0026#34;); } //6.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); //6.1生成全局唯一的订单Id Long orderId = redisIdWorker.nextId(\u0026#34;order\u0026#34;); voucherOrder.setId(orderId); //6.2设置当前线程内的用户id voucherOrder.setUserId(UserHolder.getUser().getId()); //6.3设置代金券id voucherOrder.setVoucherId(voucherId); //6.4保存到数据库 save(voucherOrder); //7.返回订单 return Result.ok(orderId); } 超卖问题 1.问题来源 2.解决方案 3.乐观锁 版本号法\nCAS法\n4.代码实现 //5.扣减库存 boolean success = seckillVoucherService.update() .setSql(\u0026#34;stock = stock - 1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId).gt(\u0026#34;stock\u0026#34;,0).update(); 一人一单 1.解决方案 2.代码实现 pom.xml中添加依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 添加启动类\n@EnableAspectJAutoProxy(exposeProxy = true) 悲观锁解决一人一单\n@Override public Result seckillVoucher(Long voucherId) { //1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); //2.判断秒杀是否开始 if(voucher.getBeginTime().isAfter(LocalDateTime.now())){ //尚未开始 return Result.fail(\u0026#34;秒杀尚未开始\u0026#34;); } //3.判断秒杀是否已经结束 if(voucher.getEndTime().isBefore(LocalDateTime.now())){ //已经结束 return Result.fail(\u0026#34;秒杀已经结束\u0026#34;); } //4.判断库存是否充足 if(voucher.getStock() \u0026lt; 1){ //库存不足 return Result.fail(\u0026#34;库存不足！\u0026#34;); } Long userId = UserHolder.getUser().getId(); synchronized (userId.toString().intern()) { //获取代理对象，避免没提交到数据库就释放锁的安全问题 IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); } } @Transactional public Result createVoucherOrder(Long voucherId) { //5.一人一单 Long userId = UserHolder.getUser().getId(); //5.1查询订单 Long count = query().eq(\u0026#34;user_id\u0026#34;, userId).eq(\u0026#34;voucher_id\u0026#34;, voucherId).count(); //5.2判断是否存在 if(count \u0026gt; 0L){ //用户已经购买过了 return Result.fail(\u0026#34;用户已经购买过一次！\u0026#34;); } //6.扣减库存 boolean success = seckillVoucherService.update() .setSql(\u0026#34;stock = stock - 1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId).gt(\u0026#34;stock\u0026#34;,0).update(); if(!success){ return Result.fail(\u0026#34;库存不足！\u0026#34;); } //7.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); //7.1生成全局唯一的订单Id Long orderId = redisIdWorker.nextId(\u0026#34;order\u0026#34;); voucherOrder.setId(orderId); //7.2设置当前线程内的用户id voucherOrder.setUserId(UserHolder.getUser().getId()); //7.3设置代金券id voucherOrder.setVoucherId(voucherId); //7.4保存到数据库 save(voucherOrder); //8.返回订单 return Result.ok(orderId); } 分布式锁 1.集群模式下的并发安全问题（TODO） 添加集群\n配置反向代理\n重启nginx nginx.exe -s reload\n问题来源\n2.分布式锁原理 3.redis实现分布式锁 代码实现\npublic class SimpleRedisLock implements ILock{ private final String name; private final StringRedisTemplate stringRedisTemplate; public SimpleRedisLock(String name,StringRedisTemplate stringRedisTemplate){ this.name = name; this.stringRedisTemplate = stringRedisTemplate; } private static final String KEY_PREFIX = \u0026#34;lock:\u0026#34;; @Override public boolean tryLock(Long timeoutSec) { //获取线程标识 long threadId = Thread.currentThread().getId(); //获取锁 Boolean success = stringRedisTemplate.opsForValue(). setIfAbsent(KEY_PREFIX + name, threadId + \u0026#34;\u0026#34;, timeoutSec, TimeUnit.SECONDS); //防止拆箱为NULL return Boolean.TRUE.equals(success); } @Override public void unlock() { //释放锁 stringRedisTemplate.delete(KEY_PREFIX + name); } } 使用样例\n//创建锁对象 SimpleRedisLock lock = new SimpleRedisLock(\u0026#34;order:\u0026#34; + userId, stringRedisTemplate); //获取锁 boolean isLock = lock.tryLock(1200L); //判断锁是否获取成功 if(!isLock){ //获取锁失败或者重试 return Result.fail(\u0026#34;一个人不允许重复下单\u0026#34;); } try { //获取代理对象，避免没提交到数据库就释放锁的安全问题 IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); } catch (IllegalStateException e) { throw new RuntimeException(e); } finally { lock.unlock(); } 4.误删问题 问题来源：业务未完成超时释放锁 。导致线程2，3全都获取锁执行成功\n**解决办法：**判断获取锁的标识前后是否一致。\n代码实现\nprivate static final String KEY_PREFIX = \u0026#34;lock:\u0026#34;; private static final String ID_PREFIX = UUID.randomUUID().toString() + \u0026#39;-\u0026#39;; @Override public boolean tryLock(Long timeoutSec) { //获取线程标识 String threadId = ID_PREFIX+Thread.currentThread().getId(); //获取锁 Boolean success = stringRedisTemplate.opsForValue(). setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS); //防止拆箱为NULL return Boolean.TRUE.equals(success); } @Override public void unlock() { //获取线程标识 String threadId = ID_PREFIX + Thread.currentThread().getId(); //获取锁中的标识 String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name); if(threadId.equals(id)){ //释放锁 stringRedisTemplate.delete(KEY_PREFIX + name); } } 5.原子性问题 问题来源：判断锁标识和释放锁之间产生了阻塞问题，导致锁超时自动释放，导致线程2，3并发安全问题、导致于线程1，3的执行都成功\nLua语言\nLua语言的执行\nLua脚本:实现判断锁标识和释放锁的一致性\n-- 比较线程标识与锁中的线程标识是否一致 if(redis.call(\u0026#39;get\u0026#39;,KEYS[i]) == ARGV[i]) then -- 释放锁 del key return redis.call(\u0026#39;del\u0026#39;,KEYS[i]) end return 0 java调用这个lua脚本\nprivate static final DefaultRedisScript\u0026lt;Long\u0026gt; UNLOCK_SCRIPT; //初始化脚本 static { UNLOCK_SCRIPT = new DefaultRedisScript\u0026lt;\u0026gt;(); UNLOCK_SCRIPT.setLocation(new ClassPathResource(\u0026#34;unlock.lua\u0026#34;)); UNLOCK_SCRIPT.setResultType(Long.class); } @Override public void unlock() { //调用lua脚本 stringRedisTemplate.execute( UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX+name), ID_PREFIX+Thread.currentThread().getId() ); } 6.Redisson重构 问题来源\nRedis秒杀优化 Redis消息队列实现异步秒杀优化 4.达人探店 5.好友关注 6.附近商铺搜索 7.用户签到 8.UV统计 ","permalink":"http://localhost:1313/java-notes/hmdp/","summary":"黑马点评项目学习笔记，涵盖 Redis 缓存、分布式锁、消息队列等核心技术实践","title":"黑马点评项目笔记"},{"content":"第一题：线性回归梯度下降 题目： 对线性模型 $h_\\theta(x) = \\theta^\\top x$，给定训练集 $\\{(x^{(i)}, y^{(i)})\\}$，推导其向量形式的最小二乘损失梯度下降更新公式为：\n$$\\theta := \\theta + \\alpha \\sum_{i=1}^{n} (y^{(i)} - h_\\theta(x^{(i)})) x^{(i)}$$解：\n最小二乘损失函数为：\n$$J(\\theta) = \\frac{1}{2}\\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)})^2 = \\frac{1}{2}\\sum_{i=1}^{n}(\\theta^\\top x^{(i)} - y^{(i)})^2$$对 $\\theta$ 求梯度：\n$$\\begin{aligned} \\nabla_\\theta J(\\theta) \u0026= \\sum_{i=1}^{n}(\\theta^\\top x^{(i)} - y^{(i)}) \\cdot x^{(i)} \\\\ \u0026= \\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} \\end{aligned}$$梯度下降更新规则为 $\\theta := \\theta - \\alpha \\nabla_\\theta J(\\theta)$，因此：\n$$\\theta := \\theta - \\alpha \\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} = \\theta + \\alpha \\sum_{i=1}^{n}(y^{(i)} - h_\\theta(x^{(i)})) x^{(i)}$$ 第二题：交叉熵损失梯度 题目： Cross Entropy Loss 定义如下：\n$$l_{ce}((t_1,\\ldots,t_k),y) = -\\log\\left(\\frac{\\exp(t_y)}{\\sum_j \\exp(t_j)}\\right)$$令向量 $t = (t_1,t_2,\\ldots,t_k)$，推导 CEL 对任意 $t_i$ 求导为：\n$$\\frac{\\partial l_{ce}(t,y)}{\\partial t_i} = \\phi_i - \\mathbb{1}\\{y=i\\}$$解：\n记 $\\phi_i = \\frac{\\exp(t_i)}{\\sum_j \\exp(t_j)}$ 为 softmax 函数。\n首先简化损失函数：\n$$l_{ce}(t,y) = -\\log(\\phi_y) = -t_y + \\log\\left(\\sum_j \\exp(t_j)\\right)$$对 $t_i$ 求导：\n$$\\begin{aligned} \\frac{\\partial l_{ce}(t,y)}{\\partial t_i} \u0026= -\\frac{\\partial t_y}{\\partial t_i} + \\frac{\\partial}{\\partial t_i}\\log\\left(\\sum_j \\exp(t_j)\\right) \\\\ \u0026= -\\mathbb{1}\\{y=i\\} + \\frac{\\exp(t_i)}{\\sum_j \\exp(t_j)} \\\\ \u0026= \\phi_i - \\mathbb{1}\\{y=i\\} \\end{aligned}$$其中 $\\mathbb{1}\\{y=i\\}$ 是指示函数，当 $y=i$ 时为1，否则为0。\n第三题：高斯假设下的最大似然估计 题目： 证明在高斯差异假定下，对线性模型 $h_\\theta(x) = \\theta^\\top x$，最大化参数似然 $L(\\theta)$ 等价于最小化二乘损失 $\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2$。\n解：\n假设误差 $\\epsilon^{(i)} = y^{(i)} - \\theta^\\top x^{(i)}$ 服从独立同分布的高斯分布 $\\mathcal{N}(0, \\sigma^2)$，即：\n$$p(\\epsilon^{(i)}) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(\\epsilon^{(i)})^2}{2\\sigma^2}\\right)$$因此：\n$$p(y^{(i)} | x^{(i)}; \\theta) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right)$$似然函数为：\n$$\\begin{aligned} L(\\theta) \u0026= \\prod_{i=1}^{n} p(y^{(i)} | x^{(i)}; \\theta) \\\\ \u0026= \\prod_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right) \\end{aligned}$$对数似然为：\n$$\\begin{aligned} \\log L(\\theta) \u0026= \\sum_{i=1}^{n}\\left[\\log\\frac{1}{\\sqrt{2\\pi}\\sigma} - \\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right] \\\\ \u0026= n\\log\\frac{1}{\\sqrt{2\\pi}\\sigma} - \\frac{1}{2\\sigma^2}\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2 \\end{aligned}$$最大化 $\\log L(\\theta)$ 等价于最小化 $\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2$。\n第四题：Logistic回归的NLL损失 题目： 对Logistic回归模型 $h_\\theta(x) = g(\\theta^\\top x) = \\frac{1}{1+e^{-\\theta^\\top x}}$，推导其在单样本 $(x,y)$ 下的NLL（negative log likelihood）损失，以及损失对特定参数 $\\theta_j$ 的导数为 $(h_\\theta(x) - y)x_j$。\n提示：Logistic回归预测概率的统一形式为 $P(y|x;\\theta) = (h_\\theta(x))^y(1-h_\\theta(x))^{1-y}$\n解：\n根据提示，Logistic回归的概率模型为：\n$$P(y|x;\\theta) = (h_\\theta(x))^y(1-h_\\theta(x))^{1-y}$$其中 $y \\in \\{0,1\\}$，$h_\\theta(x) = g(\\theta^\\top x) = \\frac{1}{1+e^{-\\theta^\\top x}}$。\n对数似然为：\n$$\\log P(y|x;\\theta) = y\\log(h_\\theta(x)) + (1-y)\\log(1-h_\\theta(x))$$NLL损失为：\n$$\\text{NLL}(x,y;\\theta) = -\\log P(y|x;\\theta) = -y\\log(h_\\theta(x)) - (1-y)\\log(1-h_\\theta(x))$$对 $\\theta_j$ 求导。首先注意到：\n$$\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j} = h_\\theta(x)(1-h_\\theta(x)) \\cdot x_j$$这是因为 $g'(z) = g(z)(1-g(z))$。\n因此：\n$$\\begin{aligned} \\frac{\\partial \\text{NLL}}{\\partial \\theta_j} \u0026= -y\\frac{1}{h_\\theta(x)}\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j} - (1-y)\\frac{1}{1-h_\\theta(x)}\\left(-\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j}\\right) \\\\ \u0026= -y\\frac{1}{h_\\theta(x)} \\cdot h_\\theta(x)(1-h_\\theta(x))x_j + (1-y)\\frac{1}{1-h_\\theta(x)} \\cdot h_\\theta(x)(1-h_\\theta(x))x_j \\\\ \u0026= -y(1-h_\\theta(x))x_j + (1-y)h_\\theta(x)x_j \\\\ \u0026= (h_\\theta(x) - y)x_j \\end{aligned}$$ 第五题：Poisson分布的指数族形式 题目： 已知指数分布族定义如下：$p(y;\\eta) = b(y)\\exp(\\eta^\\top y - a(\\eta))$。推导Poisson分布的指数分布族形式，并构建Poisson分布对应的广义线性模型。其中，Poisson分布 $\\text{Pois}(\\lambda)$ 的概率密度函数如下：\n$$P(X=k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}$$解：\n将Poisson分布改写为指数族形式：\n$$\\begin{aligned} P(X=k) \u0026= \\frac{\\lambda^k e^{-\\lambda}}{k!} \\\\ \u0026= \\frac{1}{k!}\\exp(k\\log\\lambda - \\lambda) \\\\ \u0026= \\frac{1}{k!}\\exp(\\eta \\cdot k - e^\\eta) \\end{aligned}$$其中 $\\eta = \\log\\lambda$（自然参数），因此 $\\lambda = e^\\eta$。\n对应指数族形式：\n$b(y) = \\frac{1}{y!}$ $\\eta = \\log\\lambda$ $a(\\eta) = e^\\eta = \\lambda$ $y$ 的充分统计量就是 $y$ 本身 构建广义线性模型：\n假设 $y|x;\\theta \\sim \\text{Pois}(\\lambda)$ 自然参数 $\\eta = \\theta^\\top x$ 因为 $\\lambda = e^\\eta$，所以 $\\lambda = e^{\\theta^\\top x}$ 响应函数（期望）为：$h_\\theta(x) = \\mathbb{E}[y|x;\\theta] = \\lambda = e^{\\theta^\\top x}$ 这就是Poisson回归模型。\n第六题：Shapley值计算 题目： 计算以下3人团队的Shapley值 $\\phi_1$、$\\phi_2$、$\\phi_3$。\n给定：\n$C_{123} = 10000$，$C_0 = 0$ $C_{12} = 7500$，$C_{13} = 7500$，$C_{23} = 5000$ $C_1 = 5000$，$C_2 = 5000$，$C_3 = 0$ 解：\nShapley值的公式为：\n$$\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(|N|-|S|-1)!}{|N|!}[C(S \\cup \\{i\\}) - C(S)]$$对于3人团队，$|N| = 3$，计算每个玩家的边际贡献：\n玩家1的Shapley值：\n$$\\begin{aligned} \\phi_1 \u0026= \\frac{0!2!}{3!}[C_1 - C_0] + \\frac{1!1!}{3!}[C_{12} - C_2] + \\frac{1!1!}{3!}[C_{13} - C_3] + \\frac{2!0!}{3!}[C_{123} - C_{23}] \\\\ \u0026= \\frac{1}{3}[5000 - 0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[7500 - 0] + \\frac{1}{3}[10000 - 5000] \\\\ \u0026= \\frac{5000}{3} + \\frac{2500}{6} + \\frac{7500}{6} + \\frac{5000}{3} \\\\ \u0026= \\frac{10000}{3} + \\frac{10000}{6} = \\frac{20000 + 10000}{6} = 5000 \\end{aligned}$$玩家2的Shapley值：\n$$\\begin{aligned} \\phi_2 \u0026= \\frac{0!2!}{3!}[C_2 - C_0] + \\frac{1!1!}{3!}[C_{12} - C_1] + \\frac{1!1!}{3!}[C_{23} - C_3] + \\frac{2!0!}{3!}[C_{123} - C_{13}] \\\\ \u0026= \\frac{1}{3}[5000 - 0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[5000 - 0] + \\frac{1}{3}[10000 - 7500] \\\\ \u0026= \\frac{5000}{3} + \\frac{2500}{6} + \\frac{5000}{6} + \\frac{2500}{3} \\\\ \u0026= \\frac{10000 + 2500 + 5000 + 5000}{6} = \\frac{22500}{6} =3750 \\end{aligned}$$玩家3的Shapley值：\n由对称性或直接计算：\n$$\\phi_3 = 10000 - \\phi_1 - \\phi_2 = 10000 - 5000 - 4583.33 = 416.67$$或直接计算：\n$$\\begin{aligned} \\phi_3 \u0026= \\frac{1}{3}[0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[5000 - 5000] + \\frac{1}{3}[10000 - 7500] \\\\ \u0026= 0 + \\frac{2500}{6} + 0 + \\frac{2500}{3} = \\frac{7500}{6} =1250 \\end{aligned}$$答案： $\\phi_1 = 5000$，$\\phi_2 = 3750$，$\\phi_3 $=1250\n第七题：协方差矩阵性质 题目： 基于协方差矩阵定义 $\\Sigma = \\text{Cov}(X)$ 证明：\n$\\Sigma$ 为对称矩阵； $\\Sigma$ 半正定，记 $\\Sigma \\geq 0$，即对任意向量 $z \\in \\mathbb{R}^d$ 有 $z^\\top \\Sigma z \\geq 0$。 解：\n设 $X \\in \\mathbb{R}^d$ 为随机向量，$\\mu = \\mathbb{E}[X]$，则：\n$$\\Sigma = \\text{Cov}(X) = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top]$$(1) 证明 $\\Sigma$ 为对称矩阵：\n$$\\Sigma^\\top = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top]^\\top = \\mathbb{E}[((X-\\mu)(X-\\mu)^\\top)^\\top] = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top] = \\Sigma$$因此 $\\Sigma$ 是对称矩阵。\n(2) 证明 $\\Sigma$ 半正定：\n对任意 $z \\in \\mathbb{R}^d$：\n$$\\begin{aligned} z^\\top \\Sigma z \u0026= z^\\top \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top] z \\\\ \u0026= \\mathbb{E}[z^\\top(X-\\mu)(X-\\mu)^\\top z] \\\\ \u0026= \\mathbb{E}[(z^\\top(X-\\mu))^2] \\\\ \u0026\\geq 0 \\end{aligned}$$最后一步是因为期望中的项是平方项，必然非负。因此 $\\Sigma$ 半正定。\n第八题：高斯判别分析的MLE 题目： 对高斯判别分析，已知各变量概率分布为：\n$$\\begin{aligned} p(y) \u0026= \\phi^y(1-\\phi)^{1-y} \\\\ p(x|y=0) \u0026= \\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}\\exp\\left(-\\frac{1}{2}(x-\\mu_0)^\\top\\Sigma^{-1}(x-\\mu_0)\\right) \\\\ p(x|y=1) \u0026= \\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}\\exp\\left(-\\frac{1}{2}(x-\\mu_1)^\\top\\Sigma^{-1}(x-\\mu_1)\\right) \\end{aligned}$$证明在极大似然估计下，参数 $\\phi$、$\\mu_0$、$\\mu_1$ 的形式为：\n$$\\begin{aligned} \\phi \u0026= \\frac{1}{n}\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\} \\\\ \\mu_0 \u0026= \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}} \\\\ \\mu_1 \u0026= \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}} \\end{aligned}$$解：\n对数似然函数为：\n$$\\log L = \\sum_{i=1}^{n}\\left[\\log p(y^{(i)}) + \\log p(x^{(i)}|y^{(i)})\\right]$$估计 $\\phi$：\n$$\\log L_\\phi = \\sum_{i=1}^{n}\\log p(y^{(i)}) = \\sum_{i=1}^{n}[y^{(i)}\\log\\phi + (1-y^{(i)})\\log(1-\\phi)]$$令 $\\frac{\\partial \\log L_\\phi}{\\partial \\phi} = 0$：\n$$\\sum_{i=1}^{n}\\left[\\frac{y^{(i)}}{\\phi} - \\frac{1-y^{(i)}}{1-\\phi}\\right] = 0$$解得：\n$$\\phi = \\frac{1}{n}\\sum_{i=1}^{n}y^{(i)} = \\frac{1}{n}\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}$$估计 $\\mu_0$：\n只考虑 $y=0$ 的样本：\n$$\\log L_{\\mu_0} = \\sum_{i:y^{(i)}=0}\\left[-\\frac{1}{2}(x^{(i)}-\\mu_0)^\\top\\Sigma^{-1}(x^{(i)}-\\mu_0) + \\text{const}\\right]$$令 $\\frac{\\partial \\log L_{\\mu_0}}{\\partial \\mu_0} = 0$：\n$$\\sum_{i:y^{(i)}=0}\\Sigma^{-1}(x^{(i)}-\\mu_0) = 0$$解得：\n$$\\mu_0 = \\frac{\\sum_{i:y^{(i)}=0}x^{(i)}}{\\sum_{i:y^{(i)}=0}1} = \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}}$$同理可得 $\\mu_1$ 的估计。\n第九题：GDA可转化为Logistic回归 题目： 证明GDA可转化为Logistic回归。提示：\n$p(y=1|x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=1)p(y=1) + p(x|y=0)p(y=0)}$ 可记 $r(x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)}$ 给出 $p(x|y=0)$, $p(x|y=1)$, $p(y=1)$ 的表达式 解：\n根据贝叶斯定理：\n$$p(y=1|x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=1)p(y=1) + p(x|y=0)p(y=0)} = \\frac{1}{1 + \\frac{p(x|y=0)p(y=0)}{p(x|y=1)p(y=1)}} = \\frac{1}{1 + \\frac{1}{r(x)}}$$其中：\n$$r(x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)}$$计算 $\\log r(x)$：\n$$\\begin{aligned} \\log r(x) \u0026= \\log p(x|y=1) + \\log p(y=1) - \\log p(x|y=0) - \\log p(y=0) \\\\ \u0026= -\\frac{1}{2}(x-\\mu_1)^\\top\\Sigma^{-1}(x-\\mu_1) + \\frac{1}{2}(x-\\mu_0)^\\top\\Sigma^{-1}(x-\\mu_0) + \\log\\frac{\\phi}{1-\\phi} \\end{aligned}$$展开：\n$$\\begin{aligned} \\log r(x) \u0026= -\\frac{1}{2}x^\\top\\Sigma^{-1}x + x^\\top\\Sigma^{-1}\\mu_1 - \\frac{1}{2}\\mu_1^\\top\\Sigma^{-1}\\mu_1 \\\\ \u0026\\quad + \\frac{1}{2}x^\\top\\Sigma^{-1}x - x^\\top\\Sigma^{-1}\\mu_0 + \\frac{1}{2}\\mu_0^\\top\\Sigma^{-1}\\mu_0 + \\log\\frac{\\phi}{1-\\phi} \\\\ \u0026= x^\\top\\Sigma^{-1}(\\mu_1 - \\mu_0) + \\frac{1}{2}(\\mu_0^\\top\\Sigma^{-1}\\mu_0 - \\mu_1^\\top\\Sigma^{-1}\\mu_1) + \\log\\frac{\\phi}{1-\\phi} \\\\ \u0026= \\theta^\\top x + \\theta_0 \\end{aligned}$$其中：\n$$\\theta = \\Sigma^{-1}(\\mu_1 - \\mu_0), \\quad \\theta_0 = \\frac{1}{2}(\\mu_0^\\top\\Sigma^{-1}\\mu_0 - \\mu_1^\\top\\Sigma^{-1}\\mu_1) + \\log\\frac{\\phi}{1-\\phi}$$因此：\n$$p(y=1|x) = \\frac{1}{1+e^{-\\theta^\\top x - \\theta_0}} = \\frac{1}{1+e^{-\\tilde{\\theta}^\\top \\tilde{x}}}$$这正是Logistic回归的形式（其中 $\\tilde{x}$ 包含截距项）。\n第十题：Kernel Method分析 题目： Kernel method中，若Kernel function $K(x,z) = (x^\\top z + c)^2$，推导对应的feature mapping $\\phi$，并讨论对于 $n$ 个样本一轮SGD，使用Kernel method和在feature map上的计算效率优化比。\n提示：\n基于feature map的参数更新方法为：$\\theta := \\theta + \\alpha\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top\\phi(x^{(i)}))\\phi(x^{(i)})$ Kernel method的参数更新方法为：$\\theta := \\theta + \\alpha(\\tilde{y} - K\\theta)$，其中 $K_j = K(x^{(i)}, x^{(j)})$ 解：\n推导feature mapping：\n对于 $x,z \\in \\mathbb{R}^d$，展开核函数：\n$$\\begin{aligned} K(x,z) \u0026= (x^\\top z + c)^2 \\\\ \u0026= (x_1z_1 + x_2z_2 + \\cdots + x_dz_d + c)^2 \\\\ \u0026= \\sum_{i=1}^{d}x_i^2z_i^2 + \\sum_{i \\neq j}2x_ix_jz_iz_j + 2c\\sum_{i=1}^{d}x_iz_i + c^2 \\end{aligned}$$因此，feature mapping为：\n$$\\phi(x) = (x_1^2, x_2^2, \\ldots, x_d^2, \\sqrt{2}x_1x_2, \\sqrt{2}x_1x_3, \\ldots, \\sqrt{2}x_{d-1}x_d, \\sqrt{2c}x_1, \\ldots, \\sqrt{2c}x_d, c)$$维度为：$d + \\binom{d}{2} + d + 1 = d + \\frac{d(d-1)}{2} + d + 1 = \\frac{d(d+3)}{2} + 1 = O(d^2)$\n计算效率比较：\nFeature map方法： 计算 $\\phi(x^{(i)})$：$O(d^2)$ 每个样本 内积 $\\theta^\\top\\phi(x^{(i)})$：$O(d^2)$ 更新 $\\theta$：$O(d^2)$ 总计：$O(nd^2)$ 每轮SGD Kernel method： 计算核矩阵 $K$：$O(n^2d)$（一次性预计算） 更新参数：$O(n^2)$（矩阵向量乘法） 总计：$O(n^2d + n^2) = O(n^2d)$ 每轮 效率比：\n$$\\frac{\\text{Feature map}}{\\text{Kernel method}} = \\frac{O(nd^2)}{O(n^2d)} = \\frac{d}{n}$$ 当 $n \\ll d$ 时（样本少，特征多），Kernel method更高效 当 $n \\gg d$ 时（样本多，特征少），Feature map方法更高效 第十一题：超平面的函数间隔和几何间隔 题目： 对超平面 $w^\\top x + b = 0$，样本 $x^{(i)}$ 到的函数间隔 $\\hat{\\gamma}^{(i)}$ 与几何间隔 $\\gamma^{(i)}$ 满足何关系？直接给出答案即可。\n解：\n函数间隔定义为：\n$$\\hat{\\gamma}^{(i)} = y^{(i)}(w^\\top x^{(i)} + b)$$几何间隔定义为：\n$\\gamma^{(i)} = \\frac{y^{(i)}(w^\\top x^{(i)} + b)}{|w|} = \\frac{\\hat{\\gamma}^{(i)}}{|w|}$\n关系：\n$\\gamma^{(i)} = \\frac{\\hat{\\gamma}^{(i)}}{|w|}$\n几何间隔是函数间隔除以权重向量的范数，表示点到超平面的真实距离。\n第十二题：SVM的Lagrange函数和对偶形式 题目： 已知SVM的优化目标为：\n$$ \\min_{w,b} \\quad \\frac{1}{2}\\|w\\|^2 \\qquad (1) $$$$ \\text{s.t.} \\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1, \\quad i=1,\\ldots,n $$请构造其Lagrange函数 $\\mathcal{L}(w,b,\\alpha)$。\n已知 $\\mathcal{L}(w,b,\\alpha)$ 满足Slater条件，因此强对偶成立，问题(1)最终可转化为 $\\max_{\\alpha;\\alpha_i\\geq 0}\\min_w \\mathcal{L}(w,b,\\alpha)$，证明该对偶形式问题可进一步转化为：\n$$ \\max_\\alpha W(\\alpha) = \\max_\\alpha \\left(\\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle\\right) \\qquad (2) $$约束条件：\n$$ \\alpha_i \\geq 0, \\quad i=1,\\ldots,n $$$$ \\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0 $$解：\n步骤1：构造Lagrange函数\n$\\mathcal{L}(w,b,\\alpha) = \\frac{1}{2}\\|w\\|^2 - \\sum_{i=1}^{n}\\alpha_i[y^{(i)}(w^\\top x^{(i)} + b) - 1]$\n其中 $\\alpha_i \\geq 0$ 为Lagrange乘子。\n步骤2：固定 $\\alpha$，对 $w$ 求导\n$\\frac{\\partial \\mathcal{L}}{\\partial w} = w - \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)} = 0$\n因此：\n$w = \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}$\n步骤3：固定 $\\alpha$，对 $b$ 求导\n$\\frac{\\partial \\mathcal{L}}{\\partial b} = -\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$\n因此：\n$\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$\n步骤4：代入Lagrange函数\n将 $w = \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}$ 代入 $\\mathcal{L}$：\n$\\begin{aligned} \\mathcal{L}(w,b,\\alpha) \u0026= \\frac{1}{2}w^\\top w - \\sum_{i=1}^{n}\\alpha_i y^{(i)} w^\\top x^{(i)} - b\\sum_{i=1}^{n}\\alpha_i y^{(i)} + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\frac{1}{2}\\left(\\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}\\right)^\\top\\left(\\sum_{j=1}^{n}\\alpha_j y^{(j)} x^{(j)}\\right) - \\sum_{i=1}^{n}\\alpha_i y^{(i)} \\left(\\sum_{j=1}^{n}\\alpha_j y^{(j)} x^{(j)}\\right)^\\top x^{(i)} + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle - \\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle \\end{aligned}$\n其中使用了 $\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$，所以 $b$ 项消失。\n因此对偶问题为：\n$\\max_\\alpha W(\\alpha) = \\max_\\alpha \\left(\\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle\\right)$\n约束条件为：\n$\\begin{aligned} \\alpha_i \u0026\\geq 0, \\quad i=1,\\ldots,n \\\\ \\sum_{i=1}^{n}\\alpha_i y^{(i)} \u0026= 0 \\end{aligned}$\n第十三题：线性不可分的SVM与L1正则 题目： 对线性不可分的训练集，SVM对应带L1正则的优化目标是什么？已知对线性可分情况的优化为：\n$$ \\min_{w,b} \\quad \\frac{1}{2}\\|w\\|^2 \\qquad (1) $$ $$ \\text{s.t.} \\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1, \\quad i=1,\\ldots,n $$解：\n对于线性不可分的情况，引入松弛变量 $\\xi_i \\geq 0$，允许某些样本违反间隔约束。\n带L1正则的软间隔SVM优化目标为：\n$\\begin{aligned} \\min_{w,b,\\xi} \u0026\\quad \\frac{1}{2}|w|^2 + C\\sum_{i=1}^{n}\\xi_i \\\\ \\text{s.t.} \u0026\\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1 - \\xi_i, \\quad i=1,\\ldots,n \\\\ \u0026\\quad \\xi_i \\geq 0, \\quad i=1,\\ldots,n \\end{aligned}$\n其中：\n$\\xi_i$ 是松弛变量，表示样本 $i$ 违反间隔的程度 $C \u003e 0$ 是惩罚参数，控制间隔最大化与违反程度之间的权衡 $C\\sum_{i=1}^{n}\\xi_i$ 是L1正则项（对松弛变量的惩罚） 这个目标函数平衡了两个目标：\n最大化间隔（通过最小化 $|w|^2$） 最小化分类错误（通过最小化 $\\sum\\xi_i$） 第十四题：SVM最优化问题分析 题目： 已知SVM的最终优化目标为：\n$W(\\alpha) = \\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle$\n假设此时正在优化 $\\alpha_1$ 与 $\\alpha_2$，并有 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$。请推导此时 $\\alpha_2$ 应当更新的值。\n解：\n简化目标函数：\n在固定其他 $\\alpha_i$ ($i \\geq 3$) 的情况下，目标函数关于 $\\alpha_1, \\alpha_2$ 可写为：\n$W(\\alpha_1, \\alpha_2) = \\alpha_1 + \\alpha_2 + W_0 - \\frac{1}{2}[K_{11}\\alpha_1^2 + K_{22}\\alpha_2^2 + 2K_{12}\\alpha_1\\alpha_2y^{(1)}y^{(2)}] + \\text{线性项}$\n其中 $K_{ij} = \\langle x^{(i)}, x^{(j)}\\rangle$，$W_0$ 是常数项。\n利用约束 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$：\n这个约束来自 $\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$，可以改写为：\n$\\alpha_1 y^{(1)} + \\alpha_2 y^{(2)} = -\\sum_{i=3}^{n}\\alpha_i y^{(i)} = \\zeta \\quad \\text{（常数）}$\n将 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$ 代入目标函数，得到关于 $\\alpha_2$ 的单变量优化问题。\n对 $\\alpha_2$ 求导并令其为0，经过复杂推导（涉及预测误差），得到 $\\alpha_2$ 的无约束最优解：\n$\\alpha_2^{\\text{new, unc}} = \\alpha_2^{\\text{old}} + \\frac{y^{(2)}(E_1 - E_2)}{\\eta}$\n其中：\n$E_i = f(x^{(i)}) - y^{(i)}$ 是预测误差 $\\eta = K_{11} + K_{22} - 2K_{12} = \\|x^{(1)} - x^{(2)}\\|^2$（特征空间距离） 考虑约束 $0 \\leq \\alpha_2 \\leq C$：\n根据约束 $\\alpha_1 y^{(1)} + \\alpha_2 y^{(2)} = \\zeta$：\n若 $y^{(1)} \\neq y^{(2)}$： $L = \\max(0, \\alpha_2^{\\text{old}} - \\alpha_1^{\\text{old}}), \\quad H = \\min(C, C + \\alpha_2^{\\text{old}} - \\alpha_1^{\\text{old}})$ 若 $y^{(1)} = y^{(2)}$： $L = \\max(0, \\alpha_1^{\\text{old}} + \\alpha_2^{\\text{old}} - C), \\quad H = \\min(C, \\alpha_1^{\\text{old}} + \\alpha_2^{\\text{old}})$ 最终更新公式：\n$\\alpha_2^{\\text{new}} = \\begin{cases} H \u0026 \\text{if } \\alpha_2^{\\text{new, unc}} \u003e H \\\\ \\alpha_2^{\\text{new, unc}} \u0026 \\text{if } L \\leq \\alpha_2^{\\text{new, unc}} \\leq H \\\\ L \u0026 \\text{if } \\alpha_2^{\\text{new, unc}} \u003c L \\end{cases}$\n然后通过约束更新 $\\alpha_1$：\n$\\alpha_1^{\\text{new}} = \\alpha_1^{\\text{old}} + y^{(1)}y^{(2)}(\\alpha_2^{\\text{old}} - \\alpha_2^{\\text{new}})$\n第十五题：信息增益比计算 题目： 计算给定数据集中四个特征的信息增益比。可保留log项，统一底数为2。\n解：\n首先计算数据集的熵。类别分布：否=6，是=9，总计15。\n$H(D) = -\\frac{6}{15}\\log_2\\frac{6}{15} - \\frac{9}{15}\\log_2\\frac{9}{15} = -0.4\\log_2(0.4) - 0.6\\log_2(0.6) = 0.971$\n特征1：年龄 青年(5个)：否=3，是=2，$H = 0.971$ 中年(5个)：否=1，是=4，$H = 0.722$ 老年(5个)：否=2，是=3，$H = 0.971$ 条件熵：\n$H(D|\\text{年龄}) = \\frac{5}{15}(0.971) + \\frac{5}{15}(0.722) + \\frac{5}{15}(0.971) = 0.888$\n信息增益：\n$\\text{Gain}(\\text{年龄}) = 0.971 - 0.888 = 0.083$\n特征熵（分裂信息）：\n$H_A(\\text{年龄}) = -3 \\times \\frac{5}{15}\\log_2\\frac{5}{15} = \\log_2 3 = 1.585$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{年龄}) = \\frac{0.083}{1.585} = 0.052 $$特征2：有工作 否(8个)：否=4，是=4，$H = 1.0$ 是(7个)：否=2，是=5，$H = 0.863$ 条件熵：$H(D|\\text{有工作}) = 0.936$\n信息增益：$\\text{Gain}(\\text{有工作}) = 0.035$\n特征熵：$H_A(\\text{有工作}) = 0.997$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{有工作}) = 0.035 $$特征3：有自己的房子 否(9个)：否=3，是=6，$H = 0.918$ 是(6个)：否=3，是=3，$H = 1.0$ 条件熵：$H(D|\\text{有房}) = 0.951$\n信息增益：$\\text{Gain}(\\text{有房}) = 0.020$\n特征熵：$H_A(\\text{有房}) = 0.971$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{有房}) = 0.021 $$特征4：信贷情况 一般(5个)：否=4，是=1，$H = 0.722$ 好(6个)：否=2，是=4，$H = 0.918$ 非常好(4个)：否=0，是=4，$H = 0$ 条件熵：$H(D|\\text{信贷}) = 0.608$\n信息增益：$\\text{Gain}(\\text{信贷}) = 0.363$\n特征熵：$H_A(\\text{信贷}) = 1.557$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{信贷}) = 0.233 $$总结（信息增益比排序） 信贷情况：0.233 ⭐（最佳分裂特征） 年龄：0.052 有工作：0.035 有自己的房子：0.021 应选择\u0026quot;信贷情况\u0026quot;作为根节点的分裂特征。\n第十六题：XGBoost损失函数二阶泰勒展开 题目： 已知XGBoost优化第t棵树时的损失函数为：\n$\\mathcal{L}^{(t)} = \\sum_{i=1}^{n}l(y_i, \\hat{y}*i^{(t-1)} + f_t(x_i)) + \\gamma T + \\frac{1}{2}\\lambda\\sum*{j=1}^{T}w_j^2$\n请推导 $l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i))$ 在 $l(y_i, \\hat{y}_i^{(t-1)})$ 处对于 $f_t(x_i)$ 的二阶泰勒展开。其中，一阶和二阶导数可使用：\n$g_i = \\frac{\\partial l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i}\\Big|*{\\hat{y}_i^{(t-1)}}, \\quad h_i = \\frac{\\partial^2 l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i^2}\\Big|*{\\hat{y}_i^{(t-1)}}$\n在此基础上，推导叶子节点 $j$ 对应的 $w_j^*$ 满足：\n$w_j^* = -\\frac{\\sum_{i \\in \\mathcal{I}*j}g_i}{\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda}$\n其中，$\\mathcal{I}_j = \\{i \\mid q(x_i) = j\\}$ 表示属于叶子节点 $j$ 的样本集合。\n解：\n二阶泰勒展开 在 $\\hat{y}_i^{(t-1)}$ 处对 $l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i))$ 关于 $f_t(x_i)$ 进行二阶泰勒展开：\n$\\begin{aligned} l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i)) \u0026\\approx l(y_i, \\hat{y}_i^{(t-1)}) + \\frac{\\partial l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i}\\Big|*{\\hat{y}_i^{(t-1)}} \\cdot f_t(x_i) \\\\ \u0026\\quad + \\frac{1}{2}\\frac{\\partial^2 l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i^2}\\Big|*{\\hat{y}_i^{(t-1)}} \\cdot f_t(x_i)^2 \\\\ \u0026= l(y_i, \\hat{y}_i^{(t-1)}) + g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2 \\end{aligned}$\n因此损失函数变为：\n$\\mathcal{L}^{(t)} \\approx \\sum_{i=1}^{n}[l(y_i, \\hat{y}*i^{(t-1)}) + g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2] + \\gamma T + \\frac{1}{2}\\lambda\\sum*{j=1}^{T}w_j^2$\n去掉常数项 $\\sum_{i=1}^{n}l(y_i, \\hat{y}_i^{(t-1)})$：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{i=1}^{n}[g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2] + \\gamma T + \\frac{1}{2}\\lambda\\sum_{j=1}^{T}w_j^2$\n推导叶子权重 $w_j^*$ 对于树模型，$f_t(x_i) = w_{q(x_i)}$，其中 $q(x_i)$ 表示样本 $i$ 落在的叶子节点。\n将样本按叶子节点分组：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{j=1}^{T}\\left[\\left(\\sum_{i \\in \\mathcal{I}*j}g_i\\right)w_j + \\frac{1}{2}\\left(\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda\\right)w_j^2\\right] + \\gamma T$\n记 $G_j = \\sum_{i \\in \\mathcal{I}*j}g_i$，$H_j = \\sum*{i \\in \\mathcal{I}_j}h_i$，则：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{j=1}^{T}\\left[G_j w_j + \\frac{1}{2}(H_j + \\lambda)w_j^2\\right] + \\gamma T$\n对 $w_j$ 求导并令其为0：\n$\\frac{\\partial \\tilde{\\mathcal{L}}^{(t)}}{\\partial w_j} = G_j + (H_j + \\lambda)w_j = 0$\n解得：\n$w_j^* = -\\frac{G_j}{H_j + \\lambda} = -\\frac{\\sum_{i \\in \\mathcal{I}*j}g_i}{\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda}$\n这就是叶子节点的最优权重。将其代入损失函数，得到：\n$\\tilde{\\mathcal{L}}^{(t)} = -\\frac{1}{2}\\sum_{j=1}^{T}\\frac{G_j^2}{H_j + \\lambda} + \\gamma T$\n这个公式用于评估树结构的质量，指导分裂决策。\n第十七题 KV Cache 计算 题目： 假设我们要在一台服务器上对一个采用多头注意力（MHA）的 Transformer 模型进行推理。模型参数如下：隐藏层维度 $d = 4096$，层数 $L = 32$，注意力头数 $h = 32$，采用 FP16 半精度存储（每个元素占 2 Bytes）。\n请给出生成第 $N$ 个 token 时，KV Cache 新增存储占用的计算公式。 当 Batch Size $B = 1$，序列长度达到 $N = 1024$ 时，请计算该请求在显存中占用的 KV Cache 总量（单位：MB）。 解：\n1. KV Cache 新增存储计算公式 生成第 $N$ 个 token 时，每一层需要存储该 token 的 Key 和 Value 向量。\n每个 token 的 K 和 V 向量维度均为 $d$ 总层数为 $L$ 每个元素占 2 Bytes（FP16） 因此，生成第 $N$ 个 token 时，KV Cache 新增存储占用为：\n$$\\text{新增存储} = 2 \\times L \\times d \\times 2 \\text{ Bytes} = 4Ld \\text{ Bytes}$$其中第一个 2 表示 K 和 V 两部分。\n2. 序列长度 N=1024 时的总 KV Cache 当序列长度为 $N = 1024$，Batch Size $B = 1$ 时：\n$$\\begin{aligned} \\text{总存储} \u0026= B \\times N \\times 2 \\times L \\times d \\times 2 \\text{ Bytes} \\\\\u0026= 1 \\times 1024 \\times 2 \\times 32 \\times 4096 \\times 2 \\text{ Bytes} \\\\\u0026= 1024 \\times 2 \\times 32 \\times 4096 \\times 2 \\text{ Bytes} \\\\\u0026= 536{,}870{,}912 \\text{ Bytes} \\\\ \u0026= 512 \\text{ MB} \\end{aligned}$$ 第十八题 RoPE 旋转位置编码 题目： 对于位置 $m$ 的查询向量 $q_m$ 和位置 $n$ 的键向量 $k_n$：\n证明旋转位置编码（RoPE）下变换后的向量 $\\tilde{q}_m$ 和 $\\tilde{k}_n$ 的点积仅和 $q_m$、$k_n$ 及相对位置 $m - n$ 相关； 进一步说明 RoPE 会对 q/k/v 向量中的哪几个进行位置信息注入。 提示： RoPE 通过旋转矩阵 $R_{pos}$ 将位置信息注入向量。\n解：\n1. 证明点积仅与相对位置相关 RoPE 通过旋转矩阵将位置信息编码。对于二维情况，旋转矩阵为：\n$$R_\\theta = \\begin{pmatrix} \\cos\\theta \u0026 -\\sin\\theta \\ \\sin\\theta \u0026 \\cos\\theta \\end{pmatrix}$$对于位置 $m$ 和 $n$，变换后的向量为：\n$$\\tilde{q}*m = R*{m\\theta} q_m, \\quad \\tilde{k}*n = R*{n\\theta} k_n$$它们的点积为： $$ \\begin{aligned} \\tilde{q}_m^\\top \\tilde{k}_n \u0026= (R_{m\\theta} q_m)^\\top (R_{n\\theta} k_n) \\\\ \u0026= q_m^\\top R_{m\\theta}^\\top R_{n\\theta} k_n \\\\ \u0026= q_m^\\top R_{(n-m)\\theta} k_n \\end{aligned} $$ 由于旋转矩阵满足 $R_\\alpha^\\top R_\\beta = R_{\\beta - \\alpha}$，因此点积仅依赖于相对位置 $m - n$。\n更高维度的情况下，RoPE 将向量分成多个二维子空间，每个子空间独立应用旋转，结论同样成立。\n2. RoPE 对哪些向量注入位置信息 RoPE 仅对 Query (q) 和 Key (k) 向量注入位置信息，不对 Value (v) 向量进行位置编码。\n原因是注意力机制通过 $\\text{softmax}(q^\\top k)$ 计算注意力权重，位置信息需要影响这个权重计算，而 Value 向量仅用于加权求和，不需要位置编码。\n第十九题 Transformer Block 的 Post-norm 和 Pre-norm 题目： 对于 Transformer Block 的 Post-norm 有：\n$$x_{l+1} = x_l + \\text{Sublayer}(x_l)$$ $$y_{l+1} = \\text{LN}(x_{l+1})$$ 请相应给出 Pre-norm 的计算公式； 结合梯度分析证明 Post-norm 相比 Pre-norm 更易出现梯度消失或放大，并指出其中的梯度恒等映射通路。 解：\n1. Pre-norm 计算公式 Pre-norm 将 LayerNorm 应用在 Sublayer 之前：\n$$y_l = \\text{LN}(x_l)$$ $$x_{l+1} = x_l + \\text{Sublayer}(y_l)$$2. 梯度分析 Post-norm 的梯度：\n对于 Post-norm：$y_{l+1} = \\text{LN}(x_l + \\text{Sublayer}(x_l))$\n反向传播时：\n$$\\frac{\\partial \\mathcal{L}}{\\partial x_l} = \\frac{\\partial \\mathcal{L}}{\\partial y_{l+1}} \\cdot \\frac{\\partial \\text{LN}}{\\partial x_{l+1}} \\cdot \\left(I + \\frac{\\partial \\text{Sublayer}}{\\partial x_l}\\right)$$由于 LayerNorm 的导数和 Sublayer 的导数都可能较大或较小，梯度容易累积放大或缩小，导致梯度爆炸或消失。\nPre-norm 的梯度：\n对于 Pre-norm：$x_{l+1} = x_l + \\text{Sublayer}(\\text{LN}(x_l))$\n反向传播时：\n$$\\frac{\\partial \\mathcal{L}}{\\partial x_l} = \\frac{\\partial \\mathcal{L}}{\\partial x_{l+1}} \\cdot \\left(I + \\frac{\\partial \\text{Sublayer}}{\\partial y_l} \\cdot \\frac{\\partial \\text{LN}}{\\partial x_l}\\right)$$梯度恒等映射通路： $\\frac{\\partial x_{l+1}}{\\partial x_l}$ 包含恒等项 $I$，即：\n$$\\frac{\\partial x_{l+1}}{\\partial x_l} = I + \\frac{\\partial \\text{Sublayer}}{\\partial y_l} \\cdot \\frac{\\partial \\text{LN}}{\\partial x_l}$$这个恒等项提供了一条直接的梯度传播路径，即使 Sublayer 的梯度很小，梯度仍能通过恒等映射传播，避免梯度消失。\n结论： Pre-norm 由于存在梯度恒等映射通路（residual connection 在 LayerNorm 之后），梯度更稳定；Post-norm 的梯度需要先经过 LayerNorm，更容易出现梯度消失或放大。\n第二十题 Gated Attention 的 Output 计算 题目： 已知 MHA 中第 $k$ 层第 $i$ 位置 token 的 output 表征计算如下：\n$$o_i^k = \\left(\\sum_{j=0}^{i} S_{ij}^k \\cdot X_j W_V^k\\right)W_O^k = \\sum_{j=0}^{i} S_{ij}^k \\cdot X_j(W_V^k W_O^k)$$请相应给出下图 Gated Attention 中 G1/G2/G3 对应的 output $o_i^k$ 计算方法。\n注意：可用 Non-Linearity-Map 算子表示 element-wise gating 机制，即 $$Y' = Y \\odot \\sigma(XW_\\theta) = \\text{Non-Linearity-Map}(Y)$$解：\n根据图示，Gated Attention 在不同位置应用门控机制：\nG1（最有效）： 在 Concat 之后、Dense Layer 之前应用门控\n$$o_i^k = \\left[\\sum_{j=0}^{i} S_{ij}^k \\cdot X_j W_V^k\\right] \\odot \\sigma(Z_i W_{g1}) \\cdot W_O^k$$其中 $Z_i$ 可以是 Query、Key 或其他输入特征。\nG2： 在 Value Layer 输出上应用门控\n$$o_i^k = \\sum_{j=0}^{i} S_{ij}^k \\cdot \\left[X_j W_V^k \\odot \\sigma(X_j W_{g2})\\right] W_O^k$$G3： 在 Key Layer 上应用门控\n$$\\tilde{K}*j = X_j W_K^k \\odot \\sigma(X_j W*{g3})$$ $$S_{ij}^k = \\text{softmax}\\left(\\frac{Q_i \\tilde{K}*j^\\top}{\\sqrt{d_k}}\\right)$$ $$o_i^k = \\sum*{j=0}^{i} S_{ij}^k \\cdot X_j W_V^k \\cdot W_O^k$$G4： 在 Query Layer 上应用门控（类似 G3）\nG5： 在最终输出上应用门控\n$$o_i^k = \\left[\\sum_{j=0}^{i} S_{ij}^k \\cdot X_j W_V^k \\cdot W_O^k\\right] \\odot \\sigma(X_i W_{g5})$$ 第二十一题 GPT-OSS 20B 架构分析 题目： GPT-OSS 20B 架构相比标准 Transformer 有多处改动，请依次文字分析各个改动的具体内容与意义：\nRoPE RMSNorm GQA MoE SwiGLU 解：\n1. RoPE（Rotary Position Embedding） 内容： 旋转位置编码，通过旋转矩阵将位置信息注入 Query 和 Key 向量。\n意义：\n相对位置编码：attention score 仅依赖于相对位置 $m-n$ 外推性好：可以处理训练时未见过的序列长度 计算高效：不需要额外的位置嵌入参数 2. RMSNorm（Root Mean Square Normalization） 内容： 简化的 LayerNorm，公式为：\n$$y = \\frac{x}{\\sqrt{|x|_2^2 + \\epsilon}} \\cdot \\gamma$$不计算均值，只进行缩放。\n意义：\n计算效率高：省去均值计算和减法操作 参数更少：只需 scale 参数 $\\gamma$，不需要 shift 参数 $\\beta$ 性能相当：在实践中与 LayerNorm 效果相当 3. GQA（Grouped Query Attention） 内容： 将多个 Query head 共享同一组 Key 和 Value head。\n意义：\n减少 KV Cache：多个 Query 共享 KV，显著降低显存占用 推理加速：减少 KV 读取的内存带宽需求 折中方案：介于 MHA（每个 head 独立 KV）和 MQA（所有 head 共享 KV）之间 4. MoE（Mixture of Experts） 内容： 使用路由器（Router）动态选择激活的专家（FFN），每个 token 只激活部分专家。\n意义：\n增加模型容量：总参数量大幅增加（20B 模型容量） 计算效率：每次前向只激活少量参数（实际激活 3.6B） 专业化：不同专家学习处理不同类型的输入 5. SwiGLU（Swish-Gated Linear Unit） 内容： 激活函数，结合 Swish 激活和门控机制：\n$$\\text{SwiGLU}(x) = \\text{Swish}(xW_1) \\odot (xW_2)$$其中 $\\text{Swish}(x) = x \\cdot \\sigma(x)$\n意义：\n性能提升：比标准 ReLU/GELU 效果更好 门控机制：允许模型动态控制信息流 平滑激活：Swish 的平滑特性有助于优化 第二十二题 Roofline Model 分析 题目： 结合下列代码和结果，设 repeat=32 时，f 函数在 GPU 上执行时用于数据移动和计算的时间分别为 $T_{\\text{move}}$ 和 $T_{\\text{comp}}$，并假设此时恰处于 Memory 和计算的平衡点，依次分析：\nrepeat=16 时，用于数据移动和计算的时间各是多少，此时 GPU 处于 Memory-bounded or Compute-bounded? repeat=64 时，用于数据移动和计算的时间各是多少，此时 GPU 处于 Memory-bounded or Compute-bounded? 解：\n分析 从图中可以看出：\nRuntime 在 repeat=32 之前增长缓慢，之后快速增长 FLOPS 逐渐增加并趋于平稳 Memory Bandwidth 在 repeat=32 之前保持高位，之后急剧下降 这表明在 repeat=32 时达到平衡点，此时： $$T_{\\text{move}} = T_{\\text{comp}}$$1. repeat=16 时 计算量减半： $$T_{\\text{comp}}^{(16)} = \\frac{1}{2} T_{\\text{comp}}$$数据移动量不变（输入输出大小固定）： $$T_{\\text{move}}^{(16)} = T_{\\text{move}}$$总时间： $$T_{\\text{total}}^{(16)} = T_{\\text{move}}^{(16)} + T_{\\text{comp}}^{(16)} = T_{\\text{move}} + \\frac{1}{2}T_{\\text{comp}} = \\frac{3}{2}T_{\\text{move}}$$由于 $T_{\\text{move}}^{(16)} \u003e T_{\\text{comp}}^{(16)}$，GPU 处于 Memory-bounded。\n2. repeat=64 时 计算量翻倍： $$T_{\\text{comp}}^{(64)} = 2T_{\\text{comp}}$$数据移动量不变： $$T_{\\text{move}}^{(64)} = T_{\\text{move}}$$总时间： $$T_{\\text{total}}^{(64)} = T_{\\text{move}}^{(64)} + T_{\\text{comp}}^{(64)} = T_{\\text{move}} + 2T_{\\text{comp}} = 3T_{\\text{move}}$$由于 $T_{\\text{comp}}^{(64)} \u003e T_{\\text{move}}^{(64)}$，GPU 处于 Compute-bounded。\n第二十三题 Operation Intensity 计算 题目： GPU 的 Operation Intensity 定义为浮点操作数 FLOPS 与数据移动（Bytes）的比值，请计算并对比 LayerNorm 和 RMSNorm 的 Operation Intensity。\n注意：d=8192，dtype=bf16，所有数据初始存于全局 DRAM，结果需写回全局 DRAM，且 SRAM 足够存放所有中间计算结果。\n解：\nLayerNorm 计算过程：\n计算均值：$\\mu = \\frac{1}{d}\\sum_{i=1}^d x_i$ → $d$ 次加法，1 次除法 ≈ $d$ FLOPs 计算方差：$\\sigma^2 = \\frac{1}{d}\\sum_{i=1}^d (x_i - \\mu)^2$ → $d$ 次减法，$d$ 次乘法，$d$ 次加法，1 次除法 ≈ $3d$ FLOPs 归一化和缩放：$y_i = \\frac{x_i - \\mu}{\\sqrt{\\sigma^2 + \\epsilon}} \\cdot \\gamma_i + \\beta_i$ → $d$ 次减法，$d$ 次除法，$d$ 次乘法，$d$ 次加法 ≈ $4d$ FLOPs 总计算量： $8d$ FLOPs\n数据移动：\n读取 $x$：$d \\times 2$ bytes 读取 $\\gamma, \\beta$：$2d \\times 2$ bytes 写入 $y$：$d \\times 2$ bytes 总计：$8d$ bytes Operation Intensity： $$\\text{OI}_{\\text{LN}} = \\frac{8d}{8d} = 1 \\text{ FLOP/Byte}$$RMSNorm 计算过程：\n计算 RMS：$\\text{RMS} = \\sqrt{\\frac{1}{d}\\sum_{i=1}^d x_i^2}$ → $d$ 次乘法，$d$ 次加法，1 次除法，1 次开方 ≈ $2d$ FLOPs 归一化和缩放：$y_i = \\frac{x_i}{\\text{RMS}} \\cdot \\gamma_i$ → $d$ 次除法，$d$ 次乘法 ≈ $2d$ FLOPs 总计算量： $4d$ FLOPs\n数据移动：\n读取 $x$：$d \\times 2$ bytes 读取 $\\gamma$：$d \\times 2$ bytes 写入 $y$：$d \\times 2$ bytes 总计：$6d$ bytes Operation Intensity： $$\\text{OI}_{\\text{RMS}} = \\frac{4d}{6d} = \\frac{2}{3} \\text{ FLOP/Byte}$$对比 LayerNorm 的 OI 为 1 FLOP/Byte，RMSNorm 的 OI 为 2/3 FLOP/Byte。两者都很低，属于 Memory-bounded 操作。RMSNorm 虽然计算量更少，但由于数据移动占主导，实际加速效果有限。\n第二十四题 A100 Operation Intensity 分析 题目： 以 A100 为例，分析 FP32 和 BF16（TensorCore，考虑 dense 即左边列的 FLOPS）类型在进入 Compute-bounded 时需要的 Operation Intensity 分别是多少。Bandwidth 统一简化为 2TB/s。\n解：\n从表格中读取：\nFP32：19.5 TFLOPS BF16（TensorCore）：312 TFLOPS Memory Bandwidth：2TB/s = 2000 GB/s Compute-bounded 临界点 当计算时间等于数据传输时间时，达到平衡点：\n$$\\frac{\\text{FLOPs}}{\\text{Peak FLOPS}} = \\frac{\\text{Bytes}}{\\text{Bandwidth}}$$因此临界 Operation Intensity 为：\n$$\\text{OI}_{\\text{critical}} = \\frac{\\text{Peak FLOPS}}{\\text{Bandwidth}}$$FP32 $$\\text{OI}_{\\text{FP32}} = \\frac{19.5 \\text{ TFLOPS}}{2 \\text{ TB/s}} = \\frac{19.5}{2} = 9.75 \\text{ FLOP/Byte}$$BF16 TensorCore $$\\text{OI}_{\\text{BF16}} = \\frac{312 \\text{ TFLOPS}}{2 \\text{ TB/s}} = \\frac{312}{2} = 156 \\text{ FLOP/Byte}$$结论 要让 FP32 计算进入 Compute-bounded，Operation Intensity 需要 ≥ 9.75 FLOP/Byte 要让 BF16（TensorCore） 计算进入 Compute-bounded，Operation Intensity 需要 ≥ 156 FLOP/Byte 这解释了为什么使用 TensorCore 进行矩阵乘法（OI 通常为 $O(N)$，其中 $N$ 是矩阵维度）更容易达到计算瓶颈，而 LayerNorm/RMSNorm（OI ≈ 1）始终是 Memory-bounded。\n第二十五题 ε-greedy 多臂老虎机问题 题目： 考虑一多臂老虎机问题（K=10），3 个 ε-greedy 策略下每一时刻可以获得的平均 reward 下图所示。已知该问题中随机以及最有策略下可获得 reward 的期望分别为 1 与 1.55，则：\n哪个 ε 在游戏后期（steps → +∞）可以获得更高的 average reward。 在（steps → +∞）时，这 3 个 ε-greedy 策略每次可获得 reward 的期望各是多少。 解：\n1. 后期表现 从图中可以观察到：\n$\\varepsilon = 0.1$ 收敛到约 1.4 $\\varepsilon = 0.01$ 收敛到约 1.3 $\\varepsilon = 0$（greedy）收敛到约 1.0 $\\varepsilon = 0.1$ 在后期获得更高的 average reward。\n2. 期望分析 ε-greedy 策略的期望 reward 为：\n$$\\mathbb{E}[R] = (1-\\varepsilon) \\cdot R_{\\text{greedy}} + \\varepsilon \\cdot R_{\\text{random}}$$其中：\n$R_{\\text{random}} = 1$（随机策略期望） $R_{\\text{optimal}} = 1.55$（最优策略期望） 对于 $\\varepsilon = 0$（greedy）：\n由于没有探索，可能陷入局部最优。从图中看收敛到 1.0，说明找到的并非最优臂：\n$$\\mathbb{E}[R_{\\varepsilon=0}] \\approx 1.0$$对于 $\\varepsilon = 0.01$：\n假设经过充分探索后，greedy 部分能找到最优臂：\n$$\\mathbb{E}[R_{\\varepsilon=0.01}] = 0.99 \\times 1.55 + 0.01 \\times 1 = 1.5345 + 0.01 = 1.5445 \\approx 1.3$$实际从图中看约为 1.3，可能 greedy 部分未完全收敛到最优。\n对于 $\\varepsilon = 0.1$：\n$$\\mathbb{E}[R_{\\varepsilon=0.1}] = 0.9 \\times 1.55 + 0.1 \\times 1 = 1.395 + 0.1 = 1.495 \\approx 1.4$$实际从图中看约为 1.4，与理论接近。\n总结 当 steps → ∞ 时：\n$\\varepsilon = 0$：约 1.0 $\\varepsilon = 0.01$：约 1.3-1.5 $\\varepsilon = 0.1$：约 1.4-1.5 $\\varepsilon = 0.1$ 虽然探索开销大，但能更稳定地找到最优臂，长期表现最好。\n第二十六题 MDP Bellman 方程 题目： 下图左是一个有限 Markov Decision Process (MDP) 的例子。网格中的单元格对应于环境的状态，在每个单元格中，智能体可以采取四种可能动作：上、下、左、右。这些动作确定性地使智能体在网格上沿相应方向移动一个单元格，并获取 0 的奖励。但有 2 类特殊情况：(1) 如果动作会导致智能体移出网格，则其位置保持不变，但会产生 -1 的奖励；(2) 如果智能体在状态 A 或 B 中，不管采取任意动作都会使智能体传送到 A\u0026rsquo;或 B\u0026rsquo;，并或者 +10 或 +5 的奖励。取 discount factor $\\gamma = 0.9$。\n随机策略对应的 state value 函数如下右图所示，保留 1 位有效数字。记左下状态坐标为 (1, 1)，右上状态坐标为 (5, 5)，请给出 坐标 (2, 5)、(3, 3)、(4, 5)、(5, 1) 4 个状态对应 value 的 Bellman 法代公式。\n注：上述 4 状态的 value 分别为 8.8、0.7、5.3、-2.0。\n解：\nBellman 方程的一般形式为：\n$$v(s) = \\sum_a \\pi(a|s) \\sum_{s',r} p(s',r|s,a)[r + \\gamma v(s')]$$对于随机策略，$\\pi(a|s) = 0.25$ 对所有动作 $a \\in {\\text{上, 下, 左, 右}}$。\n坐标系统 根据题意，左下为 (1,1)，右上为 (5,5)。状态 A 在 (2,4)，A\u0026rsquo; 在 (2,1)；状态 B 在 (4,2)，B\u0026rsquo; 在 (4,5)。\n(2, 5) - value = 8.8 位置 (2,5) 在网格顶部。各方向移动：\n上：出界 → 保持 (2,5)，奖励 -1 下：到 (2,4) = 状态 A 左：到 (1,5) 右：到 (3,5) 但 (2,4) 是状态 A，从 A 出发会传送到 A\u0026rsquo; = (2,1) 并获得 +10。\n$$v(2,5) = 0.25 \\times [(-1 + 0.9 v(2,5)) + (0 + 0.9 v(2,4)) + (0 + 0.9 v(1,5)) + (0 + 0.9 v(3,5))]$$由于 (2,4) 是 A，应该使用 A 的 value：\n$$v(2,5) = 0.25 \\times [(-1 + 0.9 \\times 8.8) + (0 + 0.9 \\times 8.8) + (0 + 0.9 \\times 3.0) + (0 + 0.9 \\times 4.4)]$$(3, 3) - value = 0.7 位置 (3,3) 在网格中心。各方向移动：\n上：到 (3,4) 下：到 (3,2) 左：到 (2,3) 右：到 (4,3) $$v(3,3) = 0.25 \\times [(0 + 0.9 v(3,4)) + (0 + 0.9 v(3,2)) + (0 + 0.9 v(2,3)) + (0 + 0.9 v(4,3))]$$从图中读取相邻格子的值： $$v(3,3) = 0.25 \\times 0.9 \\times [v(3,4) + v(3,2) + v(2,3) + v(4,3)]$$(4, 5) - value = 5.3 位置 (4,5) 在网格顶部。各方向移动：\n上：出界 → 保持 (4,5)，奖励 -1 下：到 (4,4) 左：到 (3,5) 右：到 (5,5) $$v(4,5) = 0.25 \\times [(-1 + 0.9 v(4,5)) + (0 + 0.9 v(4,4)) + (0 + 0.9 v(3,5)) + (0 + 0.9 v(5,5))]$$(5, 1) - value = -2.0 位置 (5,1) 在右下角。各方向移动：\n上：到 (5,2) 下：出界 → 保持 (5,1)，奖励 -1 左：到 (4,1) 右：出界 → 保持 (5,1)，奖励 -1 $$v(5,1) = 0.25 \\times [(0 + 0.9 v(5,2)) + (-1 + 0.9 v(5,1)) + (0 + 0.9 v(4,1)) + (-1 + 0.9 v(5,1))]$$化简： $$v(5,1) = 0.25 \\times [0.9 v(5,2) + 0.9 v(4,1) - 2 + 1.8 v(5,1)]$$ 第二十七题 MDP 最优策略 题目： 下图左是一个有限 Markov Decision Process (MDP) 的例子（与上题相同）。已知下图右是最优策略对应的 value function，请对应给出各状态的最佳行动策略。\n解：\n最优策略选择使 $Q(s,a) = r + \\gamma v(s')$ 最大的动作。对于每个状态，计算四个方向的 Q 值并选择最大的。\n系统方法 对于每个状态 $(i,j)$，最优动作 $a^*$ 满足：\n$$a^* = \\arg\\max_a [r(s,a) + \\gamma v(s')]$$其中 $s'$ 是执行动作 $a$ 后到达的状态。\n具体分析（部分状态示例） 状态 (1,1) - 左下角，v = 22.0\n四个方向的 Q 值：\n上：$0 + 0.9 \\times 24.4 = 21.96$ 下：$-1 + 0.9 \\times 22.0 = 18.8$（出界） 左：$-1 + 0.9 \\times 22.0 = 18.8$（出界） 右：$0 + 0.9 \\times 22.0 = 19.8$ 最优动作：上\n状态 (3,3) - 中心，v = 17.8\n四个方向的 Q 值计算邻近状态的 value，选择最大的。\n状态 A (2,4)，v = 24.4\n从 A 采取任意动作都传送到 A\u0026rsquo;(2,1) 并获得 +10： $$Q(A, a) = 10 + 0.9 \\times 22.0 = 29.8$$所有动作等价，可以任选。\n状态 B (4,2)，v = 19.8\n从 B 采取任意动作都传送到 B\u0026rsquo;(4,5) 并获得 +5： $$Q(B, a) = 5 + 0.9 \\times 19.4 = 22.46$$所有动作等价。\n最优策略总结 通过计算每个状态的所有可能动作的 Q 值，最优策略为：\n第1行（底部）：大部分向上，靠近 A\u0026rsquo; 的向右 第2行：向 B 或向上 第3行（中间）：向 A 或 B 方向 第4行：向 A 方向 第5行（顶部）：向 B\u0026rsquo; 或向左 具体每个格子的最优动作需要根据其邻居的 value 值计算得出，选择使 $r + \\gamma v(s')$ 最大的方向。\n第二十八题 AI Agent 特性解释 题目： AI Agent 是一类能够感知环境、自主决策并采取行动以实现特定目标的智能系统，并具备自主性、反应性、主动性、社会性以及进化性。请选择其中 3 种性质进行解释，并分别举例一种代表性技术（正式发表于 NeurIPS、ICLR、ICML）介绍其原理。（该题必考）\n解：\n1. 自主性 (Autonomy) 性质解释 AI Agent 能够在没有外部持续干预的情况下独立运行，自主做出决策并执行任务，无需人工指导每一步操作。\n代表性技术：ReAct\n会议：ICLR 2023 **论文：**ReAct: Synergizing Reasoning and Acting in Language Models (Yao et al.) 核心原理 ReAct 框架通过将推理（Reasoning）和行动（Acting）相结合，使语言模型能够以交替方式生成推理轨迹和任务特定的行动序列：\n思维-行动-观察循环\nThought (思考): 模型生成推理步骤，分析当前状态、任务目标和下一步计划 Action (行动): 执行具体操作（如调用搜索API、使用计算器、访问数据库） Observation (观察): 接收环境反馈和执行结果 推理增强的行动选择\n通过显式的推理轨迹，模型能够：\n动态分解复杂任务为子目标 根据中间结果调整策略 处理异常情况和错误 提示工程实现 使用 few-shot prompting，提供示例展示 Thought-Action-Observation 模式，引导模型学习这种交互模式。\n➡️ 体现的自主性：Agent 无需预定义完整的行动序列，能根据环境反馈自主决策每一步，实现端到端的任务自动化。\n2. 反应性 (Reactivity) 性质解释 AI Agent 能够感知环境变化并及时做出响应，从失败中学习，动态调整行为策略以适应变化的情境。\n代表性技术：Reflexion\n会议：NeurIPS 2023 **论文：**Reflexion: Language Agents with Verbal Reinforcement Learning (Shinn et al.) 核心原理 Reflexion 引入了语言化的自我反思机制，使 Agent 能够从试错中快速学习：\n反思-行动循环 Actor: 基于当前记忆生成行动轨迹 Evaluator: 评估行动结果（成功/失败，输出奖励信号） Self-Reflection: 当失败时，生成具体的反思文本，分析失败原因 语言化的情景记忆 将失败经验和反思以自然语言形式存储在短期记忆中 在后续尝试中，将相关反思加入提示上下文 类似于人类的\u0026quot;从错误中学习\u0026quot;机制 迭代改进机制 通过多轮试错-反思循环，Agent 逐步优化策略： Attempt 1 → Fail → Reflect (\u0026#34;边界条件未处理\u0026#34;) Attempt 2 → 根据反思调整 → Success ➡️ 体现的反应性：Agent 能够快速识别环境反馈（错误信息、失败信号），生成针对性的策略调整，实时适应新情况。\n3. 社会性 (Sociality) 性质解释 AI Agent 能够与其他 Agent 进行协作、竞争或沟通，在多智能体环境中通过合作完成单个 Agent 无法完成的复杂任务。\n代表性技术：QMIX\n会议：ICML 2018 **论文：**Monotonic Value Function Factorisation for Deep Multi-Agent Reinforcement Learning (Rashid et al.) 核心原理 QMIX 通过单调价值函数分解解决多智能体协作中的信用分配问题：\n集中训练-分散执行 (CTDE) 范式 训练阶段: 可访问全局状态 ss s 和所有 Agent 的观测 执行阶段: 每个 Agent 仅基于局部观测 oio_i oi 独立决策 单调价值函数分解 将全局 Q 函数分解为各 Agent 局部 Q 函数的单调组合： $$Q_{tot}(s, \\mathbf{a}) = f_{\\text{mix}}(Q_1(o_1, a_1), \\ldots, Q_n(o_n, a_n); s) 约束条件（单调性）： $$\\frac{\\partial Q_{tot}}{\\partial Q_i} \\geq 0, \\quad \\forall i 这保证了：局部贪婪动作（argmax QiQ_i Qi​）的组合等于全局最优动作 混合网络 (Mixing Network) 使用超网络 (hypernetwork) 根据全局状态 ss s 生成混合网络的权重 权重非负性通过绝对值函数保证单调性 网络结构：Agent Networks→Mixing Network→Qtot\\text{Agent Networks} \\rightarrow \\text{Mixing Network} \\rightarrow Q_{tot} Agent Networks→Mixing Network→Qtot ➡️ 体现的社会性：多个 Agent 无需显式通信即可通过学习形成隐式协作策略，共同最大化团队奖励，展现涌现的群体智能。\n","permalink":"http://localhost:1313/dase-course/ml-exercise-set/","summary":"25fall机器学习课程习题集解答汇总","title":"机器学习习题集"},{"content":"前言 四川麻将，又称成都麻将或血战麻将，是中国最流行的麻将玩法之一。与传统麻将相比，四川麻将节奏快、变化多，充满了刺激性和趣味性。本文将带你从零开始，系统学习四川麻将的规则和技巧。\n一、基础规则入门 1.1 牌面组成 四川麻将使用108张牌，包括：\n万子：一万到九万，各4张（36张） 条子：一条到九条，各4张（36张） 筒子：一筒到九筒，各4张（36张） 注意：四川麻将没有东南西北中发白这些字牌和花牌。\n1.2 基本概念 刻子：三张相同的牌（如：三张五万） 顺子：三张连续的同花色牌（如：三四五条） 对子：两张相同的牌（如：两张八筒） 杠：四张相同的牌\n1.3 胡牌基本型 标准胡牌牌型：3n+2 结构（n个刻子或顺子 + 1个对子）\n例如：\n一一一 + 二三四 + 五六七 + 八八八 + 九九（4组3张+1对） 1.4 游戏流程 定庄：掷骰子决定庄家 配牌：每人抓13张牌，庄家多抓一张（14张） 出牌：庄家先出一张牌，其他玩家依次摸牌、出牌 胡牌：谁先凑齐胡牌牌型谁获胜 血战到底：已胡牌的玩家退出，剩余玩家继续游戏，直到3人胡牌或流局 二、四川麻将特色规则 2.1 缺一门 四川麻将的核心规则：必须缺一门才能胡牌\n也就是说，你的手牌中只能有两种花色（万、条、筒三选二）。\n例如：\n✅ 可以胡：万子+条子（缺筒） ✅ 可以胡：万子+筒子（缺条） ❌ 不能胡：万子+条子+筒子（三门齐全） 2.2 杠牌规则 明杠：\n碰牌后，再摸到第四张，可以杠牌 别人打出的牌，自己有三张，可以直接杠 暗杠：\n自己摸到四张相同的牌，可以暗杠 杠牌后：\n摸一张牌 多算一番（底分×2） 杠后可以继续杠或胡牌 2.3 血战到底 这是四川麻将最大的特色：\n第一个人胡牌后不结束游戏 剩余三人继续打，直到有第二、第三个人胡牌 最后没胡的人要赔给所有胡牌的人 第一个胡牌的人可以继续胡（查叫） 2.4 查叫 游戏结束时，如果有人没胡牌：\n如果他已听牌（只差一张就能胡），他只赔给胡牌的人 如果他未听牌（没有听牌），他要加倍赔偿 三、番型与计分 3.1 基础番型 番型 番数 说明 平胡 1番 基础胡牌 自摸 1番 自己摸牌胡 根（杠） 1番 每杠一次+1番 对对胡 2番 全是刻子+对子，没有顺子 清一色 4番 全部是一种花色 龙七对 4番 七个对子 天胡 封顶 庄家起手就胡 地胡 封顶 闲家第一轮胡 3.2 计分方式 基础公式：底分 × 2^(番数)\n例如：\n底分1元，平胡（1番）= 1×2¹ = 2元 底分1元，清一色（4番）= 1×2⁴ = 16元 底分1元，清一色+对对胡（6番）= 1×2⁶ = 64元 封顶：很多地方设置封顶番数（如10番），防止输赢过大\n四、进阶技巧 4.1 定缺策略 游戏开始后，要快速决定缺哪一门：\n判断依据：\n数量最少的门：哪门牌少就缺哪门 孤张多的门：有很多不连续的孤张，这门不好组合 对子情况：如果某门有对子，考虑留下，可能组成刻子 例子：\n手牌：一万 三万 五万 六万 | 二条 七条 | 一筒 二筒 三筒 四筒 八筒 九筒 分析：万子4张分散，条子2张，筒子6张且有顺子潜力 建议：缺条子 4.2 听牌技巧 多面听优于单钓：\n单钓：只有一种牌能胡（如：等一张五万） 两面听：能胡两种牌（如：三四条，等二条或五条） 多面听：能胡多种牌（如：卡张、边张、对子等组合） 例子：\n手牌：一万 二万 | 三万 四万 | 五万 六万 | 七万 八万 | 九万 拆牌选择： - 打九万：听二万和五万（两面） - 打一万：听三万和六万和九万（多面） 建议打一万，听牌面更多 4.3 防守策略 观察舍牌：\n对手打出的牌反映他要什么、不要什么 如果对手大量打某一门，可能在做清一色 如果对手突然不打某种牌，可能在攒那个牌 生张和熟张：\n生张：桌面上没出现过的牌，危险度较高 熟张：已经有人打过的牌，相对安全 听牌信号：\n出牌犹豫 打牌速度突然变化 开始打生张或中张 4.4 做大牌策略 什么时候做大牌：\n起手牌型好（比如某门很多，可以做清一色） 当前领先或持平，可以冒险 对手没有明显听牌迹象 做大牌风险：\n听牌较慢，容易被别人截胡 如果未听牌查叫，要加倍赔偿 建议新手以稳为主，先保证听牌 4.5 心理战术 诱敌出牌：\n故意打出中张，引诱对手出你需要的牌 注意节奏，不要过于明显 藏牌意图：\n不要急于碰牌或杠牌，暴露自己的牌型 暗刻比明刻更有迷惑性 施压策略：\n快速出牌，给对手压力 适当沉默，让对手摸不清你的意图 五、常见错误与避免 5.1 新手常犯错误 忘记缺门：手牌三门齐全还以为能胡 盲目做大牌：不顾牌型强行做清一色，最后未听牌 不会算番：不知道自己多少番，糊里糊涂胡牌 乱碰乱杠：过早暴露牌型，让对手防范 不看舍牌：只顾自己手牌，不观察对手 5.2 进阶常犯错误 过度防守：太在意对手，错失自己的听牌机会 贪大求全：总想胡大牌，反而听牌慢 不会放弃：明知牌型不好还死撑，最后查叫 心态失衡：连续点炮后急躁，决策失误 六、实战案例分析 案例1：定缺选择 起手牌：\n二万 四万 六万 八万 九万 一条 二条 三条 五筒 六筒 七筒 八筒 分析：\n万子：5张但分散，不易组合 条子：3张成顺，很好 筒子：4张有两个顺子潜力 决策：缺万子，保留条筒两门\n案例2：听牌选择 当前牌型：\n二万 三万 四万 | 五万 六万 七万 | 一条 二条 三条 | 五筒 六筒 | 八筒 八筒 选择1：打五筒或六筒，听七筒（单钓） 选择2：打八筒，听四筒或七筒（两面）\n决策：选择2更优，两面听更容易胡牌\n案例3：要不要做清一色 当前牌型（已缺条）：\n一万 二万 三万 四万 五万 六万 | 二筒 五筒 七筒 | 八筒 八筒 分析：\n距离清一色还差3张筒子替换万子 如果做清一色，需要拆掉现有的顺子 当前可以快速听牌（1-2轮） 决策：不做清一色，保证快速听牌，除非后续摸牌特别好\n七、练习建议 7.1 新手阶段 熟悉规则：先玩小局，熟悉缺门、血战等规则 记住番型：至少记住基础番型和分数 多观察：看别人怎么打，学习经验 求稳为主：不要急于做大牌，先学会稳定胡牌 7.2 进阶阶段 提高速度：加快判断和决策速度 学习算牌：记住哪些牌出过，推测剩余牌 心理博弈：学会观察对手，做出针对性策略 复盘总结：每局结束后思考得失 7.3 推荐练习方式 线上平台：在手机或电脑上玩四川麻将游戏，方便练习 观战学习：看高手直播或录像，学习思路 实战练习：找朋友线下对局，积累实战经验 理论学习：阅读麻将书籍或教程，系统提升 八、总结 四川麻将规则简单但策略丰富，从新手到高手需要：\n扎实的基本功：熟练掌握规则和番型 灵活的战术：根据牌型和局势调整策略 敏锐的观察力：读懂对手意图，做出正确判断 稳定的心态：胜不骄败不馁，理性决策 记住：麻将三分靠运气，七分靠技术。多练习、多思考，你一定能成为四川麻将高手！\n祝你好运，胡牌多多！🀄\n","permalink":"http://localhost:1313/game-guide/sichuan-mahjong-guide/","summary":"四川麻将完全攻略：从基础规则到高阶技巧，涵盖缺一门、血战到底、番型计分、定缺策略、听牌技巧、防守要点和实战案例分析。无论你是零基础\n新手还是想提升的进阶玩家，这篇指南都能帮你系统掌握四川麻将的精髓，快速从入门到精通","title":"四川麻将指南"},{"content":"Windows PowerShell 常用指令 文件和目录操作 列出目录内容\nGet-ChildItem / ls - 列出当前目录内容 ls -Force - 显示隐藏文件 ls -Recurse - 递归列出所有子目录 ls | Sort-Object Length -Descending - 按文件大小排序 切换目录\nSet-Location \u0026lt;路径\u0026gt; / cd - 切换目录 cd ~ - 返回用户主目录 cd .. - 返回上级目录 cd - - 返回上一个目录 创建文件和目录\nNew-Item -ItemType Directory \u0026lt;名称\u0026gt; / mkdir - 创建目录 New-Item -ItemType File \u0026lt;名称\u0026gt; / ni - 创建文件 复制、移动和删除\nCopy-Item \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; 复制文件\nMove-Item \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; / mv - 移动/重命名文件\nRemove-Item \u0026lt;路径\u0026gt; 删除文件\n查看文件\nGet-Content \u0026lt;文件\u0026gt; / cat - 查看文件内容 Get-Content \u0026lt;文件\u0026gt; -Tail 10 - 查看最后 10 行 Get-Content \u0026lt;文件\u0026gt; -Wait - 实时查看文件更新（类似 tail -f） Test-Path \u0026lt;路径\u0026gt; - 检查路径是否存在 以默认方式打开文件或目录\nstart filename打开当前目录下的指定文件 code filename使用vscode打开 code .使用vscode打开当前目录 文本处理和搜索 Select-String \u0026lt;模式\u0026gt; \u0026lt;文件\u0026gt; - 在文件中搜索文本（类似 grep） Select-String \u0026quot;error\u0026quot; *.log - 在所有 log 文件中搜索 ls -Recurse | Select-String \u0026quot;TODO\u0026quot; - 递归搜索 Out-File \u0026lt;文件\u0026gt; - 输出重定向到文件 Tee-Object \u0026lt;文件\u0026gt; - 同时输出到控制台和文件 系统信息和管理 进程管理\nGet-Process / ps - 查看进程列表 Get-Process | Sort-Object CPU -Descending | Select-Object -First 5 - CPU 占用最高的 5 个进程 Stop-Process -Name \u0026lt;进程名\u0026gt; - 结束进程 服务管理\nGet-Service - 查看服务列表 Get-Service | Where-Object {$_.Status -eq \u0026quot;Running\u0026quot;} - 只显示运行中的服务 Start-Service \u0026lt;服务名\u0026gt; - 启动服务 Stop-Service \u0026lt;服务名\u0026gt; - 停止服务 系统信息\nGet-ComputerInfo - 查看计算机信息 Get-NetIPAddress - 查看网络配置 Get-Disk - 查看磁盘信息 Get-Volume - 查看卷信息 systeminfo - 显示详细系统信息 环境变量 $env:PATH - 查看 PATH 环境变量 $env:变量名 = \u0026quot;值\u0026quot; - 设置临时环境变量 [Environment]::SetEnvironmentVariable(\u0026quot;变量名\u0026quot;, \u0026quot;值\u0026quot;, \u0026quot;User\u0026quot;) - 永久设置 网络操作 Test-Connection \u0026lt;主机\u0026gt; / ping - 测试网络连接 Invoke-WebRequest \u0026lt;URL\u0026gt; / curl - 发送 HTTP 请求 Invoke-WebRequest -Uri \u0026lt;URL\u0026gt; -OutFile \u0026lt;文件\u0026gt; - 下载文件 Get-NetTCPConnection - 查看 TCP 连接 ipconfig - 查看 IP 配置 ipconfig /flushdns - 刷新 DNS 缓存 实用命令 Clear-Host / cls - 清屏 Get-History / history - 查看命令历史 Get-Help \u0026lt;命令\u0026gt; - 获取帮助 Get-Help \u0026lt;命令\u0026gt; -Examples - 查看使用示例 Get-Command - 列出所有可用命令 Get-Command *process* - 搜索包含 process 的命令 Get-Alias - 查看所有别名 Measure-Object - 统计对象 Start-Process \u0026lt;程序\u0026gt; - 启动程序 Get-Location / pwd - 显示当前路径 Linux Terminal 常用指令 文件和目录操作 列出目录\nls - 列出目录内容 ls -l - 长格式显示（详细信息） ls -a - 显示隐藏文件 ls -lh - 人性化显示文件大小 ls -lt - 按修改时间排序 ls -lS - 按文件大小排序 ls -R - 递归列出所有子目录 切换目录\ncd \u0026lt;路径\u0026gt; - 切换目录 cd / cd ~ - 返回主目录 cd .. - 返回上级目录 cd - - 返回上一个目录 pwd - 显示当前完整路径 创建\nmkdir \u0026lt;目录名\u0026gt; - 创建目录 mkdir -p a/b/c - 递归创建多级目录 touch \u0026lt;文件名\u0026gt; - 创建空文件或更新时间戳 复制、移动和删除\ncp \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 复制文件 cp -r \u0026lt;源目录\u0026gt; \u0026lt;目标\u0026gt; - 递归复制目录 cp -i \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 交互式复制（覆盖前询问） mv \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 移动/重命名文件 rm \u0026lt;文件\u0026gt; - 删除文件 rm -r \u0026lt;目录\u0026gt; - 递归删除目录 rm -f \u0026lt;文件\u0026gt; - 强制删除 rm -rf \u0026lt;目录\u0026gt; - 强制递归删除（危险！） rm -i \u0026lt;文件\u0026gt; - 交互式删除（推荐） 链接\nln -s \u0026lt;源\u0026gt; \u0026lt;链接名\u0026gt; - 创建符号链接 readlink -f \u0026lt;链接\u0026gt; - 查看链接目标 文件查看和编辑 查看文件\ncat \u0026lt;文件\u0026gt; - 显示文件内容 cat -n \u0026lt;文件\u0026gt; - 显示行号 less \u0026lt;文件\u0026gt; - 分页查看（可前后翻页） more \u0026lt;文件\u0026gt; - 分页查看（只能向前） head \u0026lt;文件\u0026gt; - 查看文件开头 head -n 20 \u0026lt;文件\u0026gt; - 查看前 20 行 tail \u0026lt;文件\u0026gt; - 查看文件末尾 tail -n 20 \u0026lt;文件\u0026gt; - 查看最后 20 行 tail -f \u0026lt;文件\u0026gt; - 实时查看文件更新 tail -f \u0026lt;文件\u0026gt; | grep \u0026quot;error\u0026quot; - 实时过滤查看 编辑文件\nnano \u0026lt;文件\u0026gt; - 简单文本编辑器 vim \u0026lt;文件\u0026gt; / vi \u0026lt;文件\u0026gt; - 强大的文本编辑器 统计文件\nwc \u0026lt;文件\u0026gt; - 统计文件 wc -l \u0026lt;文件\u0026gt; - 统计行数 wc -w \u0026lt;文件\u0026gt; - 统计单词数 wc -c \u0026lt;文件\u0026gt; - 统计字节数 文件搜索和查找 find 命令\nfind \u0026lt;路径\u0026gt; -name \u0026lt;名称\u0026gt; - 按名称查找 find . -name \u0026quot;*.txt\u0026quot; - 查找所有 txt 文件 find . -type f -name \u0026quot;*.log\u0026quot; - 查找文件（不含目录） find . -type d -name \u0026quot;node_modules\u0026quot; - 查找目录 find . -mtime -7 - 查找 7 天内修改的文件 find . -size +100M - 查找大于 100MB 的文件 find . -name \u0026quot;*.tmp\u0026quot; -delete - 查找并删除 grep 命令\ngrep \u0026lt;模式\u0026gt; \u0026lt;文件\u0026gt; - 搜索文本 grep -r \u0026quot;TODO\u0026quot; . - 递归搜索当前目录 grep -i \u0026quot;error\u0026quot; log.txt - 忽略大小写 grep -n \u0026quot;function\u0026quot; code.js - 显示行号 grep -v \u0026quot;debug\u0026quot; log.txt - 反向匹配（不包含） grep -E \u0026quot;error|warning\u0026quot; log.txt - 使用正则表达式 grep -c \u0026quot;error\u0026quot; log.txt - 统计匹配行数 其他查找工具\nlocate \u0026lt;文件名\u0026gt; - 快速查找文件 updatedb - 更新 locate 数据库 which \u0026lt;命令\u0026gt; - 查找命令位置 whereis \u0026lt;程序\u0026gt; - 查找程序位置 文件权限 chmod \u0026lt;权限\u0026gt; \u0026lt;文件\u0026gt; - 修改文件权限 chmod 755 script.sh - 数字方式（rwxr-xr-x） chmod +x script.sh - 添加执行权限 chmod -R 644 directory/ - 递归修改 chown \u0026lt;用户\u0026gt;:\u0026lt;组\u0026gt; \u0026lt;文件\u0026gt; - 修改所有者 chgrp \u0026lt;组\u0026gt; \u0026lt;文件\u0026gt; - 修改所属组 umask - 查看或设置默认权限掩码 进程管理 查看进程\nps - 查看进程 ps aux - 查看所有进程详细信息 ps -ef - 另一种格式 ps aux | grep \u0026lt;进程名\u0026gt; - 搜索特定进程 top - 实时查看系统资源（按 q 退出） htop - 增强版 top 管理进程\nkill \u0026lt;PID\u0026gt; - 结束进程 kill -9 \u0026lt;PID\u0026gt; - 强制结束 killall \u0026lt;进程名\u0026gt; - 按名称结束进程 pkill \u0026lt;进程名\u0026gt; - 按模式匹配结束 bg - 将任务放到后台 fg - 将后台任务调到前台 jobs - 查看后台任务 nohup \u0026lt;命令\u0026gt; \u0026amp; - 后台运行，不受终端关闭影响 磁盘和存储 df -h - 查看磁盘使用情况 du -sh \u0026lt;目录\u0026gt; - 查看目录大小 du -h --max-depth=1 - 查看各子目录大小 du -sh * | sort -h - 按大小排序 free -h - 查看内存使用 lsblk - 列出块设备 mount - 挂载文件系统 umount - 卸载文件系统 系统信息 uname -a - 完整系统信息 uname -r - 内核版本 hostname - 主机名 whoami - 当前用户 id - 用户 ID 和组 ID uptime - 系统运行时间和负载 date - 系统时间 cal - 日历 lsb_release -a - Linux 发行版信息（Ubuntu/Debian） cat /etc/os-release - 系统版本信息 网络操作 连接测试\nping \u0026lt;地址\u0026gt; - 测试网络连接 ping -c 4 google.com - 发送 4 个包后停止 traceroute \u0026lt;地址\u0026gt; - 追踪路由路径 文件传输\ncurl \u0026lt;URL\u0026gt; - 发送 HTTP 请求 curl -O \u0026lt;URL\u0026gt; - 下载文件（保持原文件名） curl -o \u0026lt;文件名\u0026gt; \u0026lt;URL\u0026gt; - 下载并重命名 curl -I \u0026lt;URL\u0026gt; - 只获取 HTTP 头 curl -X POST -d \u0026quot;data\u0026quot; \u0026lt;URL\u0026gt; - 发送 POST 请求 wget \u0026lt;URL\u0026gt; - 下载文件 wget -c \u0026lt;URL\u0026gt; - 断点续传 远程连接\nssh \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt; - SSH 连接 ssh -p \u0026lt;端口\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt; - 指定端口 scp \u0026lt;源\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt;:\u0026lt;目标\u0026gt; - 安全复制文件 scp -r \u0026lt;目录\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt;:\u0026lt;目标\u0026gt; - 复制目录 网络信息\nnetstat -tuln - 查看网络端口（传统） ss -tuln - 查看网络端口（现代） ip addr / ifconfig - 查看网络接口 nslookup \u0026lt;域名\u0026gt; - DNS 查询 dig \u0026lt;域名\u0026gt; - DNS 详细查询 压缩和解压 tar 格式\ntar -czf \u0026lt;文件.tar.gz\u0026gt; \u0026lt;目录\u0026gt; - 压缩为 tar.gz tar -xzf \u0026lt;文件.tar.gz\u0026gt; - 解压 tar.gz tar -xzf \u0026lt;文件.tar.gz\u0026gt; -C \u0026lt;目标目录\u0026gt; - 解压到指定目录 tar -tvf \u0026lt;文件.tar.gz\u0026gt; - 查看压缩包内容 zip 格式\nzip -r \u0026lt;文件.zip\u0026gt; \u0026lt;目录\u0026gt; - 创建 zip 压缩包 unzip \u0026lt;文件.zip\u0026gt; - 解压 zip unzip \u0026lt;文件.zip\u0026gt; -d \u0026lt;目标目录\u0026gt; - 解压到指定目录 gzip 格式\ngzip \u0026lt;文件\u0026gt; - 压缩为 .gz gunzip \u0026lt;文件.gz\u0026gt; - 解压 .gz 文本处理工具 sed（流编辑器）\nsed 's/old/new/g' file.txt - 替换文本 sed -i 's/old/new/g' file.txt - 直接修改文件 awk（文本处理）\nawk '{print $1}' file.txt - 打印第一列 awk -F',' '{print $2}' file.csv - 指定分隔符 排序和去重\nsort \u0026lt;文件\u0026gt; - 排序 sort -r \u0026lt;文件\u0026gt; - 反向排序 sort -n \u0026lt;文件\u0026gt; - 按数字排序 uniq \u0026lt;文件\u0026gt; - 去除重复行 sort file.txt | uniq - 配合使用 uniq -c \u0026lt;文件\u0026gt; - 统计重复次数 其他工具\ncut -d',' -f1,3 file.csv - 按分隔符提取列 tr 'a-z' 'A-Z' \u0026lt; file.txt - 字符转换 系统管理 用户管理\nsudo \u0026lt;命令\u0026gt; - 以管理员权限执行 su - 切换用户 su - - 切换到 root passwd - 修改密码 useradd \u0026lt;用户名\u0026gt; - 创建用户 userdel \u0026lt;用户名\u0026gt; - 删除用户 usermod -aG \u0026lt;组\u0026gt; \u0026lt;用户\u0026gt; - 添加用户到组 服务管理（systemd）\nsystemctl start \u0026lt;服务\u0026gt; - 启动服务 systemctl stop \u0026lt;服务\u0026gt; - 停止服务 systemctl restart \u0026lt;服务\u0026gt; - 重启服务 systemctl status \u0026lt;服务\u0026gt; - 查看状态 systemctl enable \u0026lt;服务\u0026gt; - 设置开机启动 journalctl -u \u0026lt;服务\u0026gt; - 查看服务日志 实用快捷键 Ctrl + C - 终止当前命令 Ctrl + Z - 暂停当前命令 Ctrl + D - 退出终端 Ctrl + L - 清屏 Ctrl + A - 光标移到行首 Ctrl + E - 光标移到行尾 Ctrl + U - 删除光标前的内容 Ctrl + K - 删除光标后的内容 Ctrl + R - 搜索命令历史 Tab - 自动补全 !! - 执行上一条命令 !$ - 上一条命令的最后一个参数 其他实用命令 clear - 清屏 history - 查看命令历史 history | grep \u0026lt;关键词\u0026gt; - 搜索历史命令 echo \u0026lt;文本\u0026gt; - 输出文本 echo \u0026quot;text\u0026quot; \u0026gt; file.txt - 覆盖写入 echo \u0026quot;text\u0026quot; \u0026gt;\u0026gt; file.txt - 追加写入 alias \u0026lt;别名\u0026gt;='\u0026lt;命令\u0026gt;' - 创建别名 watch \u0026lt;命令\u0026gt; - 定期执行命令 watch -n 2 df -h - 每 2 秒更新 xargs - 将标准输入转换为命令参数 tee \u0026lt;文件\u0026gt; - 同时输出到文件和标准输出 Git 常用指令 初始化和配置 初始化仓库\ngit init - 初始化新仓库 git clone \u0026lt;URL\u0026gt; - 克隆远程仓库 git clone \u0026lt;URL\u0026gt; \u0026lt;目录名\u0026gt; - 克隆到指定目录 git clone --depth 1 \u0026lt;URL\u0026gt; - 浅克隆（只克隆最新提交） git clone -b \u0026lt;分支名\u0026gt; \u0026lt;URL\u0026gt; - 克隆指定分支 配置 Git\ngit config --global user.name \u0026quot;\u0026lt;名字\u0026gt;\u0026quot; - 设置用户名 git config --global user.email \u0026quot;\u0026lt;邮箱\u0026gt;\u0026quot; - 设置邮箱 git config --list - 查看所有配置 git config --global core.editor \u0026quot;vim\u0026quot; - 设置编辑器 git config --global alias.st status - 设置别名 基本操作 查看状态\ngit status - 查看工作区状态 git status -s - 简短格式 添加和提交\ngit add \u0026lt;文件\u0026gt; - 添加文件到暂存区 git add . - 添加所有修改 git add -A - 添加所有变化（包括删除） git add -p - 交互式添加 git commit -m \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 提交 git commit -am \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 添加并提交已跟踪文件 git commit --amend - 修改最后一次提交 git commit --amend --no-edit - 修改提交但不改消息 推送和拉取\ngit push - 推送到远程 git push origin \u0026lt;分支名\u0026gt; - 推送指定分支 git push -u origin \u0026lt;分支名\u0026gt; - 推送并设置上游 git push --force / git push -f - 强制推送（危险！） git push --tags - 推送标签 git pull - 拉取并合并 git pull --rebase - 使用 rebase 方式拉取 git fetch - 获取但不合并 git fetch --all - 获取所有远程分支 git fetch --prune - 获取并清理已删除的远程分支 分支操作 查看分支\ngit branch - 查看本地分支 git branch -a - 查看所有分支（包括远程） git branch -r - 只查看远程分支 git branch -v - 查看分支及最后一次提交 创建和切换分支\ngit branch \u0026lt;分支名\u0026gt; - 创建分支 git checkout \u0026lt;分支名\u0026gt; - 切换分支 git checkout -b \u0026lt;分支名\u0026gt; - 创建并切换 git checkout -b \u0026lt;分支名\u0026gt; origin/\u0026lt;分支名\u0026gt; - 从远程分支创建 git switch \u0026lt;分支名\u0026gt; - 切换分支（新语法） git switch -c \u0026lt;分支名\u0026gt; - 创建并切换（新语法） 合并和删除分支\ngit merge \u0026lt;分支名\u0026gt; - 合并分支 git merge --no-ff \u0026lt;分支名\u0026gt; - 非快进合并 git merge --squash \u0026lt;分支名\u0026gt; - 压缩合并 git branch -d \u0026lt;分支名\u0026gt; - 删除已合并分支 git branch -D \u0026lt;分支名\u0026gt; - 强制删除分支 git branch -m \u0026lt;旧名\u0026gt; \u0026lt;新名\u0026gt; - 重命名分支 git push origin --delete \u0026lt;分支名\u0026gt; - 删除远程分支 查看历史 日志查看\ngit log - 查看提交历史 git log --oneline - 每个提交一行 git log --graph - 图形化显示 git log --oneline --graph --all - 图形化显示所有分支 git log -p - 显示详细差异 git log --author=\u0026quot;\u0026lt;作者\u0026gt;\u0026quot; - 按作者筛选 git log --since=\u0026quot;2 weeks ago\u0026quot; - 按时间筛选 git log --grep=\u0026quot;\u0026lt;关键词\u0026gt;\u0026quot; - 搜索提交消息 git log \u0026lt;文件\u0026gt; - 查看文件历史 git log --stat - 显示文件统计 差异比较\ngit diff - 查看未暂存的更改 git diff --staged / git diff --cached - 查看已暂存的更改 git diff \u0026lt;分支1\u0026gt; \u0026lt;分支2\u0026gt; - 比较分支 git diff \u0026lt;提交1\u0026gt; \u0026lt;提交2\u0026gt; - 比较提交 git diff HEAD - 比较工作区和最新提交 其他查看命令\ngit show \u0026lt;提交\u0026gt; - 查看提交详情 git show HEAD - 查看最新提交 git blame \u0026lt;文件\u0026gt; - 查看每行的修改者 git shortlog - 按作者分组显示 撤销和回退 撤销修改\ngit restore \u0026lt;文件\u0026gt; - 撤销工作区修改（新语法） git restore --staged \u0026lt;文件\u0026gt; - 取消暂存（新语法） git checkout -- \u0026lt;文件\u0026gt; - 撤销修改（旧语法） 重置提交\ngit reset \u0026lt;文件\u0026gt; - 取消暂存 git reset HEAD~ - 撤销最后一次提交，保留更改 git reset --soft HEAD~ - 撤销提交，更改在暂存区 git reset --hard HEAD~ - 撤销提交并丢弃更改（危险！） git reset --hard \u0026lt;提交\u0026gt; - 重置到指定提交 回退操作\ngit revert \u0026lt;提交\u0026gt; - 创建新提交来撤销 git revert HEAD - 撤销最新提交 git clean -fd - 删除未跟踪的文件 git clean -n - 预览将要删除的文件 暂存操作（Stash） git stash - 暂存当前更改 git stash save \u0026quot;描述\u0026quot; - 暂存并添加描述 git stash list - 查看暂存列表 git stash pop - 恢复并删除最新暂存 git stash apply - 恢复但不删除暂存 git stash apply stash@{0} - 恢复指定暂存 git stash drop - 删除最新暂存 git stash drop stash@{0} - 删除指定暂存 git stash clear - 清空所有暂存 git stash show - 查看暂存内容 远程仓库 查看远程\ngit remote - 查看远程仓库 git remote -v - 查看详细信息 管理远程\ngit remote add \u0026lt;名称\u0026gt; \u0026lt;URL\u0026gt; - 添加远程仓库 git remote add origin \u0026lt;URL\u0026gt; - 添加 origin git remote remove \u0026lt;名称\u0026gt; - 删除远程仓库 git remote rename \u0026lt;旧名\u0026gt; \u0026lt;新名\u0026gt; - 重命名 git remote set-url \u0026lt;名称\u0026gt; \u0026lt;新URL\u0026gt; - 修改 URL git remote show \u0026lt;名称\u0026gt; - 查看详细信息 git remote prune origin - 清理已删除的远程分支引用 标签操作 git tag - 查看所有标签 git tag \u0026lt;标签名\u0026gt; - 创建轻量标签 git tag -a \u0026lt;标签名\u0026gt; -m \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 创建带注释的标签 git tag -d \u0026lt;标签名\u0026gt; - 删除本地标签 git push origin \u0026lt;标签名\u0026gt; - 推送标签 git push origin --tags - 推送所有标签 git push origin :refs/tags/\u0026lt;标签名\u0026gt; - 删除远程标签 高级操作 变基（Rebase）\ngit rebase \u0026lt;分支\u0026gt; - 变基到指定分支 git rebase -i HEAD~3 - 交互式变基最近 3 个提交 git rebase --continue - 解决冲突后继续 git rebase --abort - 取消变基 其他高级命令\ngit cherry-pick \u0026lt;提交\u0026gt; - 将指定提交应用到当前分支 git reflog - 查看引用日志（恢复丢失的提交） git bisect start - 开始二分查找问题提交 git submodule add \u0026lt;URL\u0026gt; - 添加子模块 git submodule update --init - 初始化并更新子模块 .gitignore 配置 New-Item -ItemType File .gitignore创建 .gitignore 文件来忽略不需要跟踪的文件：\n# 忽略日志文件 *.log # 忽略 node_modules 目录 node_modules/ # 忽略环境变量文件 .env .env.local # 忽略构建输出 dist/ build/ # 忽略操作系统文件 .DS_Store Thumbs.db # 忽略 IDE 配置 .vscode/ .idea/ GitHub CLI 常用指令 认证 gh auth login - 登录 GitHub 账号 gh auth status - 查看认证状态 gh auth logout - 登出 gh auth refresh - 刷新令牌 gh config set editor vim - 设置编辑器 仓库操作 创建和克隆\ngh repo create - 创建仓库 gh repo create \u0026lt;名称\u0026gt; - 创建指定名称的仓库 gh repo create --public - 创建公开仓库 gh repo create --private - 创建私有仓库 gh repo create --clone - 创建并克隆 gh repo clone \u0026lt;仓库\u0026gt; - 克隆仓库 gh repo clone owner/repo - 克隆指定仓库 查看和管理\ngh repo view - 查看仓库信息 gh repo view --web - 在浏览器中打开 gh repo list - 列出仓库 gh repo list \u0026lt;用户名\u0026gt; - 列出指定用户的仓库 gh repo list --limit 50 - 限制显示数量 gh repo fork - Fork 仓库 gh repo fork --clone - Fork 并克隆 gh repo delete \u0026lt;仓库\u0026gt; - 删除仓库 gh repo rename \u0026lt;新名称\u0026gt; - 重命名仓库 or gh repo rename owner/repo 新名字 gh repo sync - 同步 fork Pull Request 创建 PR\ngh pr create - 创建 PR gh pr create --title \u0026quot;标题\u0026quot; --body \u0026quot;描述\u0026quot; - 指定标题和描述 gh pr create --web - 在浏览器中创建 gh pr create --draft - 创建草稿 PR 查看 PR\ngh pr list - 列出 PR gh pr list --state open - 只显示开放的 gh pr list --author \u0026lt;用户名\u0026gt; - 按作者筛选 gh pr list --label \u0026lt;标签\u0026gt; - 按标签筛选 gh pr view \u0026lt;编号\u0026gt; - 查看详情 gh pr view \u0026lt;编号\u0026gt; --web - 在浏览器中查看 gh pr view \u0026lt;编号\u0026gt; --comments - 查看评论 操作 PR\ngh pr checkout \u0026lt;编号\u0026gt; - 检出 PR 分支 gh pr diff \u0026lt;编号\u0026gt; - 查看差异 gh pr merge \u0026lt;编号\u0026gt; - 合并 PR gh pr merge \u0026lt;编号\u0026gt; --squash - 压缩合并 gh pr merge \u0026lt;编号\u0026gt; --rebase - 变基合并 gh pr close \u0026lt;编号\u0026gt; - 关闭 PR gh pr reopen \u0026lt;编号\u0026gt; - 重新打开 gh pr ready \u0026lt;编号\u0026gt; - 标记为准备好 审查 PR\ngh pr review \u0026lt;编号\u0026gt; - 审查 PR gh pr review \u0026lt;编号\u0026gt; --approve - 批准 gh pr review \u0026lt;编号\u0026gt; --request-changes - 请求更改 gh pr review \u0026lt;编号\u0026gt; --comment - 添加评论 gh pr checks \u0026lt;编号\u0026gt; - 查看 CI/CD 状态 Issue 创建 Issue\ngh issue create - 创建 Issue gh issue create --title \u0026quot;标题\u0026quot; --body \u0026quot;描述\u0026quot; - 指定内容 gh issue create --web - 在浏览器中创建 gh issue create --label \u0026quot;bug,help wanted\u0026quot; - 添加标签 查看 Issue\ngh issue list - 列出 Issues gh issue list --state open - 只显示开放的 gh issue list --assignee \u0026lt;用户名\u0026gt; - 按指派人筛选 gh issue list --label \u0026lt;标签\u0026gt; - 按标签筛选 gh issue list --author \u0026lt;用户名\u0026gt; - 按作者筛选 gh issue view \u0026lt;编号\u0026gt; - 查看详情 gh issue view \u0026lt;编号\u0026gt; --web - 在浏览器中查看 操作 Issue\ngh issue close \u0026lt;编号\u0026gt; - 关闭 Issue gh issue close \u0026lt;编号\u0026gt; --comment \u0026quot;已修复\u0026quot; - 关闭并评论 gh issue reopen \u0026lt;编号\u0026gt; - 重新打开 gh issue edit \u0026lt;编号\u0026gt; - 编辑 Issue gh issue edit \u0026lt;编号\u0026gt; --add-label \u0026quot;bug\u0026quot; - 添加标签 gh issue comment \u0026lt;编号\u0026gt; - 添加评论 gh issue status - 查看状态 Gist gh gist create \u0026lt;文件\u0026gt; - 创建 Gist gh gist create --public \u0026lt;文件\u0026gt; - 创建公开 Gist gh gist create --desc \u0026quot;描述\u0026quot; \u0026lt;文件\u0026gt; - 添加描述 gh gist list - 列出 Gists gh gist view \u0026lt;ID\u0026gt; - 查看 Gist gh gist view \u0026lt;ID\u0026gt; --web - 在浏览器中查看 gh gist edit \u0026lt;ID\u0026gt; - 编辑 Gist gh gist delete \u0026lt;ID\u0026gt; - 删除 Gist gh gist clone \u0026lt;ID\u0026gt; - 克隆到本地 Release 创建和查看\ngh release create \u0026lt;标签\u0026gt; - 创建 Release gh release create v1.0.0 --title \u0026quot;版本 1.0.0\u0026quot; --notes \u0026quot;说明\u0026quot; - 指定内容 gh release create v1.0.0 *.zip - 附加文件 gh release create v1.0.0 --draft - 创建草稿 gh release list - 列出所有 Releases gh release view \u0026lt;标签\u0026gt; - 查看详情 gh release view \u0026lt;标签\u0026gt; --web - 在浏览器中查看 下载和管理\ngh release download \u0026lt;标签\u0026gt; - 下载资源 gh release download \u0026lt;标签\u0026gt; --pattern \u0026quot;*.zip\u0026quot; - 下载匹配文件 gh release delete \u0026lt;标签\u0026gt; - 删除 Release gh release upload \u0026lt;标签\u0026gt; \u0026lt;文件\u0026gt; - 上传文件 GitHub Actions 工作流管理\ngh workflow list - 列出工作流 gh workflow view \u0026lt;工作流\u0026gt; - 查看详情 gh workflow view \u0026lt;工作流\u0026gt; --web - 在浏览器中查看 gh workflow run \u0026lt;工作流\u0026gt; - 触发工作流 gh workflow run \u0026lt;工作流\u0026gt; --ref \u0026lt;分支\u0026gt; - 在指定分支运行 运行管理\ngh run list - 列出运行记录 gh run list --workflow \u0026lt;工作流名\u0026gt; - 按工作流筛选 gh run view \u0026lt;运行ID\u0026gt; - 查看详情 gh run view \u0026lt;运行ID\u0026gt; --log - 查看日志 gh run watch \u0026lt;运行ID\u0026gt; - 实时查看状态 gh run rerun \u0026lt;运行ID\u0026gt; - 重新运行 gh run cancel \u0026lt;运行ID\u0026gt; - 取消运行 其他功能 浏览和搜索\ngh browse - 在浏览器中打开仓库 gh browse \u0026lt;文件\u0026gt; - 打开指定文件 gh browse --settings - 打开设置 gh search repos \u0026lt;关键词\u0026gt; - 搜索仓库 gh search repos --stars \u0026quot;\u0026gt;1000\u0026quot; - 按星标搜索 gh search repos --language python - 按语言搜索 gh search issues \u0026lt;关键词\u0026gt; - 搜索 Issues gh search prs \u0026lt;关键词\u0026gt; - 搜索 PRs API 和扩展\ngh api \u0026lt;端点\u0026gt; - 调用 GitHub API gh api user - 获取用户信息 gh alias set \u0026lt;别名\u0026gt; \u0026lt;命令\u0026gt; - 创建别名 gh extension install \u0026lt;扩展\u0026gt; - 安装扩展 gh extension list - 列出扩展 标签和项目\ngh label list - 列出标签 gh label create \u0026lt;名称\u0026gt; - 创建标签 gh project list - 列出项目 gh project view \u0026lt;编号\u0026gt; - 查看项目 ","permalink":"http://localhost:1313/doc-intro/command-reference/","summary":"详细的命令行指令参考手册，包含 Windows PowerShell、Linux Terminal、Git 和 GitHub CLI 的常用命令及实用技巧","title":"常用命令行指令参考"},{"content":"一、数据库操作 1.1 创建和删除数据库 -- 创建数据库 CREATE DATABASE database_name; CREATE DATABASE IF NOT EXISTS database_name CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; -- 删除数据库 DROP DATABASE database_name; DROP DATABASE IF EXISTS database_name; -- 查看所有数据库 SHOW DATABASES; -- 选择数据库 USE database_name; -- 查看当前数据库 SELECT DATABASE(); 二、数据表操作 2.1 创建表 -- 基础创建表 CREATE TABLE users ( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(50) NOT NULL UNIQUE, email VARCHAR(100), age INT DEFAULT 0, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ); -- 创建表时指定引擎和字符集 CREATE TABLE products ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(100) NOT NULL, price DECIMAL(10, 2), stock INT DEFAULT 0 ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; -- 从查询结果创建表 CREATE TABLE users_backup AS SELECT * FROM users; 2.2 修改表结构 -- 添加列 ALTER TABLE users ADD COLUMN phone VARCHAR(20); ALTER TABLE users ADD COLUMN address TEXT AFTER email; -- 修改列 ALTER TABLE users MODIFY COLUMN age TINYINT; ALTER TABLE users CHANGE COLUMN username user_name VARCHAR(60); -- 删除列 ALTER TABLE users DROP COLUMN phone; -- 重命名表 RENAME TABLE users TO members; ALTER TABLE members RENAME TO users; -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键 ALTER TABLE users DROP PRIMARY KEY; -- 添加索引 ALTER TABLE users ADD INDEX idx_username (username); ALTER TABLE users ADD UNIQUE INDEX idx_email (email); -- 删除索引 ALTER TABLE users DROP INDEX idx_username; 2.3 查看表信息 -- 查看所有表 SHOW TABLES; -- 查看表结构 DESC users; DESCRIBE users; SHOW COLUMNS FROM users; -- 查看创建表的语句 SHOW CREATE TABLE users; -- 查看表状态 SHOW TABLE STATUS LIKE \u0026#39;users\u0026#39;; 2.4 删除和清空表 -- 删除表 DROP TABLE users; DROP TABLE IF EXISTS users; -- 清空表数据（保留结构） TRUNCATE TABLE users; DELETE FROM users; -- 与 TRUNCATE 的区别是可以回滚 三、数据操作（CRUD） 3.1 插入数据（INSERT） -- 插入单条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;, 25); -- 插入多条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;李四\u0026#39;, \u0026#39;lisi@example.com\u0026#39;, 28), (\u0026#39;王五\u0026#39;, \u0026#39;wangwu@example.com\u0026#39;, 30); -- 插入所有列（可省略列名） INSERT INTO users VALUES (NULL, \u0026#39;赵六\u0026#39;, \u0026#39;zhaoliu@example.com\u0026#39;, 22, NOW(), NOW()); -- 插入或更新（存在则更新） INSERT INTO users (id, username, email) VALUES (1, \u0026#39;张三\u0026#39;, \u0026#39;new@example.com\u0026#39;) ON DUPLICATE KEY UPDATE email = \u0026#39;new@example.com\u0026#39;; -- 忽略重复插入错误 INSERT IGNORE INTO users (username, email) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;); -- 从其他表插入数据 INSERT INTO users_backup SELECT * FROM users WHERE age \u0026gt; 25; 3.2 查询数据（SELECT） 基础查询 -- 查询所有列 SELECT * FROM users; -- 查询指定列 SELECT username, email FROM users; -- 使用别名 SELECT username AS name, email AS mail FROM users; -- 去重查询 SELECT DISTINCT age FROM users; -- 限制结果数量 SELECT * FROM users LIMIT 10; SELECT * FROM users LIMIT 10, 20; -- 跳过前10条，取20条 SELECT * FROM users LIMIT 20 OFFSET 10; -- 同上 WHERE 条件查询 -- 基本条件 SELECT * FROM users WHERE age \u0026gt; 25; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users WHERE email IS NULL; SELECT * FROM users WHERE email IS NOT NULL; -- 多条件组合 SELECT * FROM users WHERE age \u0026gt; 20 AND age \u0026lt; 30; SELECT * FROM users WHERE age BETWEEN 20 AND 30; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39; OR username = \u0026#39;李四\u0026#39;; SELECT * FROM users WHERE username IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;); SELECT * FROM users WHERE username NOT IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;); -- 模糊查询 SELECT * FROM users WHERE username LIKE \u0026#39;张%\u0026#39;; -- 以\u0026#34;张\u0026#34;开头 SELECT * FROM users WHERE username LIKE \u0026#39;%三\u0026#39;; -- 以\u0026#34;三\u0026#34;结尾 SELECT * FROM users WHERE username LIKE \u0026#39;%张%\u0026#39;; -- 包含\u0026#34;张\u0026#34; SELECT * FROM users WHERE username LIKE \u0026#39;张_\u0026#39;; -- 张+一个字符 SELECT * FROM users WHERE username NOT LIKE \u0026#39;张%\u0026#39;; 排序和分组 -- 排序 SELECT * FROM users ORDER BY age ASC; -- 升序（默认） SELECT * FROM users ORDER BY age DESC; -- 降序 SELECT * FROM users ORDER BY age DESC, username ASC; -- 多列排序 -- 分组 SELECT age, COUNT(*) as count FROM users GROUP BY age; SELECT age, AVG(age) as avg_age FROM users GROUP BY age; -- HAVING 过滤分组结果 SELECT age, COUNT(*) as count FROM users GROUP BY age HAVING count \u0026gt; 5; 聚合函数 -- 计数 SELECT COUNT(*) FROM users; SELECT COUNT(DISTINCT age) FROM users; -- 求和、平均、最大、最小 SELECT SUM(age) FROM users; SELECT AVG(age) FROM users; SELECT MAX(age) FROM users; SELECT MIN(age) FROM users; -- 多个聚合函数 SELECT COUNT(*) as total, AVG(age) as avg_age, MAX(age) as max_age FROM users; 连接查询（JOIN） -- 内连接（INNER JOIN） SELECT users.username, orders.order_no FROM users INNER JOIN orders ON users.id = orders.user_id; -- 左连接（LEFT JOIN） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id; -- 右连接（RIGHT JOIN） SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 全连接（FULL JOIN，MySQL不直接支持，需要用UNION） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id UNION SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 自连接 SELECT a.username, b.username as friend FROM users a INNER JOIN users b ON a.friend_id = b.id; -- 多表连接 SELECT u.username, o.order_no, p.product_name FROM users u INNER JOIN orders o ON u.id = o.user_id INNER JOIN order_items oi ON o.id = oi.order_id INNER JOIN products p ON oi.product_id = p.id; 子查询 -- WHERE 子查询 SELECT * FROM users WHERE id IN (SELECT user_id FROM orders WHERE amount \u0026gt; 1000); -- FROM 子查询 SELECT avg_age FROM (SELECT AVG(age) as avg_age FROM users GROUP BY city) as subquery; -- EXISTS 子查询 SELECT * FROM users WHERE EXISTS (SELECT 1 FROM orders WHERE orders.user_id = users.id); -- 标量子查询 SELECT username, (SELECT COUNT(*) FROM orders WHERE user_id = users.id) as order_count FROM users; 联合查询（UNION） -- UNION（去重） SELECT username FROM users WHERE age \u0026gt; 30 UNION SELECT username FROM admins WHERE age \u0026gt; 30; -- UNION ALL（不去重，性能更好） SELECT username FROM users WHERE age \u0026gt; 30 UNION ALL SELECT username FROM admins WHERE age \u0026gt; 30; 3.3 更新数据（UPDATE） -- 更新单列 UPDATE users SET age = 26 WHERE username = \u0026#39;张三\u0026#39;; -- 更新多列 UPDATE users SET age = 26, email = \u0026#39;new@example.com\u0026#39; WHERE username = \u0026#39;张三\u0026#39;; -- 批量更新 UPDATE users SET age = age + 1 WHERE age \u0026lt; 30; -- 使用表达式更新 UPDATE users SET updated_at = NOW() WHERE id = 1; -- 基于其他表更新 UPDATE users u INNER JOIN orders o ON u.id = o.user_id SET u.total_orders = u.total_orders + 1 WHERE o.created_at \u0026gt; \u0026#39;2024-01-01\u0026#39;; -- 条件更新（CASE） UPDATE users SET level = CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END; 3.4 删除数据（DELETE） -- 删除指定数据 DELETE FROM users WHERE id = 1; -- 批量删除 DELETE FROM users WHERE age \u0026lt; 18; -- 删除所有数据 DELETE FROM users; -- 基于其他表删除 DELETE u FROM users u INNER JOIN orders o ON u.id = o.user_id WHERE o.status = \u0026#39;cancelled\u0026#39;; 四、索引管理 4.1 创建索引 -- 普通索引 CREATE INDEX idx_username ON users(username); -- 唯一索引 CREATE UNIQUE INDEX idx_email ON users(email); -- 复合索引 CREATE INDEX idx_name_age ON users(username, age); -- 全文索引 CREATE FULLTEXT INDEX idx_content ON articles(content); -- 在创建表时添加索引 CREATE TABLE users ( id INT PRIMARY KEY, username VARCHAR(50), email VARCHAR(100), INDEX idx_username (username), UNIQUE INDEX idx_email (email) ); 4.2 查看和删除索引 -- 查看索引 SHOW INDEX FROM users; -- 删除索引 DROP INDEX idx_username ON users; ALTER TABLE users DROP INDEX idx_username; 五、约束管理 5.1 主键约束 -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键（需要先删除 AUTO_INCREMENT 属性） ALTER TABLE users MODIFY id INT; ALTER TABLE users DROP PRIMARY KEY; 5.2 外键约束 -- 添加外键 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id); -- 添加外键时设置级联操作 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE; -- 删除外键 ALTER TABLE orders DROP FOREIGN KEY fk_user_id; 5.3 其他约束 -- 唯一约束 ALTER TABLE users ADD UNIQUE (email); -- 非空约束 ALTER TABLE users MODIFY username VARCHAR(50) NOT NULL; -- 检查约束（MySQL 8.0.16+） ALTER TABLE users ADD CONSTRAINT chk_age CHECK (age \u0026gt;= 0 AND age \u0026lt;= 150); -- 默认值约束 ALTER TABLE users ALTER COLUMN status SET DEFAULT \u0026#39;active\u0026#39;; 六、视图 -- 创建视图 CREATE VIEW active_users AS SELECT id, username, email FROM users WHERE status = \u0026#39;active\u0026#39;; -- 创建或替换视图 CREATE OR REPLACE VIEW active_users AS SELECT id, username, email, age FROM users WHERE status = \u0026#39;active\u0026#39;; -- 查询视图 SELECT * FROM active_users; -- 查看视图定义 SHOW CREATE VIEW active_users; -- 删除视图 DROP VIEW active_users; DROP VIEW IF EXISTS active_users; 七、事务处理 -- 开启事务 START TRANSACTION; -- 或 BEGIN; -- 提交事务 COMMIT; -- 回滚事务 ROLLBACK; -- 设置保存点 SAVEPOINT sp1; ROLLBACK TO sp1; -- 完整示例 START TRANSACTION; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; COMMIT; -- 设置自动提交 SET autocommit = 0; -- 关闭自动提交 SET autocommit = 1; -- 开启自动提交 八、存储过程和函数 8.1 存储过程 -- 创建存储过程 DELIMITER // CREATE PROCEDURE GetUserById(IN userId INT) BEGIN SELECT * FROM users WHERE id = userId; END // DELIMITER ; -- 调用存储过程 CALL GetUserById(1); -- 带输出参数的存储过程 DELIMITER // CREATE PROCEDURE GetUserCount(OUT total INT) BEGIN SELECT COUNT(*) INTO total FROM users; END // DELIMITER ; CALL GetUserCount(@count); SELECT @count; -- 删除存储过程 DROP PROCEDURE IF EXISTS GetUserById; -- 查看存储过程 SHOW PROCEDURE STATUS; SHOW CREATE PROCEDURE GetUserById; 8.2 函数 -- 创建函数 DELIMITER // CREATE FUNCTION GetUserAge(userId INT) RETURNS INT BEGIN DECLARE userAge INT; SELECT age INTO userAge FROM users WHERE id = userId; RETURN userAge; END // DELIMITER ; -- 使用函数 SELECT GetUserAge(1); -- 删除函数 DROP FUNCTION IF EXISTS GetUserAge; 九、触发器 -- 创建 BEFORE INSERT 触发器 DELIMITER // CREATE TRIGGER before_user_insert BEFORE INSERT ON users FOR EACH ROW BEGIN SET NEW.created_at = NOW(); END // DELIMITER ; -- 创建 AFTER UPDATE 触发器 DELIMITER // CREATE TRIGGER after_user_update AFTER UPDATE ON users FOR EACH ROW BEGIN INSERT INTO user_logs (user_id, action, created_at) VALUES (OLD.id, \u0026#39;update\u0026#39;, NOW()); END // DELIMITER ; -- 查看触发器 SHOW TRIGGERS; -- 删除触发器 DROP TRIGGER IF EXISTS before_user_insert; 十、用户和权限管理 -- 创建用户 CREATE USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; CREATE USER \u0026#39;username\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; -- 允许任何主机 -- 授予权限 GRANT ALL PRIVILEGES ON database_name.* TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; GRANT SELECT, INSERT, UPDATE ON database_name.table_name TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 刷新权限 FLUSH PRIVILEGES; -- 查看用户权限 SHOW GRANTS FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 撤销权限 REVOKE INSERT, UPDATE ON database_name.* FROM \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 修改密码 ALTER USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;new_password\u0026#39;; SET PASSWORD FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; = PASSWORD(\u0026#39;new_password\u0026#39;); -- 删除用户 DROP USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; 十一、备份和恢复 -- 使用 mysqldump 备份（在命令行执行） mysqldump -u username -p database_name \u0026gt; backup.sql mysqldump -u username -p database_name table_name \u0026gt; table_backup.sql mysqldump -u username -p --all-databases \u0026gt; all_databases.sql -- 恢复数据库（在命令行执行） mysql -u username -p database_name \u0026lt; backup.sql -- 导出为 CSV SELECT * FROM users INTO OUTFILE \u0026#39;/tmp/users.csv\u0026#39; FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; -- 从 CSV 导入 LOAD DATA INFILE \u0026#39;/tmp/users.csv\u0026#39; INTO TABLE users FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; 十二、性能优化相关 12.1 EXPLAIN 分析查询 -- 分析查询执行计划 EXPLAIN SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; -- 详细分析 EXPLAIN EXTENDED SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SHOW WARNINGS; -- JSON 格式 EXPLAIN FORMAT=JSON SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; 12.2 查询优化 -- 使用索引提示 SELECT * FROM users USE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users FORCE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users IGNORE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; -- 优化 COUNT SELECT COUNT(1) FROM users; -- 比 COUNT(*) 快一点 -- 分页优化（避免大 OFFSET） SELECT * FROM users WHERE id \u0026gt; 10000 ORDER BY id LIMIT 20; 12.3 查看状态和变量 -- 查看数据库状态 SHOW STATUS; SHOW STATUS LIKE \u0026#39;Threads%\u0026#39;; -- 查看系统变量 SHOW VARIABLES; SHOW VARIABLES LIKE \u0026#39;max_connections\u0026#39;; -- 查看进程列表 SHOW PROCESSLIST; SHOW FULL PROCESSLIST; -- 杀死进程 KILL process_id; 十三、常用字符串和日期函数 13.1 字符串函数 -- 字符串连接 SELECT CONCAT(\u0026#39;Hello\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;World\u0026#39;); SELECT CONCAT_WS(\u0026#39;-\u0026#39;, \u0026#39;2024\u0026#39;, \u0026#39;12\u0026#39;, \u0026#39;10\u0026#39;); -- 字符串长度 SELECT LENGTH(\u0026#39;Hello\u0026#39;), CHAR_LENGTH(\u0026#39;你好\u0026#39;); -- 大小写转换 SELECT UPPER(\u0026#39;hello\u0026#39;), LOWER(\u0026#39;HELLO\u0026#39;); -- 截取字符串 SELECT SUBSTRING(\u0026#39;Hello World\u0026#39;, 1, 5); SELECT LEFT(\u0026#39;Hello World\u0026#39;, 5), RIGHT(\u0026#39;Hello World\u0026#39;, 5); -- 替换和删除 SELECT REPLACE(\u0026#39;Hello World\u0026#39;, \u0026#39;World\u0026#39;, \u0026#39;MySQL\u0026#39;); SELECT TRIM(\u0026#39; Hello \u0026#39;), LTRIM(\u0026#39; Hello\u0026#39;), RTRIM(\u0026#39;Hello \u0026#39;); -- 查找位置 SELECT POSITION(\u0026#39;World\u0026#39; IN \u0026#39;Hello World\u0026#39;); SELECT LOCATE(\u0026#39;World\u0026#39;, \u0026#39;Hello World\u0026#39;); 13.2 日期时间函数 -- 获取当前时间 SELECT NOW(), CURDATE(), CURTIME(); SELECT CURRENT_TIMESTAMP(), CURRENT_DATE(), CURRENT_TIME(); -- 日期格式化 SELECT DATE_FORMAT(NOW(), \u0026#39;%Y-%m-%d %H:%i:%s\u0026#39;); SELECT DATE_FORMAT(NOW(), \u0026#39;%Y年%m月%d日\u0026#39;); -- 日期计算 SELECT date_add(\u0026#39;2023-01-01\u0026#39;, interval 1 day) 输出 \u0026#39;2023-01-02\u0026#39; SELECT date_sub(\u0026#39;2023-01-01\u0026#39;, interval 1 day) 输出 \u0026#39;2022-12-31\u0026#39; SELECT datediff(\u0026#39;2023-02-01\u0026#39;, \u0026#39;2023-01-01\u0026#39;) 输出31 -- 提取日期部分 SELECT YEAR(NOW()), MONTH(NOW()), DAY(NOW()); SELECT HOUR(NOW()), MINUTE(NOW()), SECOND(NOW()); -- 时间戳转换 SELECT UNIX_TIMESTAMP(NOW()); SELECT FROM_UNIXTIME(1702195200); 13.3 数学和其他函数 -- 数学函数 SELECT ROUND(3.14159, 2), CEIL(3.2), FLOOR(3.8); SELECT ABS(-5), MOD(10, 3), POWER(2, 3); SELECT RAND(), RAND()*100; -- 条件函数 SELECT IF(age \u0026gt; 18, \u0026#39;成年\u0026#39;, \u0026#39;未成年\u0026#39;) FROM users; SELECT IFNULL(email, \u0026#39;无邮箱\u0026#39;) FROM users; SELECT COALESCE(NULL, NULL, \u0026#39;default\u0026#39;, \u0026#39;value\u0026#39;); -- CASE 表达式 SELECT username, CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END as age_group FROM users; 十四、JSON 操作（MySQL 5.7+） -- 创建 JSON 列 CREATE TABLE products ( id INT PRIMARY KEY, name VARCHAR(100), attributes JSON ); -- 插入 JSON 数据 INSERT INTO products VALUES (1, \u0026#39;iPhone\u0026#39;, \u0026#39;{\u0026#34;color\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;storage\u0026#34;: \u0026#34;128GB\u0026#34;}\u0026#39;); -- 查询 JSON 数据 SELECT JSON_EXTRACT(attributes, \u0026#39;$.color\u0026#39;) as color FROM products; SELECT attributes-\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; SELECT attributes-\u0026gt;\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; -- 去除引号 -- 修改 JSON 数据 UPDATE products SET attributes = JSON_SET(attributes, \u0026#39;$.color\u0026#39;, \u0026#39;white\u0026#39;) WHERE id = 1; UPDATE products SET attributes = JSON_INSERT(attributes, \u0026#39;$.price\u0026#39;, 999) WHERE id = 1; UPDATE products SET attributes = JSON_REMOVE(attributes, \u0026#39;$.storage\u0026#39;) WHERE id = 1; -- JSON 数组操作 SELECT JSON_ARRAY(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;); SELECT JSON_CONTAINS(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;, \u0026#39;\u0026#34;a\u0026#34;\u0026#39;); SELECT JSON_LENGTH(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;); 十五、窗口函数（MySQL 8.0+） -- ROW_NUMBER：行号 SELECT username, age, ROW_NUMBER() OVER (ORDER BY age DESC) as row_num FROM users; -- RANK：排名（有并列，跳号） SELECT username, score, RANK() OVER (ORDER BY score DESC) as rank FROM students; -- DENSE_RANK：密集排名（有并列，不跳号） SELECT username, score, DENSE_RANK() OVER (ORDER BY score DESC) as rank FROM students; -- 分组窗口 SELECT department, username, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank FROM employees; -- 累计求和 SELECT username, amount, SUM(amount) OVER (ORDER BY created_at) as running_total FROM transactions; -- LAG 和 LEAD：访问上下行 SELECT username, salary, LAG(salary, 1) OVER (ORDER BY id) as prev_salary, LEAD(salary, 1) OVER (ORDER BY id) as next_salary FROM employees; 十六、常见问题和技巧 16.1 查找重复数据 -- 查找重复的用户名 SELECT username, COUNT(*) as count FROM users GROUP BY username HAVING count \u0026gt; 1; -- 删除重复数据（保留ID最小的） DELETE u1 FROM users u1 INNER JOIN users u2 WHERE u1.id \u0026gt; u2.id AND u1.username = u2.username; 16.2 随机获取数据 -- 随机获取一条数据 SELECT * FROM users ORDER BY RAND() LIMIT 1; -- 更高效的随机（大表适用） SELECT * FROM users WHERE id \u0026gt;= (SELECT FLOOR(MAX(id) * RAND()) FROM users) LIMIT 1; 16.3 行转列 -- 使用 CASE WHEN SELECT name, SUM(CASE WHEN subject = \u0026#39;语文\u0026#39; THEN score ELSE 0 END) as chinese, SUM(CASE WHEN subject = \u0026#39;数学\u0026#39; THEN score ELSE 0 END) as math FROM scores GROUP BY name; 16.4 列转行 -- 使用 UNION ALL SELECT name, \u0026#39;语文\u0026#39; as subject, chinese as score FROM scores UNION ALL SELECT name, \u0026#39;数学\u0026#39; as subject, math as score FROM scores; 十七、常用管理命令 -- 查看 MySQL 版本 SELECT VERSION(); -- 查看当前用户 SELECT USER(), CURRENT_USER(); -- 查看数据库大小 SELECT table_schema AS \u0026#39;Database\u0026#39;, ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables GROUP BY table_schema; -- 查看表大小 SELECT table_name AS \u0026#39;Table\u0026#39;, ROUND(((data_length + index_length) / 1024 / 1024), 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables WHERE table_schema = \u0026#39;database_name\u0026#39; ORDER BY (data_length + index_length) DESC; -- 修复表 REPAIR TABLE users; -- 优化表 OPTIMIZE TABLE users; -- 分析表 ANALYZE TABLE users; -- 检查表 CHECK TABLE users; 总结 这份笔记涵盖了 MySQL 从基础到进阶的大部分常用操作，当然也适合在刷题中补充，包括：\n数据库和表的管理 完整的 CRUD 操作 索引和约束 视图、事务、存储过程 用户权限管理 性能优化技巧 常用函数和 JSON、窗口函数！ ","permalink":"http://localhost:1313/database/mysql-cheatsheet/","summary":"MySQL 常用语句全面速查手册，涵盖从基础 CRUD 到高级特性（索引、事务、存储过程、窗口函数等）的所有常用操作，适合快速查阅和刷题使用","title":"MySQL 语句速查笔记"},{"content":"论文基本信息 标题: Linking Souls to Humans: Blockchain Accounts with Credible Anonymity for Web 3.0 Decentralized Identity 作者: Taotao Wang, Zibin Lin, Shengli Zhang, Long Shi, Qing Yang, Boris Düdder 会议: WWW \u0026lsquo;25 (ACM Web Conference 2025) 时间: 2025年4月28日-5月2日，悉尼 机构: 深圳大学、南京理工大学、哥本哈根大学 研究背景 数字身份的三个发展阶段 数字身份系统经历了三个演进阶段，分别对应互联网的三个时代：\n阶段 身份类型 对应时代 特点 问题 1 中心化身份 Web 1.0 用户创建，应用提供商管理 多账户管理复杂，数据泄露风险 2 联盟身份 Web 2.0 少数大型提供商管理，可跨应用使用 数据霸权，用户数据集中在少数巨头手中 3 去中心化身份 Web 3.0 用户自主创建和管理（自主权身份） 完全匿名导致无法追溯真实社交关系 Web 3.0的核心价值 Web 3.0的革命性转变在于：\n用户拥有数据主权 数据不被应用提供商占有 需要去中心化身份系统支撑 当前区块链账户系统的问题 区块链账户系统是Web 3.0去中心化身份的理想原型，但存在以下问题：\n完全匿名的缺陷： 用户可以无需认证创建多个账户 无法准确记录真实用户之间的社交关系和互动 用户与区块链身份之间的映射关系模糊 Soulbound Token的局限性： Vitalik Buterin提出的\u0026quot;灵魂\u0026quot;（Soul）概念和\u0026quot;灵魂绑定代币\u0026quot;（Soulbound Token） 用户仍可创建多个\u0026quot;灵魂\u0026quot;账户来抹除、转移或隐藏关系 无法真实反映人类社会中的真实关系 研究方案：zkBID 核心目标 zkBID（Zero-Knowledge Blockchain-account-based Web 3.0 decentralized IDentity）旨在实现：\n一对一映射：将灵魂（区块链账户）与人类（用户）建立一对一关联 去中心化：无需第三方中心化机构参与 隐私保护：隐藏身份与账户之间的绑定关系（即匿名） 可信性：每个账户在区块链上的信用与对应的真实用户一对一映射 关键技术 zkBID采用三大核心技术：\n零知识证明（zkSNARK） 可链接环签名（Linkable Ring Signature） 区块链智能合约（Smart Contracts） 技术预备知识 1. 可验证凭证（Verifiable Credentials, VC） 由W3C提出的去中心化标识符（DID）体系中的关键组件。\n三个主要角色：\n颁发者（Issuer）：签发凭证 持有者（Holder）：拥有凭证 验证者（Verifier）：验证凭证 VC的数据结构（JSON对象）：\n{ \u0026#34;metadata\u0026#34;: \u0026#34;包含颁发者DID、颁发日期、声明类型\u0026#34;, \u0026#34;claims\u0026#34;: \u0026#34;关于持有者的断言，包括持有者DID\u0026#34;, \u0026#34;proofs\u0026#34;: \u0026#34;颁发者的数字签名\u0026#34; } 2. 人格凭证（Personhood Credentials, PHC） 定义：证明用户是真人而非AI的数字凭证\n运作流程：\n注册流程 用户向PHC颁发者证明自己是真人 → 颁发者签发PHC\n使用流程 第三方服务可要求用户出示PHC作为授权过程的一部分\n验证方法（颁发者确保用户是真人的三种主要方式）：\n现有身份文件 基于政府签发的身份证件 利用现有可信来源 生物识别信息 测量持久且唯一的人体特征（掌纹、虹膜、指纹） 确保是真人且限制每人只注册一次 信任网络（Web of Trust） 通过社交图谱分析区分真人和机器 检测用户是否曾获得过凭证 在zkBID中的应用：\nPHC以VC形式作为每个人类用户的身份凭证 3. zkSNARK算法 全称：Zero-knowledge Succinct Non-interactive Argument of Knowledge\n优势：\n简洁性（Succinct）：证明大小仅几个字节，验证时间短 非交互性（Non-interactive）：证明者和验证者无需同步通信 工作原理：\n使用算术电路表示，包含基本运算：加、减、乘、除\nF-算术电路：\n输入：$x \\in \\mathbb{F}^n$ 辅助输入（见证）：$w \\in \\mathbb{F}^h$ 输出：$C(x, w) \\in \\mathbb{F}^l$ 三个算法组件：\n密钥生成（KEYGEN）\n(PK, VK) ← KEYGEN(1^λ, C) 输入：安全参数λ和电路C 输出：证明密钥PK和验证密钥VK 证明生成（PROVE）\nπ ← PROVE(PK, x, W) 输入：PK、公开输入x、私密见证W 输出：证明π 证明验证（VERIFY）\n1/0 ← VERIFY(VK, x, π) 输入：VK、公开输入x、证明π 输出：接受（1）或拒绝（0） zkBID采用的算法：Groth16\n原因：验证速度快，证明紧凑 适用于大规模应用和大型区块链网络 4. 可链接环签名（Linkable Ring Signature） 基本环签名：\n验证者可以确认签名由预定义集合中的某个成员创建 但无法确定具体是哪个成员 可链接环签名的额外特性：\n允许验证者确定两个签名是否由同一签名者生成 四个算法组件：\n密钥生成（GEN）\n(pk, sk) ← GEN(1^k) 签名生成（SIG）\nσ ← SIG(1^k, 1^n, m, L, sk) 输入：安全参数k、环大小n、消息m、公钥环L、私钥sk 输出：签名σ 签名验证（VER）\n1/0 ← VER(1^k, 1^n, m, L, σ) 可链接性检查（LINK）\n1/0 ← LINK(1^k, 1^n, m1, m2, σ1, σ2, L1, L2) 判断两个签名是否由同一签名者生成 关键属性：\n签名者模糊性（Signer Ambiguity）： 攻击者正确猜测真实签名者的概率不超过 1/(n-t) 其中n是环大小，t是攻击者拥有的私钥数量 可链接性（Linkability）： 同一签名者（相同私钥）签名的两条消息可被验证为关联 zkBID采用的算法：MLSAGS（Multilayered Linkable Spontaneous Anonymous Group Signature）\n原因：实现可链接性的技术复杂度较低，适合在智能合约上实现 密钥图像（Key Image）机制：\ny₀ ← sk * Hₚ(pk) y₀对于给定的(sk, pk)对是唯一的 所有由同一签名者产生的签名都带有相同的密钥图像 即使环中的公钥改变，签名仍可链接 zkBID系统设计 整体架构 映射关系图 真实用户 → PHC（人格凭证）→ PHC哈希 → 种子公钥 → 灵魂账户 关系说明：\n实线：可见的一对一关系 虚线：不可见但可验证的关系 箭头：单向计算关系 核心设计理念 隐私保护： PHC的具体内容不上链，只存储零知识证明 灵魂账户与种子公钥的关联不可见 可信匿名： 账户是匿名的（无法追踪到真实身份） 账户是可信的（确实与真实用户一对一绑定） 完全去中心化： 所有数据由用户生成 通过区块链上的智能合约验证 IVAC流程（Identity Verification and Account Certification） zkBID通过三个子流程生成具有可信匿名性的灵魂账户：\n[用户] → [注册信息生成] → [用户身份验证] → [灵魂账户认证] → [灵魂账户] ↓ ↓ ↓ 零知识证明 智能合约验证 可链接环签名 详细设计 阶段1：注册信息生成 目标：生成隐私保护的注册信息，不泄露PHC的具体内容\nPHC格式设计 zkBID中的PHC采用VC格式，包含三个关键字段：\n{ \u0026#34;credentialSubject\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_holder\u0026#34; // 持有者公钥 }, \u0026#34;proof\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_issuer\u0026#34;, // 颁发者公钥 \u0026#34;signature\u0026#34;: \u0026#34;sig_issuer\u0026#34; // 颁发者签名 } } 零知识证明生成流程 Protocol 1: PHC的ZK证明生成\n输入： - hash_PHC：PHC的哈希值 - sig_holder：持有者的签名 - pk_issuer：颁发者的公钥 - PHC：完整的PHC数据 设置： (PK, VK) ← zkSNARK.KEYGEN(1^λ, C) 生成证明： 1. 公开输入 x ← (hash_PHC, sig_holder, pk_issuer) 2. 私密见证 W ← PHC 3. π ← zkSNARK.PROVE(PK, x, W) 输出：π（零知识证明） 算术电路验证逻辑 graph TD A[私密输入: PHC] --\u0026gt; B[计算PHC的哈希] C[公开输入: hash_PHC] --\u0026gt; B B --\u0026gt; D{哈希值是否相等?} A --\u0026gt; E[提取pk_holder] F[公开输入: sig_holder] --\u0026gt; G[验证sig_holder] E --\u0026gt; G G --\u0026gt; H{签名是否有效?} A --\u0026gt; I[提取sig_issuer] J[公开输入: pk_issuer] --\u0026gt; K[验证sig_issuer] I --\u0026gt; K K --\u0026gt; L{签名是否有效?} D --\u0026gt; M[AND] H --\u0026gt; M L --\u0026gt; M M --\u0026gt; N{输出TRUE/FALSE} 验证步骤：\n验证哈希正确性： 计算PHC的哈希 检查是否等于公开输入中的hash_PHC 确保hash_PHC确实从PHC计算得出 验证所有权： 从PHC中提取持有者公钥pk_holder 用pk_holder验证sig_holder 证明用户拥有PHC 验证PHC有效性： 从PHC中提取颁发者签名sig_issuer 用pk_issuer验证sig_issuer 证明PHC由可信颁发者签发 输出：\n如果所有检查通过：输出TRUE和证明π π证明的声明：\u0026ldquo;PHC哈希正确，持有者拥有PHC，PHC由颁发者签发\u0026rdquo; 关键：不泄露PHC的具体内容 阶段2：用户身份验证 目标：\n验证用户的真人身份（通过验证ZK证明） 防止重复注册（检查PHC哈希未被使用） 智能合约流程 Protocol 2: 用户身份验证智能合约\n输入： - π：零知识证明 - hash_PHC：PHC哈希 - sig_holder：持有者签名 - pk_seed：种子公钥 执行步骤： 1. pk_issuer ← GetIssuerPK() // 获取预定义的颁发者公钥 2. validation ← zkSNARK.VERIFY(VK, hash_PHC, pk_issuer, π) 3. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 4. stored ← Traverse(hash_PHC) // 检查是否已注册 5. if stored ≠ 0: return \u0026#34;已经注册\u0026#34; 6. Store(hash_PHC, pk_seed) // 存储为键值对 7. return \u0026#34;认证成功\u0026#34; 用户操作步骤 生成种子密钥对：\n(pk_seed, sk_seed) ← MLSAGS.GEN(1^k) 构造交易：\n数据字段包含：π, hash_PHC, sig_holder, pk_issuer, pk_seed 发送到身份验证合约地址 合约验证：\n验证颁发者公钥匹配 验证零知识证明 检查PHC哈希未被使用 链上记录：\n存储键值对：(hash_PHC, pk_seed) hash_PHC用于防止重复注册 pk_seed作为用户在下一阶段创建灵魂账户的凭证 安全保证：\nPHC的具体内容不上链 仍能验证PHC的所有权和有效性 防止同一PHC多次注册 阶段3：灵魂账户认证 目标：认证灵魂账户与合法种子公钥的一对一关联\n整体流程 生成灵魂账户（普通以太坊账户） 建立关联（使用可链接环签名） 链上验证（智能合约验证签名） 可链接环签名的生成和验证 graph LR A[用户端] --\u0026gt; B[签名生成] B --\u0026gt; C[智能合约] C --\u0026gt; D[签名验证] E[输入] --\u0026gt; B E --\u0026gt; |选择的L-1个种子公钥| B E --\u0026gt; |用户的种子公钥pk_seed| B E --\u0026gt; |用户的种子私钥sk_seed| B E --\u0026gt; |灵魂账户地址addr_soul| B E --\u0026gt; |密钥图像y₀| B B --\u0026gt; |签名σ| C F[公钥环L] --\u0026gt; C G[addr_soul] --\u0026gt; C D --\u0026gt; H{验证结果} H --\u0026gt; |True| I[认证成功] H --\u0026gt; |False| J[认证失败] 详细步骤 步骤1：生成灵魂账户\n(addr_soul, pk_soul, sk_soul) = 生成以太坊账户 步骤2：构造公钥环\n从已注册的种子公钥中选择L-1个 加上用户自己的pk_seed 形成大小为L的公钥环 步骤3：计算密钥图像\ny₀ ← sk_seed * Hₚ(pk_seed) y₀对于给定的(sk_seed, pk_seed)是唯一的 用于防止重复注册 步骤4：生成可链接环签名\nσ ← MLSAGS.SIG(1^k, 1^n, addr_soul, L, sk_seed) 消息m = addr_soul（要签名的是灵魂账户地址） 签名格式：σ = (y₀, \u0026hellip;) y₀作为签名的一部分 步骤5：智能合约验证\nProtocol 3: 灵魂账户认证智能合约\n输入： - σ：可链接环签名 - L：公钥环 - addr_soul：灵魂账户地址 执行步骤： 1. validation ← LRS.VER(1^k, 1^n, addr_soul, L, σ) 2. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 3. stored ← Traverse(σ.y₀) // 检查密钥图像是否已使用 4. if stored ≠ 0: return \u0026#34;已经认证\u0026#34; 5. Store(σ.y₀, addr_soul) // 存储密钥图像和灵魂账户 6. return \u0026#34;认证成功\u0026#34; 隐私保护机制 关键特性：\n签名者模糊性： 签名可以被验证为有效 但无法确定环L中哪个公钥是真正的签名者 攻击者猜对的概率：1/(n-t)，其中n是环大小，t是攻击者拥有的私钥数 一对一保证： 密钥图像y₀唯一对应一个种子密钥对 同一种子密钥对只能生成一个有效签名 确保一个PHC只能关联一个灵魂账户 可验证的匿名性： 任何人都可以验证灵魂账户与某个合法种子公钥关联 但无法确定具体是哪个种子公钥 实现\u0026quot;可信匿名\u0026quot; 链上数据 存储内容：\n(σ.y₀, addr_soul) 键值对 可见信息：\n所有种子公钥（从阶段2） 所有灵魂账户地址 所有密钥图像 不可见关联：\n哪个种子公钥对应哪个灵魂账户 哪个PHC哈希对应哪个灵魂账户 哪个真实用户对应哪个灵魂账户 安全性分析 安全前提条件 计算对手受限：攻击者为多项式时间的计算对手 验证者诚实：智能合约不会接受虚假验证请求 PHC唯一性：每个用户只能从颁发者获得一个PHC 安全目标 zkBID需要满足三个核心安全属性：\n安全属性 定义 目标 身份唯一性 防止重复注册 一个用户不能注册多个灵魂账户 不可伪造性 防止身份伪造 攻击者不能冒充诚实用户认证灵魂账户 匿名性 保护身份隐私 攻击者无法检测用户身份(PHC)与灵魂账户的关联 威胁模型与防御 1. 女巫攻击（Sybil Attack） 攻击场景： 攻击者已拥有一个灵魂账户，试图获取新的灵魂账户\n攻击方法：\n方法A：使用相同PHC关联新的种子公钥 → 用新种子公钥认证新灵魂账户\n方法B：直接使用已用过的种子公钥认证新灵魂账户\n防御分析：\n方法A的防御：\n在用户身份验证合约中： 1. 合约检查hash_PHC是否已存储 2. 由于哈希函数的抗碰撞性，每个PHC只能生成一个唯一哈希 3. zkSNARK的可靠性保证：攻击者通过伪造哈希成功的概率可忽略不计 4. 因此无法用同一PHC注册两个种子账户 方法B的防御：\n在灵魂账户认证合约中： 1. 合约检查密钥图像y₀是否已使用 2. 由于可链接环签名的可链接性，同一种子私钥无法构造两个不同y₀的有效签名 3. 因此无法用同一种子密钥对认证两个灵魂账户 结论：无法使用相同PHC或种子公钥注册两个灵魂账户\n2. 链接攻击（Linkage Attack） 攻击场景： 攻击者试图通过破解环签名的真实签名者，建立用户身份（PHC哈希）与灵魂账户的链接\n攻击方法： 分析链上存储的环签名，推断哪个种子公钥是真正的签名者\n防御分析：\n基于可链接环签名的签名者模糊性： - 假设环大小为n - 攻击者拥有t个私钥 - 攻击者正确识别真实签名者的概率 = 1/(n-t) 示例： - 环大小 n = 100 - 攻击者拥有 t = 10 个私钥 - 成功概率 = 1/90 ≈ 1.1% 结论：攻击者无法有效建立身份与账户的链接 环大小的影响：\n环越大 → 匿名性越强 但签名生成和验证成本增加 需要在匿名性和效率之间权衡 3. 伪造攻击（Forgery Attack） 攻击场景： 攻击者试图冒充诚实用户获取灵魂账户\n攻击方法：\n方法A：伪造holder签名生成有效zkSNARK证明\n攻击者获得诚实用户的PHC ↓ 伪造sig_holder ↓ 生成通过验证的zkSNARK证明 ↓ 注册种子公钥 ↓ 认证灵魂账户 方法B：伪造种子账户的环签名\n已注册的种子公钥公开可见 ↓ 伪造某个诚实用户的环签名sig_seed ↓ 认证新的灵魂账户 防御分析：\n方法A的防御：\n依赖两个密码学保证： 1. EdDSA算法的不可伪造性 → 攻击者无法伪造任何诚实用户的sig_holder 2. zkSNARK的可靠性 → 没有有效签名，无法创建有效的zkSNARK证明 结论：攻击者无法通过伪造签名获得种子公钥 方法B的防御：\n依赖可链接环签名的不可伪造性： - 攻击者无法伪造任何已注册种子账户的有效签名 - 即使种子公钥公开可见 结论：攻击者无法冒充诚实用户认证灵魂账户 总结：zkBID协议能够抵御伪造攻击\n安全性总结表 攻击类型 攻击目标 依赖的安全属性 防御结果 女巫攻击-方法A 重复注册PHC 哈希抗碰撞性 + zkSNARK可靠性 ✅ 安全 女巫攻击-方法B 重复使用种子密钥 可链接环签名的可链接性 ✅ 安全 链接攻击 破坏匿名性 可链接环签名的签名者模糊性 ✅ 安全 伪造攻击-方法A 伪造身份验证 EdDSA不可伪造性 + zkSNARK可靠性 ✅ 安全 伪造攻击-方法B 伪造账户认证 可链接环签名不可伪造性 ✅ 安全 实验评估 实验环境 测试网络配置 区块链测试网络：\n平台：阿里云 节点数：6个以太坊全节点 共识协议：工作量证明（PoW） 客户端：Go-Ethereum 网络拓扑：全连接（每个节点有独立IP） 用户节点：\n1个用户节点连接到1个以太坊节点 运行用户端功能 硬件配置（所有节点）：\n操作系统：Ubuntu 20.04 CPU：Intel(R) Core(TM) i7-10700 @ 2.90GHz 内存：48GB RAM 实现技术栈 智能合约：\n语言：Solidity 部署：以太坊测试网络 zkSNARK：\n算法：Groth16 平台：Circom 2 功能：Setup和证明生成 可链接环签名：\n算法：MLSAGS 用户端实现：Python（密钥生成、签名算法） 合约实现：Solidity（签名验证） 性能评估指标 指标 说明 重要性 ZK证明生成时间 Groth16证明算法的执行时间 影响用户体验 ZK证明大小 证明所占字节数 影响链上存储 ZK证明验证成本 智能合约验证所需Gas 影响使用成本 算术电路大小 R1CS约束数量 影响系统复杂度 MLSAGS签名生成时间 环签名生成的执行时间 影响用户体验 MLSAGS签名验证成本 智能合约验证所需Gas 影响使用成本 实验结果 1. Groth16性能测试 测试方案：\n使用单个算术电路验证多个PHC批次 测试不同批次大小下的性能表现 图表 6(a)：电路大小和证明大小 PHC批次大小 R1CS约束数量 ZK证明大小 1 ~19,000 192 Bytes 2 ~38,000 192 Bytes 4 ~76,000 192 Bytes 8 ~152,000 192 Bytes 16 ~304,000 192 Bytes 32 ~608,000 192 Bytes 64 ~1,216,000 192 Bytes 128 ~2,432,000 192 Bytes 关键发现：\n✨ 证明大小恒定：无论批次大小如何，证明始终为192字节 这是Groth16的核心优势：简洁性（Succinctness） 电路大小随批次线性增长 图表 6(b)：证明生成时间和验证成本 证明生成时间：\nPHC批次大小 生成时间 (ms) 增长趋势 1 ~2,000 基准 2 ~4,000 2x 4 ~8,000 4x 8 ~16,000 8x 16 ~32,000 16x 32 ~64,000 32x 证明验证成本（Gas）：\nPHC批次大小 验证Gas消耗 单个PHC平均Gas 1 215.7K 215.7K 2 247.2K 123.6K 4 310.2K 77.6K 8 436.2K 54.5K 16 688.2K 43.0K 32 1,040.0K 32.5K 关键发现：\n📈 线性增长：生成时间和验证成本都与批次大小呈线性关系\n💰\n批处理优势\n：批次大小为32时，单个PHC的Gas消耗仅为32.5K\n相比单独验证（215.7K），节省约85% 效率提升约7倍 ⚠️ 部署限制：批次大小≥64时，验证合约因以太坊合约大小限制无法部署\n最佳实践建议：\n推荐批次大小：16-32个PHC - 在合约大小限制内 - 获得显著的Gas优化 - 用户体验可接受 2. MLSAGS性能测试 测试方案：\n测试不同环大小L下的签名生成和验证性能 环大小影响匿名性和性能的权衡 图表 6(c)：MLSAGS性能指标 签名生成时间：\n环大小 L 生成时间 (ms) 增量时间 1 ~40 - 2 ~80 +40ms 4 ~160 +40ms 8 ~320 +40ms 16 ~640 +40ms 32 ~1,280 +40ms 64 ~2,560 +40ms 128 ~5,120 +40ms 签名验证成本（Gas）：\n环大小 L 验证Gas消耗 增量Gas 1 ~57K - 2 ~114K +57K 4 ~228K +57K 8 ~456K +57K 16 ~912K +57K 32 ~1,824K +57K 64 ~3,648K +57K 128 ~7,296K +57K 关键发现：\n📏\n完美线性关系\n：\n每增加1个公钥，生成时间增加约40ms 每增加1个公钥，验证Gas增加约57K ⚖️\n匿名性vs效率权衡\n：\n环越大 → 匿名性越强（攻击者猜中概率 = 1/L） 环越大 → 成本越高（时间和Gas） 匿名性分析：\n环大小 L 攻击者成功率 匿名性等级 Gas成本 10 10% 较弱 570K 50 2% 中等 2,850K 100 1% 强 5,700K 1000 0.1% 非常强 57,000K 实际应用建议：\n小规模应用（\u0026lt; 1000用户）： 环大小：10-20 匿名性：10%-5%攻击成功率 Gas成本：570K-1,140K（可接受） 中等规模应用（1000-10000用户）： 环大小：50-100 匿名性：2%-1%攻击成功率 Gas成本：2,850K-5,700K（需要优化） 大规模应用（\u0026gt; 10000用户）： 环大小：100+ 匿名性：\u0026lt; 1%攻击成功率 Gas成本：\u0026gt; 5,700K（需要Layer 2或批处理） 性能优化建议 1. 对于zkSNARK部分 批处理策略：\n低频场景（个人注册）： - 批次大小：1-4 - 适用：个人用户单次注册 - 优点：即时处理 - 缺点：Gas成本较高（215K-310K） 高频场景（批量注册）： - 批次大小：16-32 - 适用：组织批量入职、大规模注册活动 - 优点：Gas效率提升7倍 - 缺点：需要等待批次凑齐 2. 对于MLSAGS部分 环大小配置：\n# 根据用户总数动态调整 def calculate_ring_size(total_users, target_anonymity=0.01): \u0026#34;\u0026#34;\u0026#34; total_users: 系统总用户数 target_anonymity: 目标攻击成功率（如0.01 = 1%） \u0026#34;\u0026#34;\u0026#34; # 环大小不超过总用户数 ring_size = min(int(1 / target_anonymity), total_users) # 考虑Gas成本限制（假设单笔交易Gas上限为8M） max_affordable_ring = 8_000_000 / 57_000 # ≈ 140 return min(ring_size, max_affordable_ring) # 示例 calculate_ring_size(1000, 0.01) # 返回 100 calculate_ring_size(10000, 0.01) # 返回 100（受成本限制） calculate_ring_size(50, 0.01) # 返回 50（受用户数限制） 分层匿名策略：\nVIP用户/高价值账户： - 使用较大环（100+） - 提供更强匿名性 - 愿意支付更高Gas 普通用户： - 使用中等环（20-50） - 平衡匿名性和成本 - 实际应用最常见 测试/低价值账户： - 使用小环（10-20） - 基本匿名性 - 成本最低 实验结论 zkSNARK的优势： ✅ 证明大小恒定（192字节）：不受批次影响 ✅ 批处理优化显著：32个PHC可节省85% Gas ✅ 验证快速：链上验证成本可接受 MLSAGS的特性： ✅ 性能可预测：完美线性关系 ⚠️ 需要权衡：匿名性与成本呈正比 ✅ 灵活配置：可根据场景调整环大小 系统可行性： ✅ 在实际以太坊网络上完全可行 ✅ 通过参数优化可适应不同规模 ✅ 性能瓶颈明确且可优化 相关工作对比 现有方案分析 论文对比了8个相关的区块链身份方案：\n方案 年份 主要技术 应用场景 TradeMap [12] 2019 ZKP 符合FINMA的匿名KYC平台 Pauwels et al. [14] 2022 zkSNARK DeFi协议的KYC系统 Aydar et al. [3] 2019 Blockchain 数字身份验证框架 Singh et al. [18] 2020 Credential Protocol 保护个人属性的身份系统 Abraham et al. [1] 2020 SSI Model 支持凭证撤销的自主身份 ZEBRA [15] 2022 zkSNARK 链上匿名凭证验证 Zhang et al. [26] 2024 ZKP 能源交易身份认证 Kim et al. [10] 2023 SBT + DID 元宇宙的KYC系统 设计目标对比 方案 DG1 技术灵活性 DG2 身份匿名性 DG3 身份可信性 DG4 隐私存储 TradeMap [12] ✅ ❌ ❌ ❌ Pauwels [14] ✅ ❌ ✅ ✅ Aydar [3] ❌ ✅ ❌ ❌ Singh [18] ❌ ✅ ✅ ✅ Abraham [1] ✅ ✅ ❌ ❌ ZEBRA [15] ❌ ✅ ❌ ❌ Zhang [26] ✅ ❌ ✅ ❌ Kim [10] ❌ ✅ ❌ ❌ zkBID ✅ ✅ ✅ ✅ 设计目标说明：\nDG1 - 技术灵活性：不局限于特定的ZKP算法或区块链平台 DG2 - 身份匿名性：无法从链上活动推断用户真实身份 DG3 - 身份可信性：每个身份可信地连接到真实世界用户 DG4 - 隐私存储：身份文档保密存储，不公开可见 zkBID的独特优势 1. 唯一全面满足所有设计目标 其他方案的局限： ├─ TradeMap: 只关注合规性，缺乏匿名性和可信映射 ├─ Pauwels: DeFi场景，但身份匿名性不足 ├─ Aydar/Singh: 技术灵活性差，绑定特定实现 ├─ Abraham/ZEBRA: 缺乏与真实用户的可信绑定 ├─ Zhang: 特定场景（能源交易），匿名性不足 └─ Kim: 元宇宙场景，技术灵活性和可信性不足 zkBID的创新： ✅ 同时实现匿名性和可信性（看似矛盾的目标） ✅ 完全去中心化（无需可信第三方） ✅ 技术灵活（可替换ZKP算法和环签名方案） ✅ 隐私保护（身份信息不上链） 2. 技术组合的创新性 现有方案的技术使用：\n大多只使用zkSNARK进行凭证验证 少数使用环签名，但未实现身份-账户绑定 没有方案同时使用zkSNARK + 可链接环签名 zkBID的技术创新：\nzkSNARK（阶段1-2）： 目的：验证PHC有效性 优势：不泄露PHC内容 创新：批处理优化 可链接环签名（阶段3）： 目的：建立身份-账户映射 优势：保持匿名性的同时确保一对一 创新：使用密钥图像防止重复绑定 组合效果： = 可验证的身份 + 不可追踪的账户绑定 = 可信匿名（Credible Anonymity） 3. 实际应用价值 传统KYC系统的问题：\n中心化KYC： ❌ 隐私泄露风险 ❌ 数据被服务商控制 ❌ 跨平台不互通 区块链匿名账户： ❌ 无法防止女巫攻击 ❌ 信誉系统难以建立 ❌ 监管合规困难 zkBID的解决方案：\n对用户： ✅ 保护隐私（身份信息不泄露） ✅ 自主控制（无需信任中心化机构） ✅ 一次认证，多处使用 对平台： ✅ 防止女巫攻击（一人一账户） ✅ 建立信誉系统（账户可信） ✅ 满足监管要求（有认证机制） 对监管： ✅ 可验证的身份（PHC由可信机构签发） ✅ 可追责性（必要时可追踪） ✅ 隐私保护合规 应用场景 1. 去中心化社交网络 问题：\nTwitter/X上的机器人和假账户泛滥 难以区分真人和AI生成的内容 水军和虚假舆论操纵 zkBID解决方案：\n用户注册： 1. 用政府ID获取PHC 2. 通过zkBID认证获得灵魂账户 3. 使用灵魂账户在社交网络发布内容 效果： ✅ 每个账户对应一个真人 ✅ 保持用户匿名性 ✅ 机器人和假账户显著减少 ✅ 信誉系统可以建立在灵魂账户上 2. DAO治理 问题：\n一人多账户操纵投票 女巫攻击破坏治理公平性 难以验证投票者资格 zkBID解决方案：\n治理流程： 1. DAO成员通过zkBID认证 2. 每个灵魂账户 = 一个真实成员 3. 投票时保持匿名 4. 防止多重投票 效果： ✅ 一人一票（真正的民主） ✅ 投票匿名（防止胁迫和贿赂） ✅ 可验证（确保只有成员投票） ✅ 信誉加权（可基于历史贡献） 3. DeFi空投和激励 问题：\n空投被羊毛党多账户瓜分 难以识别真实用户 激励机制被滥用 zkBID解决方案：\n空投流程： 1. 要求使用zkBID认证的灵魂账户 2. 每个灵魂账户只能领取一次 3. 基于链上行为的信誉评分 效果： ✅ 公平分配（每人一份） ✅ 防止女巫攻击 ✅ 识别真实活跃用户 ✅ 建立长期激励机制 4. Web3游戏和元宇宙 问题：\n工作室多开刷金币 游戏经济被破坏 难以建立公平竞技环境 zkBID解决方案：\n游戏应用： 1. 玩家使用灵魂账户登录 2. 游戏内资产绑定到灵魂账户 3. 排行榜和竞技只认可灵魂账户 效果： ✅ 一人一号（公平竞争） ✅ 资产真实归属 ✅ 游戏经济稳定 ✅ 社交关系可信 5. 去中心化信用系统 问题：\n传统信用系统中心化 跨平台信用不互通 隐私泄露风险 zkBID解决方案：\n信用体系： 1. 灵魂账户作为信用载体 2. 链上行为建立信用历史 3. 跨DApp信用互认 4. 保护用户隐私 效果： ✅ 去中心化信用（不被单一机构控制） ✅ 可移植性（跨平台使用） ✅ 隐私保护（匿名但可信） ✅ 防止信用欺诈（一人一信用档案） 局限性与未来工作 当前局限性 1. 性能限制 Gas成本：\n当前状态： - 单次PHC验证：215.7K Gas - 环大小100的签名验证：5,700K Gas - 在以太坊主网上成本较高 影响： ❌ 大规模应用成本高 ❌ 限制了环大小（影响匿名性） 可能的解决方案：\nLayer 2方案（如Optimism、Arbitrum） 侧链部署 批处理优化 2. PHC依赖 当前状态：\n依赖可信的PHC颁发机构： - 政府机构 - 大型科技公司 - 其他可信第三方 问题： ❌ PHC系统尚未广泛部署 ❌ 不同颁发者的互操作性 ❌ 颁发者可能成为中心化风险点 3. 隐私权衡 匿名性级别：\n环大小的限制： - 小环（\u0026lt;20）：匿名性较弱 - 大环（100+）：成本高昂 - 实际应用中需要权衡 4. 撤销机制 当前缺失：\n无法撤销已认证的灵魂账户： ❌ 如果PHC被吊销怎么办？ ❌ 如果用户想注销怎么办？ ❌ 如果发现欺诈怎么办？ 需要设计： - 灵活的撤销机制 - 保持匿名性的撤销 - 防止滥用撤销权 未来研究方向 1. 性能优化 方向A：递归证明：\n使用递归zkSNARK： - 将多个证明聚合成一个 - 减少链上验证成本 - 提高批处理效率 预期效果： - Gas成本降低50%+ - 支持更大批次 方向B：量子抗性：\n替换为抗量子密码算法： - 格基密码学 - 哈希基签名 - 为后量子时代做准备 2. PHC生态系统 多颁发者互操作：\n标准化PHC格式： - 统一的VC模板 - 跨颁发者互认 - 去中心化颁发者网络 目标： - 减少单点故障 - 提高可用性 - 增强去中心化 去中心化PHC颁发：\n探索无需中心化颁发者的方案： - 基于生物识别的去中心化验证 - 社交图谱验证 - 组合多种验证方式 3. 隐私增强 方向A：动态环：\n允许用户动态选择环大小： - 根据交易重要性调整 - 重要交易用大环 - 普通交易用小环 效果： - 灵活性提高 - 成本优化 方向B：分层匿名：\n不同隐私级别的灵魂账户： - 公开级：最小匿名性，低成本 - 标准级：中等匿名性，中等成本 - 隐私级：高匿名性，高成本 4. 跨链支持 多链部署：\n扩展到其他区块链： - Polkadot/Cosmos生态 - 高性能链（Solana、Aptos） - 专用隐私链（Zcash、Monero概念） 跨链身份： - 一个PHC，多链认证 - 统一的身份层 5. 撤销和恢复机制 优雅的撤销：\n设计保护隐私的撤销： - 使用累加器（Accumulator） - 撤销列表不泄露身份 - 高效的撤销验证 恢复机制： - PHC过期后的更新流程 - 密钥丢失的恢复方案 - 保持连续性的信誉迁移 6. 合规和监管 可选的透明性：\n为监管场景设计： - 选择性披露机制 - 紧急情况下的去匿名化 - 法院命令的执行 平衡： - 保护普通用户隐私 - 满足反洗钱（AML）要求 - 支持合法调查 关键takeaways 技术创新 可信匿名的突破： 首次在区块链上实现\u0026quot;可信\u0026quot;+\u0026ldquo;匿名\u0026quot;的结合 通过零知识证明保护隐私 通过可链接环签名确保一对一映射 完全去中心化： 无需可信第三方参与验证 所有逻辑在智能合约中执行 用户完全控制自己的身份 实用性验证： 在真实以太坊测试网络上实现 性能指标明确可测 成本可接受且可优化 理论贡献 身份模型创新：\n传统模型：身份 → 账户（可见映射） zkBID模型：身份 → [ZK层] → 种子 → [环签名层] → 账户 创新点： - 两层隐私保护 - 可验证但不可追踪 - 数学上可证明的安全性 密码学组合：\nzkSNARK + 可链接环签名的首次组合应用 各取所长，弥补对方不足 为未来类似系统提供范式 实践意义 Web3基础设施： 为Web3提供关键的身份层 解决匿名性与可信性的矛盾 使去中心化应用更实用 防止AI冒充： 在AI时代区分人类和机器 PHC作为\u0026quot;数字人格证\u0026rdquo; 保护在线空间的人类性 新经济模式： 支持基于信誉的去中心化经济 公平的激励分配机制 可持续的社区治理 结论 zkBID是一个创新的Web 3.0去中心化身份方案，成功解决了区块链账户系统中匿名性与可信性的矛盾。\n核心成就 ✅ 技术突破：\n零知识证明保护身份隐私 可链接环签名确保一对一映射 完全去中心化的验证机制 ✅ 安全保证：\n抵御女巫攻击 抵御链接攻击 抵御伪造攻击 ✅ 实用验证：\n以太坊测试网络成功部署 性能指标满足实际应用需求 成本可通过参数优化控制 未来展望 zkBID为Web3去中心化身份提供了一个可行的解决方案，但仍有改进空间：\n继续优化性能和成本 推动PHC生态系统发展 探索跨链和多链支持 完善撤销和恢复机制 平衡隐私保护 ","permalink":"http://localhost:1313/blockchain/linking-souls-to-humans/","summary":"zkBID通过零知识证明和可链接环签名技术，首次实现了区块链账户的\u0026quot;可信匿名\u0026quot;：每个账户与真实用户一对一绑定（可信），但外界无法追踪具体对应关系（匿名）。系统采用三阶段IVAC流程，将人格凭证(PHC)通过零知识证明验证后绑定到种子公钥，再用环签名将种子公钥关联到灵魂账户。实验显示批处理可将验证成本降低85%，环大小灵活可调以平衡匿名性与效率。该方案为Web3提供了关键身份基础设施，可有效防止女巫攻击，支持去中心化社交、DAO治理、DeFi空投等场景。","title":"zkBID: 区块链账户与Web 3.0去中心化身份"},{"content":"📚 Part 1: Java 集合使用手册 0.String - 不可变字符串 // 初始化 String s = \u0026#34;hello\u0026#34;; String s2 = new String(\u0026#34;world\u0026#34;); String s3 = String.valueOf(123); // 数字转字符串 // 基本属性 int len = s.length(); // 长度 boolean empty = s.isEmpty(); // 是否为空 char ch = s.charAt(0); // 获取字符 // 查找 int index = s.indexOf(\u0026#34;ll\u0026#34;); // 查找子串位置 int lastIndex = s.lastIndexOf(\u0026#34;l\u0026#34;); // 最后出现位置 boolean contains = s.contains(\u0026#34;el\u0026#34;); // 是否包含 // 截取 String sub = s.substring(1, 4); // [1, 4) 截取 String sub2 = s.substring(2); // 从索引2到结尾 // 替换 String replaced = s.replace(\u0026#34;l\u0026#34;, \u0026#34;L\u0026#34;); // 替换所有 String replaced2 = s.replaceFirst(\u0026#34;l\u0026#34;, \u0026#34;L\u0026#34;); // 替换第一个 String replaced3 = s.replaceAll(\u0026#34;[aeiou]\u0026#34;, \u0026#34;*\u0026#34;); // 正则替换 // 分割 String[] parts = \u0026#34;a,b,c\u0026#34;.split(\u0026#34;,\u0026#34;); // 按分隔符分割 String[] parts2 = \u0026#34;a b c\u0026#34;.split(\u0026#34;\\\\s+\u0026#34;); // 按空格分割 // 拼接 String joined = String.join(\u0026#34;,\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); // \u0026#34;a,b,c\u0026#34; String concat = s.concat(\u0026#34; world\u0026#34;); // 拼接 // 大小写 String upper = s.toUpperCase(); String lower = s.toUpperCase().toLowerCase(); // 去空格 String trimmed = \u0026#34; hello \u0026#34;.trim(); // 去两端空格 String stripped = \u0026#34; hello \u0026#34;.strip(); // Java 11+ // 比较 boolean equals = s.equals(\u0026#34;hello\u0026#34;); boolean equalsIgnoreCase = s.equalsIgnoreCase(\u0026#34;HELLO\u0026#34;); int compare = s.compareTo(\u0026#34;world\u0026#34;); // 字典序比较 // 判断 boolean startsWith = s.startsWith(\u0026#34;he\u0026#34;); boolean endsWith = s.endsWith(\u0026#34;lo\u0026#34;); // 转换 char[] chars = s.toCharArray(); // 转字符数组 byte[] bytes = s.getBytes(); // 转字节数组 StringBuilder - 可变字符串 使用场景：单线程环境下需要频繁修改字符串\n// 初始化 StringBuilder sb = new StringBuilder(); StringBuilder sb2 = new StringBuilder(\u0026#34;hello\u0026#34;); StringBuilder sb3 = new StringBuilder(100); // 指定初始容量 // 添加（拼接） sb.append(\u0026#34;hello\u0026#34;); // 尾部添加 sb.append(123); // 添加数字 sb.append(\u0026#39;!\u0026#39;); // 添加字符 sb.insert(0, \u0026#34;start \u0026#34;); // 指定位置插入 // 删除 sb.delete(0, 5); // 删除 [0, 5) sb.deleteCharAt(0); // 删除指定位置 sb.setLength(0); // 清空（重置长度为0） // 修改 sb.replace(0, 5, \u0026#34;world\u0026#34;); // 替换 [0, 5) sb.setCharAt(0, \u0026#39;H\u0026#39;); // 修改指定位置字符 // 反转 sb.reverse(); // 查询 int len = sb.length(); char ch = sb.charAt(0); String sub = sb.substring(0, 5); // 转换为 String String result = sb.toString(); // 常见应用：循环拼接字符串 StringBuilder result = new StringBuilder(); for (int i = 0; i \u0026lt; 1000; i++) { result.append(i).append(\u0026#34;,\u0026#34;); } // 比用 String + 拼接快得多！ StringBuffer - 可变字符串 使用场景：多线程环境下需要频繁修改字符串\n// API 与 StringBuilder 完全相同 StringBuffer sb = new StringBuffer(); sb.append(\u0026#34;hello\u0026#34;); sb.append(\u0026#34; world\u0026#34;); String result = sb.toString(); // 区别：StringBuffer 的方法都是 synchronized 的 // 多线程安全，但性能比 StringBuilder 差 常用字符串操作技巧 // 1. 字符串转数字 int num = Integer.parseInt(\u0026#34;123\u0026#34;); long l = Long.parseLong(\u0026#34;123\u0026#34;); double d = Double.parseDouble(\u0026#34;3.14\u0026#34;); // 2. 数字转字符串 String s1 = String.valueOf(123); String s2 = Integer.toString(123); String s3 = \u0026#34;\u0026#34; + 123; // 不推荐 // 3. 字符串数组拼接 String[] arr = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; String joined = String.join(\u0026#34;,\u0026#34;, arr); // \u0026#34;a,b,c\u0026#34; // 4. 重复字符串（Java 11+） String repeated = \u0026#34;ab\u0026#34;.repeat(3); // \u0026#34;ababab\u0026#34; // 5. 判断空字符串 if (s != null \u0026amp;\u0026amp; !s.isEmpty()) { } if (s != null \u0026amp;\u0026amp; !s.isBlank()) { } // Java 11+，忽略空白字符 // 6. 字符串格式化 String formatted = String.format(\u0026#34;Hello %s, you are %d years old\u0026#34;, \u0026#34;Alice\u0026#34;, 25); 1. List - 列表 ArrayList - 动态数组 // 初始化 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); List\u0026lt;Integer\u0026gt; list3 = new ArrayList\u0026lt;\u0026gt;(100); // 指定初始容量 // 增 list.add(1); // 尾部添加 list.add(0, 10); // 指定位置添加 list.addAll(Arrays.asList(2,3,4)); // 批量添加 // 删 list.remove(0); // 删除指定索引 list.remove(Integer.valueOf(1)); // 删除指定元素 list.clear(); // 清空 // 改 list.set(0, 100); // 修改指定位置 // 查 int val = list.get(0); // 获取元素 int size = list.size(); // 获取大小 boolean empty = list.isEmpty(); // 是否为空 boolean contains = list.contains(1); // 是否包含 int index = list.indexOf(1); // 查找索引 // 遍历 for (int num : list) { System.out.println(num); } // 或使用迭代器 Iterator\u0026lt;Integer\u0026gt; it = list.iterator(); while (it.hasNext()) { System.out.println(it.next()); } LinkedList - 双向链表 LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 头部操作 list.addFirst(1); list.removeFirst(); int first = list.getFirst(); // 尾部操作 list.addLast(2); list.removeLast(); int last = list.getLast(); // 作为队列使用 list.offer(3); // 入队 int head = list.poll(); // 出队 // 作为栈使用 list.push(4); // 入栈 int top = list.pop(); // 出栈 2. Set - 集合 HashSet - 无序不重复 // 初始化 Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); // 增 set.add(1); set.addAll(Arrays.asList(2, 3, 4)); // 删 set.remove(1); set.clear(); // 查 boolean contains = set.contains(1); int size = set.size(); boolean empty = set.isEmpty(); // 遍历 for (int num : set) { System.out.println(num); } TreeSet - 有序集合（红黑树） TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 基本操作同 HashSet set.add(3); set.add(1); set.add(2); System.out.println(set); // [1, 2, 3] 自动排序 // 特有方法 int first = set.first(); // 最小元素 int last = set.last(); // 最大元素 int lower = set.lower(2); // 小于 2 的最大元素 int higher = set.higher(2); // 大于 2 的最小元素 int floor = set.floor(2); // ≤ 2 的最大元素 int ceiling = set.ceiling(2); // ≥ 2 的最小元素 // 子集操作 SortedSet\u0026lt;Integer\u0026gt; subset = set.subSet(1, 3); // [1, 3) SortedSet\u0026lt;Integer\u0026gt; headSet = set.headSet(2); // \u0026lt; 2 SortedSet\u0026lt;Integer\u0026gt; tailSet = set.tailSet(2); // \u0026gt;= 2 LinkedHashSet - 保持插入顺序 Set\u0026lt;Integer\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); set.add(3); set.add(1); set.add(2); System.out.println(set); // [3, 1, 2] 保持插入顺序 3. Map - 映射 HashMap - 键值对 // 初始化 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 增/改 map.put(\u0026#34;apple\u0026#34;, 1); map.put(\u0026#34;banana\u0026#34;, 2); map.putIfAbsent(\u0026#34;apple\u0026#34;, 10); // 键不存在时才添加 // 删 map.remove(\u0026#34;apple\u0026#34;); map.clear(); // 查 int val = map.get(\u0026#34;apple\u0026#34;); int valOrDefault = map.getOrDefault(\u0026#34;orange\u0026#34;, 0); boolean hasKey = map.containsKey(\u0026#34;apple\u0026#34;); boolean hasValue = map.containsValue(1); int size = map.size(); // 遍历键值对 for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { String key = entry.getKey(); int value = entry.getValue(); } // 遍历键 for (String key : map.keySet()) { System.out.println(key); } // 遍历值 for (int value : map.values()) { System.out.println(value); } // Java 8+ 新方法 map.computeIfAbsent(\u0026#34;cherry\u0026#34;, k -\u0026gt; 3); map.merge(\u0026#34;apple\u0026#34;, 1, Integer::sum); // 累加 TreeMap - 有序映射（红黑树） TreeMap\u0026lt;Integer, String\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); map.put(3, \u0026#34;c\u0026#34;); map.put(1, \u0026#34;a\u0026#34;); map.put(2, \u0026#34;b\u0026#34;); // 基本操作同 HashMap // 特有方法 int firstKey = map.firstKey(); int lastKey = map.lastKey(); Map.Entry\u0026lt;Integer, String\u0026gt; firstEntry = map.firstEntry(); Map.Entry\u0026lt;Integer, String\u0026gt; lastEntry = map.lastEntry(); int lowerKey = map.lowerKey(2); // \u0026lt; 2 的最大键 int higherKey = map.higherKey(2); // \u0026gt; 2 的最小键 int floorKey = map.floorKey(2); // \u0026lt;= 2 的最大键 int ceilingKey = map.ceilingKey(2); // \u0026gt;= 2 的最小键 LinkedHashMap - 保持插入顺序 Map\u0026lt;String, Integer\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;c\u0026#34;, 3); map.put(\u0026#34;a\u0026#34;, 1); map.put(\u0026#34;b\u0026#34;, 2); // 遍历时保持插入顺序: c, a, b 4. Queue - 队列 普通队列 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 入队 queue.offer(1); queue.add(2); // 队列满时抛异常 // 出队 int head = queue.poll(); // 空时返回 null int head2 = queue.remove(); // 空时抛异常 // 查看队首 int peek = queue.peek(); // 空时返回 null int peek2 = queue.element(); // 空时抛异常 PriorityQueue - 优先队列（堆） // 小根堆（默认） PriorityQueue\u0026lt;Integer\u0026gt; minHeap = new PriorityQueue\u0026lt;\u0026gt;(); // 大根堆 PriorityQueue\u0026lt;Integer\u0026gt; maxHeap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); // 自定义对象 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); minHeap.offer(3); minHeap.offer(1); minHeap.offer(2); while (!minHeap.isEmpty()) { System.out.println(minHeap.poll()); // 1, 2, 3 } Deque - 双端队列 Deque\u0026lt;Integer\u0026gt; deque = new ArrayDeque\u0026lt;\u0026gt;(); // 头部操作 deque.offerFirst(1); deque.pollFirst(); deque.peekFirst(); // 尾部操作 deque.offerLast(2); deque.pollLast(); deque.peekLast(); // 作为栈使用 deque.push(3); int top = deque.pop(); 5. Stack - 栈 Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(1); // 入栈 int top = stack.pop(); // 出栈 int peek = stack.peek(); // 查看栈顶 boolean empty = stack.isEmpty(); int size = stack.size(); // 推荐使用 Deque 代替 Stack Deque\u0026lt;Integer\u0026gt; stack2 = new ArrayDeque\u0026lt;\u0026gt;(); 🧮 Part 2: 算法模板 1. 树的遍历 二叉树定义 class TreeNode { int val; // 节点值 TreeNode left; // 左子节点 TreeNode right; // 右子节点 TreeNode(int val) { this.val = val; } } DFS - 深度优先遍历 前序遍历（根-左-右） // 递归版本 - 最简洁直观 void preorder(TreeNode root) { if (root == null) return; // 递归终止条件：空节点 System.out.println(root.val); // 1. 先访问根节点 preorder(root.left); // 2. 再遍历左子树 preorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 使用栈模拟递归 List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); // 根节点入栈 while (!stack.isEmpty()) { TreeNode node = stack.pop(); // 弹出栈顶节点 res.add(node.val); // 访问该节点 // 关键：先压右子节点，再压左子节点 // 这样出栈时左子节点先出（栈是后进先出） if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); } return res; } 中序遍历（左-根-右） // 递归版本 void inorder(TreeNode root) { if (root == null) return; // 递归终止条件 inorder(root.left); // 1. 先遍历左子树 System.out.println(root.val); // 2. 再访问根节点 inorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 一直向左走到底 List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode curr = root; while (curr != null || !stack.isEmpty()) { // 第一步：一直向左走到底，沿途节点入栈 while (curr != null) { stack.push(curr); curr = curr.left; } // 第二步：弹出栈顶（当前最左节点），访问它 curr = stack.pop(); res.add(curr.val); // 第三步：转向右子树 curr = curr.right; } return res; } 后序遍历（左-右-根） // 递归版本 void postorder(TreeNode root) { if (root == null) return; // 递归终止条件 postorder(root.left); // 1. 先遍历左子树 postorder(root.right); // 2. 再遍历右子树 System.out.println(root.val); // 3. 最后访问根节点 } // 迭代版本 - 巧妙方法：前序遍历变形 + 反转 // 思路：前序是\u0026#34;根左右\u0026#34;，改成\u0026#34;根右左\u0026#34;，反转后得到\u0026#34;左右根\u0026#34; List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); res.add(node.val); // 添加到结果（根右左顺序） // 注意：这里先左后右，出栈时就是先右后左 if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); } Collections.reverse(res); // 反转得到左右根 return res; } BFS - 层序遍历 // 按层遍历二叉树，每层的节点放在一个列表中 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); // 根节点入队 while (!queue.isEmpty()) { int size = queue.size(); // 当前层的节点数（重要！） List\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); // 遍历当前层的所有节点 for (int i = 0; i \u0026lt; size; i++) { TreeNode node = queue.poll(); // 出队 level.add(node.val); // 记录节点值 // 将下一层的节点入队 if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } res.add(level); // 保存当前层结果 } return res; } 线段树（Segment Tree） /** * 线段树：用于高效处理区间查询和单点修改 * 时间复杂度：构建 O(n)，查询 O(log n)，更新 O(log n) */ class SegmentTree { private int[] tree; // 线段树数组 private int n; // 原数组大小 public SegmentTree(int[] nums) { n = nums.length; tree = new int[4 * n]; // 线段树最多需要 4n 空间 build(nums, 0, 0, n - 1); } // 构建线段树：递归构建 // node: 当前节点在 tree 中的索引 // start, end: 当前节点代表的区间 [start, end] private void build(int[] nums, int node, int start, int end) { if (start == end) { // 叶子节点：直接存储原数组的值 tree[node] = nums[start]; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; // 左子节点索引 int rightNode = 2 * node + 2; // 右子节点索引 // 递归构建左右子树 build(nums, leftNode, start, mid); build(nums, rightNode, mid + 1, end); // 当前节点的值 = 左子树 + 右子树（区间和） tree[node] = tree[leftNode] + tree[rightNode]; } // 区间查询：查询区间 [l, r] 的和 public int query(int l, int r) { return query(0, 0, n - 1, l, r); } private int query(int node, int start, int end, int l, int r) { // 情况1：当前区间与查询区间完全不相交 if (l \u0026gt; end || r \u0026lt; start) return 0; // 情况2：当前区间完全包含在查询区间内 if (l \u0026lt;= start \u0026amp;\u0026amp; end \u0026lt;= r) return tree[node]; // 情况3：部分相交，需要递归查询左右子树 int mid = start + (end - start) / 2; int leftSum = query(2 * node + 1, start, mid, l, r); int rightSum = query(2 * node + 2, mid + 1, end, l, r); return leftSum + rightSum; } // 单点更新：将 index 位置的值更新为 val public void update(int index, int val) { update(0, 0, n - 1, index, val); } private void update(int node, int start, int end, int index, int val) { if (start == end) { // 找到叶子节点，更新值 tree[node] = val; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; int rightNode = 2 * node + 2; // 判断 index 在左子树还是右子树 if (index \u0026lt;= mid) { update(leftNode, start, mid, index, val); } else { update(rightNode, mid + 1, end, index, val); } // 更新完子树后，更新当前节点 tree[node] = tree[leftNode] + tree[rightNode]; } } 2. 图算法 图的表示 // 方式1：邻接表（适合稀疏图） Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; graph = new HashMap\u0026lt;\u0026gt;(); // 或使用 ArrayList List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); // 方式2：邻接矩阵（适合密集图） int[][] graph = new int[n][n]; // graph[i][j] 表示 i 到 j 的边权 DFS - 图的深度优先遍历 // 递归实现 DFS void dfs(int node, Set\u0026lt;Integer\u0026gt; visited, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { visited.add(node); // 标记当前节点已访问 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { // 如果邻居未访问 dfs(neighbor, visited, graph); // 递归访问邻居 } } } // 使用示例 Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); dfs(0, visited, graph); // 从节点 0 开始 DFS BFS - 图的广度优先遍历 // 使用队列实现 BFS void bfs(int start, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(start); // 起始节点入队 visited.add(start); // 标记已访问 while (!queue.isEmpty()) { int node = queue.poll(); // 出队 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { queue.offer(neighbor); // 邻居入队 visited.add(neighbor); // 标记已访问 } } } } 拓扑排序（Kahn 算法） /** * 拓扑排序：将有向无环图(DAG)转换为线性序列 * 应用：课程安排、任务调度等 * 核心思想：不断移除入度为0的节点 */ List\u0026lt;Integer\u0026gt; topologicalSort(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] inDegree = new int[n]; // 记录每个节点的入度 for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } // 构建图并计算入度 for (int[] edge : edges) { graph.get(edge[0]).add(edge[1]); // edge[0] -\u0026gt; edge[1] inDegree[edge[1]]++; // edge[1] 的入度+1 } // 将所有入度为0的节点入队 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (inDegree[i] == 0) { queue.offer(i); } } List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); while (!queue.isEmpty()) { int node = queue.poll(); res.add(node); // 将节点加入结果 // 删除该节点的所有出边 for (int neighbor : graph.get(node)) { inDegree[neighbor]--; // 邻居的入度-1 if (inDegree[neighbor] == 0) { // 入度变为0，入队 queue.offer(neighbor); } } } // 如果所有节点都被访问，说明无环，返回结果；否则返回空 return res.size() == n ? res : new ArrayList\u0026lt;\u0026gt;(); } Dijkstra 最短路径算法 /** * Dijkstra算法：单源最短路径（不能有负权边） * 时间复杂度：O(E log V)，E是边数，V是顶点数 * 核心思想：贪心，每次选择距离最小的未访问节点 */ int[] dijkstra(int n, int[][] edges, int start) { // 构建邻接表: {neighbor, weight} List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // edge = [from, to, weight] graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); } // dist[i] 表示从 start 到 i 的最短距离 int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 优先队列: {distance, node}，按距离从小到大排序 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); pq.offer(new int[]{0, start}); while (!pq.isEmpty()) { int[] curr = pq.poll(); int d = curr[0], node = curr[1]; // 如果当前距离大于已知最短距离，跳过 if (d \u0026gt; dist[node]) continue; // 遍历所有邻居，尝试松弛操作 for (int[] neighbor : graph.get(node)) { int next = neighbor[0], weight = neighbor[1]; int newDist = d + weight; // 如果找到更短的路径，更新距离 if (newDist \u0026lt; dist[next]) { dist[next] = newDist; pq.offer(new int[]{newDist, next}); } } } return dist; } Bellman-Ford 算法（可处理负权边） /** * Bellman-Ford算法：单源最短路径，可处理负权边 * 时间复杂度：O(V * E) * 可以检测负环 */ int[] bellmanFord(int n, int[][] edges, int start) { int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 松弛操作：最多进行 n-1 次 // 原理：最短路径最多包含 n-1 条边 for (int i = 0; i \u0026lt; n - 1; i++) { for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; // 松弛操作：如果经过 u 到 v 更短，则更新 if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { dist[v] = dist[u] + w; } } } // 第 n 次松弛：如果还能更新，说明存在负环 for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { return null; // 存在负环 } } return dist; } Floyd-Warshall 全源最短路径 /** * Floyd-Warshall算法：计算所有点对之间的最短路径 * 时间复杂度：O(V³) * 核心思想：动态规划，逐步加入中间节点 */ int[][] floydWarshall(int n, int[][] edges) { int[][] dist = new int[n][n]; // 初始化距离矩阵 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(dist[i], Integer.MAX_VALUE / 2); // 除以2防止溢出 dist[i][i] = 0; // 自己到自己距离为0 } // 填入边的权重 for (int[] edge : edges) { dist[edge[0]][edge[1]] = edge[2]; } // 动态规划：k 是中间节点 // dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) for (int k = 0; k \u0026lt; n; k++) { // 枚举中间节点 for (int i = 0; i \u0026lt; n; i++) { // 枚举起点 for (int j = 0; j \u0026lt; n; j++) { // 枚举终点 // 如果经过 k 中转更短，则更新 dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]); } } } return dist; } Prim 最小生成树 /** * Prim算法：构建最小生成树 * 时间复杂度：O(E log V) * 核心思想：从一个节点开始，逐步扩展，每次选最小边 */ int prim(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // 无向图：添加双向边 graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); graph.get(edge[1]).add(new int[]{edge[0], edge[2]}); } boolean[] visited = new boolean[n]; // 优先队列：{node, weight}，按权重从小到大 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[1] - b[1]); pq.offer(new int[]{0, 0}); // 从节点0开始，权重0 int totalWeight = 0; // 最小生成树的总权重 int edgeCount = 0; // 已添加的边数 while (!pq.isEmpty() \u0026amp;\u0026amp; edgeCount \u0026lt; n) { int[] curr = pq.poll(); int node = curr[0], weight = curr[1]; if (visited[node]) continue; // 已访问，跳过 visited[node] = true; totalWeight += weight; // 加入最小生成树 edgeCount++; // 将邻居节点的边加入优先队列 for (int[] neighbor : graph.get(node)) { if (!visited[neighbor[0]]) { pq.offer(neighbor); } } } // 如果所有节点都连通，返回总权重；否则返回-1 return edgeCount == n ? totalWeight : -1; } Kruskal 最小生成树（并查集） /** * 并查集：用于判断连通性和合并集合 */ class UnionFind { int[] parent; // parent[i] 表示 i 的父节点 int[] rank; // rank[i] 表示以 i 为根的树的高度 public UnionFind(int n) { parent = new int[n]; rank = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; // 初始时每个节点的父节点是自己 } } // 查找：找到 x 所在集合的代表元素（路径压缩） public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); // 路径压缩：直接连到根节点 } return parent[x]; } // 合并：将 x 和 y 所在的集合合并（按秩合并） public boolean union(int x, int y) { int rootX = find(x), rootY = find(y); if (rootX == rootY) return false; // 已经在同一集合 // 按秩合并：将矮树挂到高树上 if (rank[rootX] \u0026lt; rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] \u0026gt; rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; // 高度相同，随便挂，高度+1 } return true; } } /** * Kruskal算法：构建最小生成树 * 时间复杂度：O(E log E) * 核心思想：按边权从小到大排序，用并查集避免成环 */ int kruskal(int n, int[][] edges) { // 按边权从小到大排序 Arrays.sort(edges, (a, b) -\u0026gt; a[2] - b[2]); UnionFind uf = new UnionFind(n); int totalWeight = 0; int edgeCount = 0; for (int[] edge : edges) { // 如果两个节点不在同一集合，添加这条边 if (uf.union(edge[0], edge[1])) { totalWeight += edge[2]; edgeCount++; if (edgeCount == n - 1) break; // 最小生成树有 n-1 条边 } } return edgeCount == n - 1 ? totalWeight : -1; } 3. 回溯算法 组合问题 /** * 组合问题：从 n 个数中选 k 个数的所有组合 * 例如：n=4, k=2 -\u0026gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), 1, n, k); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int start, int n, int k) { // 递归终止条件：已选择 k 个数 if (path.size() == k) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 注意：要复制一份 return; } // 从 start 开始枚举，避免重复 for (int i = start; i \u0026lt;= n; i++) { path.add(i); // 做选择 backtrack(res, path, i + 1, n, k); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } 全排列 /** * 全排列问题：给定数组，返回所有可能的排列 * 例如：[1,2,3] -\u0026gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, new boolean[nums.length]); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, boolean[] used) { // 递归终止条件：所有数字都已使用 if (path.size() == nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } // 枚举所有数字 for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) continue; // 已使用过，跳过 path.add(nums[i]); // 做选择 used[i] = true; // 标记已使用 backtrack(res, path, nums, used); // 递归 used[i] = false; // 撤销标记（回溯） path.remove(path.size() - 1); // 撤销选择（回溯） } } 子集问题 /** * 子集问题：返回数组的所有子集（幂集） * 例如：[1,2,3] -\u0026gt; [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, int start) { // 每个状态都是一个子集 res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 枚举后续元素 for (int i = start; i \u0026lt; nums.length; i++) { path.add(nums[i]); // 做选择 backtrack(res, path, nums, i + 1); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } N 皇后问题 /** * N皇后问题：在 n×n 的棋盘上放置 n 个皇后，使它们互不攻击 * 规则：任意两个皇后不能在同一行、同一列、同一对角线 */ List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); char[][] board = new char[n][n]; // 初始化棋盘：\u0026#39;.\u0026#39; 表示空位 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(board[i], \u0026#39;.\u0026#39;); } backtrack(res, board, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res, char[][] board, int row) { // 递归终止条件：所有行都放置完成 if (row == board.length) { res.add(construct(board)); // 将棋盘转换为字符串列表 return; } // 尝试在当前行的每一列放置皇后 for (int col = 0; col \u0026lt; board.length; col++) { if (!isValid(board, row, col)) continue; // 不合法，跳过 board[row][col] = \u0026#39;Q\u0026#39;; // 放置皇后 backtrack(res, board, row + 1); // 递归下一行 board[row][col] = \u0026#39;.\u0026#39;; // 撤销放置（回溯） } } // 检查在 (row, col) 位置放置皇后是否合法 boolean isValid(char[][] board, int row, int col) { int n = board.length; // 检查列：同一列不能有其他皇后 for (int i = 0; i \u0026lt; row; i++) { if (board[i][col] == \u0026#39;Q\u0026#39;) return false; } // 检查左上对角线 for (int i = row - 1, j = col - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } // 检查右上对角线 for (int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } return true; } // 将棋盘转换为字符串列表 List\u0026lt;String\u0026gt; construct(char[][] board) { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for (char[] row : board) { res.add(new String(row)); } return res; } 4. 动态规划 0-1 背包问题 /** * 0-1背包：每个物品只能选一次 * weights[i]: 第i个物品的重量 * values[i]: 第i个物品的价值 * capacity: 背包容量 * 返回：最大价值 */ int knapsack(int[] weights, int[] values, int capacity) { int n = weights.length; // dp[i][w] 表示前 i 个物品，背包容量为 w 时的最大价值 int[][] dp = new int[n + 1][capacity + 1]; for (int i = 1; i \u0026lt;= n; i++) { for (int w = 0; w \u0026lt;= capacity; w++) { // 如果当前物品的重量 \u0026lt;= 背包容量 if (weights[i - 1] \u0026lt;= w) { // 选择：max(不拿, 拿) dp[i][w] = Math.max( dp[i - 1][w], // 不拿第i个物品 dp[i - 1][w - weights[i - 1]] + values[i - 1] // 拿第i个物品 ); } else { // 放不下，只能不拿 dp[i][w] = dp[i - 1][w]; } } } return dp[n][capacity]; } /** * 0-1背包 - 空间优化版本 * 时间复杂度：O(n * capacity) * 空间复杂度：O(capacity) */ int knapsackOptimized(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：必须从后往前遍历，避免重复使用同一物品 for (int w = capacity; w \u0026gt;= weights[i]; w--) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 完全背包问题 /** * 完全背包：每个物品可以选无限次 * 与0-1背包的区别：内层循环从前往后遍历 */ int completeKnapsack(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：从前往后遍历，允许重复使用物品 for (int w = weights[i]; w \u0026lt;= capacity; w++) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 最长公共子序列（LCS） /** * 最长公共子序列：找两个字符串的最长公共子序列长度 * 子序列：不要求连续 * 例如：\u0026#34;abcde\u0026#34; 和 \u0026#34;ace\u0026#34; 的LCS是 \u0026#34;ace\u0026#34;，长度为3 */ int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); // dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的LCS长度 int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (text1.charAt(i - 1) == text2.charAt(j - 1)) { // 字符相同：LCS长度+1 dp[i][j] = dp[i - 1][j - 1] + 1; } else { // 字符不同：取两种情况的最大值 dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; } 最长递增子序列（LIS） /** * 最长递增子序列 - O(n²) 动态规划解法 * dp[i] 表示以 nums[i] 结尾的最长递增子序列长度 */ int lengthOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; Arrays.fill(dp, 1); // 初始每个元素自己构成长度为1的子序列 int maxLen = 1; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { // 如果 nums[i] 可以接在 nums[j] 后面 if (nums[i] \u0026gt; nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } maxLen = Math.max(maxLen, dp[i]); } return maxLen; } /** * 最长递增子序列 - O(n log n) 二分解法 * tails[i] 表示长度为 i+1 的递增子序列的最小尾部元素 */ int lengthOfLISBinary(int[] nums) { List\u0026lt;Integer\u0026gt; tails = new ArrayList\u0026lt;\u0026gt;(); for (int num : nums) { // 二分查找：找到第一个 \u0026gt;= num 的位置 int left = 0, right = tails.size(); while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (tails.get(mid) \u0026lt; num) { left = mid + 1; } else { right = mid; } } // 如果 num 比所有元素都大，追加到末尾 if (left == tails.size()) { tails.add(num); } else { // 否则替换找到的位置 tails.set(left, num); } } return tails.size(); } 编辑距离 /** * 编辑距离：将 word1 转换为 word2 的最少操作次数 * 操作：插入、删除、替换 * 例如：\u0026#34;horse\u0026#34; -\u0026gt; \u0026#34;ros\u0026#34; 需要3步（删除h、删除r、替换s） */ int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); // dp[i][j] 表示 word1[0..i-1] 转换为 word2[0..j-1] 的最少操作数 int[][] dp = new int[m + 1][n + 1]; // 边界条件：一个字符串为空 for (int i = 0; i \u0026lt;= m; i++) dp[i][0] = i; // word1 -\u0026gt; 空串：删除i个字符 for (int j = 0; j \u0026lt;= n; j++) dp[0][j] = j; // 空串 -\u0026gt; word2：插入j个字符 for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { // 字符相同：不需要操作 dp[i][j] = dp[i - 1][j - 1]; } else { // 字符不同：三种操作取最小 dp[i][j] = Math.min( Math.min( dp[i - 1][j], // 删除 word1[i-1] dp[i][j - 1] // 插入 word2[j-1] ), dp[i - 1][j - 1] // 替换 word1[i-1] 为 word2[j-1] ) + 1; } } } return dp[m][n]; } 股票买卖问题 只能买卖一次\n/** * 买卖股票的最佳时机 I：只能买卖一次 * 贪心思想：记录最低价格，计算每天卖出的最大利润 */ int maxProfit(int[] prices) { int minPrice = Integer.MAX_VALUE; // 记录目前为止的最低价格 int maxProfit = 0; // 记录最大利润 for (int price : prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; } 可以买卖多次\n/** * 买卖股票的最佳时机 II：可以买卖多次 * 贪心思想：只要今天价格比昨天高，就在昨天买今天卖 */ int maxProfitMultiple(int[] prices) { int profit = 0; for (int i = 1; i \u0026lt; prices.length; i++) { // 如果今天价格更高，累加差价 if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } 最多买卖 k 次\n/** * 买卖股票的最佳时机 III/IV：最多买卖 k 次 * dp[i][j] 表示第 i 次交易后，第 j 天的最大利润 */ int maxProfitK(int k, int[] prices) { if (prices.length == 0) return 0; int n = prices.length; // 如果 k \u0026gt;= n/2，相当于无限次交易 if (k \u0026gt;= n / 2) { int profit = 0; for (int i = 1; i \u0026lt; n; i++) { if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } int[][] dp = new int[k + 1][n]; for (int i = 1; i \u0026lt;= k; i++) { int maxDiff = -prices[0]; // 第 i-1 次交易后买入的最大收益 for (int j = 1; j \u0026lt; n; j++) { // 不操作 vs 卖出 dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff); // 更新买入的最大收益 maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]); } } return dp[k][n - 1]; } 打家劫舍 /** * 打家劫舍 I：线性排列的房屋 * 不能抢相邻的房屋 * dp[i] = max(dp[i-1], dp[i-2] + nums[i]) */ int rob(int[] nums) { if (nums.length == 0) return 0; if (nums.length == 1) return nums[0]; int prev2 = 0, prev1 = 0; // prev2: dp[i-2], prev1: dp[i-1] for (int num : nums) { int temp = prev1; // 不抢 vs 抢 prev1 = Math.max(prev1, prev2 + num); prev2 = temp; } return prev1; } /** * 打家劫舍 II：环形排列的房屋 * 第一个和最后一个房屋相邻 * 思路：分两种情况，取最大值 * 1. 抢第一个房屋，不抢最后一个 * 2. 不抢第一个房屋，抢最后一个 */ int robCircular(int[] nums) { if (nums.length == 1) return nums[0]; return Math.max( robRange(nums, 0, nums.length - 2), robRange(nums, 1, nums.length - 1) ); } int robRange(int[] nums, int start, int end) { int prev2 = 0, prev1 = 0; for (int i = start; i \u0026lt;= end; i++) { int temp = prev1; prev1 = Math.max(prev1, prev2 + nums[i]); prev2 = temp; } return prev1; } 分割等和子集 /** * 分割等和子集：判断是否能将数组分成两个和相等的子集 * 本质：0-1背包问题，目标是找到和为 sum/2 的子集 */ boolean canPartition(int[] nums) { int sum = 0; for (int num : nums) sum += num; if (sum % 2 != 0) return false; // 和为奇数，不可能分割 int target = sum / 2; // dp[j] 表示能否凑出和为 j boolean[] dp = new boolean[target + 1]; dp[0] = true; // 和为0总是可以（不选任何数） for (int num : nums) { // 从后往前遍历，避免重复使用 for (int j = target; j \u0026gt;= num; j--) { dp[j] = dp[j] || dp[j - num]; // 不选 num 或 选 num } } return dp[target]; } 零钱兑换 /** * 零钱兑换 I：最少硬币数 * dp[i] 表示凑出金额 i 所需的最少硬币数 */ int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); // 初始化为不可能的大值 dp[0] = 0; // 凑出0元需要0个硬币 for (int i = 1; i \u0026lt;= amount; i++) { for (int coin : coins) { if (i \u0026gt;= coin) { // 选择使用当前硬币 dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } } return dp[amount] \u0026gt; amount ? -1 : dp[amount]; } /** * 零钱兑换 II：组成方案数 * dp[i] 表示凑出金额 i 的方案数 */ int change(int amount, int[] coins) { int[] dp = new int[amount + 1]; dp[0] = 1; // 凑出0元有1种方案（不选） // 外层遍历硬币，内层遍历金额（避免重复计数） for (int coin : coins) { for (int i = coin; i \u0026lt;= amount; i++) { dp[i] += dp[i - coin]; } } return dp[amount]; } 5. 双指针 对撞指针 // 两数之和（有序数组） int[] twoSum(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[left] + nums[right]; if (sum == target) { return new int[]{left, right}; } else if (sum \u0026lt; target) { left++; } else { right--; } } return new int[]{-1, -1}; } // 三数之和 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length - 2; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { res.add(Arrays.asList(nums[i], nums[left], nums[right])); while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; left++; right--; } else if (sum \u0026lt; 0) { left++; } else { right--; } } } return res; } 快慢指针 // 链表中点 ListNode findMiddle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } // 环形链表 boolean hasCycle(ListNode head) { if (head == null) return false; ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) return true; } return false; } // 找环的入口 ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { slow = head; while (slow != fast) { slow = slow.next; fast = fast.next; } return slow; } } return null; } 6. 单调栈 // 下一个更大元素 int[] nextGreaterElement(int[] nums) { int n = nums.length; int[] res = new int[n]; Arrays.fill(res, -1); Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; nums[stack.peek()] \u0026lt; nums[i]) { int idx = stack.pop(); res[idx] = nums[i]; } stack.push(i); } return res; } // 每日温度 int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] res = new int[n]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[stack.peek()] \u0026lt; temperatures[i]) { int idx = stack.pop(); res[idx] = i - idx; } stack.push(i); } return res; } // 柱状图中最大的矩形 int largestRectangleArea(int[] heights) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(-1); int maxArea = 0; for (int i = 0; i \u0026lt; heights.length; i++) { while (stack.peek() != -1 \u0026amp;\u0026amp; heights[stack.peek()] \u0026gt;= heights[i]) { int h = heights[stack.pop()]; int w = i - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } stack.push(i); } while (stack.peek() != -1) { int h = heights[stack.pop()]; int w = heights.length - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } return maxArea; } 7. 前缀和 // 一维前缀和 class PrefixSum { private int[] preSum; public PrefixSum(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 0; i \u0026lt; nums.length; i++) { preSum[i + 1] = preSum[i] + nums[i]; } } // 查询区间 [left, right] 的和 public int query(int left, int right) { return preSum[right + 1] - preSum[left]; } } // 二维前缀和 class MatrixPrefixSum { private int[][] preSum; public MatrixPrefixSum(int[][] matrix) { int m = matrix.length, n = matrix[0].length; preSum = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } // 查询子矩阵 [row1, col1] 到 [row2, col2] 的和 public int query(int row1, int col1, int row2, int col2) { return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]; } } 📌 总结 这份文档涵盖了：\nJava 集合框架：List、Set、Map、Queue、Stack 的完整使用方法 树算法：DFS、BFS、线段树 图算法：遍历、最短路径、最小生成树 经典算法：回溯、动态规划、二分查找、滑动窗口、双指针、单调栈、前缀和 建议配合 LeetCode 刷题使用，遇到问题时可以快速查阅对应的模板代码。\n持续更新中\u0026hellip; 🚀\n","permalink":"http://localhost:1313/java-notes/algorithm-with-java/","summary":"详细介绍java集合的使用,以及在刷算法题中需要使用到的一些板子","title":"算法刷题必备：Java集合与算法模板"},{"content":"一、Hugo 常用指令 1.1 创建新站点 # 创建一个新的 Hugo 站点 hugo new site mysite # 进入站点目录 cd mysite 1.2 创建新文章 # 在 content/posts 目录下创建新文章 hugo new posts/my-first-post.md # 在 content 目录下创建文章 hugo new about.md # 创建在特定子目录 hugo new blog/2024/new-post.md 1.3 本地预览 # 启动本地开发服务器（默认 http://localhost:1313） hugo server # 启动并显示草稿文章 hugo server -D # 启动并显示草稿、未来日期和过期的文章 hugo server -DEF # 指定端口 hugo server --port 8080 # 实时重载并打开浏览器 hugo server -D --navigateToChanged 1.4 主题管理 # 添加主题（使用 Git submodule） git submodule add https://github.com/username/theme-name.git themes/theme-name # 更新主题 git submodule update --remote --merge # 删除主题 git submodule deinit -f themes/theme-name rm -rf .git/modules/themes/theme-name git rm -f themes/theme-name 1.5 其他常用指令 # 查看 Hugo 版本 hugo version # 查看帮助 hugo help # 查看配置信息 hugo config # 列出所有内容 hugo list all # 列出草稿 hugo list drafts 二、Markdown Front Matter 配置 2.1 完整配置示例 --- # 基本信息 title: \u0026#34;我的第一篇文章\u0026#34; date: 2025-12-06T15:04:05+08:00 lastmod: 2025-12-07T10:00:00+08:00 draft: false # 作者信息 author: \u0026#34;Minjie\u0026#34; authorLink: \u0026#34;https://github.com/Minjie2003\u0026#34; # 分类和标签 categories: [\u0026#34;技术\u0026#34;] tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;, \u0026#34;博客\u0026#34;] series: [\u0026#34;Hugo教程\u0026#34;] # 摘要和描述 summary: \u0026#34;这是一篇关于 Hugo 和 Markdown 的完整指南\u0026#34; description: \u0026#34;详细介绍 Hugo 的使用方法和 Markdown 配置\u0026#34; # 特色图片 image: \u0026#34;/images/featured.jpg\u0026#34; cover: image: \u0026#34;/images/cover.jpg\u0026#34; alt: \u0026#34;封面图片描述\u0026#34; caption: \u0026#34;图片说明文字\u0026#34; # SEO 相关 keywords: [\u0026#34;Hugo\u0026#34;, \u0026#34;静态博客\u0026#34;, \u0026#34;Markdown\u0026#34;] slug: \u0026#34;hugo-markdown-guide\u0026#34; url: \u0026#34;/posts/hugo-guide/\u0026#34; # 显示控制 toc: true # 显示目录 comments: true # 允许评论 showToc: true # 显示目录 TocOpen: false # 默认展开目录 hidemeta: false # 隐藏元信息 disableShare: false # 禁用分享按钮 hideSummary: false # 隐藏摘要 ShowReadingTime: true # 显示阅读时间 ShowBreadCrumbs: true # 显示面包屑导航 ShowPostNavLinks: true # 显示文章导航链接 # 权重（用于排序） weight: 1 # 外部链接 externalLink: \u0026#34;https://example.com\u0026#34; # 是否在首页显示 showhome: true --- 2.2 常用字段说明 字段 说明 示例 title 文章标题 \u0026quot;我的文章\u0026quot; date 发布日期 2025-12-06 或 2025-12-06T15:04:05+08:00 draft 是否为草稿 true / false tags 标签（数组） [\u0026quot;Hugo\u0026quot;, \u0026quot;博客\u0026quot;] categories 分类（数组） [\u0026quot;技术\u0026quot;, \u0026quot;教程\u0026quot;] summary 文章摘要 \u0026quot;这是摘要\u0026quot; description SEO 描述 \u0026quot;页面描述\u0026quot; slug URL 友好名称 \u0026quot;my-post\u0026quot; url 自定义完整 URL \u0026quot;/posts/my-post/\u0026quot; weight 排序权重 1 (数字越小越靠前) toc 是否显示目录 true / false 三、Hugo Shortcodes（短代码） 3.1 内置 Shortcodes # 显示图片 {{\u0026lt; figure src=\u0026#34;/images/photo.jpg\u0026#34; title=\u0026#34;图片标题\u0026#34; \u0026gt;}} # 高亮文本 {{\u0026lt; highlight python \u0026gt;}} def hello(): print(\u0026#34;Hello!\u0026#34;) {{\u0026lt; /highlight \u0026gt;}} # YouTube 视频 {{\u0026lt; youtube VIDEO_ID \u0026gt;}} # X (Twitter) 推文（新版） {{\u0026lt; x user=\u0026#34;USERNAME\u0026#34; id=\u0026#34;TWEET_ID\u0026#34; \u0026gt;}} # GitHub Gist（已废弃，建议直接嵌入代码） # 可以使用 highlight 或直接用代码块替代 # 参数传递（需要在 Front Matter 中定义参数） {{\u0026lt; param \u0026#34;description\u0026#34; \u0026gt;}} 3.2 自定义 Shortcode 示例 在 layouts/shortcodes/note.html 创建：\n\u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; 使用时：\n{{\u0026lt; note \u0026gt;}} 这是一个提示框 {{\u0026lt; /note \u0026gt;}} 四、Markdown 基本语法 4.1 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 4.2 文本样式 **粗体文字** *斜体文字* ***粗斜体*** ~~删除线~~ `行内代码` 4.3 列表 # 无序列表 - 项目 1 - 项目 2 - 子项目 2.1 - 子项目 2.2 # 有序列表 1. 第一项 2. 第二项 1. 子项 2.1 2. 子项 2.2 4.4 链接和图片 # 链接 [链接文字](https://example.com) [带标题的链接](https://example.com \u0026#34;鼠标悬停显示\u0026#34;) # 图片 ![图片描述](/images/photo.jpg) ![图片](https://example.com/image.jpg \u0026#34;图片标题\u0026#34;) 4.5 引用 \u0026gt; 这是一段引用文字 \u0026gt; 可以多行 \u0026gt;\u0026gt; 嵌套引用 4.6 代码块 ```python def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) ``` ```javascript console.log(\u0026#34;Hello, World!\u0026#34;); ``` 4.7 表格 | 列1 | 列2 | 列3 | |-----|-----|-----| | 数据1 | 数据2 | 数据3 | | 数据4 | 数据5 | 数据6 | # 对齐方式 | 左对齐 | 居中 | 右对齐 | |:-------|:----:|-------:| | 内容 | 内容 | 内容 | 4.8 分隔线 --- *** ___ 4.9 任务列表 - [x] 已完成的任务 - [ ] 未完成的任务 - [ ] 另一个任务 五、实用技巧 5.1 文章模板 在 archetypes/default.md 创建默认模板：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true tags: [] categories: [] summary: \u0026#34;\u0026#34; --- ## 简介 内容开始... 5.2 多语言配置 在 Front Matter 中：\n--- title: \u0026#34;English Title\u0026#34; title.zh: \u0026#34;中文标题\u0026#34; --- 5.3 自定义 URL 结构 在 hugo.toml 中：\n[permalinks] posts = \u0026#34;/:year/:month/:slug/\u0026#34; 5.4 草稿快速发布 # 将草稿改为发布状态 sed -i \u0026#39;s/draft: true/draft: false/\u0026#39; content/posts/my-post.md ","permalink":"http://localhost:1313/doc-intro/hugo-readme/","summary":"详细介绍 Hugo 常用指令、Markdown Front Matter 配置、基本语法和实用技巧的完整指南","title":"Hugo 常用指令与 Markdown 配置指南"},{"content":"👋 嗨，我是 Minjie 很高兴你能来到这里！这是我在互联网上的一个小角落，用来记录代码、想法和生活的点滴。\n🧑‍💻 关于我 我是一名在读研究生，研究方向包括区块链，web3.0，数据库管理等。当然，目前更加专注于 Java 后端开发。相比起\u0026quot;全栈工程师\u0026quot;这样的标签，我更喜欢把自己定义为一个对计算机技术充满好奇心的探索者。\n📖 这个博客写什么 这里主要记录我在技术道路上的成长轨迹，你可能会看到：\n技术笔记 - Java 后端开发的实践经验、框架使用心得、踩过的坑和解决方案\n项目复盘 - 从需求分析到上线部署，记录项目中的思考和收获\n学习记录 - 新技术的探索、算法题的思路、计算机基础知识的整理\n随笔杂谈 - 偶尔也会写写读书笔记、游戏感想，或者对技术趋势的一些思考\n我希望这里不仅是我个人的知识库,也能给同样在技术路上摸索的你带来一些启发或共鸣。\n🎯 技术栈 \u0026amp; 兴趣方向 后端开发：Java、Spring Boot、MyBatis、MySQL、Redis - 这是我的主战场\n折腾爱好：除了后端，我还喜欢写点爬虫玩玩，做些自动化小工具来解决日常遇到的重复性工作。总觉得能用代码解决的事情，就不该浪费时间手动操作。有时候为了实现一个自动化脚本，花的时间可能比手动做还多，但那种\u0026quot;一劳永逸\u0026quot;的快感真的很上头。\n探索中：对各种能提高效率的技术和工具都充满兴趣，正在不断拓展技术边界\u0026hellip;\n🎮 代码之外 游戏时光：Steam 上收藏了不少游戏，也会玩玩王者、原神这些。\n音乐陪伴：写代码的时候总要听点什么。古典音乐能让思路更清晰，ACG 音乐带来满满的回忆，偶尔也会跟着流行音乐哼哼唱唱。喜欢洗澡的时候k歌······当然，也是个半吊子吉他选手\n运动爱好：除了敲键盘，也喜欢出去动一动。篮球、羽毛球、乒乓球都有涉猎，虽然都不算精通，但也能过上两招。过去打篮球多一点，现在更想尝试羽毛球。\n历史爱好者：对历史有种莫名的着迷，喜欢看历史书籍、纪录片。主要包括近现代欧洲历史，唐史，春秋战国。\n💬 来聊聊？ 如果你也对后端开发感兴趣，或者想交流技术、分享项目经验，甚至只是想推荐个好玩的游戏或好听的歌，都欢迎联系我：\n📧 邮箱：zhongnagisa01@gmail.com 🐙 GitHub：Minjie2003 \u0026ldquo;流水不争先，争的是滔滔不绝\u0026rdquo;\n感谢你的访问，希望我们能在这里有更多交流！✨\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于我"}]