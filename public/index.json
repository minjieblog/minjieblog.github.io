[{"content":"一、数据库操作 1.1 创建和删除数据库 -- 创建数据库 CREATE DATABASE database_name; CREATE DATABASE IF NOT EXISTS database_name CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; -- 删除数据库 DROP DATABASE database_name; DROP DATABASE IF EXISTS database_name; -- 查看所有数据库 SHOW DATABASES; -- 选择数据库 USE database_name; -- 查看当前数据库 SELECT DATABASE(); 二、数据表操作 2.1 创建表 -- 基础创建表 CREATE TABLE users ( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(50) NOT NULL UNIQUE, email VARCHAR(100), age INT DEFAULT 0, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ); -- 创建表时指定引擎和字符集 CREATE TABLE products ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(100) NOT NULL, price DECIMAL(10, 2), stock INT DEFAULT 0 ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; -- 从查询结果创建表 CREATE TABLE users_backup AS SELECT * FROM users; 2.2 修改表结构 -- 添加列 ALTER TABLE users ADD COLUMN phone VARCHAR(20); ALTER TABLE users ADD COLUMN address TEXT AFTER email; -- 修改列 ALTER TABLE users MODIFY COLUMN age TINYINT; ALTER TABLE users CHANGE COLUMN username user_name VARCHAR(60); -- 删除列 ALTER TABLE users DROP COLUMN phone; -- 重命名表 RENAME TABLE users TO members; ALTER TABLE members RENAME TO users; -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键 ALTER TABLE users DROP PRIMARY KEY; -- 添加索引 ALTER TABLE users ADD INDEX idx_username (username); ALTER TABLE users ADD UNIQUE INDEX idx_email (email); -- 删除索引 ALTER TABLE users DROP INDEX idx_username; 2.3 查看表信息 -- 查看所有表 SHOW TABLES; -- 查看表结构 DESC users; DESCRIBE users; SHOW COLUMNS FROM users; -- 查看创建表的语句 SHOW CREATE TABLE users; -- 查看表状态 SHOW TABLE STATUS LIKE \u0026#39;users\u0026#39;; 2.4 删除和清空表 -- 删除表 DROP TABLE users; DROP TABLE IF EXISTS users; -- 清空表数据（保留结构） TRUNCATE TABLE users; DELETE FROM users; -- 与 TRUNCATE 的区别是可以回滚 三、数据操作（CRUD） 3.1 插入数据（INSERT） -- 插入单条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;, 25); -- 插入多条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;李四\u0026#39;, \u0026#39;lisi@example.com\u0026#39;, 28), (\u0026#39;王五\u0026#39;, \u0026#39;wangwu@example.com\u0026#39;, 30); -- 插入所有列（可省略列名） INSERT INTO users VALUES (NULL, \u0026#39;赵六\u0026#39;, \u0026#39;zhaoliu@example.com\u0026#39;, 22, NOW(), NOW()); -- 插入或更新（存在则更新） INSERT INTO users (id, username, email) VALUES (1, \u0026#39;张三\u0026#39;, \u0026#39;new@example.com\u0026#39;) ON DUPLICATE KEY UPDATE email = \u0026#39;new@example.com\u0026#39;; -- 忽略重复插入错误 INSERT IGNORE INTO users (username, email) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;); -- 从其他表插入数据 INSERT INTO users_backup SELECT * FROM users WHERE age \u0026gt; 25; 3.2 查询数据（SELECT） 基础查询 -- 查询所有列 SELECT * FROM users; -- 查询指定列 SELECT username, email FROM users; -- 使用别名 SELECT username AS name, email AS mail FROM users; -- 去重查询 SELECT DISTINCT age FROM users; -- 限制结果数量 SELECT * FROM users LIMIT 10; SELECT * FROM users LIMIT 10, 20; -- 跳过前10条，取20条 SELECT * FROM users LIMIT 20 OFFSET 10; -- 同上 WHERE 条件查询 -- 基本条件 SELECT * FROM users WHERE age \u0026gt; 25; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users WHERE email IS NULL; SELECT * FROM users WHERE email IS NOT NULL; -- 多条件组合 SELECT * FROM users WHERE age \u0026gt; 20 AND age \u0026lt; 30; SELECT * FROM users WHERE age BETWEEN 20 AND 30; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39; OR username = \u0026#39;李四\u0026#39;; SELECT * FROM users WHERE username IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;); SELECT * FROM users WHERE username NOT IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;); -- 模糊查询 SELECT * FROM users WHERE username LIKE \u0026#39;张%\u0026#39;; -- 以\u0026#34;张\u0026#34;开头 SELECT * FROM users WHERE username LIKE \u0026#39;%三\u0026#39;; -- 以\u0026#34;三\u0026#34;结尾 SELECT * FROM users WHERE username LIKE \u0026#39;%张%\u0026#39;; -- 包含\u0026#34;张\u0026#34; SELECT * FROM users WHERE username LIKE \u0026#39;张_\u0026#39;; -- 张+一个字符 SELECT * FROM users WHERE username NOT LIKE \u0026#39;张%\u0026#39;; 排序和分组 -- 排序 SELECT * FROM users ORDER BY age ASC; -- 升序（默认） SELECT * FROM users ORDER BY age DESC; -- 降序 SELECT * FROM users ORDER BY age DESC, username ASC; -- 多列排序 -- 分组 SELECT age, COUNT(*) as count FROM users GROUP BY age; SELECT age, AVG(age) as avg_age FROM users GROUP BY age; -- HAVING 过滤分组结果 SELECT age, COUNT(*) as count FROM users GROUP BY age HAVING count \u0026gt; 5; 聚合函数 -- 计数 SELECT COUNT(*) FROM users; SELECT COUNT(DISTINCT age) FROM users; -- 求和、平均、最大、最小 SELECT SUM(age) FROM users; SELECT AVG(age) FROM users; SELECT MAX(age) FROM users; SELECT MIN(age) FROM users; -- 多个聚合函数 SELECT COUNT(*) as total, AVG(age) as avg_age, MAX(age) as max_age FROM users; 连接查询（JOIN） -- 内连接（INNER JOIN） SELECT users.username, orders.order_no FROM users INNER JOIN orders ON users.id = orders.user_id; -- 左连接（LEFT JOIN） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id; -- 右连接（RIGHT JOIN） SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 全连接（FULL JOIN，MySQL不直接支持，需要用UNION） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id UNION SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 自连接 SELECT a.username, b.username as friend FROM users a INNER JOIN users b ON a.friend_id = b.id; -- 多表连接 SELECT u.username, o.order_no, p.product_name FROM users u INNER JOIN orders o ON u.id = o.user_id INNER JOIN order_items oi ON o.id = oi.order_id INNER JOIN products p ON oi.product_id = p.id; 子查询 -- WHERE 子查询 SELECT * FROM users WHERE id IN (SELECT user_id FROM orders WHERE amount \u0026gt; 1000); -- FROM 子查询 SELECT avg_age FROM (SELECT AVG(age) as avg_age FROM users GROUP BY city) as subquery; -- EXISTS 子查询 SELECT * FROM users WHERE EXISTS (SELECT 1 FROM orders WHERE orders.user_id = users.id); -- 标量子查询 SELECT username, (SELECT COUNT(*) FROM orders WHERE user_id = users.id) as order_count FROM users; 联合查询（UNION） -- UNION（去重） SELECT username FROM users WHERE age \u0026gt; 30 UNION SELECT username FROM admins WHERE age \u0026gt; 30; -- UNION ALL（不去重，性能更好） SELECT username FROM users WHERE age \u0026gt; 30 UNION ALL SELECT username FROM admins WHERE age \u0026gt; 30; 3.3 更新数据（UPDATE） -- 更新单列 UPDATE users SET age = 26 WHERE username = \u0026#39;张三\u0026#39;; -- 更新多列 UPDATE users SET age = 26, email = \u0026#39;new@example.com\u0026#39; WHERE username = \u0026#39;张三\u0026#39;; -- 批量更新 UPDATE users SET age = age + 1 WHERE age \u0026lt; 30; -- 使用表达式更新 UPDATE users SET updated_at = NOW() WHERE id = 1; -- 基于其他表更新 UPDATE users u INNER JOIN orders o ON u.id = o.user_id SET u.total_orders = u.total_orders + 1 WHERE o.created_at \u0026gt; \u0026#39;2024-01-01\u0026#39;; -- 条件更新（CASE） UPDATE users SET level = CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END; 3.4 删除数据（DELETE） -- 删除指定数据 DELETE FROM users WHERE id = 1; -- 批量删除 DELETE FROM users WHERE age \u0026lt; 18; -- 删除所有数据 DELETE FROM users; -- 基于其他表删除 DELETE u FROM users u INNER JOIN orders o ON u.id = o.user_id WHERE o.status = \u0026#39;cancelled\u0026#39;; 四、索引管理 4.1 创建索引 -- 普通索引 CREATE INDEX idx_username ON users(username); -- 唯一索引 CREATE UNIQUE INDEX idx_email ON users(email); -- 复合索引 CREATE INDEX idx_name_age ON users(username, age); -- 全文索引 CREATE FULLTEXT INDEX idx_content ON articles(content); -- 在创建表时添加索引 CREATE TABLE users ( id INT PRIMARY KEY, username VARCHAR(50), email VARCHAR(100), INDEX idx_username (username), UNIQUE INDEX idx_email (email) ); 4.2 查看和删除索引 -- 查看索引 SHOW INDEX FROM users; -- 删除索引 DROP INDEX idx_username ON users; ALTER TABLE users DROP INDEX idx_username; 五、约束管理 5.1 主键约束 -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键（需要先删除 AUTO_INCREMENT 属性） ALTER TABLE users MODIFY id INT; ALTER TABLE users DROP PRIMARY KEY; 5.2 外键约束 -- 添加外键 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id); -- 添加外键时设置级联操作 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE; -- 删除外键 ALTER TABLE orders DROP FOREIGN KEY fk_user_id; 5.3 其他约束 -- 唯一约束 ALTER TABLE users ADD UNIQUE (email); -- 非空约束 ALTER TABLE users MODIFY username VARCHAR(50) NOT NULL; -- 检查约束（MySQL 8.0.16+） ALTER TABLE users ADD CONSTRAINT chk_age CHECK (age \u0026gt;= 0 AND age \u0026lt;= 150); -- 默认值约束 ALTER TABLE users ALTER COLUMN status SET DEFAULT \u0026#39;active\u0026#39;; 六、视图 -- 创建视图 CREATE VIEW active_users AS SELECT id, username, email FROM users WHERE status = \u0026#39;active\u0026#39;; -- 创建或替换视图 CREATE OR REPLACE VIEW active_users AS SELECT id, username, email, age FROM users WHERE status = \u0026#39;active\u0026#39;; -- 查询视图 SELECT * FROM active_users; -- 查看视图定义 SHOW CREATE VIEW active_users; -- 删除视图 DROP VIEW active_users; DROP VIEW IF EXISTS active_users; 七、事务处理 -- 开启事务 START TRANSACTION; -- 或 BEGIN; -- 提交事务 COMMIT; -- 回滚事务 ROLLBACK; -- 设置保存点 SAVEPOINT sp1; ROLLBACK TO sp1; -- 完整示例 START TRANSACTION; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; COMMIT; -- 设置自动提交 SET autocommit = 0; -- 关闭自动提交 SET autocommit = 1; -- 开启自动提交 八、存储过程和函数 8.1 存储过程 -- 创建存储过程 DELIMITER // CREATE PROCEDURE GetUserById(IN userId INT) BEGIN SELECT * FROM users WHERE id = userId; END // DELIMITER ; -- 调用存储过程 CALL GetUserById(1); -- 带输出参数的存储过程 DELIMITER // CREATE PROCEDURE GetUserCount(OUT total INT) BEGIN SELECT COUNT(*) INTO total FROM users; END // DELIMITER ; CALL GetUserCount(@count); SELECT @count; -- 删除存储过程 DROP PROCEDURE IF EXISTS GetUserById; -- 查看存储过程 SHOW PROCEDURE STATUS; SHOW CREATE PROCEDURE GetUserById; 8.2 函数 -- 创建函数 DELIMITER // CREATE FUNCTION GetUserAge(userId INT) RETURNS INT BEGIN DECLARE userAge INT; SELECT age INTO userAge FROM users WHERE id = userId; RETURN userAge; END // DELIMITER ; -- 使用函数 SELECT GetUserAge(1); -- 删除函数 DROP FUNCTION IF EXISTS GetUserAge; 九、触发器 -- 创建 BEFORE INSERT 触发器 DELIMITER // CREATE TRIGGER before_user_insert BEFORE INSERT ON users FOR EACH ROW BEGIN SET NEW.created_at = NOW(); END // DELIMITER ; -- 创建 AFTER UPDATE 触发器 DELIMITER // CREATE TRIGGER after_user_update AFTER UPDATE ON users FOR EACH ROW BEGIN INSERT INTO user_logs (user_id, action, created_at) VALUES (OLD.id, \u0026#39;update\u0026#39;, NOW()); END // DELIMITER ; -- 查看触发器 SHOW TRIGGERS; -- 删除触发器 DROP TRIGGER IF EXISTS before_user_insert; 十、用户和权限管理 -- 创建用户 CREATE USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; CREATE USER \u0026#39;username\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; -- 允许任何主机 -- 授予权限 GRANT ALL PRIVILEGES ON database_name.* TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; GRANT SELECT, INSERT, UPDATE ON database_name.table_name TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 刷新权限 FLUSH PRIVILEGES; -- 查看用户权限 SHOW GRANTS FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 撤销权限 REVOKE INSERT, UPDATE ON database_name.* FROM \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 修改密码 ALTER USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;new_password\u0026#39;; SET PASSWORD FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; = PASSWORD(\u0026#39;new_password\u0026#39;); -- 删除用户 DROP USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; 十一、备份和恢复 -- 使用 mysqldump 备份（在命令行执行） mysqldump -u username -p database_name \u0026gt; backup.sql mysqldump -u username -p database_name table_name \u0026gt; table_backup.sql mysqldump -u username -p --all-databases \u0026gt; all_databases.sql -- 恢复数据库（在命令行执行） mysql -u username -p database_name \u0026lt; backup.sql -- 导出为 CSV SELECT * FROM users INTO OUTFILE \u0026#39;/tmp/users.csv\u0026#39; FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; -- 从 CSV 导入 LOAD DATA INFILE \u0026#39;/tmp/users.csv\u0026#39; INTO TABLE users FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; 十二、性能优化相关 12.1 EXPLAIN 分析查询 -- 分析查询执行计划 EXPLAIN SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; -- 详细分析 EXPLAIN EXTENDED SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SHOW WARNINGS; -- JSON 格式 EXPLAIN FORMAT=JSON SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; 12.2 查询优化 -- 使用索引提示 SELECT * FROM users USE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users FORCE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users IGNORE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; -- 优化 COUNT SELECT COUNT(1) FROM users; -- 比 COUNT(*) 快一点 -- 分页优化（避免大 OFFSET） SELECT * FROM users WHERE id \u0026gt; 10000 ORDER BY id LIMIT 20; 12.3 查看状态和变量 -- 查看数据库状态 SHOW STATUS; SHOW STATUS LIKE \u0026#39;Threads%\u0026#39;; -- 查看系统变量 SHOW VARIABLES; SHOW VARIABLES LIKE \u0026#39;max_connections\u0026#39;; -- 查看进程列表 SHOW PROCESSLIST; SHOW FULL PROCESSLIST; -- 杀死进程 KILL process_id; 十三、常用字符串和日期函数 13.1 字符串函数 -- 字符串连接 SELECT CONCAT(\u0026#39;Hello\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;World\u0026#39;); SELECT CONCAT_WS(\u0026#39;-\u0026#39;, \u0026#39;2024\u0026#39;, \u0026#39;12\u0026#39;, \u0026#39;10\u0026#39;); -- 字符串长度 SELECT LENGTH(\u0026#39;Hello\u0026#39;), CHAR_LENGTH(\u0026#39;你好\u0026#39;); -- 大小写转换 SELECT UPPER(\u0026#39;hello\u0026#39;), LOWER(\u0026#39;HELLO\u0026#39;); -- 截取字符串 SELECT SUBSTRING(\u0026#39;Hello World\u0026#39;, 1, 5); SELECT LEFT(\u0026#39;Hello World\u0026#39;, 5), RIGHT(\u0026#39;Hello World\u0026#39;, 5); -- 替换和删除 SELECT REPLACE(\u0026#39;Hello World\u0026#39;, \u0026#39;World\u0026#39;, \u0026#39;MySQL\u0026#39;); SELECT TRIM(\u0026#39; Hello \u0026#39;), LTRIM(\u0026#39; Hello\u0026#39;), RTRIM(\u0026#39;Hello \u0026#39;); -- 查找位置 SELECT POSITION(\u0026#39;World\u0026#39; IN \u0026#39;Hello World\u0026#39;); SELECT LOCATE(\u0026#39;World\u0026#39;, \u0026#39;Hello World\u0026#39;); 13.2 日期时间函数 -- 获取当前时间 SELECT NOW(), CURDATE(), CURTIME(); SELECT CURRENT_TIMESTAMP(), CURRENT_DATE(), CURRENT_TIME(); -- 日期格式化 SELECT DATE_FORMAT(NOW(), \u0026#39;%Y-%m-%d %H:%i:%s\u0026#39;); SELECT DATE_FORMAT(NOW(), \u0026#39;%Y年%m月%d日\u0026#39;); -- 日期计算 SELECT DATE_ADD(NOW(), INTERVAL 1 DAY); SELECT DATE_SUB(NOW(), INTERVAL 1 MONTH); SELECT DATEDIFF(\u0026#39;2024-12-31\u0026#39;, \u0026#39;2024-01-01\u0026#39;); -- 提取日期部分 SELECT YEAR(NOW()), MONTH(NOW()), DAY(NOW()); SELECT HOUR(NOW()), MINUTE(NOW()), SECOND(NOW()); -- 时间戳转换 SELECT UNIX_TIMESTAMP(NOW()); SELECT FROM_UNIXTIME(1702195200); 13.3 数学和其他函数 -- 数学函数 SELECT ROUND(3.14159, 2), CEIL(3.2), FLOOR(3.8); SELECT ABS(-5), MOD(10, 3), POWER(2, 3); SELECT RAND(), RAND()*100; -- 条件函数 SELECT IF(age \u0026gt; 18, \u0026#39;成年\u0026#39;, \u0026#39;未成年\u0026#39;) FROM users; SELECT IFNULL(email, \u0026#39;无邮箱\u0026#39;) FROM users; SELECT COALESCE(NULL, NULL, \u0026#39;default\u0026#39;, \u0026#39;value\u0026#39;); -- CASE 表达式 SELECT username, CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END as age_group FROM users; 十四、JSON 操作（MySQL 5.7+） -- 创建 JSON 列 CREATE TABLE products ( id INT PRIMARY KEY, name VARCHAR(100), attributes JSON ); -- 插入 JSON 数据 INSERT INTO products VALUES (1, \u0026#39;iPhone\u0026#39;, \u0026#39;{\u0026#34;color\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;storage\u0026#34;: \u0026#34;128GB\u0026#34;}\u0026#39;); -- 查询 JSON 数据 SELECT JSON_EXTRACT(attributes, \u0026#39;$.color\u0026#39;) as color FROM products; SELECT attributes-\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; SELECT attributes-\u0026gt;\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; -- 去除引号 -- 修改 JSON 数据 UPDATE products SET attributes = JSON_SET(attributes, \u0026#39;$.color\u0026#39;, \u0026#39;white\u0026#39;) WHERE id = 1; UPDATE products SET attributes = JSON_INSERT(attributes, \u0026#39;$.price\u0026#39;, 999) WHERE id = 1; UPDATE products SET attributes = JSON_REMOVE(attributes, \u0026#39;$.storage\u0026#39;) WHERE id = 1; -- JSON 数组操作 SELECT JSON_ARRAY(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;); SELECT JSON_CONTAINS(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;, \u0026#39;\u0026#34;a\u0026#34;\u0026#39;); SELECT JSON_LENGTH(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;); 十五、窗口函数（MySQL 8.0+） -- ROW_NUMBER：行号 SELECT username, age, ROW_NUMBER() OVER (ORDER BY age DESC) as row_num FROM users; -- RANK：排名（有并列，跳号） SELECT username, score, RANK() OVER (ORDER BY score DESC) as rank FROM students; -- DENSE_RANK：密集排名（有并列，不跳号） SELECT username, score, DENSE_RANK() OVER (ORDER BY score DESC) as rank FROM students; -- 分组窗口 SELECT department, username, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank FROM employees; -- 累计求和 SELECT username, amount, SUM(amount) OVER (ORDER BY created_at) as running_total FROM transactions; -- LAG 和 LEAD：访问上下行 SELECT username, salary, LAG(salary, 1) OVER (ORDER BY id) as prev_salary, LEAD(salary, 1) OVER (ORDER BY id) as next_salary FROM employees; 十六、常见问题和技巧 16.1 查找重复数据 -- 查找重复的用户名 SELECT username, COUNT(*) as count FROM users GROUP BY username HAVING count \u0026gt; 1; -- 删除重复数据（保留ID最小的） DELETE u1 FROM users u1 INNER JOIN users u2 WHERE u1.id \u0026gt; u2.id AND u1.username = u2.username; 16.2 随机获取数据 -- 随机获取一条数据 SELECT * FROM users ORDER BY RAND() LIMIT 1; -- 更高效的随机（大表适用） SELECT * FROM users WHERE id \u0026gt;= (SELECT FLOOR(MAX(id) * RAND()) FROM users) LIMIT 1; 16.3 行转列 -- 使用 CASE WHEN SELECT name, SUM(CASE WHEN subject = \u0026#39;语文\u0026#39; THEN score ELSE 0 END) as chinese, SUM(CASE WHEN subject = \u0026#39;数学\u0026#39; THEN score ELSE 0 END) as math FROM scores GROUP BY name; 16.4 列转行 -- 使用 UNION ALL SELECT name, \u0026#39;语文\u0026#39; as subject, chinese as score FROM scores UNION ALL SELECT name, \u0026#39;数学\u0026#39; as subject, math as score FROM scores; 十七、常用管理命令 -- 查看 MySQL 版本 SELECT VERSION(); -- 查看当前用户 SELECT USER(), CURRENT_USER(); -- 查看数据库大小 SELECT table_schema AS \u0026#39;Database\u0026#39;, ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables GROUP BY table_schema; -- 查看表大小 SELECT table_name AS \u0026#39;Table\u0026#39;, ROUND(((data_length + index_length) / 1024 / 1024), 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables WHERE table_schema = \u0026#39;database_name\u0026#39; ORDER BY (data_length + index_length) DESC; -- 修复表 REPAIR TABLE users; -- 优化表 OPTIMIZE TABLE users; -- 分析表 ANALYZE TABLE users; -- 检查表 CHECK TABLE users; 总结 这份笔记涵盖了 MySQL 从基础到进阶的大部分常用操作，当然也适合在刷题中补充，包括：\n数据库和表的管理 完整的 CRUD 操作 索引和约束 视图、事务、存储过程 用户权限管理 性能优化技巧 常用函数和 JSON、窗口函数！ ","permalink":"http://localhost:1313/posts/mysql-cheatsheet/","summary":"MySQL 常用语句全面速查手册，涵盖从基础 CRUD 到高级特性（索引、事务、存储过程、窗口函数等）的所有常用操作，适合快速查阅和刷题使用","title":"MySQL 语句速查笔记"},{"content":"论文基本信息 标题: Linking Souls to Humans: Blockchain Accounts with Credible Anonymity for Web 3.0 Decentralized Identity 作者: Taotao Wang, Zibin Lin, Shengli Zhang, Long Shi, Qing Yang, Boris Düdder 会议: WWW \u0026lsquo;25 (ACM Web Conference 2025) 时间: 2025年4月28日-5月2日，悉尼 机构: 深圳大学、南京理工大学、哥本哈根大学 研究背景 数字身份的三个发展阶段 数字身份系统经历了三个演进阶段，分别对应互联网的三个时代：\n阶段 身份类型 对应时代 特点 问题 1 中心化身份 Web 1.0 用户创建，应用提供商管理 多账户管理复杂，数据泄露风险 2 联盟身份 Web 2.0 少数大型提供商管理，可跨应用使用 数据霸权，用户数据集中在少数巨头手中 3 去中心化身份 Web 3.0 用户自主创建和管理（自主权身份） 完全匿名导致无法追溯真实社交关系 Web 3.0的核心价值 Web 3.0的革命性转变在于：\n用户拥有数据主权 数据不被应用提供商占有 需要去中心化身份系统支撑 当前区块链账户系统的问题 区块链账户系统是Web 3.0去中心化身份的理想原型，但存在以下问题：\n完全匿名的缺陷： 用户可以无需认证创建多个账户 无法准确记录真实用户之间的社交关系和互动 用户与区块链身份之间的映射关系模糊 Soulbound Token的局限性： Vitalik Buterin提出的\u0026quot;灵魂\u0026quot;（Soul）概念和\u0026quot;灵魂绑定代币\u0026quot;（Soulbound Token） 用户仍可创建多个\u0026quot;灵魂\u0026quot;账户来抹除、转移或隐藏关系 无法真实反映人类社会中的真实关系 研究方案：zkBID 核心目标 zkBID（Zero-Knowledge Blockchain-account-based Web 3.0 decentralized IDentity）旨在实现：\n一对一映射：将灵魂（区块链账户）与人类（用户）建立一对一关联 去中心化：无需第三方中心化机构参与 隐私保护：隐藏身份与账户之间的绑定关系（即匿名） 可信性：每个账户在区块链上的信用与对应的真实用户一对一映射 关键技术 zkBID采用三大核心技术：\n零知识证明（zkSNARK） 可链接环签名（Linkable Ring Signature） 区块链智能合约（Smart Contracts） 技术预备知识 1. 可验证凭证（Verifiable Credentials, VC） 由W3C提出的去中心化标识符（DID）体系中的关键组件。\n三个主要角色：\n颁发者（Issuer）：签发凭证 持有者（Holder）：拥有凭证 验证者（Verifier）：验证凭证 VC的数据结构（JSON对象）：\n{ \u0026#34;metadata\u0026#34;: \u0026#34;包含颁发者DID、颁发日期、声明类型\u0026#34;, \u0026#34;claims\u0026#34;: \u0026#34;关于持有者的断言，包括持有者DID\u0026#34;, \u0026#34;proofs\u0026#34;: \u0026#34;颁发者的数字签名\u0026#34; } 2. 人格凭证（Personhood Credentials, PHC） 定义：证明用户是真人而非AI的数字凭证\n运作流程：\n注册流程 用户向PHC颁发者证明自己是真人 → 颁发者签发PHC\n使用流程 第三方服务可要求用户出示PHC作为授权过程的一部分\n验证方法（颁发者确保用户是真人的三种主要方式）：\n现有身份文件 基于政府签发的身份证件 利用现有可信来源 生物识别信息 测量持久且唯一的人体特征（掌纹、虹膜、指纹） 确保是真人且限制每人只注册一次 信任网络（Web of Trust） 通过社交图谱分析区分真人和机器 检测用户是否曾获得过凭证 在zkBID中的应用：\nPHC以VC形式作为每个人类用户的身份凭证 3. zkSNARK算法 全称：Zero-knowledge Succinct Non-interactive Argument of Knowledge\n优势：\n简洁性（Succinct）：证明大小仅几个字节，验证时间短 非交互性（Non-interactive）：证明者和验证者无需同步通信 工作原理：\n使用算术电路表示，包含基本运算：加、减、乘、除\nF-算术电路：\n输入：$x \\in \\mathbb{F}^n$ 辅助输入（见证）：$w \\in \\mathbb{F}^h$ 输出：$C(x, w) \\in \\mathbb{F}^l$ 三个算法组件：\n密钥生成（KEYGEN）\n(PK, VK) ← KEYGEN(1^λ, C) 输入：安全参数λ和电路C 输出：证明密钥PK和验证密钥VK 证明生成（PROVE）\nπ ← PROVE(PK, x, W) 输入：PK、公开输入x、私密见证W 输出：证明π 证明验证（VERIFY）\n1/0 ← VERIFY(VK, x, π) 输入：VK、公开输入x、证明π 输出：接受（1）或拒绝（0） zkBID采用的算法：Groth16\n原因：验证速度快，证明紧凑 适用于大规模应用和大型区块链网络 4. 可链接环签名（Linkable Ring Signature） 基本环签名：\n验证者可以确认签名由预定义集合中的某个成员创建 但无法确定具体是哪个成员 可链接环签名的额外特性：\n允许验证者确定两个签名是否由同一签名者生成 四个算法组件：\n密钥生成（GEN）\n(pk, sk) ← GEN(1^k) 签名生成（SIG）\nσ ← SIG(1^k, 1^n, m, L, sk) 输入：安全参数k、环大小n、消息m、公钥环L、私钥sk 输出：签名σ 签名验证（VER）\n1/0 ← VER(1^k, 1^n, m, L, σ) 可链接性检查（LINK）\n1/0 ← LINK(1^k, 1^n, m1, m2, σ1, σ2, L1, L2) 判断两个签名是否由同一签名者生成 关键属性：\n签名者模糊性（Signer Ambiguity）： 攻击者正确猜测真实签名者的概率不超过 1/(n-t) 其中n是环大小，t是攻击者拥有的私钥数量 可链接性（Linkability）： 同一签名者（相同私钥）签名的两条消息可被验证为关联 zkBID采用的算法：MLSAGS（Multilayered Linkable Spontaneous Anonymous Group Signature）\n原因：实现可链接性的技术复杂度较低，适合在智能合约上实现 密钥图像（Key Image）机制：\ny₀ ← sk * Hₚ(pk) y₀对于给定的(sk, pk)对是唯一的 所有由同一签名者产生的签名都带有相同的密钥图像 即使环中的公钥改变，签名仍可链接 zkBID系统设计 整体架构 映射关系图 真实用户 → PHC（人格凭证）→ PHC哈希 → 种子公钥 → 灵魂账户 关系说明：\n实线：可见的一对一关系 虚线：不可见但可验证的关系 箭头：单向计算关系 核心设计理念 隐私保护： PHC的具体内容不上链，只存储零知识证明 灵魂账户与种子公钥的关联不可见 可信匿名： 账户是匿名的（无法追踪到真实身份） 账户是可信的（确实与真实用户一对一绑定） 完全去中心化： 所有数据由用户生成 通过区块链上的智能合约验证 IVAC流程（Identity Verification and Account Certification） zkBID通过三个子流程生成具有可信匿名性的灵魂账户：\n[用户] → [注册信息生成] → [用户身份验证] → [灵魂账户认证] → [灵魂账户] ↓ ↓ ↓ 零知识证明 智能合约验证 可链接环签名 详细设计 阶段1：注册信息生成 目标：生成隐私保护的注册信息，不泄露PHC的具体内容\nPHC格式设计 zkBID中的PHC采用VC格式，包含三个关键字段：\n{ \u0026#34;credentialSubject\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_holder\u0026#34; // 持有者公钥 }, \u0026#34;proof\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_issuer\u0026#34;, // 颁发者公钥 \u0026#34;signature\u0026#34;: \u0026#34;sig_issuer\u0026#34; // 颁发者签名 } } 零知识证明生成流程 Protocol 1: PHC的ZK证明生成\n输入： - hash_PHC：PHC的哈希值 - sig_holder：持有者的签名 - pk_issuer：颁发者的公钥 - PHC：完整的PHC数据 设置： (PK, VK) ← zkSNARK.KEYGEN(1^λ, C) 生成证明： 1. 公开输入 x ← (hash_PHC, sig_holder, pk_issuer) 2. 私密见证 W ← PHC 3. π ← zkSNARK.PROVE(PK, x, W) 输出：π（零知识证明） 算术电路验证逻辑 graph TD A[私密输入: PHC] --\u0026gt; B[计算PHC的哈希] C[公开输入: hash_PHC] --\u0026gt; B B --\u0026gt; D{哈希值是否相等?} A --\u0026gt; E[提取pk_holder] F[公开输入: sig_holder] --\u0026gt; G[验证sig_holder] E --\u0026gt; G G --\u0026gt; H{签名是否有效?} A --\u0026gt; I[提取sig_issuer] J[公开输入: pk_issuer] --\u0026gt; K[验证sig_issuer] I --\u0026gt; K K --\u0026gt; L{签名是否有效?} D --\u0026gt; M[AND] H --\u0026gt; M L --\u0026gt; M M --\u0026gt; N{输出TRUE/FALSE} 验证步骤：\n验证哈希正确性： 计算PHC的哈希 检查是否等于公开输入中的hash_PHC 确保hash_PHC确实从PHC计算得出 验证所有权： 从PHC中提取持有者公钥pk_holder 用pk_holder验证sig_holder 证明用户拥有PHC 验证PHC有效性： 从PHC中提取颁发者签名sig_issuer 用pk_issuer验证sig_issuer 证明PHC由可信颁发者签发 输出：\n如果所有检查通过：输出TRUE和证明π π证明的声明：\u0026ldquo;PHC哈希正确，持有者拥有PHC，PHC由颁发者签发\u0026rdquo; 关键：不泄露PHC的具体内容 阶段2：用户身份验证 目标：\n验证用户的真人身份（通过验证ZK证明） 防止重复注册（检查PHC哈希未被使用） 智能合约流程 Protocol 2: 用户身份验证智能合约\n输入： - π：零知识证明 - hash_PHC：PHC哈希 - sig_holder：持有者签名 - pk_seed：种子公钥 执行步骤： 1. pk_issuer ← GetIssuerPK() // 获取预定义的颁发者公钥 2. validation ← zkSNARK.VERIFY(VK, hash_PHC, pk_issuer, π) 3. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 4. stored ← Traverse(hash_PHC) // 检查是否已注册 5. if stored ≠ 0: return \u0026#34;已经注册\u0026#34; 6. Store(hash_PHC, pk_seed) // 存储为键值对 7. return \u0026#34;认证成功\u0026#34; 用户操作步骤 生成种子密钥对：\n(pk_seed, sk_seed) ← MLSAGS.GEN(1^k) 构造交易：\n数据字段包含：π, hash_PHC, sig_holder, pk_issuer, pk_seed 发送到身份验证合约地址 合约验证：\n验证颁发者公钥匹配 验证零知识证明 检查PHC哈希未被使用 链上记录：\n存储键值对：(hash_PHC, pk_seed) hash_PHC用于防止重复注册 pk_seed作为用户在下一阶段创建灵魂账户的凭证 安全保证：\nPHC的具体内容不上链 仍能验证PHC的所有权和有效性 防止同一PHC多次注册 阶段3：灵魂账户认证 目标：认证灵魂账户与合法种子公钥的一对一关联\n整体流程 生成灵魂账户（普通以太坊账户） 建立关联（使用可链接环签名） 链上验证（智能合约验证签名） 可链接环签名的生成和验证 graph LR A[用户端] --\u0026gt; B[签名生成] B --\u0026gt; C[智能合约] C --\u0026gt; D[签名验证] E[输入] --\u0026gt; B E --\u0026gt; |选择的L-1个种子公钥| B E --\u0026gt; |用户的种子公钥pk_seed| B E --\u0026gt; |用户的种子私钥sk_seed| B E --\u0026gt; |灵魂账户地址addr_soul| B E --\u0026gt; |密钥图像y₀| B B --\u0026gt; |签名σ| C F[公钥环L] --\u0026gt; C G[addr_soul] --\u0026gt; C D --\u0026gt; H{验证结果} H --\u0026gt; |True| I[认证成功] H --\u0026gt; |False| J[认证失败] 详细步骤 步骤1：生成灵魂账户\n(addr_soul, pk_soul, sk_soul) = 生成以太坊账户 步骤2：构造公钥环\n从已注册的种子公钥中选择L-1个 加上用户自己的pk_seed 形成大小为L的公钥环 步骤3：计算密钥图像\ny₀ ← sk_seed * Hₚ(pk_seed) y₀对于给定的(sk_seed, pk_seed)是唯一的 用于防止重复注册 步骤4：生成可链接环签名\nσ ← MLSAGS.SIG(1^k, 1^n, addr_soul, L, sk_seed) 消息m = addr_soul（要签名的是灵魂账户地址） 签名格式：σ = (y₀, \u0026hellip;) y₀作为签名的一部分 步骤5：智能合约验证\nProtocol 3: 灵魂账户认证智能合约\n输入： - σ：可链接环签名 - L：公钥环 - addr_soul：灵魂账户地址 执行步骤： 1. validation ← LRS.VER(1^k, 1^n, addr_soul, L, σ) 2. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 3. stored ← Traverse(σ.y₀) // 检查密钥图像是否已使用 4. if stored ≠ 0: return \u0026#34;已经认证\u0026#34; 5. Store(σ.y₀, addr_soul) // 存储密钥图像和灵魂账户 6. return \u0026#34;认证成功\u0026#34; 隐私保护机制 关键特性：\n签名者模糊性： 签名可以被验证为有效 但无法确定环L中哪个公钥是真正的签名者 攻击者猜对的概率：1/(n-t)，其中n是环大小，t是攻击者拥有的私钥数 一对一保证： 密钥图像y₀唯一对应一个种子密钥对 同一种子密钥对只能生成一个有效签名 确保一个PHC只能关联一个灵魂账户 可验证的匿名性： 任何人都可以验证灵魂账户与某个合法种子公钥关联 但无法确定具体是哪个种子公钥 实现\u0026quot;可信匿名\u0026quot; 链上数据 存储内容：\n(σ.y₀, addr_soul) 键值对 可见信息：\n所有种子公钥（从阶段2） 所有灵魂账户地址 所有密钥图像 不可见关联：\n哪个种子公钥对应哪个灵魂账户 哪个PHC哈希对应哪个灵魂账户 哪个真实用户对应哪个灵魂账户 安全性分析 安全前提条件 计算对手受限：攻击者为多项式时间的计算对手 验证者诚实：智能合约不会接受虚假验证请求 PHC唯一性：每个用户只能从颁发者获得一个PHC 安全目标 zkBID需要满足三个核心安全属性：\n安全属性 定义 目标 身份唯一性 防止重复注册 一个用户不能注册多个灵魂账户 不可伪造性 防止身份伪造 攻击者不能冒充诚实用户认证灵魂账户 匿名性 保护身份隐私 攻击者无法检测用户身份(PHC)与灵魂账户的关联 威胁模型与防御 1. 女巫攻击（Sybil Attack） 攻击场景： 攻击者已拥有一个灵魂账户，试图获取新的灵魂账户\n攻击方法：\n方法A：使用相同PHC关联新的种子公钥 → 用新种子公钥认证新灵魂账户\n方法B：直接使用已用过的种子公钥认证新灵魂账户\n防御分析：\n方法A的防御：\n在用户身份验证合约中： 1. 合约检查hash_PHC是否已存储 2. 由于哈希函数的抗碰撞性，每个PHC只能生成一个唯一哈希 3. zkSNARK的可靠性保证：攻击者通过伪造哈希成功的概率可忽略不计 4. 因此无法用同一PHC注册两个种子账户 方法B的防御：\n在灵魂账户认证合约中： 1. 合约检查密钥图像y₀是否已使用 2. 由于可链接环签名的可链接性，同一种子私钥无法构造两个不同y₀的有效签名 3. 因此无法用同一种子密钥对认证两个灵魂账户 结论：无法使用相同PHC或种子公钥注册两个灵魂账户\n2. 链接攻击（Linkage Attack） 攻击场景： 攻击者试图通过破解环签名的真实签名者，建立用户身份（PHC哈希）与灵魂账户的链接\n攻击方法： 分析链上存储的环签名，推断哪个种子公钥是真正的签名者\n防御分析：\n基于可链接环签名的签名者模糊性： - 假设环大小为n - 攻击者拥有t个私钥 - 攻击者正确识别真实签名者的概率 = 1/(n-t) 示例： - 环大小 n = 100 - 攻击者拥有 t = 10 个私钥 - 成功概率 = 1/90 ≈ 1.1% 结论：攻击者无法有效建立身份与账户的链接 环大小的影响：\n环越大 → 匿名性越强 但签名生成和验证成本增加 需要在匿名性和效率之间权衡 3. 伪造攻击（Forgery Attack） 攻击场景： 攻击者试图冒充诚实用户获取灵魂账户\n攻击方法：\n方法A：伪造holder签名生成有效zkSNARK证明\n攻击者获得诚实用户的PHC ↓ 伪造sig_holder ↓ 生成通过验证的zkSNARK证明 ↓ 注册种子公钥 ↓ 认证灵魂账户 方法B：伪造种子账户的环签名\n已注册的种子公钥公开可见 ↓ 伪造某个诚实用户的环签名sig_seed ↓ 认证新的灵魂账户 防御分析：\n方法A的防御：\n依赖两个密码学保证： 1. EdDSA算法的不可伪造性 → 攻击者无法伪造任何诚实用户的sig_holder 2. zkSNARK的可靠性 → 没有有效签名，无法创建有效的zkSNARK证明 结论：攻击者无法通过伪造签名获得种子公钥 方法B的防御：\n依赖可链接环签名的不可伪造性： - 攻击者无法伪造任何已注册种子账户的有效签名 - 即使种子公钥公开可见 结论：攻击者无法冒充诚实用户认证灵魂账户 总结：zkBID协议能够抵御伪造攻击\n安全性总结表 攻击类型 攻击目标 依赖的安全属性 防御结果 女巫攻击-方法A 重复注册PHC 哈希抗碰撞性 + zkSNARK可靠性 ✅ 安全 女巫攻击-方法B 重复使用种子密钥 可链接环签名的可链接性 ✅ 安全 链接攻击 破坏匿名性 可链接环签名的签名者模糊性 ✅ 安全 伪造攻击-方法A 伪造身份验证 EdDSA不可伪造性 + zkSNARK可靠性 ✅ 安全 伪造攻击-方法B 伪造账户认证 可链接环签名不可伪造性 ✅ 安全 实验评估 实验环境 测试网络配置 区块链测试网络：\n平台：阿里云 节点数：6个以太坊全节点 共识协议：工作量证明（PoW） 客户端：Go-Ethereum 网络拓扑：全连接（每个节点有独立IP） 用户节点：\n1个用户节点连接到1个以太坊节点 运行用户端功能 硬件配置（所有节点）：\n操作系统：Ubuntu 20.04 CPU：Intel(R) Core(TM) i7-10700 @ 2.90GHz 内存：48GB RAM 实现技术栈 智能合约：\n语言：Solidity 部署：以太坊测试网络 zkSNARK：\n算法：Groth16 平台：Circom 2 功能：Setup和证明生成 可链接环签名：\n算法：MLSAGS 用户端实现：Python（密钥生成、签名算法） 合约实现：Solidity（签名验证） 性能评估指标 指标 说明 重要性 ZK证明生成时间 Groth16证明算法的执行时间 影响用户体验 ZK证明大小 证明所占字节数 影响链上存储 ZK证明验证成本 智能合约验证所需Gas 影响使用成本 算术电路大小 R1CS约束数量 影响系统复杂度 MLSAGS签名生成时间 环签名生成的执行时间 影响用户体验 MLSAGS签名验证成本 智能合约验证所需Gas 影响使用成本 实验结果 1. Groth16性能测试 测试方案：\n使用单个算术电路验证多个PHC批次 测试不同批次大小下的性能表现 图表 6(a)：电路大小和证明大小 PHC批次大小 R1CS约束数量 ZK证明大小 1 ~19,000 192 Bytes 2 ~38,000 192 Bytes 4 ~76,000 192 Bytes 8 ~152,000 192 Bytes 16 ~304,000 192 Bytes 32 ~608,000 192 Bytes 64 ~1,216,000 192 Bytes 128 ~2,432,000 192 Bytes 关键发现：\n✨ 证明大小恒定：无论批次大小如何，证明始终为192字节 这是Groth16的核心优势：简洁性（Succinctness） 电路大小随批次线性增长 图表 6(b)：证明生成时间和验证成本 证明生成时间：\nPHC批次大小 生成时间 (ms) 增长趋势 1 ~2,000 基准 2 ~4,000 2x 4 ~8,000 4x 8 ~16,000 8x 16 ~32,000 16x 32 ~64,000 32x 证明验证成本（Gas）：\nPHC批次大小 验证Gas消耗 单个PHC平均Gas 1 215.7K 215.7K 2 247.2K 123.6K 4 310.2K 77.6K 8 436.2K 54.5K 16 688.2K 43.0K 32 1,040.0K 32.5K 关键发现：\n📈 线性增长：生成时间和验证成本都与批次大小呈线性关系\n💰\n批处理优势\n：批次大小为32时，单个PHC的Gas消耗仅为32.5K\n相比单独验证（215.7K），节省约85% 效率提升约7倍 ⚠️ 部署限制：批次大小≥64时，验证合约因以太坊合约大小限制无法部署\n最佳实践建议：\n推荐批次大小：16-32个PHC - 在合约大小限制内 - 获得显著的Gas优化 - 用户体验可接受 2. MLSAGS性能测试 测试方案：\n测试不同环大小L下的签名生成和验证性能 环大小影响匿名性和性能的权衡 图表 6(c)：MLSAGS性能指标 签名生成时间：\n环大小 L 生成时间 (ms) 增量时间 1 ~40 - 2 ~80 +40ms 4 ~160 +40ms 8 ~320 +40ms 16 ~640 +40ms 32 ~1,280 +40ms 64 ~2,560 +40ms 128 ~5,120 +40ms 签名验证成本（Gas）：\n环大小 L 验证Gas消耗 增量Gas 1 ~57K - 2 ~114K +57K 4 ~228K +57K 8 ~456K +57K 16 ~912K +57K 32 ~1,824K +57K 64 ~3,648K +57K 128 ~7,296K +57K 关键发现：\n📏\n完美线性关系\n：\n每增加1个公钥，生成时间增加约40ms 每增加1个公钥，验证Gas增加约57K ⚖️\n匿名性vs效率权衡\n：\n环越大 → 匿名性越强（攻击者猜中概率 = 1/L） 环越大 → 成本越高（时间和Gas） 匿名性分析：\n环大小 L 攻击者成功率 匿名性等级 Gas成本 10 10% 较弱 570K 50 2% 中等 2,850K 100 1% 强 5,700K 1000 0.1% 非常强 57,000K 实际应用建议：\n小规模应用（\u0026lt; 1000用户）： 环大小：10-20 匿名性：10%-5%攻击成功率 Gas成本：570K-1,140K（可接受） 中等规模应用（1000-10000用户）： 环大小：50-100 匿名性：2%-1%攻击成功率 Gas成本：2,850K-5,700K（需要优化） 大规模应用（\u0026gt; 10000用户）： 环大小：100+ 匿名性：\u0026lt; 1%攻击成功率 Gas成本：\u0026gt; 5,700K（需要Layer 2或批处理） 性能优化建议 1. 对于zkSNARK部分 批处理策略：\n低频场景（个人注册）： - 批次大小：1-4 - 适用：个人用户单次注册 - 优点：即时处理 - 缺点：Gas成本较高（215K-310K） 高频场景（批量注册）： - 批次大小：16-32 - 适用：组织批量入职、大规模注册活动 - 优点：Gas效率提升7倍 - 缺点：需要等待批次凑齐 2. 对于MLSAGS部分 环大小配置：\n# 根据用户总数动态调整 def calculate_ring_size(total_users, target_anonymity=0.01): \u0026#34;\u0026#34;\u0026#34; total_users: 系统总用户数 target_anonymity: 目标攻击成功率（如0.01 = 1%） \u0026#34;\u0026#34;\u0026#34; # 环大小不超过总用户数 ring_size = min(int(1 / target_anonymity), total_users) # 考虑Gas成本限制（假设单笔交易Gas上限为8M） max_affordable_ring = 8_000_000 / 57_000 # ≈ 140 return min(ring_size, max_affordable_ring) # 示例 calculate_ring_size(1000, 0.01) # 返回 100 calculate_ring_size(10000, 0.01) # 返回 100（受成本限制） calculate_ring_size(50, 0.01) # 返回 50（受用户数限制） 分层匿名策略：\nVIP用户/高价值账户： - 使用较大环（100+） - 提供更强匿名性 - 愿意支付更高Gas 普通用户： - 使用中等环（20-50） - 平衡匿名性和成本 - 实际应用最常见 测试/低价值账户： - 使用小环（10-20） - 基本匿名性 - 成本最低 实验结论 zkSNARK的优势： ✅ 证明大小恒定（192字节）：不受批次影响 ✅ 批处理优化显著：32个PHC可节省85% Gas ✅ 验证快速：链上验证成本可接受 MLSAGS的特性： ✅ 性能可预测：完美线性关系 ⚠️ 需要权衡：匿名性与成本呈正比 ✅ 灵活配置：可根据场景调整环大小 系统可行性： ✅ 在实际以太坊网络上完全可行 ✅ 通过参数优化可适应不同规模 ✅ 性能瓶颈明确且可优化 相关工作对比 现有方案分析 论文对比了8个相关的区块链身份方案：\n方案 年份 主要技术 应用场景 TradeMap [12] 2019 ZKP 符合FINMA的匿名KYC平台 Pauwels et al. [14] 2022 zkSNARK DeFi协议的KYC系统 Aydar et al. [3] 2019 Blockchain 数字身份验证框架 Singh et al. [18] 2020 Credential Protocol 保护个人属性的身份系统 Abraham et al. [1] 2020 SSI Model 支持凭证撤销的自主身份 ZEBRA [15] 2022 zkSNARK 链上匿名凭证验证 Zhang et al. [26] 2024 ZKP 能源交易身份认证 Kim et al. [10] 2023 SBT + DID 元宇宙的KYC系统 设计目标对比 方案 DG1 技术灵活性 DG2 身份匿名性 DG3 身份可信性 DG4 隐私存储 TradeMap [12] ✅ ❌ ❌ ❌ Pauwels [14] ✅ ❌ ✅ ✅ Aydar [3] ❌ ✅ ❌ ❌ Singh [18] ❌ ✅ ✅ ✅ Abraham [1] ✅ ✅ ❌ ❌ ZEBRA [15] ❌ ✅ ❌ ❌ Zhang [26] ✅ ❌ ✅ ❌ Kim [10] ❌ ✅ ❌ ❌ zkBID ✅ ✅ ✅ ✅ 设计目标说明：\nDG1 - 技术灵活性：不局限于特定的ZKP算法或区块链平台 DG2 - 身份匿名性：无法从链上活动推断用户真实身份 DG3 - 身份可信性：每个身份可信地连接到真实世界用户 DG4 - 隐私存储：身份文档保密存储，不公开可见 zkBID的独特优势 1. 唯一全面满足所有设计目标 其他方案的局限： ├─ TradeMap: 只关注合规性，缺乏匿名性和可信映射 ├─ Pauwels: DeFi场景，但身份匿名性不足 ├─ Aydar/Singh: 技术灵活性差，绑定特定实现 ├─ Abraham/ZEBRA: 缺乏与真实用户的可信绑定 ├─ Zhang: 特定场景（能源交易），匿名性不足 └─ Kim: 元宇宙场景，技术灵活性和可信性不足 zkBID的创新： ✅ 同时实现匿名性和可信性（看似矛盾的目标） ✅ 完全去中心化（无需可信第三方） ✅ 技术灵活（可替换ZKP算法和环签名方案） ✅ 隐私保护（身份信息不上链） 2. 技术组合的创新性 现有方案的技术使用：\n大多只使用zkSNARK进行凭证验证 少数使用环签名，但未实现身份-账户绑定 没有方案同时使用zkSNARK + 可链接环签名 zkBID的技术创新：\nzkSNARK（阶段1-2）： 目的：验证PHC有效性 优势：不泄露PHC内容 创新：批处理优化 可链接环签名（阶段3）： 目的：建立身份-账户映射 优势：保持匿名性的同时确保一对一 创新：使用密钥图像防止重复绑定 组合效果： = 可验证的身份 + 不可追踪的账户绑定 = 可信匿名（Credible Anonymity） 3. 实际应用价值 传统KYC系统的问题：\n中心化KYC： ❌ 隐私泄露风险 ❌ 数据被服务商控制 ❌ 跨平台不互通 区块链匿名账户： ❌ 无法防止女巫攻击 ❌ 信誉系统难以建立 ❌ 监管合规困难 zkBID的解决方案：\n对用户： ✅ 保护隐私（身份信息不泄露） ✅ 自主控制（无需信任中心化机构） ✅ 一次认证，多处使用 对平台： ✅ 防止女巫攻击（一人一账户） ✅ 建立信誉系统（账户可信） ✅ 满足监管要求（有认证机制） 对监管： ✅ 可验证的身份（PHC由可信机构签发） ✅ 可追责性（必要时可追踪） ✅ 隐私保护合规 应用场景 1. 去中心化社交网络 问题：\nTwitter/X上的机器人和假账户泛滥 难以区分真人和AI生成的内容 水军和虚假舆论操纵 zkBID解决方案：\n用户注册： 1. 用政府ID获取PHC 2. 通过zkBID认证获得灵魂账户 3. 使用灵魂账户在社交网络发布内容 效果： ✅ 每个账户对应一个真人 ✅ 保持用户匿名性 ✅ 机器人和假账户显著减少 ✅ 信誉系统可以建立在灵魂账户上 2. DAO治理 问题：\n一人多账户操纵投票 女巫攻击破坏治理公平性 难以验证投票者资格 zkBID解决方案：\n治理流程： 1. DAO成员通过zkBID认证 2. 每个灵魂账户 = 一个真实成员 3. 投票时保持匿名 4. 防止多重投票 效果： ✅ 一人一票（真正的民主） ✅ 投票匿名（防止胁迫和贿赂） ✅ 可验证（确保只有成员投票） ✅ 信誉加权（可基于历史贡献） 3. DeFi空投和激励 问题：\n空投被羊毛党多账户瓜分 难以识别真实用户 激励机制被滥用 zkBID解决方案：\n空投流程： 1. 要求使用zkBID认证的灵魂账户 2. 每个灵魂账户只能领取一次 3. 基于链上行为的信誉评分 效果： ✅ 公平分配（每人一份） ✅ 防止女巫攻击 ✅ 识别真实活跃用户 ✅ 建立长期激励机制 4. Web3游戏和元宇宙 问题：\n工作室多开刷金币 游戏经济被破坏 难以建立公平竞技环境 zkBID解决方案：\n游戏应用： 1. 玩家使用灵魂账户登录 2. 游戏内资产绑定到灵魂账户 3. 排行榜和竞技只认可灵魂账户 效果： ✅ 一人一号（公平竞争） ✅ 资产真实归属 ✅ 游戏经济稳定 ✅ 社交关系可信 5. 去中心化信用系统 问题：\n传统信用系统中心化 跨平台信用不互通 隐私泄露风险 zkBID解决方案：\n信用体系： 1. 灵魂账户作为信用载体 2. 链上行为建立信用历史 3. 跨DApp信用互认 4. 保护用户隐私 效果： ✅ 去中心化信用（不被单一机构控制） ✅ 可移植性（跨平台使用） ✅ 隐私保护（匿名但可信） ✅ 防止信用欺诈（一人一信用档案） 局限性与未来工作 当前局限性 1. 性能限制 Gas成本：\n当前状态： - 单次PHC验证：215.7K Gas - 环大小100的签名验证：5,700K Gas - 在以太坊主网上成本较高 影响： ❌ 大规模应用成本高 ❌ 限制了环大小（影响匿名性） 可能的解决方案：\nLayer 2方案（如Optimism、Arbitrum） 侧链部署 批处理优化 2. PHC依赖 当前状态：\n依赖可信的PHC颁发机构： - 政府机构 - 大型科技公司 - 其他可信第三方 问题： ❌ PHC系统尚未广泛部署 ❌ 不同颁发者的互操作性 ❌ 颁发者可能成为中心化风险点 3. 隐私权衡 匿名性级别：\n环大小的限制： - 小环（\u0026lt;20）：匿名性较弱 - 大环（100+）：成本高昂 - 实际应用中需要权衡 4. 撤销机制 当前缺失：\n无法撤销已认证的灵魂账户： ❌ 如果PHC被吊销怎么办？ ❌ 如果用户想注销怎么办？ ❌ 如果发现欺诈怎么办？ 需要设计： - 灵活的撤销机制 - 保持匿名性的撤销 - 防止滥用撤销权 未来研究方向 1. 性能优化 方向A：递归证明：\n使用递归zkSNARK： - 将多个证明聚合成一个 - 减少链上验证成本 - 提高批处理效率 预期效果： - Gas成本降低50%+ - 支持更大批次 方向B：量子抗性：\n替换为抗量子密码算法： - 格基密码学 - 哈希基签名 - 为后量子时代做准备 2. PHC生态系统 多颁发者互操作：\n标准化PHC格式： - 统一的VC模板 - 跨颁发者互认 - 去中心化颁发者网络 目标： - 减少单点故障 - 提高可用性 - 增强去中心化 去中心化PHC颁发：\n探索无需中心化颁发者的方案： - 基于生物识别的去中心化验证 - 社交图谱验证 - 组合多种验证方式 3. 隐私增强 方向A：动态环：\n允许用户动态选择环大小： - 根据交易重要性调整 - 重要交易用大环 - 普通交易用小环 效果： - 灵活性提高 - 成本优化 方向B：分层匿名：\n不同隐私级别的灵魂账户： - 公开级：最小匿名性，低成本 - 标准级：中等匿名性，中等成本 - 隐私级：高匿名性，高成本 4. 跨链支持 多链部署：\n扩展到其他区块链： - Polkadot/Cosmos生态 - 高性能链（Solana、Aptos） - 专用隐私链（Zcash、Monero概念） 跨链身份： - 一个PHC，多链认证 - 统一的身份层 5. 撤销和恢复机制 优雅的撤销：\n设计保护隐私的撤销： - 使用累加器（Accumulator） - 撤销列表不泄露身份 - 高效的撤销验证 恢复机制： - PHC过期后的更新流程 - 密钥丢失的恢复方案 - 保持连续性的信誉迁移 6. 合规和监管 可选的透明性：\n为监管场景设计： - 选择性披露机制 - 紧急情况下的去匿名化 - 法院命令的执行 平衡： - 保护普通用户隐私 - 满足反洗钱（AML）要求 - 支持合法调查 关键takeaways 技术创新 可信匿名的突破： 首次在区块链上实现\u0026quot;可信\u0026quot;+\u0026ldquo;匿名\u0026quot;的结合 通过零知识证明保护隐私 通过可链接环签名确保一对一映射 完全去中心化： 无需可信第三方参与验证 所有逻辑在智能合约中执行 用户完全控制自己的身份 实用性验证： 在真实以太坊测试网络上实现 性能指标明确可测 成本可接受且可优化 理论贡献 身份模型创新：\n传统模型：身份 → 账户（可见映射） zkBID模型：身份 → [ZK层] → 种子 → [环签名层] → 账户 创新点： - 两层隐私保护 - 可验证但不可追踪 - 数学上可证明的安全性 密码学组合：\nzkSNARK + 可链接环签名的首次组合应用 各取所长，弥补对方不足 为未来类似系统提供范式 实践意义 Web3基础设施： 为Web3提供关键的身份层 解决匿名性与可信性的矛盾 使去中心化应用更实用 防止AI冒充： 在AI时代区分人类和机器 PHC作为\u0026quot;数字人格证\u0026rdquo; 保护在线空间的人类性 新经济模式： 支持基于信誉的去中心化经济 公平的激励分配机制 可持续的社区治理 结论 zkBID是一个创新的Web 3.0去中心化身份方案，成功解决了区块链账户系统中匿名性与可信性的矛盾。\n核心成就 ✅ 技术突破：\n零知识证明保护身份隐私 可链接环签名确保一对一映射 完全去中心化的验证机制 ✅ 安全保证：\n抵御女巫攻击 抵御链接攻击 抵御伪造攻击 ✅ 实用验证：\n以太坊测试网络成功部署 性能指标满足实际应用需求 成本可通过参数优化控制 未来展望 zkBID为Web3去中心化身份提供了一个可行的解决方案，但仍有改进空间：\n继续优化性能和成本 推动PHC生态系统发展 探索跨链和多链支持 完善撤销和恢复机制 平衡隐私保护 ","permalink":"http://localhost:1313/posts/linking-souls-to-humans/","summary":"zkBID通过零知识证明和可链接环签名技术，首次实现了区块链账户的\u0026quot;可信匿名\u0026quot;：每个账户与真实用户一对一绑定（可信），但外界无法追踪具体对应关系（匿名）。系统采用三阶段IVAC流程，将人格凭证(PHC)通过零知识证明验证后绑定到种子公钥，再用环签名将种子公钥关联到灵魂账户。实验显示批处理可将验证成本降低85%，环大小灵活可调以平衡匿名性与效率。该方案为Web3提供了关键身份基础设施，可有效防止女巫攻击，支持去中心化社交、DAO治理、DeFi空投等场景。","title":"zkBID: 区块链账户与Web 3.0去中心化身份"},{"content":"📚 Part 1: Java 集合使用手册 1. List - 列表 ArrayList - 动态数组 // 初始化 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); List\u0026lt;Integer\u0026gt; list3 = new ArrayList\u0026lt;\u0026gt;(100); // 指定初始容量 // 增 list.add(1); // 尾部添加 list.add(0, 10); // 指定位置添加 list.addAll(Arrays.asList(2,3,4)); // 批量添加 // 删 list.remove(0); // 删除指定索引 list.remove(Integer.valueOf(1)); // 删除指定元素 list.clear(); // 清空 // 改 list.set(0, 100); // 修改指定位置 // 查 int val = list.get(0); // 获取元素 int size = list.size(); // 获取大小 boolean empty = list.isEmpty(); // 是否为空 boolean contains = list.contains(1); // 是否包含 int index = list.indexOf(1); // 查找索引 // 遍历 for (int num : list) { System.out.println(num); } // 或使用迭代器 Iterator\u0026lt;Integer\u0026gt; it = list.iterator(); while (it.hasNext()) { System.out.println(it.next()); } LinkedList - 双向链表 LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 头部操作 list.addFirst(1); list.removeFirst(); int first = list.getFirst(); // 尾部操作 list.addLast(2); list.removeLast(); int last = list.getLast(); // 作为队列使用 list.offer(3); // 入队 int head = list.poll(); // 出队 // 作为栈使用 list.push(4); // 入栈 int top = list.pop(); // 出栈 2. Set - 集合 HashSet - 无序不重复 // 初始化 Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); // 增 set.add(1); set.addAll(Arrays.asList(2, 3, 4)); // 删 set.remove(1); set.clear(); // 查 boolean contains = set.contains(1); int size = set.size(); boolean empty = set.isEmpty(); // 遍历 for (int num : set) { System.out.println(num); } TreeSet - 有序集合（红黑树） TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 基本操作同 HashSet set.add(3); set.add(1); set.add(2); System.out.println(set); // [1, 2, 3] 自动排序 // 特有方法 int first = set.first(); // 最小元素 int last = set.last(); // 最大元素 int lower = set.lower(2); // 小于 2 的最大元素 int higher = set.higher(2); // 大于 2 的最小元素 int floor = set.floor(2); // ≤ 2 的最大元素 int ceiling = set.ceiling(2); // ≥ 2 的最小元素 // 子集操作 SortedSet\u0026lt;Integer\u0026gt; subset = set.subSet(1, 3); // [1, 3) SortedSet\u0026lt;Integer\u0026gt; headSet = set.headSet(2); // \u0026lt; 2 SortedSet\u0026lt;Integer\u0026gt; tailSet = set.tailSet(2); // \u0026gt;= 2 LinkedHashSet - 保持插入顺序 Set\u0026lt;Integer\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); set.add(3); set.add(1); set.add(2); System.out.println(set); // [3, 1, 2] 保持插入顺序 3. Map - 映射 HashMap - 键值对 // 初始化 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 增/改 map.put(\u0026#34;apple\u0026#34;, 1); map.put(\u0026#34;banana\u0026#34;, 2); map.putIfAbsent(\u0026#34;apple\u0026#34;, 10); // 键不存在时才添加 // 删 map.remove(\u0026#34;apple\u0026#34;); map.clear(); // 查 int val = map.get(\u0026#34;apple\u0026#34;); int valOrDefault = map.getOrDefault(\u0026#34;orange\u0026#34;, 0); boolean hasKey = map.containsKey(\u0026#34;apple\u0026#34;); boolean hasValue = map.containsValue(1); int size = map.size(); // 遍历键值对 for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { String key = entry.getKey(); int value = entry.getValue(); } // 遍历键 for (String key : map.keySet()) { System.out.println(key); } // 遍历值 for (int value : map.values()) { System.out.println(value); } // Java 8+ 新方法 map.computeIfAbsent(\u0026#34;cherry\u0026#34;, k -\u0026gt; 3); map.merge(\u0026#34;apple\u0026#34;, 1, Integer::sum); // 累加 TreeMap - 有序映射（红黑树） TreeMap\u0026lt;Integer, String\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); map.put(3, \u0026#34;c\u0026#34;); map.put(1, \u0026#34;a\u0026#34;); map.put(2, \u0026#34;b\u0026#34;); // 基本操作同 HashMap // 特有方法 int firstKey = map.firstKey(); int lastKey = map.lastKey(); Map.Entry\u0026lt;Integer, String\u0026gt; firstEntry = map.firstEntry(); Map.Entry\u0026lt;Integer, String\u0026gt; lastEntry = map.lastEntry(); int lowerKey = map.lowerKey(2); // \u0026lt; 2 的最大键 int higherKey = map.higherKey(2); // \u0026gt; 2 的最小键 int floorKey = map.floorKey(2); // \u0026lt;= 2 的最大键 int ceilingKey = map.ceilingKey(2); // \u0026gt;= 2 的最小键 LinkedHashMap - 保持插入顺序 Map\u0026lt;String, Integer\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;c\u0026#34;, 3); map.put(\u0026#34;a\u0026#34;, 1); map.put(\u0026#34;b\u0026#34;, 2); // 遍历时保持插入顺序: c, a, b 4. Queue - 队列 普通队列 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 入队 queue.offer(1); queue.add(2); // 队列满时抛异常 // 出队 int head = queue.poll(); // 空时返回 null int head2 = queue.remove(); // 空时抛异常 // 查看队首 int peek = queue.peek(); // 空时返回 null int peek2 = queue.element(); // 空时抛异常 PriorityQueue - 优先队列（堆） // 小根堆（默认） PriorityQueue\u0026lt;Integer\u0026gt; minHeap = new PriorityQueue\u0026lt;\u0026gt;(); // 大根堆 PriorityQueue\u0026lt;Integer\u0026gt; maxHeap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); // 自定义对象 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); minHeap.offer(3); minHeap.offer(1); minHeap.offer(2); while (!minHeap.isEmpty()) { System.out.println(minHeap.poll()); // 1, 2, 3 } Deque - 双端队列 Deque\u0026lt;Integer\u0026gt; deque = new ArrayDeque\u0026lt;\u0026gt;(); // 头部操作 deque.offerFirst(1); deque.pollFirst(); deque.peekFirst(); // 尾部操作 deque.offerLast(2); deque.pollLast(); deque.peekLast(); // 作为栈使用 deque.push(3); int top = deque.pop(); 5. Stack - 栈 Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(1); // 入栈 int top = stack.pop(); // 出栈 int peek = stack.peek(); // 查看栈顶 boolean empty = stack.isEmpty(); int size = stack.size(); // 推荐使用 Deque 代替 Stack Deque\u0026lt;Integer\u0026gt; stack2 = new ArrayDeque\u0026lt;\u0026gt;(); 🧮 Part 2: 算法模板 1. 树的遍历 二叉树定义 class TreeNode { int val; // 节点值 TreeNode left; // 左子节点 TreeNode right; // 右子节点 TreeNode(int val) { this.val = val; } } DFS - 深度优先遍历 前序遍历（根-左-右） // 递归版本 - 最简洁直观 void preorder(TreeNode root) { if (root == null) return; // 递归终止条件：空节点 System.out.println(root.val); // 1. 先访问根节点 preorder(root.left); // 2. 再遍历左子树 preorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 使用栈模拟递归 List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); // 根节点入栈 while (!stack.isEmpty()) { TreeNode node = stack.pop(); // 弹出栈顶节点 res.add(node.val); // 访问该节点 // 关键：先压右子节点，再压左子节点 // 这样出栈时左子节点先出（栈是后进先出） if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); } return res; } 中序遍历（左-根-右） // 递归版本 void inorder(TreeNode root) { if (root == null) return; // 递归终止条件 inorder(root.left); // 1. 先遍历左子树 System.out.println(root.val); // 2. 再访问根节点 inorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 一直向左走到底 List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode curr = root; while (curr != null || !stack.isEmpty()) { // 第一步：一直向左走到底，沿途节点入栈 while (curr != null) { stack.push(curr); curr = curr.left; } // 第二步：弹出栈顶（当前最左节点），访问它 curr = stack.pop(); res.add(curr.val); // 第三步：转向右子树 curr = curr.right; } return res; } 后序遍历（左-右-根） // 递归版本 void postorder(TreeNode root) { if (root == null) return; // 递归终止条件 postorder(root.left); // 1. 先遍历左子树 postorder(root.right); // 2. 再遍历右子树 System.out.println(root.val); // 3. 最后访问根节点 } // 迭代版本 - 巧妙方法：前序遍历变形 + 反转 // 思路：前序是\u0026#34;根左右\u0026#34;，改成\u0026#34;根右左\u0026#34;，反转后得到\u0026#34;左右根\u0026#34; List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); res.add(node.val); // 添加到结果（根右左顺序） // 注意：这里先左后右，出栈时就是先右后左 if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); } Collections.reverse(res); // 反转得到左右根 return res; } BFS - 层序遍历 // 按层遍历二叉树，每层的节点放在一个列表中 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); // 根节点入队 while (!queue.isEmpty()) { int size = queue.size(); // 当前层的节点数（重要！） List\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); // 遍历当前层的所有节点 for (int i = 0; i \u0026lt; size; i++) { TreeNode node = queue.poll(); // 出队 level.add(node.val); // 记录节点值 // 将下一层的节点入队 if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } res.add(level); // 保存当前层结果 } return res; } 线段树（Segment Tree） /** * 线段树：用于高效处理区间查询和单点修改 * 时间复杂度：构建 O(n)，查询 O(log n)，更新 O(log n) */ class SegmentTree { private int[] tree; // 线段树数组 private int n; // 原数组大小 public SegmentTree(int[] nums) { n = nums.length; tree = new int[4 * n]; // 线段树最多需要 4n 空间 build(nums, 0, 0, n - 1); } // 构建线段树：递归构建 // node: 当前节点在 tree 中的索引 // start, end: 当前节点代表的区间 [start, end] private void build(int[] nums, int node, int start, int end) { if (start == end) { // 叶子节点：直接存储原数组的值 tree[node] = nums[start]; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; // 左子节点索引 int rightNode = 2 * node + 2; // 右子节点索引 // 递归构建左右子树 build(nums, leftNode, start, mid); build(nums, rightNode, mid + 1, end); // 当前节点的值 = 左子树 + 右子树（区间和） tree[node] = tree[leftNode] + tree[rightNode]; } // 区间查询：查询区间 [l, r] 的和 public int query(int l, int r) { return query(0, 0, n - 1, l, r); } private int query(int node, int start, int end, int l, int r) { // 情况1：当前区间与查询区间完全不相交 if (l \u0026gt; end || r \u0026lt; start) return 0; // 情况2：当前区间完全包含在查询区间内 if (l \u0026lt;= start \u0026amp;\u0026amp; end \u0026lt;= r) return tree[node]; // 情况3：部分相交，需要递归查询左右子树 int mid = start + (end - start) / 2; int leftSum = query(2 * node + 1, start, mid, l, r); int rightSum = query(2 * node + 2, mid + 1, end, l, r); return leftSum + rightSum; } // 单点更新：将 index 位置的值更新为 val public void update(int index, int val) { update(0, 0, n - 1, index, val); } private void update(int node, int start, int end, int index, int val) { if (start == end) { // 找到叶子节点，更新值 tree[node] = val; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; int rightNode = 2 * node + 2; // 判断 index 在左子树还是右子树 if (index \u0026lt;= mid) { update(leftNode, start, mid, index, val); } else { update(rightNode, mid + 1, end, index, val); } // 更新完子树后，更新当前节点 tree[node] = tree[leftNode] + tree[rightNode]; } } 2. 图算法 图的表示 // 方式1：邻接表（适合稀疏图） Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; graph = new HashMap\u0026lt;\u0026gt;(); // 或使用 ArrayList List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); // 方式2：邻接矩阵（适合密集图） int[][] graph = new int[n][n]; // graph[i][j] 表示 i 到 j 的边权 DFS - 图的深度优先遍历 // 递归实现 DFS void dfs(int node, Set\u0026lt;Integer\u0026gt; visited, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { visited.add(node); // 标记当前节点已访问 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { // 如果邻居未访问 dfs(neighbor, visited, graph); // 递归访问邻居 } } } // 使用示例 Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); dfs(0, visited, graph); // 从节点 0 开始 DFS BFS - 图的广度优先遍历 // 使用队列实现 BFS void bfs(int start, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(start); // 起始节点入队 visited.add(start); // 标记已访问 while (!queue.isEmpty()) { int node = queue.poll(); // 出队 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { queue.offer(neighbor); // 邻居入队 visited.add(neighbor); // 标记已访问 } } } } 拓扑排序（Kahn 算法） /** * 拓扑排序：将有向无环图(DAG)转换为线性序列 * 应用：课程安排、任务调度等 * 核心思想：不断移除入度为0的节点 */ List\u0026lt;Integer\u0026gt; topologicalSort(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] inDegree = new int[n]; // 记录每个节点的入度 for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } // 构建图并计算入度 for (int[] edge : edges) { graph.get(edge[0]).add(edge[1]); // edge[0] -\u0026gt; edge[1] inDegree[edge[1]]++; // edge[1] 的入度+1 } // 将所有入度为0的节点入队 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (inDegree[i] == 0) { queue.offer(i); } } List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); while (!queue.isEmpty()) { int node = queue.poll(); res.add(node); // 将节点加入结果 // 删除该节点的所有出边 for (int neighbor : graph.get(node)) { inDegree[neighbor]--; // 邻居的入度-1 if (inDegree[neighbor] == 0) { // 入度变为0，入队 queue.offer(neighbor); } } } // 如果所有节点都被访问，说明无环，返回结果；否则返回空 return res.size() == n ? res : new ArrayList\u0026lt;\u0026gt;(); } Dijkstra 最短路径算法 /** * Dijkstra算法：单源最短路径（不能有负权边） * 时间复杂度：O(E log V)，E是边数，V是顶点数 * 核心思想：贪心，每次选择距离最小的未访问节点 */ int[] dijkstra(int n, int[][] edges, int start) { // 构建邻接表: {neighbor, weight} List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // edge = [from, to, weight] graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); } // dist[i] 表示从 start 到 i 的最短距离 int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 优先队列: {distance, node}，按距离从小到大排序 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); pq.offer(new int[]{0, start}); while (!pq.isEmpty()) { int[] curr = pq.poll(); int d = curr[0], node = curr[1]; // 如果当前距离大于已知最短距离，跳过 if (d \u0026gt; dist[node]) continue; // 遍历所有邻居，尝试松弛操作 for (int[] neighbor : graph.get(node)) { int next = neighbor[0], weight = neighbor[1]; int newDist = d + weight; // 如果找到更短的路径，更新距离 if (newDist \u0026lt; dist[next]) { dist[next] = newDist; pq.offer(new int[]{newDist, next}); } } } return dist; } Bellman-Ford 算法（可处理负权边） /** * Bellman-Ford算法：单源最短路径，可处理负权边 * 时间复杂度：O(V * E) * 可以检测负环 */ int[] bellmanFord(int n, int[][] edges, int start) { int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 松弛操作：最多进行 n-1 次 // 原理：最短路径最多包含 n-1 条边 for (int i = 0; i \u0026lt; n - 1; i++) { for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; // 松弛操作：如果经过 u 到 v 更短，则更新 if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { dist[v] = dist[u] + w; } } } // 第 n 次松弛：如果还能更新，说明存在负环 for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { return null; // 存在负环 } } return dist; } Floyd-Warshall 全源最短路径 /** * Floyd-Warshall算法：计算所有点对之间的最短路径 * 时间复杂度：O(V³) * 核心思想：动态规划，逐步加入中间节点 */ int[][] floydWarshall(int n, int[][] edges) { int[][] dist = new int[n][n]; // 初始化距离矩阵 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(dist[i], Integer.MAX_VALUE / 2); // 除以2防止溢出 dist[i][i] = 0; // 自己到自己距离为0 } // 填入边的权重 for (int[] edge : edges) { dist[edge[0]][edge[1]] = edge[2]; } // 动态规划：k 是中间节点 // dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) for (int k = 0; k \u0026lt; n; k++) { // 枚举中间节点 for (int i = 0; i \u0026lt; n; i++) { // 枚举起点 for (int j = 0; j \u0026lt; n; j++) { // 枚举终点 // 如果经过 k 中转更短，则更新 dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]); } } } return dist; } Prim 最小生成树 /** * Prim算法：构建最小生成树 * 时间复杂度：O(E log V) * 核心思想：从一个节点开始，逐步扩展，每次选最小边 */ int prim(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // 无向图：添加双向边 graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); graph.get(edge[1]).add(new int[]{edge[0], edge[2]}); } boolean[] visited = new boolean[n]; // 优先队列：{node, weight}，按权重从小到大 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[1] - b[1]); pq.offer(new int[]{0, 0}); // 从节点0开始，权重0 int totalWeight = 0; // 最小生成树的总权重 int edgeCount = 0; // 已添加的边数 while (!pq.isEmpty() \u0026amp;\u0026amp; edgeCount \u0026lt; n) { int[] curr = pq.poll(); int node = curr[0], weight = curr[1]; if (visited[node]) continue; // 已访问，跳过 visited[node] = true; totalWeight += weight; // 加入最小生成树 edgeCount++; // 将邻居节点的边加入优先队列 for (int[] neighbor : graph.get(node)) { if (!visited[neighbor[0]]) { pq.offer(neighbor); } } } // 如果所有节点都连通，返回总权重；否则返回-1 return edgeCount == n ? totalWeight : -1; } Kruskal 最小生成树（并查集） /** * 并查集：用于判断连通性和合并集合 */ class UnionFind { int[] parent; // parent[i] 表示 i 的父节点 int[] rank; // rank[i] 表示以 i 为根的树的高度 public UnionFind(int n) { parent = new int[n]; rank = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; // 初始时每个节点的父节点是自己 } } // 查找：找到 x 所在集合的代表元素（路径压缩） public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); // 路径压缩：直接连到根节点 } return parent[x]; } // 合并：将 x 和 y 所在的集合合并（按秩合并） public boolean union(int x, int y) { int rootX = find(x), rootY = find(y); if (rootX == rootY) return false; // 已经在同一集合 // 按秩合并：将矮树挂到高树上 if (rank[rootX] \u0026lt; rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] \u0026gt; rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; // 高度相同，随便挂，高度+1 } return true; } } /** * Kruskal算法：构建最小生成树 * 时间复杂度：O(E log E) * 核心思想：按边权从小到大排序，用并查集避免成环 */ int kruskal(int n, int[][] edges) { // 按边权从小到大排序 Arrays.sort(edges, (a, b) -\u0026gt; a[2] - b[2]); UnionFind uf = new UnionFind(n); int totalWeight = 0; int edgeCount = 0; for (int[] edge : edges) { // 如果两个节点不在同一集合，添加这条边 if (uf.union(edge[0], edge[1])) { totalWeight += edge[2]; edgeCount++; if (edgeCount == n - 1) break; // 最小生成树有 n-1 条边 } } return edgeCount == n - 1 ? totalWeight : -1; } 3. 回溯算法 组合问题 /** * 组合问题：从 n 个数中选 k 个数的所有组合 * 例如：n=4, k=2 -\u0026gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), 1, n, k); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int start, int n, int k) { // 递归终止条件：已选择 k 个数 if (path.size() == k) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 注意：要复制一份 return; } // 从 start 开始枚举，避免重复 for (int i = start; i \u0026lt;= n; i++) { path.add(i); // 做选择 backtrack(res, path, i + 1, n, k); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } 全排列 /** * 全排列问题：给定数组，返回所有可能的排列 * 例如：[1,2,3] -\u0026gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, new boolean[nums.length]); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, boolean[] used) { // 递归终止条件：所有数字都已使用 if (path.size() == nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } // 枚举所有数字 for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) continue; // 已使用过，跳过 path.add(nums[i]); // 做选择 used[i] = true; // 标记已使用 backtrack(res, path, nums, used); // 递归 used[i] = false; // 撤销标记（回溯） path.remove(path.size() - 1); // 撤销选择（回溯） } } 子集问题 /** * 子集问题：返回数组的所有子集（幂集） * 例如：[1,2,3] -\u0026gt; [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, int start) { // 每个状态都是一个子集 res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 枚举后续元素 for (int i = start; i \u0026lt; nums.length; i++) { path.add(nums[i]); // 做选择 backtrack(res, path, nums, i + 1); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } N 皇后问题 /** * N皇后问题：在 n×n 的棋盘上放置 n 个皇后，使它们互不攻击 * 规则：任意两个皇后不能在同一行、同一列、同一对角线 */ List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); char[][] board = new char[n][n]; // 初始化棋盘：\u0026#39;.\u0026#39; 表示空位 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(board[i], \u0026#39;.\u0026#39;); } backtrack(res, board, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res, char[][] board, int row) { // 递归终止条件：所有行都放置完成 if (row == board.length) { res.add(construct(board)); // 将棋盘转换为字符串列表 return; } // 尝试在当前行的每一列放置皇后 for (int col = 0; col \u0026lt; board.length; col++) { if (!isValid(board, row, col)) continue; // 不合法，跳过 board[row][col] = \u0026#39;Q\u0026#39;; // 放置皇后 backtrack(res, board, row + 1); // 递归下一行 board[row][col] = \u0026#39;.\u0026#39;; // 撤销放置（回溯） } } // 检查在 (row, col) 位置放置皇后是否合法 boolean isValid(char[][] board, int row, int col) { int n = board.length; // 检查列：同一列不能有其他皇后 for (int i = 0; i \u0026lt; row; i++) { if (board[i][col] == \u0026#39;Q\u0026#39;) return false; } // 检查左上对角线 for (int i = row - 1, j = col - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } // 检查右上对角线 for (int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } return true; } // 将棋盘转换为字符串列表 List\u0026lt;String\u0026gt; construct(char[][] board) { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for (char[] row : board) { res.add(new String(row)); } return res; } 4. 动态规划 0-1 背包问题 /** * 0-1背包：每个物品只能选一次 * weights[i]: 第i个物品的重量 * values[i]: 第i个物品的价值 * capacity: 背包容量 * 返回：最大价值 */ int knapsack(int[] weights, int[] values, int capacity) { int n = weights.length; // dp[i][w] 表示前 i 个物品，背包容量为 w 时的最大价值 int[][] dp = new int[n + 1][capacity + 1]; for (int i = 1; i \u0026lt;= n; i++) { for (int w = 0; w \u0026lt;= capacity; w++) { // 如果当前物品的重量 \u0026lt;= 背包容量 if (weights[i - 1] \u0026lt;= w) { // 选择：max(不拿, 拿) dp[i][w] = Math.max( dp[i - 1][w], // 不拿第i个物品 dp[i - 1][w - weights[i - 1]] + values[i - 1] // 拿第i个物品 ); } else { // 放不下，只能不拿 dp[i][w] = dp[i - 1][w]; } } } return dp[n][capacity]; } /** * 0-1背包 - 空间优化版本 * 时间复杂度：O(n * capacity) * 空间复杂度：O(capacity) */ int knapsackOptimized(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：必须从后往前遍历，避免重复使用同一物品 for (int w = capacity; w \u0026gt;= weights[i]; w--) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 完全背包问题 /** * 完全背包：每个物品可以选无限次 * 与0-1背包的区别：内层循环从前往后遍历 */ int completeKnapsack(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：从前往后遍历，允许重复使用物品 for (int w = weights[i]; w \u0026lt;= capacity; w++) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 最长公共子序列（LCS） /** * 最长公共子序列：找两个字符串的最长公共子序列长度 * 子序列：不要求连续 * 例如：\u0026#34;abcde\u0026#34; 和 \u0026#34;ace\u0026#34; 的LCS是 \u0026#34;ace\u0026#34;，长度为3 */ int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); // dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的LCS长度 int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (text1.charAt(i - 1) == text2.charAt(j - 1)) { // 字符相同：LCS长度+1 dp[i][j] = dp[i - 1][j - 1] + 1; } else { // 字符不同：取两种情况的最大值 dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; } 最长递增子序列（LIS） /** * 最长递增子序列 - O(n²) 动态规划解法 * dp[i] 表示以 nums[i] 结尾的最长递增子序列长度 */ int lengthOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; Arrays.fill(dp, 1); // 初始每个元素自己构成长度为1的子序列 int maxLen = 1; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { // 如果 nums[i] 可以接在 nums[j] 后面 if (nums[i] \u0026gt; nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } maxLen = Math.max(maxLen, dp[i]); } return maxLen; } /** * 最长递增子序列 - O(n log n) 二分解法 * tails[i] 表示长度为 i+1 的递增子序列的最小尾部元素 */ int lengthOfLISBinary(int[] nums) { List\u0026lt;Integer\u0026gt; tails = new ArrayList\u0026lt;\u0026gt;(); for (int num : nums) { // 二分查找：找到第一个 \u0026gt;= num 的位置 int left = 0, right = tails.size(); while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (tails.get(mid) \u0026lt; num) { left = mid + 1; } else { right = mid; } } // 如果 num 比所有元素都大，追加到末尾 if (left == tails.size()) { tails.add(num); } else { // 否则替换找到的位置 tails.set(left, num); } } return tails.size(); } 编辑距离 /** * 编辑距离：将 word1 转换为 word2 的最少操作次数 * 操作：插入、删除、替换 * 例如：\u0026#34;horse\u0026#34; -\u0026gt; \u0026#34;ros\u0026#34; 需要3步（删除h、删除r、替换s） */ int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); // dp[i][j] 表示 word1[0..i-1] 转换为 word2[0..j-1] 的最少操作数 int[][] dp = new int[m + 1][n + 1]; // 边界条件：一个字符串为空 for (int i = 0; i \u0026lt;= m; i++) dp[i][0] = i; // word1 -\u0026gt; 空串：删除i个字符 for (int j = 0; j \u0026lt;= n; j++) dp[0][j] = j; // 空串 -\u0026gt; word2：插入j个字符 for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { // 字符相同：不需要操作 dp[i][j] = dp[i - 1][j - 1]; } else { // 字符不同：三种操作取最小 dp[i][j] = Math.min( Math.min( dp[i - 1][j], // 删除 word1[i-1] dp[i][j - 1] // 插入 word2[j-1] ), dp[i - 1][j - 1] // 替换 word1[i-1] 为 word2[j-1] ) + 1; } } } return dp[m][n]; } 股票买卖问题 只能买卖一次\n/** * 买卖股票的最佳时机 I：只能买卖一次 * 贪心思想：记录最低价格，计算每天卖出的最大利润 */ int maxProfit(int[] prices) { int minPrice = Integer.MAX_VALUE; // 记录目前为止的最低价格 int maxProfit = 0; // 记录最大利润 for (int price : prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; } 可以买卖多次\n/** * 买卖股票的最佳时机 II：可以买卖多次 * 贪心思想：只要今天价格比昨天高，就在昨天买今天卖 */ int maxProfitMultiple(int[] prices) { int profit = 0; for (int i = 1; i \u0026lt; prices.length; i++) { // 如果今天价格更高，累加差价 if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } 最多买卖 k 次\n/** * 买卖股票的最佳时机 III/IV：最多买卖 k 次 * dp[i][j] 表示第 i 次交易后，第 j 天的最大利润 */ int maxProfitK(int k, int[] prices) { if (prices.length == 0) return 0; int n = prices.length; // 如果 k \u0026gt;= n/2，相当于无限次交易 if (k \u0026gt;= n / 2) { int profit = 0; for (int i = 1; i \u0026lt; n; i++) { if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } int[][] dp = new int[k + 1][n]; for (int i = 1; i \u0026lt;= k; i++) { int maxDiff = -prices[0]; // 第 i-1 次交易后买入的最大收益 for (int j = 1; j \u0026lt; n; j++) { // 不操作 vs 卖出 dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff); // 更新买入的最大收益 maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]); } } return dp[k][n - 1]; } 打家劫舍 /** * 打家劫舍 I：线性排列的房屋 * 不能抢相邻的房屋 * dp[i] = max(dp[i-1], dp[i-2] + nums[i]) */ int rob(int[] nums) { if (nums.length == 0) return 0; if (nums.length == 1) return nums[0]; int prev2 = 0, prev1 = 0; // prev2: dp[i-2], prev1: dp[i-1] for (int num : nums) { int temp = prev1; // 不抢 vs 抢 prev1 = Math.max(prev1, prev2 + num); prev2 = temp; } return prev1; } /** * 打家劫舍 II：环形排列的房屋 * 第一个和最后一个房屋相邻 * 思路：分两种情况，取最大值 * 1. 抢第一个房屋，不抢最后一个 * 2. 不抢第一个房屋，抢最后一个 */ int robCircular(int[] nums) { if (nums.length == 1) return nums[0]; return Math.max( robRange(nums, 0, nums.length - 2), robRange(nums, 1, nums.length - 1) ); } int robRange(int[] nums, int start, int end) { int prev2 = 0, prev1 = 0; for (int i = start; i \u0026lt;= end; i++) { int temp = prev1; prev1 = Math.max(prev1, prev2 + nums[i]); prev2 = temp; } return prev1; } 分割等和子集 /** * 分割等和子集：判断是否能将数组分成两个和相等的子集 * 本质：0-1背包问题，目标是找到和为 sum/2 的子集 */ boolean canPartition(int[] nums) { int sum = 0; for (int num : nums) sum += num; if (sum % 2 != 0) return false; // 和为奇数，不可能分割 int target = sum / 2; // dp[j] 表示能否凑出和为 j boolean[] dp = new boolean[target + 1]; dp[0] = true; // 和为0总是可以（不选任何数） for (int num : nums) { // 从后往前遍历，避免重复使用 for (int j = target; j \u0026gt;= num; j--) { dp[j] = dp[j] || dp[j - num]; // 不选 num 或 选 num } } return dp[target]; } 零钱兑换 /** * 零钱兑换 I：最少硬币数 * dp[i] 表示凑出金额 i 所需的最少硬币数 */ int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); // 初始化为不可能的大值 dp[0] = 0; // 凑出0元需要0个硬币 for (int i = 1; i \u0026lt;= amount; i++) { for (int coin : coins) { if (i \u0026gt;= coin) { // 选择使用当前硬币 dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } } return dp[amount] \u0026gt; amount ? -1 : dp[amount]; } /** * 零钱兑换 II：组成方案数 * dp[i] 表示凑出金额 i 的方案数 */ int change(int amount, int[] coins) { int[] dp = new int[amount + 1]; dp[0] = 1; // 凑出0元有1种方案（不选） // 外层遍历硬币，内层遍历金额（避免重复计数） for (int coin : coins) { for (int i = coin; i \u0026lt;= amount; i++) { dp[i] += dp[i - coin]; } } return dp[amount]; } 5. 双指针 对撞指针 // 两数之和（有序数组） int[] twoSum(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[left] + nums[right]; if (sum == target) { return new int[]{left, right}; } else if (sum \u0026lt; target) { left++; } else { right--; } } return new int[]{-1, -1}; } // 三数之和 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length - 2; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { res.add(Arrays.asList(nums[i], nums[left], nums[right])); while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; left++; right--; } else if (sum \u0026lt; 0) { left++; } else { right--; } } } return res; } 快慢指针 // 链表中点 ListNode findMiddle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } // 环形链表 boolean hasCycle(ListNode head) { if (head == null) return false; ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) return true; } return false; } // 找环的入口 ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { slow = head; while (slow != fast) { slow = slow.next; fast = fast.next; } return slow; } } return null; } 6. 单调栈 // 下一个更大元素 int[] nextGreaterElement(int[] nums) { int n = nums.length; int[] res = new int[n]; Arrays.fill(res, -1); Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; nums[stack.peek()] \u0026lt; nums[i]) { int idx = stack.pop(); res[idx] = nums[i]; } stack.push(i); } return res; } // 每日温度 int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] res = new int[n]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[stack.peek()] \u0026lt; temperatures[i]) { int idx = stack.pop(); res[idx] = i - idx; } stack.push(i); } return res; } // 柱状图中最大的矩形 int largestRectangleArea(int[] heights) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(-1); int maxArea = 0; for (int i = 0; i \u0026lt; heights.length; i++) { while (stack.peek() != -1 \u0026amp;\u0026amp; heights[stack.peek()] \u0026gt;= heights[i]) { int h = heights[stack.pop()]; int w = i - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } stack.push(i); } while (stack.peek() != -1) { int h = heights[stack.pop()]; int w = heights.length - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } return maxArea; } 7. 前缀和 // 一维前缀和 class PrefixSum { private int[] preSum; public PrefixSum(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 0; i \u0026lt; nums.length; i++) { preSum[i + 1] = preSum[i] + nums[i]; } } // 查询区间 [left, right] 的和 public int query(int left, int right) { return preSum[right + 1] - preSum[left]; } } // 二维前缀和 class MatrixPrefixSum { private int[][] preSum; public MatrixPrefixSum(int[][] matrix) { int m = matrix.length, n = matrix[0].length; preSum = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } // 查询子矩阵 [row1, col1] 到 [row2, col2] 的和 public int query(int row1, int col1, int row2, int col2) { return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]; } } 📌 总结 这份文档涵盖了：\nJava 集合框架：List、Set、Map、Queue、Stack 的完整使用方法 树算法：DFS、BFS、线段树 图算法：遍历、最短路径、最小生成树 经典算法：回溯、动态规划、二分查找、滑动窗口、双指针、单调栈、前缀和 建议配合 LeetCode 刷题使用，遇到问题时可以快速查阅对应的模板代码。\n持续更新中\u0026hellip; 🚀\n","permalink":"http://localhost:1313/posts/algorithm-with-java/","summary":"详细介绍java集合的使用,以及在刷算法题中需要使用到的一些板子","title":"算法刷题必备：Java集合与算法模板"},{"content":"一、Hugo 常用指令 1.1 创建新站点 # 创建一个新的 Hugo 站点 hugo new site mysite # 进入站点目录 cd mysite 1.2 创建新文章 # 在 content/posts 目录下创建新文章 hugo new posts/my-first-post.md # 在 content 目录下创建文章 hugo new about.md # 创建在特定子目录 hugo new blog/2024/new-post.md 1.3 本地预览 # 启动本地开发服务器（默认 http://localhost:1313） hugo server # 启动并显示草稿文章 hugo server -D # 启动并显示草稿、未来日期和过期的文章 hugo server -DEF # 指定端口 hugo server --port 8080 # 实时重载并打开浏览器 hugo server -D --navigateToChanged 1.4 主题管理 # 添加主题（使用 Git submodule） git submodule add https://github.com/username/theme-name.git themes/theme-name # 更新主题 git submodule update --remote --merge # 删除主题 git submodule deinit -f themes/theme-name rm -rf .git/modules/themes/theme-name git rm -f themes/theme-name 1.5 其他常用指令 # 查看 Hugo 版本 hugo version # 查看帮助 hugo help # 查看配置信息 hugo config # 列出所有内容 hugo list all # 列出草稿 hugo list drafts 二、Markdown Front Matter 配置 2.1 完整配置示例 --- # 基本信息 title: \u0026#34;我的第一篇文章\u0026#34; date: 2025-12-06T15:04:05+08:00 lastmod: 2025-12-07T10:00:00+08:00 draft: false # 作者信息 author: \u0026#34;Minjie\u0026#34; authorLink: \u0026#34;https://github.com/Minjie2003\u0026#34; # 分类和标签 categories: [\u0026#34;技术\u0026#34;] tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;, \u0026#34;博客\u0026#34;] series: [\u0026#34;Hugo教程\u0026#34;] # 摘要和描述 summary: \u0026#34;这是一篇关于 Hugo 和 Markdown 的完整指南\u0026#34; description: \u0026#34;详细介绍 Hugo 的使用方法和 Markdown 配置\u0026#34; # 特色图片 image: \u0026#34;/images/featured.jpg\u0026#34; cover: image: \u0026#34;/images/cover.jpg\u0026#34; alt: \u0026#34;封面图片描述\u0026#34; caption: \u0026#34;图片说明文字\u0026#34; # SEO 相关 keywords: [\u0026#34;Hugo\u0026#34;, \u0026#34;静态博客\u0026#34;, \u0026#34;Markdown\u0026#34;] slug: \u0026#34;hugo-markdown-guide\u0026#34; url: \u0026#34;/posts/hugo-guide/\u0026#34; # 显示控制 toc: true # 显示目录 comments: true # 允许评论 showToc: true # 显示目录 TocOpen: false # 默认展开目录 hidemeta: false # 隐藏元信息 disableShare: false # 禁用分享按钮 hideSummary: false # 隐藏摘要 ShowReadingTime: true # 显示阅读时间 ShowBreadCrumbs: true # 显示面包屑导航 ShowPostNavLinks: true # 显示文章导航链接 # 权重（用于排序） weight: 1 # 外部链接 externalLink: \u0026#34;https://example.com\u0026#34; # 是否在首页显示 showhome: true --- 2.2 常用字段说明 字段 说明 示例 title 文章标题 \u0026quot;我的文章\u0026quot; date 发布日期 2025-12-06 或 2025-12-06T15:04:05+08:00 draft 是否为草稿 true / false tags 标签（数组） [\u0026quot;Hugo\u0026quot;, \u0026quot;博客\u0026quot;] categories 分类（数组） [\u0026quot;技术\u0026quot;, \u0026quot;教程\u0026quot;] summary 文章摘要 \u0026quot;这是摘要\u0026quot; description SEO 描述 \u0026quot;页面描述\u0026quot; slug URL 友好名称 \u0026quot;my-post\u0026quot; url 自定义完整 URL \u0026quot;/posts/my-post/\u0026quot; weight 排序权重 1 (数字越小越靠前) toc 是否显示目录 true / false 三、Hugo Shortcodes（短代码） 3.1 内置 Shortcodes # 显示图片 {{\u0026lt; figure src=\u0026#34;/images/photo.jpg\u0026#34; title=\u0026#34;图片标题\u0026#34; \u0026gt;}} # 高亮文本 {{\u0026lt; highlight python \u0026gt;}} def hello(): print(\u0026#34;Hello!\u0026#34;) {{\u0026lt; /highlight \u0026gt;}} # YouTube 视频 {{\u0026lt; youtube VIDEO_ID \u0026gt;}} # X (Twitter) 推文（新版） {{\u0026lt; x user=\u0026#34;USERNAME\u0026#34; id=\u0026#34;TWEET_ID\u0026#34; \u0026gt;}} # GitHub Gist（已废弃，建议直接嵌入代码） # 可以使用 highlight 或直接用代码块替代 # 参数传递（需要在 Front Matter 中定义参数） {{\u0026lt; param \u0026#34;description\u0026#34; \u0026gt;}} 3.2 自定义 Shortcode 示例 在 layouts/shortcodes/note.html 创建：\n\u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; 使用时：\n{{\u0026lt; note \u0026gt;}} 这是一个提示框 {{\u0026lt; /note \u0026gt;}} 四、Markdown 基本语法 4.1 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 4.2 文本样式 **粗体文字** *斜体文字* ***粗斜体*** ~~删除线~~ `行内代码` 4.3 列表 # 无序列表 - 项目 1 - 项目 2 - 子项目 2.1 - 子项目 2.2 # 有序列表 1. 第一项 2. 第二项 1. 子项 2.1 2. 子项 2.2 4.4 链接和图片 # 链接 [链接文字](https://example.com) [带标题的链接](https://example.com \u0026#34;鼠标悬停显示\u0026#34;) # 图片 ![图片描述](/images/photo.jpg) ![图片](https://example.com/image.jpg \u0026#34;图片标题\u0026#34;) 4.5 引用 \u0026gt; 这是一段引用文字 \u0026gt; 可以多行 \u0026gt;\u0026gt; 嵌套引用 4.6 代码块 ```python def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) ``` ```javascript console.log(\u0026#34;Hello, World!\u0026#34;); ``` 4.7 表格 | 列1 | 列2 | 列3 | |-----|-----|-----| | 数据1 | 数据2 | 数据3 | | 数据4 | 数据5 | 数据6 | # 对齐方式 | 左对齐 | 居中 | 右对齐 | |:-------|:----:|-------:| | 内容 | 内容 | 内容 | 4.8 分隔线 --- *** ___ 4.9 任务列表 - [x] 已完成的任务 - [ ] 未完成的任务 - [ ] 另一个任务 五、实用技巧 5.1 文章模板 在 archetypes/default.md 创建默认模板：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true tags: [] categories: [] summary: \u0026#34;\u0026#34; --- ## 简介 内容开始... 5.2 多语言配置 在 Front Matter 中：\n--- title: \u0026#34;English Title\u0026#34; title.zh: \u0026#34;中文标题\u0026#34; --- 5.3 自定义 URL 结构 在 hugo.toml 中：\n[permalinks] posts = \u0026#34;/:year/:month/:slug/\u0026#34; 5.4 草稿快速发布 # 将草稿改为发布状态 sed -i \u0026#39;s/draft: true/draft: false/\u0026#39; content/posts/my-post.md ","permalink":"http://localhost:1313/posts/hugo-readme/","summary":"详细介绍 Hugo 常用指令、Markdown Front Matter 配置、基本语法和实用技巧的完整指南","title":"Hugo 常用指令与 Markdown 配置指南"},{"content":"👋 嗨，我是 Minjie 很高兴你能来到这里！这是我在互联网上的一个小角落，用来记录代码、想法和生活的点滴。\n🧑‍💻 关于我 我是一名在读研究生，研究方向包括区块链，web3.0，数据库管理等。当然，目前更加专注于 Java 后端开发。相比起\u0026quot;全栈工程师\u0026quot;这样的标签，我更喜欢把自己定义为一个对计算机技术充满好奇心的探索者。\n📖 这个博客写什么 这里主要记录我在技术道路上的成长轨迹，你可能会看到：\n技术笔记 - Java 后端开发的实践经验、框架使用心得、踩过的坑和解决方案\n项目复盘 - 从需求分析到上线部署，记录项目中的思考和收获\n学习记录 - 新技术的探索、算法题的思路、计算机基础知识的整理\n随笔杂谈 - 偶尔也会写写读书笔记、游戏感想，或者对技术趋势的一些思考\n我希望这里不仅是我个人的知识库,也能给同样在技术路上摸索的你带来一些启发或共鸣。\n🎯 技术栈 \u0026amp; 兴趣方向 后端开发：Java、Spring Boot、MyBatis、MySQL、Redis - 这是我的主战场\n折腾爱好：除了后端，我还喜欢写点爬虫玩玩，做些自动化小工具来解决日常遇到的重复性工作。总觉得能用代码解决的事情，就不该浪费时间手动操作。有时候为了实现一个自动化脚本，花的时间可能比手动做还多，但那种\u0026quot;一劳永逸\u0026quot;的快感真的很上头。\n探索中：对各种能提高效率的技术和工具都充满兴趣，正在不断拓展技术边界\u0026hellip;\n🎮 代码之外 游戏时光：Steam 上收藏了不少游戏，也会玩玩王者、原神这些。\n音乐陪伴：写代码的时候总要听点什么。古典音乐能让思路更清晰，ACG 音乐带来满满的回忆，偶尔也会跟着流行音乐哼哼唱唱。喜欢洗澡的时候k歌······当然，也是个半吊子吉他选手\n运动爱好：除了敲键盘，也喜欢出去动一动。篮球、羽毛球、乒乓球都有涉猎，虽然都不算精通，但也能过上两招。过去打篮球多一点，现在更想尝试羽毛球。\n历史爱好者：对历史有种莫名的着迷，喜欢看历史书籍、纪录片。主要包括近现代欧洲历史，唐史，春秋战国。\n💬 来聊聊？ 如果你也对后端开发感兴趣，或者想交流技术、分享项目经验，甚至只是想推荐个好玩的游戏或好听的歌，都欢迎联系我：\n📧 邮箱：zhongnagisa01@gmail.com 🐙 GitHub：Minjie2003 \u0026ldquo;代码改变世界，但别忘了偶尔抬头看看星空。\u0026rdquo;\n感谢你的访问，希望我们能在这里有更多交流！✨\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于我"}]