[{"content":"论文基本信息 标题: Enhancing trust and privacy in distributed networks: a comprehensive survey on blockchain-based federated learning\n作者: Ji Liu, Chunlu Chen, Yu Li, Lin Sun, Yulun Song, Jingbo Zhou, Bo Jing, Dejing Dou\n发表: Knowledge and Information Systems (2024) 66:4377–4403\n机构: 恒生电子、九州大学、百度、联通数科、波士顿咨询\n一、研究背景 1.1 区块链技术概述 论文首先介绍了区块链的基本概念和特性：\n核心特性：\n去中心化架构：将验证系统从中心化转变为去中心化，通过多个用户的共识来促进验证过程 不可篡改性：通过哈希函数将数据块链接成链，任何篡改尝试都会破坏哈希链，导致不匹配 加密安全：使用哈希函数、数字签名和加密技术保护数据完整性和安全性 透明性：区块链上记录的每笔交易对所有网络参与者透明可见 智能合约：自动执行的协议，按预定义规则执行交易，无需中介 区块链类型：\n类型 访问方式 典型代表 常用共识 无许可链 匿名访问，任何人可加入 Bitcoin, Ethereum PoW, PoS 有许可链 需要注册，限制访问 Hyperledger Fabric Kafka, Raft, PBFT 分布式系统特性：\n去中心化：控制和决策分布在各个节点 共识机制：确保所有节点对系统状态达成一致 容错性：通过冗余、复制和错误处理机制实现 可扩展性：通过增加节点水平扩展 1.2 联邦学习基础 FL基本流程：\n中央服务器初始化模型参数并分发给所有客户端 客户端使用本地数据训练模型 客户端上传训练后的模型参数到中央服务器 中央服务器聚合参数，更新全局模型 重复以上步骤直到模型收敛 FL分类：\n按网络拓扑：\n中心化FL 去中心化FL 按数据可用性：\n跨孤岛FL (Cross-silo) 跨设备FL (Cross-device) 按数据分区：\n横向FL：特征空间相同，样本不同 纵向FL：样本相同，特征空间不同 联邦迁移学习：样本和特征都不同 常见优化算法：FedAvg, FedProx, SCAFFOLD, FedPD, FedBN\n1.3 FL面临的主要挑战 论文总结了FL的三大核心挑战：\n挑战1：数据异构性 三种异构：\n特征异构：参与设备拥有不同的特征集，使模型聚合和对齐变得困难 数据分布异构：由于用户群体、地理位置、数据收集实践的差异，导致数据分布不同，可能引入偏见 数据格式异构：来自不同来源或平台的数据可能具有不同的格式、表示或结构 解决技术：\n模型架构调整和特征工程 元学习和域适应 多格式设计的模型 挑战2：隐私与安全 主要威胁：\n数据泄露：共享模型可能包含训练数据的敏感信息 成员推理攻击：对手试图确定特定数据点是否属于训练数据集 模型投毒攻击：对手注入恶意数据或操纵本地更新以毒化共享模型 防御技术：\n差分隐私(DP)：向数据或模型更新添加噪声以模糊个体贡献 同态加密(HE)：允许对加密数据进行计算 安全多方计算(SMPC)：多方在不暴露私有数据的情况下联合计算 可信执行环境(TEE)：如TrustFL方案 挑战3：可追溯性与问责性 可追溯性需求：\n模型审计：通过记录元数据（模型架构、超参数、数据源）跟踪和审计FL中训练的模型 数据溯源：追踪训练数据的来源和历史，确保真实性并评估潜在偏见 问责性需求：\n参与者问责：参与者应遵守商定的协议、隐私措施和安全实践 安全与信任维护：实施适当的安全措施，保护数据机密性，防止未授权访问或恶意活动 面临的困难：\nFL的去中心化结构使协调和建立共识变得复杂 在保护隐私的同时确保可追溯性需要平衡 数据分散在不同参与者之间，追踪数据来源和血统面临挑战 1.4 整合区块链与FL的必要性 论文论述了结合区块链和FL的三大核心价值：\n价值1：激励机制 传统FL中，许多客户端由于经济理性不愿分享有价值的数据 区块链原生的加密货币或代币系统可建立激励机制 通过奖励数据贡献者、模型验证者和其他参与者，激励积极参与、数据共享和模型改进 价值2：增强数据隐私与安全 解决中心化风险：传统FL严重依赖单一中央服务器，如果服务器恶意行为，整个系统可能崩溃 防御客户端攻击：现有设计容易受到恶意客户端的攻击，可能上传有毒模型攻击FL网络 区块链优势： 去中心化和不可变的特性提供安全透明的数据共享和存储框架 加密方法显著增强数据隐私和安全 参与者可以验证共享模型的完整性和真实性，而不暴露敏感信息 价值3：信任与透明 区块链固有的透明性和可审计性可以解决FL中的信任问题 使参与者能够追踪数据、模型和计算的历史和来源 透明性在参与者之间培养信任，因为他们可以验证FL过程的公平性和可靠性 二、BCFL系统架构 2.1 整体架构概览 论文提出从底向上的五层架构（加上贯穿的区块链共识层）：\n┌─────────────────────────────────────────────┐ │ 应用层 (Application Layer) │ │ 医疗 | 车联网 | 边缘计算 | 能源 | 资源分配 │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 区块链共识层 (Blockchain Consensus) │ │ PoW | PoS | DPoS | PBFT | PoQ | PoF | Raft │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 算法层 (Algorithm Layer) │ │ 聚合算法 | 安全算法 | 优化算法 | 激励算法 │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 通信层 (Communication Layer) │ │ 加密技术 | 网络协议 | 同步机制 | P2P框架 │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 网络层 (Network Layer) │ │ 中心化 | 多中心化 | 去中心化 (P2P) │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 基础设施层 (Infrastructure Layer) │ │ L1/L2架构 | 存储资源 | 计算资源(CPU/GPU/TPU)│ └─────────────────────────────────────────────┘ 2.2 架构分类：三种耦合方式 论文根据操作动态将BCFL系统分为三种架构：\n完全耦合 (Fully Coupled) 定义：客户端同时作为训练节点和区块链节点\n特点：\n提供去中心化 要求高设备性能 适用场景：参与者设备能力强的环境\n灵活耦合 (Flexibly Coupled) 定义：分离区块链和FL操作以减轻网络通信负担\n实现方式：\n委员会选择：选择部分节点参与共识 智能合约：通过智能合约实现分离 特点：平衡了去中心化和效率\n松散耦合 (Loosely Coupled) 定义：优先考虑声誉来衡量参与者可靠性\n关注点：\n主要关注模型更新验证 在账本上进行声誉管理 特点：轻量级，适合大规模异构设备\n三、六层架构详解 3.1 基础设施层 L1与L2架构 L1层架构：\nFL直接集成到区块链 提供去中心化的P2P框架 对等方自由加入 由共识机制支持系统可靠性 L2层架构：\nFL构建在区块链节点之上 强调分层数据处理和模型训练 存储方案 去中心化存储：\n采用去中心化存储模型 通过高级加密方法确保隐私： 安全多方计算(SMPC) 同态加密 优势：\n促进安全、私密的数据共享和模型聚合 区块链的可审计性提高透明度和信任 计算资源 本地计算：\n本地满足计算需求 利用CPU、GPU、TPU 异构性处理：\n通过轻量级架构处理设备异构性 模型压缩技术 联邦蒸馏(Federated Distillation) 优化性能和资源分配 3.2 网络层 论文将区块链网络结构分为三类：\n中心化网络 特点：\n所有通信和交易通过中央节点路由 常见于有许可区块链系统 优势：\n简化效率 由于单一控制点，共识更快 劣势：\n显著的安全风险 中央节点成为攻击的主要目标 可能损害整个网络的完整性和隐私 多中心化网络（联邦区块链） 特点：\n引入多个中央节点而非单一节点 通常用于平衡多个组织或方之间的控制 优势：\n增强协作 维持一定程度的中心化治理 改善安全性，减少单点故障风险 劣势：\n仍可能面临可扩展性限制 中心化控制问题 去中心化网络 特点：\n以无许可区块链为代表（如Bitcoin、Ethereum） 在广泛的节点阵列中分布数据验证和交易处理 P2P网络结构 无单点控制或故障 每个节点以平等地位运行 优势：\n最高级别的安全性和数据完整性 显著增强对审查、篡改和攻击的抵抗力 劣势：\n可能在可扩展性方面面临挑战 由于决策过程的分布式性质，共识速度可能较慢 论文总结：网络设置的选择深刻影响BCFL系统的性能和安全性\n3.3 通信层 核心任务 通信层在BCFL系统中扮演关键角色，负责：\n编排参与者之间的数据传输和消息交换 促进协作学习过程 高效、安全地传输模型更新、聚合结果和协调指令 关键技术 加密技术：\n在传输前加密数据 防止未授权访问 确保维护数据隐私 网络协议：\n采用可靠高效的网络协议管理消息传递 确保数据包可靠有序地到达目的地 即使在网络中断或拥塞情况下 同步机制：\n在BCFL系统的分布式特性下，同步机制至关重要 协调参与者之间的通信 确保及时共享模型更新 管理数据传输的异步性质 对齐来自不同参与者的更新 去中心化通信框架：\n采用去中心化框架（如P2P网络或区块链） 促进参与者之间的直接通信 消除中心化中介的需要 增强系统的韧性和去中心化 减少潜在瓶颈和故障点 案例 - BLADE-FL：\n论文提到的完全去中心化框架 将训练和挖矿的责任都分配给全节点 增强去中心化和系统韧性 面临的挑战 延迟和有限带宽：\n通过数据压缩技术解决 最小化数据传输的大小 提高交换速度 优化策略：\n自适应网络路由 拥塞控制算法 优化数据流 减少延迟 提高通信效率 批处理和缓存：\n降低数据传输的频率和数量 减轻网络约束的影响 3.4 算法层 论文将算法层分为四个关键方面：\n1. 聚合算法 经典算法：\nFedAvg：\n参与者上传本地模型权重到区块链网络 通过智能合约计算权重平均值获得全局模型 进阶算法：\nFedProx：处理异构性 SCAFFOLD：减少方差 FedPD：原对偶优化 FedBN：批归一化层处理 异步FL系统：\n解决中心化模型带来的安全挑战 实现隐私、容错和可靠的数据共享 基于有许可区块链的FL异步聚合协议 通过将学习模型集成到区块链并执行二阶聚合计算 有效缓解同步FL算法的问题 2. 安全算法 论文详细介绍了三种核心隐私保护技术：\n安全多方计算(SMPC)：\n定义：保护数据隐私的计算模型，允许多方在不披露私有数据的情况下进行计算\n特点：\n各方持有部分私有数据 可以对加密数据执行计算以维护隐私 各方通过协议进行通信和交互 共同计算最终结果而无需直接暴露私有数据 技术组成：\n同态加密 秘密共享(Secret Sharing) 零知识证明(Zero-Knowledge Proof) 安全多方计算协议 同态加密(HE)：\n定义：满足密文同态运算性质的加密算法\n核心特性：\n数据经过同态加密后 对密文执行特定计算 密文计算结果经相应同态解密后 等价于对明文数据直接执行相同计算 实现数据的\u0026quot;可计算但不可见\u0026quot;状态 优势：\n可以在密文上进行计算而无需密钥 减少通信成本 平衡各方的计算成本 差分隐私(DP)：\n定义：通过添加扰动噪声保护底层用户隐私信息的技术\n原理：\n确保即使攻击者掌握除一条信息外的所有其他信息 仍无法推断该条信息 方法：\n向结果添加符合特定分布的噪声 随机化查询结果 挑战：需要解决数据可用性问题（由于需要在查询结果中加入随机性，可能导致数据可用性下降）\n3. 优化算法 目标：\n优化FL性能 减少训练轮次 降低通信开销 提高模型准确性 常用方法：\n梯度压缩：减少通信开销 梯度剪枝：减少通信开销 异步更新：减少训练轮次 本地更新：减少训练轮次 4. 激励算法 论文强调：虽然FL在保护数据隐私的同时实现协作学习展现了巨大优势，但仍面临如何激励人们通过贡献计算能力和数据加入FL的开放挑战。\n基于声誉的FL：\n核心思想：通过设计安全机制衡量参与者的可靠性\n代表性工作：\n区块链声誉系统\n增加贡献正确有用模型参数的客户端的声誉值 降低上传恶意参数的客户端的声誉值 影响后续训练轮次的客户端选择 RepBFL框架\n结合区块链和FL应用于车联网(IoV) 利用区块链确保共享数据保护 选择高声誉节点进行FL 评估IoV中车辆的可靠性 基于模型质量参数的评估\n使用模型质量参数进行声誉评估 区块链衡量工作者可靠性并维护声誉值 CFFL协作公平框架\n引入基于经验个体模型性能的声誉机制 调节参与者奖励以保持通信轮次间的公平性 多权重主观逻辑模型\n将声誉作为量化移动设备可靠性和可信度的指标 采用多权重主观逻辑模型进行声誉计算 联盟区块链技术以去中心化方式保护声誉存储 基于支付的FL：\nFedCoin\n采用Shapley值(SVs)进行可行的基于SV的利润分配 公平反映对全局FL模型的贡献 区块链共识实体部署Shapley权益证明协议(PoSap) 用于计算SVs和创建新区块 公共区块链上的FL协议\n解决监控工作者行为和保证协议遵守的挑战 将竞争嵌入BCFL 仅奖励贡献有价值的工作者 自然抑制偏离协议的行为 移动群体FL系统\n通过根据个人贡献提供奖励来激励移动设备训练准确模型 Stackelberg博弈建模服务器和设备间的交互 比较基于规模和基于准确性的两种奖励策略 跨孤岛横向FL的贡献评估\n解决透明评估不同数据所有者贡献的挑战 使用可调精度量化数据所有者基于SV的贡献 保护隐私 DeepChain：\n特点：\n客户端联合参与训练深度学习模型的协作框架 保证数据机密性和计算可验证性 为参与者提供激励 激励机制：\n围绕超时检查和货币惩罚编排 促进参与者之间的公平性 在参与者未能满足截止日期或不准确执行函数的情况下采取惩罚措施 施加货币惩罚，没收不诚实参与者的预存资金 在诚实参与者之间重新分配 机制设计综述：\n论文引用的综述工作：\n基于关键技术对现有激励机制进行分类 包括：Stackelberg博弈、拍卖、合约理论、Shapley值、强化学习、区块链 Refiner系统：\n部署在Ethereum公共区块链平台 运行激励机制，根据训练数据量和本地更新性能奖励参与者 处理大规模协作中的恶意参与者 部署随机选择的验证者委员会 验证者惩罚不道德参与者，拒绝奖励并从全局模型中消除腐败更新 3.5 区块链共识层 论文强调：在FL系统实现的背景下，共识涉及参与者同步模型并集体做出决策所采用的协议。共识算法确保所有参与者对模型更新的有效性达成一致，并防止恶意行为者篡改系统。\n共识机制的重要性 共识机制的作用：\n在极短时间内完成交易验证和确认 通过特殊节点的投票完成 如果利益不同的节点能对交易达成共识，则可以认为整个网络也能达成共识 主要共识机制 1. Proof of Work (PoW)\n特点：\nBitcoin使用PoW工作量证明机制 Ethereum曾使用PoW和PoS混合共识机制 相当于解决一个随时间变难的数学难题 挑战：\n计算消耗大量能源 可能间接影响碳排放和环境 应用案例：\nBCFL系统：引入分布式哈希表用于高效区块生成，采用PoW共识机制确保全局模型一致性 LearningChain：去中心化联邦系统，利用基于PoW共识的拜占庭容错聚合算法（l-nearest aggregation），通过竞争选择领导者，使用l-nearest算法聚合梯度 Swarm Learning (SL)：去中心化机器学习方法，结合边缘计算和基于区块链的P2P网络，数据和参数保留在边缘，消除中央协调者的需求 2. Proof of Stake (PoS)\n特点：\n被视为PoW的环保替代方案 验证者基于持有和愿意\u0026quot;质押\u0026quot;作为抵押品的加密货币数量被选择创建新区块 3. Delegated Proof of Stake (DPoS)\n特点：\n利益相关者选举一定数量的代表来验证交易和创建区块 设计为比传统PoS更民主和高效 4. Proof of Training Quality (PoQ)\n背景：现有共识机制（如PoW）消耗大量计算和通信资源，或对数据共享的额外贡献有限\n解决方案：\n论文提到提出了结合FL与差分隐私的共识机制PoQ 将数据模型训练与共识过程集成 用模型参数准确性的认证替代PoW中寻找随机数的无意义计算工作 5. Byzantine Fault Tolerance (BFT)\n目标：抵御\u0026quot;拜占庭\u0026quot;故障（组件可能失败且对组件是否失败的信息不完善）\n变体：\nPBFT (Practical Byzantine Fault Tolerance)：用于Hyperledger Fabric FBA (Federated Byzantine Agreement)：用于Stellar 6. Proof of Federation (PoF)\nBiscotti系统：\n将PoF与一致性哈希和可验证随机函数(VRF)结合 为对等节点选择关键角色，协助协调模型更新的隐私和安全 通过Multi-Krum防御防止对等点毒化模型 采用差分化私有噪声提供隐私 利用Shamir秘密共享进行安全聚合 挑战：当所有节点参与共识时，计算负载过大\n7. RAFT\n特点：\n在一组节点中选举领导者 领导者负责提出和验证区块 专注于简单性和容错性 设计为比其他共识算法更易理解和实现 应用：一些有许可区块链网络\n8. Proof of Federated Training (PoFT)\n特点：\n实现跨多个区块链网络的可验证模型训练的框架 解决PoW中的功耗/资源浪费问题 解决区块链中的数据隐私问题 扩展 - PoFL：\n联邦学习证明 应用于车辆网络 车辆通过遵守区块链网络内的FL共识证明竞争成为矿工 IPFS和PoFL用于确保连接自动驾驶车辆的去中心化联邦学习安全 9. 委员会共识\nBFLC框架：\n基于区块链的委员会共识FL框架 利用区块链进行全局模型存储和本地模型更新交换 消除中心化服务器需求 引入创新的委员会共识机制减少计算负载并缓解恶意攻击 论文总结：\n所有这些共识算法都有其优势和劣势 适合不同的用例 选择正确的共识机制对区块链网络的安全性、可扩展性和效率至关重要 共识算法的选择受期望的去中心化程度、安全性、可扩展性以及区块链网络的特定需求等因素影响 3.6 应用层 论文探讨了FL在不同领域的应用，这些领域可以提供基于该技术的服务。\n车联网 (Internet of Vehicles) 应用背景：\n车辆日益成为数据生成源 GPS位置、速度、道路状况等数据可以为更好的交通管理、路线规划和事故预防做出贡献 但这些数据也是敏感的 BCFL的价值：\n能够聚合来自多辆车辆的数据来训练模型，而无需共享原始数据 区块链还可以用于维护网络中车辆交互和交易的防篡改记录 相关研究：论文引用了多篇关于BCFL在车联网应用的研究工作\n资源分配 应用价值：\n在大型分布式系统中，有效的资源分配对于最大化效率至关重要 通过在区块链网络之上应用FL，可以根据从网络使用模式中学习的知识动态分配资源 将区块链与FL集成不仅加强隐私和可靠性，还为高效的资源分配和利用提供平台 边缘计算 应用潜力：\nBCFL在边缘计算应用方面具有巨大潜力 为数据共享、资源协作和共享、模型更新和升级以及抗干扰和容错提供安全机制 实现方式：\n通过利用边缘设备的计算资源和数据 使智能应用能够高效安全地执行推理和决策任务 解决的挑战：\n数据隐私 资源约束 边缘计算中常见的不稳定环境 应用现状：\n已在移动电话场景中进行了广泛研究和应用 预计将为更多边缘计算场景的发展和扩展提供解决方案 医疗健康 应用价值：\n患者数据敏感但对检测疾病和改善治疗极有价值 BCFL允许医疗机构协作并从大量患者数据中学习，而不损害患者隐私 区块链优势：\n可以提供数据和计算的可追溯性 增加对学习模型的信任 相关应用：\n疾病检测 治疗改进 电子健康记录系统的安全性、隐私和互操作性 能源 应用场景：\n智能电网：\n优化电网运营 促进微电网间的P2P能源交易和共享 工业物联网(IIoT)：\n解决无线网络中与信用数据共享相关的安全和隐私问题 可再生能源：\n应用于风能涡轮机的叶片结冰检测 风能是快速增长的可再生能源部门 四、关键框架案例 论文介绍了多个具有代表性的BCFL框架：\nBML-ES 基于区块链的工业物联网(IIoT)边缘服务机器学习框架 利用智能合约实现聚合策略 采用SM2公钥密码系统保护隐私并提高模型准确性 TrustFed 将区块链集成到跨设备FL系统中 防止模型投毒 确保公平训练 维护参与者声誉 使用智能合约管理声誉并排除恶意行为者 确保可靠的训练环境 基于状态通道的信任监督机制 使用区块链和FL为分布式数据共享创建可信环境 采用状态通道为FL任务建立安全沙箱 确保整个过程的完整性和监督 Proof of Federated Training (PoFT) 实现跨区块链网络可验证模型训练的框架 增强协作训练过程中的透明度和信任 去中心化模型训练和梯度聚合 提出基于区块链的安全模型训练架构 引入旨在提高模型准确性、隐私和性能的梯度聚合方法 Blockchain-in-the-loop FL 将传统FL与Hyperledger Fabric合并 结合游戏化以增强参与度和效率 Swarm Learning 去中心化机器学习方法 结合边缘计算和基于区块链的P2P网络 数据和参数保留在边缘 消除中央协调者的需求 发表在Nature上，应用于COVID-19等疾病的去中心化临床机器学习 五、挑战与未来研究方向 论文在结尾部分识别了BCFL面临的主要挑战并提出未来研究方向：\n5.1 数据安全与隐私保护 挑战：\n在FL与区块链结合的环境中，确保数据安全和隐私成为首要关注点 在网络环境中有效管理敏感信息（如医疗记录或个人身份）是一项挑战 需要深入探索在不暴露其真实内容的情况下处理此类数据的密码技术 研究方向：\n未来研究应深入研究针对这个集成系统定制的新密码解决方案 5.2 模型效率与性能优化 挑战：\n分布式数据和模型的高效计算是FL的基本要求 该领域的核心挑战涉及： 设计降低计算复杂度的算法 最小化通信开销 提高模型训练和推理的效率 研究方向：\n未来研究工作应集中于微调分布式优化方法 整合先进的压缩策略以减轻通信负担 探索硬件增强以提高计算效率 调查混合模型，合并中心化和去中心化训练方法，也具有相当大的前景 5.3 可扩展性 问题描述：\n随着区块链和FL融合以创建安全、私密的数据管理框架 可扩展性成为一个关键瓶颈 特别是当系统规模扩大和需求增加时 解决方案： 论文提出的前瞻性方法：\n链下计算 (Off-chain Calculations)：卸载密集任务，减少主区块链负载 侧链 (Sidechains)：单独管理交易以减少拥塞 Layer-2技术： 状态通道(State Channels) Plasma 在现有区块链之上促进快速交易，同时保持安全性 目标：\n这些方法利用区块链和FL的核心原则 旨在培育可扩展、安全和去中心化的学习生态系统 六、论文贡献总结 论文明确指出其核心贡献：\n分类法提出\n从三个方面呈现BCFL的分类： 去中心化架构 分离网络 基于声誉的架构 通用架构总结\n总结了BCFL系统的通用架构 提供了基于区块链的FL架构的全面视角 包括六个关键层： 基础设施层 网络层 通信层 算法层 区块链共识层 应用层 应用分析\n分析了BCFL在以下领域的应用： 医疗健康 物联网 其他隐私敏感领域 未来方向识别\n识别了BCFL的未来研究方向 综合视角\n本研究旨在提供BCFL系统的全面视角 为BCFL系统领域的未来研究提供基础 七、个人理解 说明：以下是我基于论文内容的理解和思考，并非论文原文\n论文的核心价值 这篇综述的主要价值在于：\n系统性整合：将分散的BCFL研究整合到统一框架中 架构清晰：六层架构为理解BCFL系统提供了清晰的分析框架 全面覆盖：从底层基础设施到上层应用都有涉及 论文的特点 优势：\n文献综述全面，引用了大量相关工作 分类清晰，便于理解不同方法的特点 对各种技术（共识机制、激励机制、隐私保护）都有介绍 可能的不足：\n对各种方案的性能对比分析较少 部分技术介绍较为概念化，实现细节不足 缺少对不同方案适用场景的明确指导 对未来研究的启示 BCFL是一个跨学科领域，需要区块链、机器学习、密码学等多方面知识 不同应用场景可能需要不同的架构选择（完全耦合 vs 灵活耦合 vs 松散耦合） 隐私保护、效率、去中心化程度之间的权衡是核心问题 实际应用还需要考虑工程实现、成本、监管合规等问题 引用 @article{liu2024enhancing, title={Enhancing trust and privacy in distributed networks: a comprehensive survey on blockchain-based federated learning}, author={Liu, Ji and Chen, Chunlu and Li, Yu and Sun, Lin and Song, Yulun and Zhou, Jingbo and Jing, Bo and Dou, Dejing}, journal={Knowledge and Information Systems}, volume={66}, pages={4377--4403}, year={2024}, publisher={Springer} } 阅读日期: 2024年12月14日\n笔记状态: ✅ 完成（严格基于原文）\n建议阅读时间: 30-40分钟\n","permalink":"http://localhost:1313/posts/blockchain-federated-learning-survey/","summary":"本文系统性地综述了区块链联邦学习（BCFL）技术，从架构分类、基础设施层、网络层、通信层、算法层到共识机制进行了深入分析，并探讨了其在医疗、物联网车辆、边缘计算等领域的应用，为构建安全、隐私保护的分布式学习系统提供了理论框架","title":"区块链联邦学习综述：增强分布式网络中的信任与隐私"},{"content":"第一题：线性回归梯度下降 题目： 对线性模型 $h_\\theta(x) = \\theta^\\top x$，给定训练集 $\\{(x^{(i)}, y^{(i)})\\}$，推导其向量形式的最小二乘损失梯度下降更新公式为：\n$$\\theta := \\theta + \\alpha \\sum_{i=1}^{n} (y^{(i)} - h_\\theta(x^{(i)})) x^{(i)}$$解：\n最小二乘损失函数为：\n$$J(\\theta) = \\frac{1}{2}\\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)})^2 = \\frac{1}{2}\\sum_{i=1}^{n}(\\theta^\\top x^{(i)} - y^{(i)})^2$$对 $\\theta$ 求梯度：\n$$\\begin{aligned} \\nabla_\\theta J(\\theta) \u0026= \\sum_{i=1}^{n}(\\theta^\\top x^{(i)} - y^{(i)}) \\cdot x^{(i)} \\\\ \u0026= \\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} \\end{aligned}$$梯度下降更新规则为 $\\theta := \\theta - \\alpha \\nabla_\\theta J(\\theta)$，因此：\n$$\\theta := \\theta - \\alpha \\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} = \\theta + \\alpha \\sum_{i=1}^{n}(y^{(i)} - h_\\theta(x^{(i)})) x^{(i)}$$ 第二题：交叉熵损失梯度 题目： Cross Entropy Loss 定义如下：\n$$l_{ce}((t_1,\\ldots,t_k),y) = -\\log\\left(\\frac{\\exp(t_y)}{\\sum_j \\exp(t_j)}\\right)$$令向量 $t = (t_1,t_2,\\ldots,t_k)$，推导 CEL 对任意 $t_i$ 求导为：\n$$\\frac{\\partial l_{ce}(t,y)}{\\partial t_i} = \\phi_i - \\mathbb{1}\\{y=i\\}$$解：\n记 $\\phi_i = \\frac{\\exp(t_i)}{\\sum_j \\exp(t_j)}$ 为 softmax 函数。\n首先简化损失函数：\n$$l_{ce}(t,y) = -\\log(\\phi_y) = -t_y + \\log\\left(\\sum_j \\exp(t_j)\\right)$$对 $t_i$ 求导：\n$$\\begin{aligned} \\frac{\\partial l_{ce}(t,y)}{\\partial t_i} \u0026= -\\frac{\\partial t_y}{\\partial t_i} + \\frac{\\partial}{\\partial t_i}\\log\\left(\\sum_j \\exp(t_j)\\right) \\\\ \u0026= -\\mathbb{1}\\{y=i\\} + \\frac{\\exp(t_i)}{\\sum_j \\exp(t_j)} \\\\ \u0026= \\phi_i - \\mathbb{1}\\{y=i\\} \\end{aligned}$$其中 $\\mathbb{1}\\{y=i\\}$ 是指示函数，当 $y=i$ 时为1，否则为0。\n第三题：高斯假设下的最大似然估计 题目： 证明在高斯差异假定下，对线性模型 $h_\\theta(x) = \\theta^\\top x$，最大化参数似然 $L(\\theta)$ 等价于最小化二乘损失 $\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2$。\n解：\n假设误差 $\\epsilon^{(i)} = y^{(i)} - \\theta^\\top x^{(i)}$ 服从独立同分布的高斯分布 $\\mathcal{N}(0, \\sigma^2)$，即：\n$$p(\\epsilon^{(i)}) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(\\epsilon^{(i)})^2}{2\\sigma^2}\\right)$$因此：\n$$p(y^{(i)} | x^{(i)}; \\theta) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right)$$似然函数为：\n$$\\begin{aligned} L(\\theta) \u0026= \\prod_{i=1}^{n} p(y^{(i)} | x^{(i)}; \\theta) \\\\ \u0026= \\prod_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right) \\end{aligned}$$对数似然为：\n$$\\begin{aligned} \\log L(\\theta) \u0026= \\sum_{i=1}^{n}\\left[\\log\\frac{1}{\\sqrt{2\\pi}\\sigma} - \\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right] \\\\ \u0026= n\\log\\frac{1}{\\sqrt{2\\pi}\\sigma} - \\frac{1}{2\\sigma^2}\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2 \\end{aligned}$$最大化 $\\log L(\\theta)$ 等价于最小化 $\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2$。\n第四题：Logistic回归的NLL损失 题目： 对Logistic回归模型 $h_\\theta(x) = g(\\theta^\\top x) = \\frac{1}{1+e^{-\\theta^\\top x}}$，推导其在单样本 $(x,y)$ 下的NLL（negative log likelihood）损失，以及损失对特定参数 $\\theta_j$ 的导数为 $(h_\\theta(x) - y)x_j$。\n提示：Logistic回归预测概率的统一形式为 $P(y|x;\\theta) = (h_\\theta(x))^y(1-h_\\theta(x))^{1-y}$\n解：\n根据提示，Logistic回归的概率模型为：\n$$P(y|x;\\theta) = (h_\\theta(x))^y(1-h_\\theta(x))^{1-y}$$其中 $y \\in \\{0,1\\}$，$h_\\theta(x) = g(\\theta^\\top x) = \\frac{1}{1+e^{-\\theta^\\top x}}$。\n对数似然为：\n$$\\log P(y|x;\\theta) = y\\log(h_\\theta(x)) + (1-y)\\log(1-h_\\theta(x))$$NLL损失为：\n$$\\text{NLL}(x,y;\\theta) = -\\log P(y|x;\\theta) = -y\\log(h_\\theta(x)) - (1-y)\\log(1-h_\\theta(x))$$对 $\\theta_j$ 求导。首先注意到：\n$$\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j} = h_\\theta(x)(1-h_\\theta(x)) \\cdot x_j$$这是因为 $g'(z) = g(z)(1-g(z))$。\n因此：\n$$\\begin{aligned} \\frac{\\partial \\text{NLL}}{\\partial \\theta_j} \u0026= -y\\frac{1}{h_\\theta(x)}\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j} - (1-y)\\frac{1}{1-h_\\theta(x)}\\left(-\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j}\\right) \\\\ \u0026= -y\\frac{1}{h_\\theta(x)} \\cdot h_\\theta(x)(1-h_\\theta(x))x_j + (1-y)\\frac{1}{1-h_\\theta(x)} \\cdot h_\\theta(x)(1-h_\\theta(x))x_j \\\\ \u0026= -y(1-h_\\theta(x))x_j + (1-y)h_\\theta(x)x_j \\\\ \u0026= (h_\\theta(x) - y)x_j \\end{aligned}$$ 第五题：Poisson分布的指数族形式 题目： 已知指数分布族定义如下：$p(y;\\eta) = b(y)\\exp(\\eta^\\top y - a(\\eta))$。推导Poisson分布的指数分布族形式，并构建Poisson分布对应的广义线性模型。其中，Poisson分布 $\\text{Pois}(\\lambda)$ 的概率密度函数如下：\n$$P(X=k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}$$解：\n将Poisson分布改写为指数族形式：\n$$\\begin{aligned} P(X=k) \u0026= \\frac{\\lambda^k e^{-\\lambda}}{k!} \\\\ \u0026= \\frac{1}{k!}\\exp(k\\log\\lambda - \\lambda) \\\\ \u0026= \\frac{1}{k!}\\exp(\\eta \\cdot k - e^\\eta) \\end{aligned}$$其中 $\\eta = \\log\\lambda$（自然参数），因此 $\\lambda = e^\\eta$。\n对应指数族形式：\n$b(y) = \\frac{1}{y!}$ $\\eta = \\log\\lambda$ $a(\\eta) = e^\\eta = \\lambda$ $y$ 的充分统计量就是 $y$ 本身 构建广义线性模型：\n假设 $y|x;\\theta \\sim \\text{Pois}(\\lambda)$ 自然参数 $\\eta = \\theta^\\top x$ 因为 $\\lambda = e^\\eta$，所以 $\\lambda = e^{\\theta^\\top x}$ 响应函数（期望）为：$h_\\theta(x) = \\mathbb{E}[y|x;\\theta] = \\lambda = e^{\\theta^\\top x}$ 这就是Poisson回归模型。\n第六题：Shapley值计算 题目： 计算以下3人团队的Shapley值 $\\phi_1$、$\\phi_2$、$\\phi_3$。\n给定：\n$C_{123} = 10000$，$C_0 = 0$ $C_{12} = 7500$，$C_{13} = 7500$，$C_{23} = 5000$ $C_1 = 5000$，$C_2 = 5000$，$C_3 = 0$ 解：\nShapley值的公式为：\n$$\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(|N|-|S|-1)!}{|N|!}[C(S \\cup \\{i\\}) - C(S)]$$对于3人团队，$|N| = 3$，计算每个玩家的边际贡献：\n玩家1的Shapley值：\n$$\\begin{aligned} \\phi_1 \u0026= \\frac{0!2!}{3!}[C_1 - C_0] + \\frac{1!1!}{3!}[C_{12} - C_2] + \\frac{1!1!}{3!}[C_{13} - C_3] + \\frac{2!0!}{3!}[C_{123} - C_{23}] \\\\ \u0026= \\frac{1}{3}[5000 - 0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[7500 - 0] + \\frac{1}{3}[10000 - 5000] \\\\ \u0026= \\frac{5000}{3} + \\frac{2500}{6} + \\frac{7500}{6} + \\frac{5000}{3} \\\\ \u0026= \\frac{10000}{3} + \\frac{10000}{6} = \\frac{20000 + 10000}{6} = 5000 \\end{aligned}$$玩家2的Shapley值：\n$$\\begin{aligned} \\phi_2 \u0026= \\frac{0!2!}{3!}[C_2 - C_0] + \\frac{1!1!}{3!}[C_{12} - C_1] + \\frac{1!1!}{3!}[C_{23} - C_3] + \\frac{2!0!}{3!}[C_{123} - C_{13}] \\\\ \u0026= \\frac{1}{3}[5000 - 0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[5000 - 0] + \\frac{1}{3}[10000 - 7500] \\\\ \u0026= \\frac{5000}{3} + \\frac{2500}{6} + \\frac{5000}{6} + \\frac{2500}{3} \\\\ \u0026= \\frac{15000 + 2500 + 5000 + 5000}{6} = \\frac{27500}{6} \\approx 4583.33 \\end{aligned}$$玩家3的Shapley值：\n由对称性或直接计算：\n$$\\phi_3 = 10000 - \\phi_1 - \\phi_2 = 10000 - 5000 - 4583.33 = 416.67$$或直接计算：\n$$\\begin{aligned} \\phi_3 \u0026= \\frac{1}{3}[0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[5000 - 5000] + \\frac{1}{3}[10000 - 7500] \\\\ \u0026= 0 + \\frac{2500}{6} + 0 + \\frac{2500}{3} = \\frac{5000}{6} \\approx 416.67 \\end{aligned}$$答案： $\\phi_1 = 5000$，$\\phi_2 \\approx 4583.33$，$\\phi_3 \\approx 416.67$\n第七题：协方差矩阵性质 题目： 基于协方差矩阵定义 $\\Sigma = \\text{Cov}(X)$ 证明：\n$\\Sigma$ 为对称矩阵； $\\Sigma$ 半正定，记 $\\Sigma \\geq 0$，即对任意向量 $z \\in \\mathbb{R}^d$ 有 $z^\\top \\Sigma z \\geq 0$。 解：\n设 $X \\in \\mathbb{R}^d$ 为随机向量，$\\mu = \\mathbb{E}[X]$，则：\n$$\\Sigma = \\text{Cov}(X) = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top]$$(1) 证明 $\\Sigma$ 为对称矩阵：\n$$\\Sigma^\\top = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top]^\\top = \\mathbb{E}[((X-\\mu)(X-\\mu)^\\top)^\\top] = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top] = \\Sigma$$因此 $\\Sigma$ 是对称矩阵。\n(2) 证明 $\\Sigma$ 半正定：\n对任意 $z \\in \\mathbb{R}^d$：\n$$\\begin{aligned} z^\\top \\Sigma z \u0026= z^\\top \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top] z \\\\ \u0026= \\mathbb{E}[z^\\top(X-\\mu)(X-\\mu)^\\top z] \\\\ \u0026= \\mathbb{E}[(z^\\top(X-\\mu))^2] \\\\ \u0026\\geq 0 \\end{aligned}$$最后一步是因为期望中的项是平方项，必然非负。因此 $\\Sigma$ 半正定。\n第八题：高斯判别分析的MLE 题目： 对高斯判别分析，已知各变量概率分布为：\n$$\\begin{aligned} p(y) \u0026= \\phi^y(1-\\phi)^{1-y} \\\\ p(x|y=0) \u0026= \\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}\\exp\\left(-\\frac{1}{2}(x-\\mu_0)^\\top\\Sigma^{-1}(x-\\mu_0)\\right) \\\\ p(x|y=1) \u0026= \\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}\\exp\\left(-\\frac{1}{2}(x-\\mu_1)^\\top\\Sigma^{-1}(x-\\mu_1)\\right) \\end{aligned}$$证明在极大似然估计下，参数 $\\phi$、$\\mu_0$、$\\mu_1$ 的形式为：\n$$\\begin{aligned} \\phi \u0026= \\frac{1}{n}\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\} \\\\ \\mu_0 \u0026= \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}} \\\\ \\mu_1 \u0026= \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}} \\end{aligned}$$解：\n对数似然函数为：\n$$\\log L = \\sum_{i=1}^{n}\\left[\\log p(y^{(i)}) + \\log p(x^{(i)}|y^{(i)})\\right]$$估计 $\\phi$：\n$$\\log L_\\phi = \\sum_{i=1}^{n}\\log p(y^{(i)}) = \\sum_{i=1}^{n}[y^{(i)}\\log\\phi + (1-y^{(i)})\\log(1-\\phi)]$$令 $\\frac{\\partial \\log L_\\phi}{\\partial \\phi} = 0$：\n$$\\sum_{i=1}^{n}\\left[\\frac{y^{(i)}}{\\phi} - \\frac{1-y^{(i)}}{1-\\phi}\\right] = 0$$解得：\n$$\\phi = \\frac{1}{n}\\sum_{i=1}^{n}y^{(i)} = \\frac{1}{n}\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}$$估计 $\\mu_0$：\n只考虑 $y=0$ 的样本：\n$$\\log L_{\\mu_0} = \\sum_{i:y^{(i)}=0}\\left[-\\frac{1}{2}(x^{(i)}-\\mu_0)^\\top\\Sigma^{-1}(x^{(i)}-\\mu_0) + \\text{const}\\right]$$令 $\\frac{\\partial \\log L_{\\mu_0}}{\\partial \\mu_0} = 0$：\n$$\\sum_{i:y^{(i)}=0}\\Sigma^{-1}(x^{(i)}-\\mu_0) = 0$$解得：\n$$\\mu_0 = \\frac{\\sum_{i:y^{(i)}=0}x^{(i)}}{\\sum_{i:y^{(i)}=0}1} = \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}}$$同理可得 $\\mu_1$ 的估计。\n第九题：GDA可转化为Logistic回归 题目： 证明GDA可转化为Logistic回归。提示：\n$p(y=1|x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=1)p(y=1) + p(x|y=0)p(y=0)}$ 可记 $r(x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)}$ 给出 $p(x|y=0)$, $p(x|y=1)$, $p(y=1)$ 的表达式 解：\n根据贝叶斯定理：\n$$p(y=1|x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=1)p(y=1) + p(x|y=0)p(y=0)} = \\frac{1}{1 + \\frac{p(x|y=0)p(y=0)}{p(x|y=1)p(y=1)}} = \\frac{1}{1 + \\frac{1}{r(x)}}$$其中：\n$$r(x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)}$$计算 $\\log r(x)$：\n$$\\begin{aligned} \\log r(x) \u0026= \\log p(x|y=1) + \\log p(y=1) - \\log p(x|y=0) - \\log p(y=0) \\\\ \u0026= -\\frac{1}{2}(x-\\mu_1)^\\top\\Sigma^{-1}(x-\\mu_1) + \\frac{1}{2}(x-\\mu_0)^\\top\\Sigma^{-1}(x-\\mu_0) + \\log\\frac{\\phi}{1-\\phi} \\end{aligned}$$展开：\n$$\\begin{aligned} \\log r(x) \u0026= -\\frac{1}{2}x^\\top\\Sigma^{-1}x + x^\\top\\Sigma^{-1}\\mu_1 - \\frac{1}{2}\\mu_1^\\top\\Sigma^{-1}\\mu_1 \\\\ \u0026\\quad + \\frac{1}{2}x^\\top\\Sigma^{-1}x - x^\\top\\Sigma^{-1}\\mu_0 + \\frac{1}{2}\\mu_0^\\top\\Sigma^{-1}\\mu_0 + \\log\\frac{\\phi}{1-\\phi} \\\\ \u0026= x^\\top\\Sigma^{-1}(\\mu_1 - \\mu_0) + \\frac{1}{2}(\\mu_0^\\top\\Sigma^{-1}\\mu_0 - \\mu_1^\\top\\Sigma^{-1}\\mu_1) + \\log\\frac{\\phi}{1-\\phi} \\\\ \u0026= \\theta^\\top x + \\theta_0 \\end{aligned}$$其中：\n$$\\theta = \\Sigma^{-1}(\\mu_1 - \\mu_0), \\quad \\theta_0 = \\frac{1}{2}(\\mu_0^\\top\\Sigma^{-1}\\mu_0 - \\mu_1^\\top\\Sigma^{-1}\\mu_1) + \\log\\frac{\\phi}{1-\\phi}$$因此：\n$$p(y=1|x) = \\frac{1}{1+e^{-\\theta^\\top x - \\theta_0}} = \\frac{1}{1+e^{-\\tilde{\\theta}^\\top \\tilde{x}}}$$这正是Logistic回归的形式（其中 $\\tilde{x}$ 包含截距项）。\n第十题：Kernel Method分析 题目： Kernel method中，若Kernel function $K(x,z) = (x^\\top z + c)^2$，推导对应的feature mapping $\\phi$，并讨论对于 $n$ 个样本一轮SGD，使用Kernel method和在feature map上的计算效率优化比。\n提示：\n基于feature map的参数更新方法为：$\\theta := \\theta + \\alpha\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top\\phi(x^{(i)}))\\phi(x^{(i)})$ Kernel method的参数更新方法为：$\\theta := \\theta + \\alpha(\\tilde{y} - K\\theta)$，其中 $K_j = K(x^{(i)}, x^{(j)})$ 解：\n推导feature mapping：\n对于 $x,z \\in \\mathbb{R}^d$，展开核函数：\n$$\\begin{aligned} K(x,z) \u0026= (x^\\top z + c)^2 \\\\ \u0026= (x_1z_1 + x_2z_2 + \\cdots + x_dz_d + c)^2 \\\\ \u0026= \\sum_{i=1}^{d}x_i^2z_i^2 + \\sum_{i \\neq j}2x_ix_jz_iz_j + 2c\\sum_{i=1}^{d}x_iz_i + c^2 \\end{aligned}$$因此，feature mapping为：\n$$\\phi(x) = (x_1^2, x_2^2, \\ldots, x_d^2, \\sqrt{2}x_1x_2, \\sqrt{2}x_1x_3, \\ldots, \\sqrt{2}x_{d-1}x_d, \\sqrt{2c}x_1, \\ldots, \\sqrt{2c}x_d, c)$$维度为：$d + \\binom{d}{2} + d + 1 = d + \\frac{d(d-1)}{2} + d + 1 = \\frac{d(d+3)}{2} + 1 = O(d^2)$\n计算效率比较：\nFeature map方法： 计算 $\\phi(x^{(i)})$：$O(d^2)$ 每个样本 内积 $\\theta^\\top\\phi(x^{(i)})$：$O(d^2)$ 更新 $\\theta$：$O(d^2)$ 总计：$O(nd^2)$ 每轮SGD Kernel method： 计算核矩阵 $K$：$O(n^2d)$（一次性预计算） 更新参数：$O(n^2)$（矩阵向量乘法） 总计：$O(n^2d + n^2) = O(n^2d)$ 每轮 效率比：\n$$\\frac{\\text{Feature map}}{\\text{Kernel method}} = \\frac{O(nd^2)}{O(n^2d)} = \\frac{d}{n}$$ 当 $n \\ll d$ 时（样本少，特征多），Kernel method更高效 当 $n \\gg d$ 时（样本多，特征少），Feature map方法更高效 第十一题：超平面的函数间隔和几何间隔 题目： 对超平面 $w^\\top x + b = 0$，样本 $x^{(i)}$ 到的函数间隔 $\\hat{\\gamma}^{(i)}$ 与几何间隔 $\\gamma^{(i)}$ 满足何关系？直接给出答案即可。\n解：\n函数间隔定义为：\n$$\\hat{\\gamma}^{(i)} = y^{(i)}(w^\\top x^{(i)} + b)$$几何间隔定义为：\n$\\gamma^{(i)} = \\frac{y^{(i)}(w^\\top x^{(i)} + b)}{|w|} = \\frac{\\hat{\\gamma}^{(i)}}{|w|}$\n关系：\n$\\gamma^{(i)} = \\frac{\\hat{\\gamma}^{(i)}}{|w|}$\n几何间隔是函数间隔除以权重向量的范数，表示点到超平面的真实距离。\n第十二题：SVM的Lagrange函数和对偶形式 题目： 已知SVM的优化目标为：\n$$ \\min_{w,b} \\quad \\frac{1}{2}\\|w\\|^2 \\qquad (1) $$$$ \\text{s.t.} \\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1, \\quad i=1,\\ldots,n $$请构造其Lagrange函数 $\\mathcal{L}(w,b,\\alpha)$。\n已知 $\\mathcal{L}(w,b,\\alpha)$ 满足Slater条件，因此强对偶成立，问题(1)最终可转化为 $\\max_{\\alpha;\\alpha_i\\geq 0}\\min_w \\mathcal{L}(w,b,\\alpha)$，证明该对偶形式问题可进一步转化为：\n$$ \\max_\\alpha W(\\alpha) = \\max_\\alpha \\left(\\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle\\right) \\qquad (2) $$约束条件：\n$$ \\alpha_i \\geq 0, \\quad i=1,\\ldots,n $$$$ \\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0 $$解：\n步骤1：构造Lagrange函数\n$\\mathcal{L}(w,b,\\alpha) = \\frac{1}{2}|w|^2 - \\sum_{i=1}^{n}\\alpha_i[y^{(i)}(w^\\top x^{(i)} + b) - 1]$\n其中 $\\alpha_i \\geq 0$ 为Lagrange乘子。\n步骤2：固定 $\\alpha$，对 $w$ 求导\n$\\frac{\\partial \\mathcal{L}}{\\partial w} = w - \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)} = 0$\n因此：\n$w = \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}$\n步骤3：固定 $\\alpha$，对 $b$ 求导\n$\\frac{\\partial \\mathcal{L}}{\\partial b} = -\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$\n因此：\n$\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$\n步骤4：代入Lagrange函数\n将 $w = \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}$ 代入 $\\mathcal{L}$：\n$\\begin{aligned} \\mathcal{L}(w,b,\\alpha) \u0026= \\frac{1}{2}w^\\top w - \\sum_{i=1}^{n}\\alpha_i y^{(i)} w^\\top x^{(i)} - b\\sum_{i=1}^{n}\\alpha_i y^{(i)} + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\frac{1}{2}\\left(\\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}\\right)^\\top\\left(\\sum_{j=1}^{n}\\alpha_j y^{(j)} x^{(j)}\\right) - \\sum_{i=1}^{n}\\alpha_i y^{(i)} \\left(\\sum_{j=1}^{n}\\alpha_j y^{(j)} x^{(j)}\\right)^\\top x^{(i)} + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle - \\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle \\end{aligned}$\n其中使用了 $\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$，所以 $b$ 项消失。\n因此对偶问题为：\n$\\max_\\alpha W(\\alpha) = \\max_\\alpha \\left(\\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle\\right)$\n约束条件为：\n$\\begin{aligned} \\alpha_i \u0026\\geq 0, \\quad i=1,\\ldots,n \\\\ \\sum_{i=1}^{n}\\alpha_i y^{(i)} \u0026= 0 \\end{aligned}$\n第十三题：线性不可分的SVM与L1正则 题目： 对线性不可分的训练集，SVM对应带L1正则的优化目标是什么？已知对线性可分情况的优化为：\n$$ \\min_{w,b} \\quad \\frac{1}{2}\\|w\\|^2 \\qquad (1) $$ $$ \\text{s.t.} \\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1, \\quad i=1,\\ldots,n $$解：\n对于线性不可分的情况，引入松弛变量 $\\xi_i \\geq 0$，允许某些样本违反间隔约束。\n带L1正则的软间隔SVM优化目标为：\n$\\begin{aligned} \\min_{w,b,\\xi} \u0026\\quad \\frac{1}{2}|w|^2 + C\\sum_{i=1}^{n}\\xi_i \\\\ \\text{s.t.} \u0026\\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1 - \\xi_i, \\quad i=1,\\ldots,n \\\\ \u0026\\quad \\xi_i \\geq 0, \\quad i=1,\\ldots,n \\end{aligned}$\n其中：\n$\\xi_i$ 是松弛变量，表示样本 $i$ 违反间隔的程度 $C \u003e 0$ 是惩罚参数，控制间隔最大化与违反程度之间的权衡 $C\\sum_{i=1}^{n}\\xi_i$ 是L1正则项（对松弛变量的惩罚） 这个目标函数平衡了两个目标：\n最大化间隔（通过最小化 $|w|^2$） 最小化分类错误（通过最小化 $\\sum\\xi_i$） 第十四题：SVM最优化问题分析 题目： 已知SVM的最终优化目标为：\n$W(\\alpha) = \\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle$\n假设此时正在优化 $\\alpha_1$ 与 $\\alpha_2$，并有 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$。请推导此时 $\\alpha_2$ 应当更新的值。\n解：\n简化目标函数：\n在固定其他 $\\alpha_i$ ($i \\geq 3$) 的情况下，目标函数关于 $\\alpha_1, \\alpha_2$ 可写为：\n$W(\\alpha_1, \\alpha_2) = \\alpha_1 + \\alpha_2 + W_0 - \\frac{1}{2}[K_{11}\\alpha_1^2 + K_{22}\\alpha_2^2 + 2K_{12}\\alpha_1\\alpha_2y^{(1)}y^{(2)}] + \\text{线性项}$\n其中 $K_{ij} = \\langle x^{(i)}, x^{(j)}\\rangle$，$W_0$ 是常数项。\n利用约束 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$：\n这个约束来自 $\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$，可以改写为：\n$\\alpha_1 y^{(1)} + \\alpha_2 y^{(2)} = -\\sum_{i=3}^{n}\\alpha_i y^{(i)} = \\zeta \\quad \\text{（常数）}$\n将 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$ 代入目标函数，得到关于 $\\alpha_2$ 的单变量优化问题。\n对 $\\alpha_2$ 求导并令其为0，经过复杂推导（涉及预测误差），得到 $\\alpha_2$ 的无约束最优解：\n$\\alpha_2^{\\text{new, unc}} = \\alpha_2^{\\text{old}} + \\frac{y^{(2)}(E_1 - E_2)}{\\eta}$\n其中：\n$E_i = f(x^{(i)}) - y^{(i)}$ 是预测误差 $\\eta = K_{11} + K_{22} - 2K_{12} = \\|x^{(1)} - x^{(2)}\\|^2$（特征空间距离） 考虑约束 $0 \\leq \\alpha_2 \\leq C$：\n根据约束 $\\alpha_1 y^{(1)} + \\alpha_2 y^{(2)} = \\zeta$：\n若 $y^{(1)} \\neq y^{(2)}$： $L = \\max(0, \\alpha_2^{\\text{old}} - \\alpha_1^{\\text{old}}), \\quad H = \\min(C, C + \\alpha_2^{\\text{old}} - \\alpha_1^{\\text{old}})$ 若 $y^{(1)} = y^{(2)}$： $L = \\max(0, \\alpha_1^{\\text{old}} + \\alpha_2^{\\text{old}} - C), \\quad H = \\min(C, \\alpha_1^{\\text{old}} + \\alpha_2^{\\text{old}})$ 最终更新公式：\n$\\alpha_2^{\\text{new}} = \\begin{cases} H \u0026 \\text{if } \\alpha_2^{\\text{new, unc}} \u003e H \\\\ \\alpha_2^{\\text{new, unc}} \u0026 \\text{if } L \\leq \\alpha_2^{\\text{new, unc}} \\leq H \\\\ L \u0026 \\text{if } \\alpha_2^{\\text{new, unc}} \u003c L \\end{cases}$\n然后通过约束更新 $\\alpha_1$：\n$\\alpha_1^{\\text{new}} = \\alpha_1^{\\text{old}} + y^{(1)}y^{(2)}(\\alpha_2^{\\text{old}} - \\alpha_2^{\\text{new}})$\n第十五题：信息增益比计算 题目： 计算给定数据集中四个特征的信息增益比。可保留log项，统一底数为2。\n解：\n首先计算数据集的熵。类别分布：否=6，是=9，总计15。\n$H(D) = -\\frac{6}{15}\\log_2\\frac{6}{15} - \\frac{9}{15}\\log_2\\frac{9}{15} = -0.4\\log_2(0.4) - 0.6\\log_2(0.6) = 0.971$\n特征1：年龄 青年(5个)：否=3，是=2，$H = 0.971$ 中年(5个)：否=1，是=4，$H = 0.722$ 老年(5个)：否=2，是=3，$H = 0.971$ 条件熵：\n$H(D|\\text{年龄}) = \\frac{5}{15}(0.971) + \\frac{5}{15}(0.722) + \\frac{5}{15}(0.971) = 0.888$\n信息增益：\n$\\text{Gain}(\\text{年龄}) = 0.971 - 0.888 = 0.083$\n特征熵（分裂信息）：\n$H_A(\\text{年龄}) = -3 \\times \\frac{5}{15}\\log_2\\frac{5}{15} = \\log_2 3 = 1.585$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{年龄}) = \\frac{0.083}{1.585} = 0.052 $$特征2：有工作 否(8个)：否=4，是=4，$H = 1.0$ 是(7个)：否=2，是=5，$H = 0.863$ 条件熵：$H(D|\\text{有工作}) = 0.936$\n信息增益：$\\text{Gain}(\\text{有工作}) = 0.035$\n特征熵：$H_A(\\text{有工作}) = 0.997$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{有工作}) = 0.035 $$特征3：有自己的房子 否(9个)：否=3，是=6，$H = 0.918$ 是(6个)：否=3，是=3，$H = 1.0$ 条件熵：$H(D|\\text{有房}) = 0.951$\n信息增益：$\\text{Gain}(\\text{有房}) = 0.020$\n特征熵：$H_A(\\text{有房}) = 0.971$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{有房}) = 0.021 $$特征4：信贷情况 一般(5个)：否=4，是=1，$H = 0.722$ 好(6个)：否=2，是=4，$H = 0.918$ 非常好(4个)：否=0，是=4，$H = 0$ 条件熵：$H(D|\\text{信贷}) = 0.608$\n信息增益：$\\text{Gain}(\\text{信贷}) = 0.363$\n特征熵：$H_A(\\text{信贷}) = 1.557$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{信贷}) = 0.233 $$总结（信息增益比排序） 信贷情况：0.233 ⭐（最佳分裂特征） 年龄：0.052 有工作：0.035 有自己的房子：0.021 应选择\u0026quot;信贷情况\u0026quot;作为根节点的分裂特征。\n第十六题：XGBoost损失函数二阶泰勒展开 题目： 已知XGBoost优化第t棵树时的损失函数为：\n$\\mathcal{L}^{(t)} = \\sum_{i=1}^{n}l(y_i, \\hat{y}*i^{(t-1)} + f_t(x_i)) + \\gamma T + \\frac{1}{2}\\lambda\\sum*{j=1}^{T}w_j^2$\n请推导 $l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i))$ 在 $l(y_i, \\hat{y}_i^{(t-1)})$ 处对于 $f_t(x_i)$ 的二阶泰勒展开。其中，一阶和二阶导数可使用：\n$g_i = \\frac{\\partial l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i}\\Big|*{\\hat{y}_i^{(t-1)}}, \\quad h_i = \\frac{\\partial^2 l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i^2}\\Big|*{\\hat{y}_i^{(t-1)}}$\n在此基础上，推导叶子节点 $j$ 对应的 $w_j^*$ 满足：\n$w_j^* = -\\frac{\\sum_{i \\in \\mathcal{I}*j}g_i}{\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda}$\n其中，$\\mathcal{I}_j = \\{i \\mid q(x_i) = j\\}$ 表示属于叶子节点 $j$ 的样本集合。\n解：\n二阶泰勒展开 在 $\\hat{y}_i^{(t-1)}$ 处对 $l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i))$ 关于 $f_t(x_i)$ 进行二阶泰勒展开：\n$\\begin{aligned} l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i)) \u0026\\approx l(y_i, \\hat{y}_i^{(t-1)}) + \\frac{\\partial l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i}\\Big|*{\\hat{y}_i^{(t-1)}} \\cdot f_t(x_i) \\\\ \u0026\\quad + \\frac{1}{2}\\frac{\\partial^2 l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i^2}\\Big|*{\\hat{y}_i^{(t-1)}} \\cdot f_t(x_i)^2 \\\\ \u0026= l(y_i, \\hat{y}_i^{(t-1)}) + g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2 \\end{aligned}$\n因此损失函数变为：\n$\\mathcal{L}^{(t)} \\approx \\sum_{i=1}^{n}[l(y_i, \\hat{y}*i^{(t-1)}) + g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2] + \\gamma T + \\frac{1}{2}\\lambda\\sum*{j=1}^{T}w_j^2$\n去掉常数项 $\\sum_{i=1}^{n}l(y_i, \\hat{y}_i^{(t-1)})$：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{i=1}^{n}[g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2] + \\gamma T + \\frac{1}{2}\\lambda\\sum_{j=1}^{T}w_j^2$\n推导叶子权重 $w_j^*$ 对于树模型，$f_t(x_i) = w_{q(x_i)}$，其中 $q(x_i)$ 表示样本 $i$ 落在的叶子节点。\n将样本按叶子节点分组：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{j=1}^{T}\\left[\\left(\\sum_{i \\in \\mathcal{I}*j}g_i\\right)w_j + \\frac{1}{2}\\left(\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda\\right)w_j^2\\right] + \\gamma T$\n记 $G_j = \\sum_{i \\in \\mathcal{I}*j}g_i$，$H_j = \\sum*{i \\in \\mathcal{I}_j}h_i$，则：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{j=1}^{T}\\left[G_j w_j + \\frac{1}{2}(H_j + \\lambda)w_j^2\\right] + \\gamma T$\n对 $w_j$ 求导并令其为0：\n$\\frac{\\partial \\tilde{\\mathcal{L}}^{(t)}}{\\partial w_j} = G_j + (H_j + \\lambda)w_j = 0$\n解得：\n$w_j^* = -\\frac{G_j}{H_j + \\lambda} = -\\frac{\\sum_{i \\in \\mathcal{I}*j}g_i}{\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda}$\n这就是叶子节点的最优权重。将其代入损失函数，得到：\n$\\tilde{\\mathcal{L}}^{(t)} = -\\frac{1}{2}\\sum_{j=1}^{T}\\frac{G_j^2}{H_j + \\lambda} + \\gamma T$\n这个公式用于评估树结构的质量，指导分裂决策。\n","permalink":"http://localhost:1313/posts/ml-exercise-set/","summary":"胡老师上的机器学习课程习题集解答汇总","title":"机器学习习题集"},{"content":"前言 四川麻将，又称成都麻将或血战麻将，是中国最流行的麻将玩法之一。与传统麻将相比，四川麻将节奏快、变化多，充满了刺激性和趣味性。本文将带你从零开始，系统学习四川麻将的规则和技巧。\n一、基础规则入门 1.1 牌面组成 四川麻将使用108张牌，包括：\n万子：一万到九万，各4张（36张） 条子：一条到九条，各4张（36张） 筒子：一筒到九筒，各4张（36张） 注意：四川麻将没有东南西北中发白这些字牌和花牌。\n1.2 基本概念 刻子：三张相同的牌（如：三张五万） 顺子：三张连续的同花色牌（如：三四五条） 对子：两张相同的牌（如：两张八筒） 杠：四张相同的牌\n1.3 胡牌基本型 标准胡牌牌型：3n+2 结构（n个刻子或顺子 + 1个对子）\n例如：\n一一一 + 二三四 + 五六七 + 八八八 + 九九（4组3张+1对） 1.4 游戏流程 定庄：掷骰子决定庄家 配牌：每人抓13张牌，庄家多抓一张（14张） 出牌：庄家先出一张牌，其他玩家依次摸牌、出牌 胡牌：谁先凑齐胡牌牌型谁获胜 血战到底：已胡牌的玩家退出，剩余玩家继续游戏，直到3人胡牌或流局 二、四川麻将特色规则 2.1 缺一门 四川麻将的核心规则：必须缺一门才能胡牌\n也就是说，你的手牌中只能有两种花色（万、条、筒三选二）。\n例如：\n✅ 可以胡：万子+条子（缺筒） ✅ 可以胡：万子+筒子（缺条） ❌ 不能胡：万子+条子+筒子（三门齐全） 2.2 杠牌规则 明杠：\n碰牌后，再摸到第四张，可以杠牌 别人打出的牌，自己有三张，可以直接杠 暗杠：\n自己摸到四张相同的牌，可以暗杠 杠牌后：\n摸一张牌 多算一番（底分×2） 杠后可以继续杠或胡牌 2.3 血战到底 这是四川麻将最大的特色：\n第一个人胡牌后不结束游戏 剩余三人继续打，直到有第二、第三个人胡牌 最后没胡的人要赔给所有胡牌的人 第一个胡牌的人可以继续胡（查叫） 2.4 查叫 游戏结束时，如果有人没胡牌：\n如果他已听牌（只差一张就能胡），他只赔给胡牌的人 如果他未听牌（没有听牌），他要加倍赔偿 三、番型与计分 3.1 基础番型 番型 番数 说明 平胡 1番 基础胡牌 自摸 1番 自己摸牌胡 根（杠） 1番 每杠一次+1番 对对胡 2番 全是刻子+对子，没有顺子 清一色 4番 全部是一种花色 龙七对 4番 七个对子 天胡 封顶 庄家起手就胡 地胡 封顶 闲家第一轮胡 3.2 计分方式 基础公式：底分 × 2^(番数)\n例如：\n底分1元，平胡（1番）= 1×2¹ = 2元 底分1元，清一色（4番）= 1×2⁴ = 16元 底分1元，清一色+对对胡（6番）= 1×2⁶ = 64元 封顶：很多地方设置封顶番数（如10番），防止输赢过大\n四、进阶技巧 4.1 定缺策略 游戏开始后，要快速决定缺哪一门：\n判断依据：\n数量最少的门：哪门牌少就缺哪门 孤张多的门：有很多不连续的孤张，这门不好组合 对子情况：如果某门有对子，考虑留下，可能组成刻子 例子：\n手牌：一万 三万 五万 六万 | 二条 七条 | 一筒 二筒 三筒 四筒 八筒 九筒 分析：万子4张分散，条子2张，筒子6张且有顺子潜力 建议：缺条子 4.2 听牌技巧 多面听优于单钓：\n单钓：只有一种牌能胡（如：等一张五万） 两面听：能胡两种牌（如：三四条，等二条或五条） 多面听：能胡多种牌（如：卡张、边张、对子等组合） 例子：\n手牌：一万 二万 | 三万 四万 | 五万 六万 | 七万 八万 | 九万 拆牌选择： - 打九万：听二万和五万（两面） - 打一万：听三万和六万和九万（多面） 建议打一万，听牌面更多 4.3 防守策略 观察舍牌：\n对手打出的牌反映他要什么、不要什么 如果对手大量打某一门，可能在做清一色 如果对手突然不打某种牌，可能在攒那个牌 生张和熟张：\n生张：桌面上没出现过的牌，危险度较高 熟张：已经有人打过的牌，相对安全 听牌信号：\n出牌犹豫 打牌速度突然变化 开始打生张或中张 4.4 做大牌策略 什么时候做大牌：\n起手牌型好（比如某门很多，可以做清一色） 当前领先或持平，可以冒险 对手没有明显听牌迹象 做大牌风险：\n听牌较慢，容易被别人截胡 如果未听牌查叫，要加倍赔偿 建议新手以稳为主，先保证听牌 4.5 心理战术 诱敌出牌：\n故意打出中张，引诱对手出你需要的牌 注意节奏，不要过于明显 藏牌意图：\n不要急于碰牌或杠牌，暴露自己的牌型 暗刻比明刻更有迷惑性 施压策略：\n快速出牌，给对手压力 适当沉默，让对手摸不清你的意图 五、常见错误与避免 5.1 新手常犯错误 忘记缺门：手牌三门齐全还以为能胡 盲目做大牌：不顾牌型强行做清一色，最后未听牌 不会算番：不知道自己多少番，糊里糊涂胡牌 乱碰乱杠：过早暴露牌型，让对手防范 不看舍牌：只顾自己手牌，不观察对手 5.2 进阶常犯错误 过度防守：太在意对手，错失自己的听牌机会 贪大求全：总想胡大牌，反而听牌慢 不会放弃：明知牌型不好还死撑，最后查叫 心态失衡：连续点炮后急躁，决策失误 六、实战案例分析 案例1：定缺选择 起手牌：\n二万 四万 六万 八万 九万 一条 二条 三条 五筒 六筒 七筒 八筒 分析：\n万子：5张但分散，不易组合 条子：3张成顺，很好 筒子：4张有两个顺子潜力 决策：缺万子，保留条筒两门\n案例2：听牌选择 当前牌型：\n二万 三万 四万 | 五万 六万 七万 | 一条 二条 三条 | 五筒 六筒 | 八筒 八筒 选择1：打五筒或六筒，听七筒（单钓） 选择2：打八筒，听四筒或七筒（两面）\n决策：选择2更优，两面听更容易胡牌\n案例3：要不要做清一色 当前牌型（已缺条）：\n一万 二万 三万 四万 五万 六万 | 二筒 五筒 七筒 | 八筒 八筒 分析：\n距离清一色还差3张筒子替换万子 如果做清一色，需要拆掉现有的顺子 当前可以快速听牌（1-2轮） 决策：不做清一色，保证快速听牌，除非后续摸牌特别好\n七、练习建议 7.1 新手阶段 熟悉规则：先玩小局，熟悉缺门、血战等规则 记住番型：至少记住基础番型和分数 多观察：看别人怎么打，学习经验 求稳为主：不要急于做大牌，先学会稳定胡牌 7.2 进阶阶段 提高速度：加快判断和决策速度 学习算牌：记住哪些牌出过，推测剩余牌 心理博弈：学会观察对手，做出针对性策略 复盘总结：每局结束后思考得失 7.3 推荐练习方式 线上平台：在手机或电脑上玩四川麻将游戏，方便练习 观战学习：看高手直播或录像，学习思路 实战练习：找朋友线下对局，积累实战经验 理论学习：阅读麻将书籍或教程，系统提升 八、总结 四川麻将规则简单但策略丰富，从新手到高手需要：\n扎实的基本功：熟练掌握规则和番型 灵活的战术：根据牌型和局势调整策略 敏锐的观察力：读懂对手意图，做出正确判断 稳定的心态：胜不骄败不馁，理性决策 记住：麻将三分靠运气，七分靠技术。多练习、多思考，你一定能成为四川麻将高手！\n祝你好运，胡牌多多！🀄\n","permalink":"http://localhost:1313/posts/sichuan-mahjong-guide/","summary":"四川麻将完全攻略：从基础规则到高阶技巧，涵盖缺一门、血战到底、番型计分、定缺策略、听牌技巧、防守要点和实战案例分析。无论你是零基础| 新手还是想提升的进阶玩家，这篇指南都能帮你系统掌握四川麻将的精髓，快速从入门到精通。","title":"四川麻将指南"},{"content":"Windows PowerShell 常用指令 文件和目录操作 列出目录内容\nGet-ChildItem / ls - 列出当前目录内容 ls -Force - 显示隐藏文件 ls -Recurse - 递归列出所有子目录 ls | Sort-Object Length -Descending - 按文件大小排序 切换目录\nSet-Location \u0026lt;路径\u0026gt; / cd - 切换目录 cd ~ - 返回用户主目录 cd .. - 返回上级目录 cd - - 返回上一个目录 创建文件和目录\nNew-Item -ItemType Directory \u0026lt;名称\u0026gt; / mkdir - 创建目录 New-Item -ItemType File \u0026lt;名称\u0026gt; / ni - 创建文件 复制、移动和删除\nCopy-Item \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; 复制文件\nMove-Item \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; / mv - 移动/重命名文件\nRemove-Item \u0026lt;路径\u0026gt; 删除文件\n查看文件\nGet-Content \u0026lt;文件\u0026gt; / cat - 查看文件内容 Get-Content \u0026lt;文件\u0026gt; -Tail 10 - 查看最后 10 行 Get-Content \u0026lt;文件\u0026gt; -Wait - 实时查看文件更新（类似 tail -f） Test-Path \u0026lt;路径\u0026gt; - 检查路径是否存在 以默认方式打开文件或目录\nstart filename打开当前目录下的指定文件 code filename使用vscode打开 code .使用vscode打开当前目录 文本处理和搜索 Select-String \u0026lt;模式\u0026gt; \u0026lt;文件\u0026gt; - 在文件中搜索文本（类似 grep） Select-String \u0026quot;error\u0026quot; *.log - 在所有 log 文件中搜索 ls -Recurse | Select-String \u0026quot;TODO\u0026quot; - 递归搜索 Out-File \u0026lt;文件\u0026gt; - 输出重定向到文件 Tee-Object \u0026lt;文件\u0026gt; - 同时输出到控制台和文件 系统信息和管理 进程管理\nGet-Process / ps - 查看进程列表 Get-Process | Sort-Object CPU -Descending | Select-Object -First 5 - CPU 占用最高的 5 个进程 Stop-Process -Name \u0026lt;进程名\u0026gt; - 结束进程 服务管理\nGet-Service - 查看服务列表 Get-Service | Where-Object {$_.Status -eq \u0026quot;Running\u0026quot;} - 只显示运行中的服务 Start-Service \u0026lt;服务名\u0026gt; - 启动服务 Stop-Service \u0026lt;服务名\u0026gt; - 停止服务 系统信息\nGet-ComputerInfo - 查看计算机信息 Get-NetIPAddress - 查看网络配置 Get-Disk - 查看磁盘信息 Get-Volume - 查看卷信息 systeminfo - 显示详细系统信息 环境变量 $env:PATH - 查看 PATH 环境变量 $env:变量名 = \u0026quot;值\u0026quot; - 设置临时环境变量 [Environment]::SetEnvironmentVariable(\u0026quot;变量名\u0026quot;, \u0026quot;值\u0026quot;, \u0026quot;User\u0026quot;) - 永久设置 网络操作 Test-Connection \u0026lt;主机\u0026gt; / ping - 测试网络连接 Invoke-WebRequest \u0026lt;URL\u0026gt; / curl - 发送 HTTP 请求 Invoke-WebRequest -Uri \u0026lt;URL\u0026gt; -OutFile \u0026lt;文件\u0026gt; - 下载文件 Get-NetTCPConnection - 查看 TCP 连接 ipconfig - 查看 IP 配置 ipconfig /flushdns - 刷新 DNS 缓存 实用命令 Clear-Host / cls - 清屏 Get-History / history - 查看命令历史 Get-Help \u0026lt;命令\u0026gt; - 获取帮助 Get-Help \u0026lt;命令\u0026gt; -Examples - 查看使用示例 Get-Command - 列出所有可用命令 Get-Command *process* - 搜索包含 process 的命令 Get-Alias - 查看所有别名 Measure-Object - 统计对象 Start-Process \u0026lt;程序\u0026gt; - 启动程序 Get-Location / pwd - 显示当前路径 Linux Terminal 常用指令 文件和目录操作 列出目录\nls - 列出目录内容 ls -l - 长格式显示（详细信息） ls -a - 显示隐藏文件 ls -lh - 人性化显示文件大小 ls -lt - 按修改时间排序 ls -lS - 按文件大小排序 ls -R - 递归列出所有子目录 切换目录\ncd \u0026lt;路径\u0026gt; - 切换目录 cd / cd ~ - 返回主目录 cd .. - 返回上级目录 cd - - 返回上一个目录 pwd - 显示当前完整路径 创建\nmkdir \u0026lt;目录名\u0026gt; - 创建目录 mkdir -p a/b/c - 递归创建多级目录 touch \u0026lt;文件名\u0026gt; - 创建空文件或更新时间戳 复制、移动和删除\ncp \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 复制文件 cp -r \u0026lt;源目录\u0026gt; \u0026lt;目标\u0026gt; - 递归复制目录 cp -i \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 交互式复制（覆盖前询问） mv \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 移动/重命名文件 rm \u0026lt;文件\u0026gt; - 删除文件 rm -r \u0026lt;目录\u0026gt; - 递归删除目录 rm -f \u0026lt;文件\u0026gt; - 强制删除 rm -rf \u0026lt;目录\u0026gt; - 强制递归删除（危险！） rm -i \u0026lt;文件\u0026gt; - 交互式删除（推荐） 链接\nln -s \u0026lt;源\u0026gt; \u0026lt;链接名\u0026gt; - 创建符号链接 readlink -f \u0026lt;链接\u0026gt; - 查看链接目标 文件查看和编辑 查看文件\ncat \u0026lt;文件\u0026gt; - 显示文件内容 cat -n \u0026lt;文件\u0026gt; - 显示行号 less \u0026lt;文件\u0026gt; - 分页查看（可前后翻页） more \u0026lt;文件\u0026gt; - 分页查看（只能向前） head \u0026lt;文件\u0026gt; - 查看文件开头 head -n 20 \u0026lt;文件\u0026gt; - 查看前 20 行 tail \u0026lt;文件\u0026gt; - 查看文件末尾 tail -n 20 \u0026lt;文件\u0026gt; - 查看最后 20 行 tail -f \u0026lt;文件\u0026gt; - 实时查看文件更新 tail -f \u0026lt;文件\u0026gt; | grep \u0026quot;error\u0026quot; - 实时过滤查看 编辑文件\nnano \u0026lt;文件\u0026gt; - 简单文本编辑器 vim \u0026lt;文件\u0026gt; / vi \u0026lt;文件\u0026gt; - 强大的文本编辑器 统计文件\nwc \u0026lt;文件\u0026gt; - 统计文件 wc -l \u0026lt;文件\u0026gt; - 统计行数 wc -w \u0026lt;文件\u0026gt; - 统计单词数 wc -c \u0026lt;文件\u0026gt; - 统计字节数 文件搜索和查找 find 命令\nfind \u0026lt;路径\u0026gt; -name \u0026lt;名称\u0026gt; - 按名称查找 find . -name \u0026quot;*.txt\u0026quot; - 查找所有 txt 文件 find . -type f -name \u0026quot;*.log\u0026quot; - 查找文件（不含目录） find . -type d -name \u0026quot;node_modules\u0026quot; - 查找目录 find . -mtime -7 - 查找 7 天内修改的文件 find . -size +100M - 查找大于 100MB 的文件 find . -name \u0026quot;*.tmp\u0026quot; -delete - 查找并删除 grep 命令\ngrep \u0026lt;模式\u0026gt; \u0026lt;文件\u0026gt; - 搜索文本 grep -r \u0026quot;TODO\u0026quot; . - 递归搜索当前目录 grep -i \u0026quot;error\u0026quot; log.txt - 忽略大小写 grep -n \u0026quot;function\u0026quot; code.js - 显示行号 grep -v \u0026quot;debug\u0026quot; log.txt - 反向匹配（不包含） grep -E \u0026quot;error|warning\u0026quot; log.txt - 使用正则表达式 grep -c \u0026quot;error\u0026quot; log.txt - 统计匹配行数 其他查找工具\nlocate \u0026lt;文件名\u0026gt; - 快速查找文件 updatedb - 更新 locate 数据库 which \u0026lt;命令\u0026gt; - 查找命令位置 whereis \u0026lt;程序\u0026gt; - 查找程序位置 文件权限 chmod \u0026lt;权限\u0026gt; \u0026lt;文件\u0026gt; - 修改文件权限 chmod 755 script.sh - 数字方式（rwxr-xr-x） chmod +x script.sh - 添加执行权限 chmod -R 644 directory/ - 递归修改 chown \u0026lt;用户\u0026gt;:\u0026lt;组\u0026gt; \u0026lt;文件\u0026gt; - 修改所有者 chgrp \u0026lt;组\u0026gt; \u0026lt;文件\u0026gt; - 修改所属组 umask - 查看或设置默认权限掩码 进程管理 查看进程\nps - 查看进程 ps aux - 查看所有进程详细信息 ps -ef - 另一种格式 ps aux | grep \u0026lt;进程名\u0026gt; - 搜索特定进程 top - 实时查看系统资源（按 q 退出） htop - 增强版 top 管理进程\nkill \u0026lt;PID\u0026gt; - 结束进程 kill -9 \u0026lt;PID\u0026gt; - 强制结束 killall \u0026lt;进程名\u0026gt; - 按名称结束进程 pkill \u0026lt;进程名\u0026gt; - 按模式匹配结束 bg - 将任务放到后台 fg - 将后台任务调到前台 jobs - 查看后台任务 nohup \u0026lt;命令\u0026gt; \u0026amp; - 后台运行，不受终端关闭影响 磁盘和存储 df -h - 查看磁盘使用情况 du -sh \u0026lt;目录\u0026gt; - 查看目录大小 du -h --max-depth=1 - 查看各子目录大小 du -sh * | sort -h - 按大小排序 free -h - 查看内存使用 lsblk - 列出块设备 mount - 挂载文件系统 umount - 卸载文件系统 系统信息 uname -a - 完整系统信息 uname -r - 内核版本 hostname - 主机名 whoami - 当前用户 id - 用户 ID 和组 ID uptime - 系统运行时间和负载 date - 系统时间 cal - 日历 lsb_release -a - Linux 发行版信息（Ubuntu/Debian） cat /etc/os-release - 系统版本信息 网络操作 连接测试\nping \u0026lt;地址\u0026gt; - 测试网络连接 ping -c 4 google.com - 发送 4 个包后停止 traceroute \u0026lt;地址\u0026gt; - 追踪路由路径 文件传输\ncurl \u0026lt;URL\u0026gt; - 发送 HTTP 请求 curl -O \u0026lt;URL\u0026gt; - 下载文件（保持原文件名） curl -o \u0026lt;文件名\u0026gt; \u0026lt;URL\u0026gt; - 下载并重命名 curl -I \u0026lt;URL\u0026gt; - 只获取 HTTP 头 curl -X POST -d \u0026quot;data\u0026quot; \u0026lt;URL\u0026gt; - 发送 POST 请求 wget \u0026lt;URL\u0026gt; - 下载文件 wget -c \u0026lt;URL\u0026gt; - 断点续传 远程连接\nssh \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt; - SSH 连接 ssh -p \u0026lt;端口\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt; - 指定端口 scp \u0026lt;源\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt;:\u0026lt;目标\u0026gt; - 安全复制文件 scp -r \u0026lt;目录\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt;:\u0026lt;目标\u0026gt; - 复制目录 网络信息\nnetstat -tuln - 查看网络端口（传统） ss -tuln - 查看网络端口（现代） ip addr / ifconfig - 查看网络接口 nslookup \u0026lt;域名\u0026gt; - DNS 查询 dig \u0026lt;域名\u0026gt; - DNS 详细查询 压缩和解压 tar 格式\ntar -czf \u0026lt;文件.tar.gz\u0026gt; \u0026lt;目录\u0026gt; - 压缩为 tar.gz tar -xzf \u0026lt;文件.tar.gz\u0026gt; - 解压 tar.gz tar -xzf \u0026lt;文件.tar.gz\u0026gt; -C \u0026lt;目标目录\u0026gt; - 解压到指定目录 tar -tvf \u0026lt;文件.tar.gz\u0026gt; - 查看压缩包内容 zip 格式\nzip -r \u0026lt;文件.zip\u0026gt; \u0026lt;目录\u0026gt; - 创建 zip 压缩包 unzip \u0026lt;文件.zip\u0026gt; - 解压 zip unzip \u0026lt;文件.zip\u0026gt; -d \u0026lt;目标目录\u0026gt; - 解压到指定目录 gzip 格式\ngzip \u0026lt;文件\u0026gt; - 压缩为 .gz gunzip \u0026lt;文件.gz\u0026gt; - 解压 .gz 文本处理工具 sed（流编辑器）\nsed 's/old/new/g' file.txt - 替换文本 sed -i 's/old/new/g' file.txt - 直接修改文件 awk（文本处理）\nawk '{print $1}' file.txt - 打印第一列 awk -F',' '{print $2}' file.csv - 指定分隔符 排序和去重\nsort \u0026lt;文件\u0026gt; - 排序 sort -r \u0026lt;文件\u0026gt; - 反向排序 sort -n \u0026lt;文件\u0026gt; - 按数字排序 uniq \u0026lt;文件\u0026gt; - 去除重复行 sort file.txt | uniq - 配合使用 uniq -c \u0026lt;文件\u0026gt; - 统计重复次数 其他工具\ncut -d',' -f1,3 file.csv - 按分隔符提取列 tr 'a-z' 'A-Z' \u0026lt; file.txt - 字符转换 系统管理 用户管理\nsudo \u0026lt;命令\u0026gt; - 以管理员权限执行 su - 切换用户 su - - 切换到 root passwd - 修改密码 useradd \u0026lt;用户名\u0026gt; - 创建用户 userdel \u0026lt;用户名\u0026gt; - 删除用户 usermod -aG \u0026lt;组\u0026gt; \u0026lt;用户\u0026gt; - 添加用户到组 服务管理（systemd）\nsystemctl start \u0026lt;服务\u0026gt; - 启动服务 systemctl stop \u0026lt;服务\u0026gt; - 停止服务 systemctl restart \u0026lt;服务\u0026gt; - 重启服务 systemctl status \u0026lt;服务\u0026gt; - 查看状态 systemctl enable \u0026lt;服务\u0026gt; - 设置开机启动 journalctl -u \u0026lt;服务\u0026gt; - 查看服务日志 实用快捷键 Ctrl + C - 终止当前命令 Ctrl + Z - 暂停当前命令 Ctrl + D - 退出终端 Ctrl + L - 清屏 Ctrl + A - 光标移到行首 Ctrl + E - 光标移到行尾 Ctrl + U - 删除光标前的内容 Ctrl + K - 删除光标后的内容 Ctrl + R - 搜索命令历史 Tab - 自动补全 !! - 执行上一条命令 !$ - 上一条命令的最后一个参数 其他实用命令 clear - 清屏 history - 查看命令历史 history | grep \u0026lt;关键词\u0026gt; - 搜索历史命令 echo \u0026lt;文本\u0026gt; - 输出文本 echo \u0026quot;text\u0026quot; \u0026gt; file.txt - 覆盖写入 echo \u0026quot;text\u0026quot; \u0026gt;\u0026gt; file.txt - 追加写入 alias \u0026lt;别名\u0026gt;='\u0026lt;命令\u0026gt;' - 创建别名 watch \u0026lt;命令\u0026gt; - 定期执行命令 watch -n 2 df -h - 每 2 秒更新 xargs - 将标准输入转换为命令参数 tee \u0026lt;文件\u0026gt; - 同时输出到文件和标准输出 Git 常用指令 初始化和配置 初始化仓库\ngit init - 初始化新仓库 git clone \u0026lt;URL\u0026gt; - 克隆远程仓库 git clone \u0026lt;URL\u0026gt; \u0026lt;目录名\u0026gt; - 克隆到指定目录 git clone --depth 1 \u0026lt;URL\u0026gt; - 浅克隆（只克隆最新提交） git clone -b \u0026lt;分支名\u0026gt; \u0026lt;URL\u0026gt; - 克隆指定分支 配置 Git\ngit config --global user.name \u0026quot;\u0026lt;名字\u0026gt;\u0026quot; - 设置用户名 git config --global user.email \u0026quot;\u0026lt;邮箱\u0026gt;\u0026quot; - 设置邮箱 git config --list - 查看所有配置 git config --global core.editor \u0026quot;vim\u0026quot; - 设置编辑器 git config --global alias.st status - 设置别名 基本操作 查看状态\ngit status - 查看工作区状态 git status -s - 简短格式 添加和提交\ngit add \u0026lt;文件\u0026gt; - 添加文件到暂存区 git add . - 添加所有修改 git add -A - 添加所有变化（包括删除） git add -p - 交互式添加 git commit -m \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 提交 git commit -am \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 添加并提交已跟踪文件 git commit --amend - 修改最后一次提交 git commit --amend --no-edit - 修改提交但不改消息 推送和拉取\ngit push - 推送到远程 git push origin \u0026lt;分支名\u0026gt; - 推送指定分支 git push -u origin \u0026lt;分支名\u0026gt; - 推送并设置上游 git push --force / git push -f - 强制推送（危险！） git push --tags - 推送标签 git pull - 拉取并合并 git pull --rebase - 使用 rebase 方式拉取 git fetch - 获取但不合并 git fetch --all - 获取所有远程分支 git fetch --prune - 获取并清理已删除的远程分支 分支操作 查看分支\ngit branch - 查看本地分支 git branch -a - 查看所有分支（包括远程） git branch -r - 只查看远程分支 git branch -v - 查看分支及最后一次提交 创建和切换分支\ngit branch \u0026lt;分支名\u0026gt; - 创建分支 git checkout \u0026lt;分支名\u0026gt; - 切换分支 git checkout -b \u0026lt;分支名\u0026gt; - 创建并切换 git checkout -b \u0026lt;分支名\u0026gt; origin/\u0026lt;分支名\u0026gt; - 从远程分支创建 git switch \u0026lt;分支名\u0026gt; - 切换分支（新语法） git switch -c \u0026lt;分支名\u0026gt; - 创建并切换（新语法） 合并和删除分支\ngit merge \u0026lt;分支名\u0026gt; - 合并分支 git merge --no-ff \u0026lt;分支名\u0026gt; - 非快进合并 git merge --squash \u0026lt;分支名\u0026gt; - 压缩合并 git branch -d \u0026lt;分支名\u0026gt; - 删除已合并分支 git branch -D \u0026lt;分支名\u0026gt; - 强制删除分支 git branch -m \u0026lt;旧名\u0026gt; \u0026lt;新名\u0026gt; - 重命名分支 git push origin --delete \u0026lt;分支名\u0026gt; - 删除远程分支 查看历史 日志查看\ngit log - 查看提交历史 git log --oneline - 每个提交一行 git log --graph - 图形化显示 git log --oneline --graph --all - 图形化显示所有分支 git log -p - 显示详细差异 git log --author=\u0026quot;\u0026lt;作者\u0026gt;\u0026quot; - 按作者筛选 git log --since=\u0026quot;2 weeks ago\u0026quot; - 按时间筛选 git log --grep=\u0026quot;\u0026lt;关键词\u0026gt;\u0026quot; - 搜索提交消息 git log \u0026lt;文件\u0026gt; - 查看文件历史 git log --stat - 显示文件统计 差异比较\ngit diff - 查看未暂存的更改 git diff --staged / git diff --cached - 查看已暂存的更改 git diff \u0026lt;分支1\u0026gt; \u0026lt;分支2\u0026gt; - 比较分支 git diff \u0026lt;提交1\u0026gt; \u0026lt;提交2\u0026gt; - 比较提交 git diff HEAD - 比较工作区和最新提交 其他查看命令\ngit show \u0026lt;提交\u0026gt; - 查看提交详情 git show HEAD - 查看最新提交 git blame \u0026lt;文件\u0026gt; - 查看每行的修改者 git shortlog - 按作者分组显示 撤销和回退 撤销修改\ngit restore \u0026lt;文件\u0026gt; - 撤销工作区修改（新语法） git restore --staged \u0026lt;文件\u0026gt; - 取消暂存（新语法） git checkout -- \u0026lt;文件\u0026gt; - 撤销修改（旧语法） 重置提交\ngit reset \u0026lt;文件\u0026gt; - 取消暂存 git reset HEAD~ - 撤销最后一次提交，保留更改 git reset --soft HEAD~ - 撤销提交，更改在暂存区 git reset --hard HEAD~ - 撤销提交并丢弃更改（危险！） git reset --hard \u0026lt;提交\u0026gt; - 重置到指定提交 回退操作\ngit revert \u0026lt;提交\u0026gt; - 创建新提交来撤销 git revert HEAD - 撤销最新提交 git clean -fd - 删除未跟踪的文件 git clean -n - 预览将要删除的文件 暂存操作（Stash） git stash - 暂存当前更改 git stash save \u0026quot;描述\u0026quot; - 暂存并添加描述 git stash list - 查看暂存列表 git stash pop - 恢复并删除最新暂存 git stash apply - 恢复但不删除暂存 git stash apply stash@{0} - 恢复指定暂存 git stash drop - 删除最新暂存 git stash drop stash@{0} - 删除指定暂存 git stash clear - 清空所有暂存 git stash show - 查看暂存内容 远程仓库 查看远程\ngit remote - 查看远程仓库 git remote -v - 查看详细信息 管理远程\ngit remote add \u0026lt;名称\u0026gt; \u0026lt;URL\u0026gt; - 添加远程仓库 git remote add origin \u0026lt;URL\u0026gt; - 添加 origin git remote remove \u0026lt;名称\u0026gt; - 删除远程仓库 git remote rename \u0026lt;旧名\u0026gt; \u0026lt;新名\u0026gt; - 重命名 git remote set-url \u0026lt;名称\u0026gt; \u0026lt;新URL\u0026gt; - 修改 URL git remote show \u0026lt;名称\u0026gt; - 查看详细信息 git remote prune origin - 清理已删除的远程分支引用 标签操作 git tag - 查看所有标签 git tag \u0026lt;标签名\u0026gt; - 创建轻量标签 git tag -a \u0026lt;标签名\u0026gt; -m \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 创建带注释的标签 git tag -d \u0026lt;标签名\u0026gt; - 删除本地标签 git push origin \u0026lt;标签名\u0026gt; - 推送标签 git push origin --tags - 推送所有标签 git push origin :refs/tags/\u0026lt;标签名\u0026gt; - 删除远程标签 高级操作 变基（Rebase）\ngit rebase \u0026lt;分支\u0026gt; - 变基到指定分支 git rebase -i HEAD~3 - 交互式变基最近 3 个提交 git rebase --continue - 解决冲突后继续 git rebase --abort - 取消变基 其他高级命令\ngit cherry-pick \u0026lt;提交\u0026gt; - 将指定提交应用到当前分支 git reflog - 查看引用日志（恢复丢失的提交） git bisect start - 开始二分查找问题提交 git submodule add \u0026lt;URL\u0026gt; - 添加子模块 git submodule update --init - 初始化并更新子模块 .gitignore 配置 New-Item -ItemType File .gitignore创建 .gitignore 文件来忽略不需要跟踪的文件：\n# 忽略日志文件 *.log # 忽略 node_modules 目录 node_modules/ # 忽略环境变量文件 .env .env.local # 忽略构建输出 dist/ build/ # 忽略操作系统文件 .DS_Store Thumbs.db # 忽略 IDE 配置 .vscode/ .idea/ GitHub CLI 常用指令 认证 gh auth login - 登录 GitHub 账号 gh auth status - 查看认证状态 gh auth logout - 登出 gh auth refresh - 刷新令牌 gh config set editor vim - 设置编辑器 仓库操作 创建和克隆\ngh repo create - 创建仓库 gh repo create \u0026lt;名称\u0026gt; - 创建指定名称的仓库 gh repo create --public - 创建公开仓库 gh repo create --private - 创建私有仓库 gh repo create --clone - 创建并克隆 gh repo clone \u0026lt;仓库\u0026gt; - 克隆仓库 gh repo clone owner/repo - 克隆指定仓库 查看和管理\ngh repo view - 查看仓库信息 gh repo view --web - 在浏览器中打开 gh repo list - 列出仓库 gh repo list \u0026lt;用户名\u0026gt; - 列出指定用户的仓库 gh repo list --limit 50 - 限制显示数量 gh repo fork - Fork 仓库 gh repo fork --clone - Fork 并克隆 gh repo delete \u0026lt;仓库\u0026gt; - 删除仓库 gh repo rename \u0026lt;新名称\u0026gt; - 重命名仓库 or gh repo rename owner/repo 新名字 gh repo sync - 同步 fork Pull Request 创建 PR\ngh pr create - 创建 PR gh pr create --title \u0026quot;标题\u0026quot; --body \u0026quot;描述\u0026quot; - 指定标题和描述 gh pr create --web - 在浏览器中创建 gh pr create --draft - 创建草稿 PR 查看 PR\ngh pr list - 列出 PR gh pr list --state open - 只显示开放的 gh pr list --author \u0026lt;用户名\u0026gt; - 按作者筛选 gh pr list --label \u0026lt;标签\u0026gt; - 按标签筛选 gh pr view \u0026lt;编号\u0026gt; - 查看详情 gh pr view \u0026lt;编号\u0026gt; --web - 在浏览器中查看 gh pr view \u0026lt;编号\u0026gt; --comments - 查看评论 操作 PR\ngh pr checkout \u0026lt;编号\u0026gt; - 检出 PR 分支 gh pr diff \u0026lt;编号\u0026gt; - 查看差异 gh pr merge \u0026lt;编号\u0026gt; - 合并 PR gh pr merge \u0026lt;编号\u0026gt; --squash - 压缩合并 gh pr merge \u0026lt;编号\u0026gt; --rebase - 变基合并 gh pr close \u0026lt;编号\u0026gt; - 关闭 PR gh pr reopen \u0026lt;编号\u0026gt; - 重新打开 gh pr ready \u0026lt;编号\u0026gt; - 标记为准备好 审查 PR\ngh pr review \u0026lt;编号\u0026gt; - 审查 PR gh pr review \u0026lt;编号\u0026gt; --approve - 批准 gh pr review \u0026lt;编号\u0026gt; --request-changes - 请求更改 gh pr review \u0026lt;编号\u0026gt; --comment - 添加评论 gh pr checks \u0026lt;编号\u0026gt; - 查看 CI/CD 状态 Issue 创建 Issue\ngh issue create - 创建 Issue gh issue create --title \u0026quot;标题\u0026quot; --body \u0026quot;描述\u0026quot; - 指定内容 gh issue create --web - 在浏览器中创建 gh issue create --label \u0026quot;bug,help wanted\u0026quot; - 添加标签 查看 Issue\ngh issue list - 列出 Issues gh issue list --state open - 只显示开放的 gh issue list --assignee \u0026lt;用户名\u0026gt; - 按指派人筛选 gh issue list --label \u0026lt;标签\u0026gt; - 按标签筛选 gh issue list --author \u0026lt;用户名\u0026gt; - 按作者筛选 gh issue view \u0026lt;编号\u0026gt; - 查看详情 gh issue view \u0026lt;编号\u0026gt; --web - 在浏览器中查看 操作 Issue\ngh issue close \u0026lt;编号\u0026gt; - 关闭 Issue gh issue close \u0026lt;编号\u0026gt; --comment \u0026quot;已修复\u0026quot; - 关闭并评论 gh issue reopen \u0026lt;编号\u0026gt; - 重新打开 gh issue edit \u0026lt;编号\u0026gt; - 编辑 Issue gh issue edit \u0026lt;编号\u0026gt; --add-label \u0026quot;bug\u0026quot; - 添加标签 gh issue comment \u0026lt;编号\u0026gt; - 添加评论 gh issue status - 查看状态 Gist gh gist create \u0026lt;文件\u0026gt; - 创建 Gist gh gist create --public \u0026lt;文件\u0026gt; - 创建公开 Gist gh gist create --desc \u0026quot;描述\u0026quot; \u0026lt;文件\u0026gt; - 添加描述 gh gist list - 列出 Gists gh gist view \u0026lt;ID\u0026gt; - 查看 Gist gh gist view \u0026lt;ID\u0026gt; --web - 在浏览器中查看 gh gist edit \u0026lt;ID\u0026gt; - 编辑 Gist gh gist delete \u0026lt;ID\u0026gt; - 删除 Gist gh gist clone \u0026lt;ID\u0026gt; - 克隆到本地 Release 创建和查看\ngh release create \u0026lt;标签\u0026gt; - 创建 Release gh release create v1.0.0 --title \u0026quot;版本 1.0.0\u0026quot; --notes \u0026quot;说明\u0026quot; - 指定内容 gh release create v1.0.0 *.zip - 附加文件 gh release create v1.0.0 --draft - 创建草稿 gh release list - 列出所有 Releases gh release view \u0026lt;标签\u0026gt; - 查看详情 gh release view \u0026lt;标签\u0026gt; --web - 在浏览器中查看 下载和管理\ngh release download \u0026lt;标签\u0026gt; - 下载资源 gh release download \u0026lt;标签\u0026gt; --pattern \u0026quot;*.zip\u0026quot; - 下载匹配文件 gh release delete \u0026lt;标签\u0026gt; - 删除 Release gh release upload \u0026lt;标签\u0026gt; \u0026lt;文件\u0026gt; - 上传文件 GitHub Actions 工作流管理\ngh workflow list - 列出工作流 gh workflow view \u0026lt;工作流\u0026gt; - 查看详情 gh workflow view \u0026lt;工作流\u0026gt; --web - 在浏览器中查看 gh workflow run \u0026lt;工作流\u0026gt; - 触发工作流 gh workflow run \u0026lt;工作流\u0026gt; --ref \u0026lt;分支\u0026gt; - 在指定分支运行 运行管理\ngh run list - 列出运行记录 gh run list --workflow \u0026lt;工作流名\u0026gt; - 按工作流筛选 gh run view \u0026lt;运行ID\u0026gt; - 查看详情 gh run view \u0026lt;运行ID\u0026gt; --log - 查看日志 gh run watch \u0026lt;运行ID\u0026gt; - 实时查看状态 gh run rerun \u0026lt;运行ID\u0026gt; - 重新运行 gh run cancel \u0026lt;运行ID\u0026gt; - 取消运行 其他功能 浏览和搜索\ngh browse - 在浏览器中打开仓库 gh browse \u0026lt;文件\u0026gt; - 打开指定文件 gh browse --settings - 打开设置 gh search repos \u0026lt;关键词\u0026gt; - 搜索仓库 gh search repos --stars \u0026quot;\u0026gt;1000\u0026quot; - 按星标搜索 gh search repos --language python - 按语言搜索 gh search issues \u0026lt;关键词\u0026gt; - 搜索 Issues gh search prs \u0026lt;关键词\u0026gt; - 搜索 PRs API 和扩展\ngh api \u0026lt;端点\u0026gt; - 调用 GitHub API gh api user - 获取用户信息 gh alias set \u0026lt;别名\u0026gt; \u0026lt;命令\u0026gt; - 创建别名 gh extension install \u0026lt;扩展\u0026gt; - 安装扩展 gh extension list - 列出扩展 标签和项目\ngh label list - 列出标签 gh label create \u0026lt;名称\u0026gt; - 创建标签 gh project list - 列出项目 gh project view \u0026lt;编号\u0026gt; - 查看项目 ","permalink":"http://localhost:1313/posts/command-reference/","summary":"详细的命令行指令参考手册，包含 Windows PowerShell、Linux Terminal、Git 和 GitHub CLI 的常用命令及实用技巧","title":"常用命令行指令参考"},{"content":"一、数据库操作 1.1 创建和删除数据库 -- 创建数据库 CREATE DATABASE database_name; CREATE DATABASE IF NOT EXISTS database_name CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; -- 删除数据库 DROP DATABASE database_name; DROP DATABASE IF EXISTS database_name; -- 查看所有数据库 SHOW DATABASES; -- 选择数据库 USE database_name; -- 查看当前数据库 SELECT DATABASE(); 二、数据表操作 2.1 创建表 -- 基础创建表 CREATE TABLE users ( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(50) NOT NULL UNIQUE, email VARCHAR(100), age INT DEFAULT 0, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ); -- 创建表时指定引擎和字符集 CREATE TABLE products ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(100) NOT NULL, price DECIMAL(10, 2), stock INT DEFAULT 0 ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; -- 从查询结果创建表 CREATE TABLE users_backup AS SELECT * FROM users; 2.2 修改表结构 -- 添加列 ALTER TABLE users ADD COLUMN phone VARCHAR(20); ALTER TABLE users ADD COLUMN address TEXT AFTER email; -- 修改列 ALTER TABLE users MODIFY COLUMN age TINYINT; ALTER TABLE users CHANGE COLUMN username user_name VARCHAR(60); -- 删除列 ALTER TABLE users DROP COLUMN phone; -- 重命名表 RENAME TABLE users TO members; ALTER TABLE members RENAME TO users; -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键 ALTER TABLE users DROP PRIMARY KEY; -- 添加索引 ALTER TABLE users ADD INDEX idx_username (username); ALTER TABLE users ADD UNIQUE INDEX idx_email (email); -- 删除索引 ALTER TABLE users DROP INDEX idx_username; 2.3 查看表信息 -- 查看所有表 SHOW TABLES; -- 查看表结构 DESC users; DESCRIBE users; SHOW COLUMNS FROM users; -- 查看创建表的语句 SHOW CREATE TABLE users; -- 查看表状态 SHOW TABLE STATUS LIKE \u0026#39;users\u0026#39;; 2.4 删除和清空表 -- 删除表 DROP TABLE users; DROP TABLE IF EXISTS users; -- 清空表数据（保留结构） TRUNCATE TABLE users; DELETE FROM users; -- 与 TRUNCATE 的区别是可以回滚 三、数据操作（CRUD） 3.1 插入数据（INSERT） -- 插入单条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;, 25); -- 插入多条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;李四\u0026#39;, \u0026#39;lisi@example.com\u0026#39;, 28), (\u0026#39;王五\u0026#39;, \u0026#39;wangwu@example.com\u0026#39;, 30); -- 插入所有列（可省略列名） INSERT INTO users VALUES (NULL, \u0026#39;赵六\u0026#39;, \u0026#39;zhaoliu@example.com\u0026#39;, 22, NOW(), NOW()); -- 插入或更新（存在则更新） INSERT INTO users (id, username, email) VALUES (1, \u0026#39;张三\u0026#39;, \u0026#39;new@example.com\u0026#39;) ON DUPLICATE KEY UPDATE email = \u0026#39;new@example.com\u0026#39;; -- 忽略重复插入错误 INSERT IGNORE INTO users (username, email) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;); -- 从其他表插入数据 INSERT INTO users_backup SELECT * FROM users WHERE age \u0026gt; 25; 3.2 查询数据（SELECT） 基础查询 -- 查询所有列 SELECT * FROM users; -- 查询指定列 SELECT username, email FROM users; -- 使用别名 SELECT username AS name, email AS mail FROM users; -- 去重查询 SELECT DISTINCT age FROM users; -- 限制结果数量 SELECT * FROM users LIMIT 10; SELECT * FROM users LIMIT 10, 20; -- 跳过前10条，取20条 SELECT * FROM users LIMIT 20 OFFSET 10; -- 同上 WHERE 条件查询 -- 基本条件 SELECT * FROM users WHERE age \u0026gt; 25; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users WHERE email IS NULL; SELECT * FROM users WHERE email IS NOT NULL; -- 多条件组合 SELECT * FROM users WHERE age \u0026gt; 20 AND age \u0026lt; 30; SELECT * FROM users WHERE age BETWEEN 20 AND 30; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39; OR username = \u0026#39;李四\u0026#39;; SELECT * FROM users WHERE username IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;); SELECT * FROM users WHERE username NOT IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;); -- 模糊查询 SELECT * FROM users WHERE username LIKE \u0026#39;张%\u0026#39;; -- 以\u0026#34;张\u0026#34;开头 SELECT * FROM users WHERE username LIKE \u0026#39;%三\u0026#39;; -- 以\u0026#34;三\u0026#34;结尾 SELECT * FROM users WHERE username LIKE \u0026#39;%张%\u0026#39;; -- 包含\u0026#34;张\u0026#34; SELECT * FROM users WHERE username LIKE \u0026#39;张_\u0026#39;; -- 张+一个字符 SELECT * FROM users WHERE username NOT LIKE \u0026#39;张%\u0026#39;; 排序和分组 -- 排序 SELECT * FROM users ORDER BY age ASC; -- 升序（默认） SELECT * FROM users ORDER BY age DESC; -- 降序 SELECT * FROM users ORDER BY age DESC, username ASC; -- 多列排序 -- 分组 SELECT age, COUNT(*) as count FROM users GROUP BY age; SELECT age, AVG(age) as avg_age FROM users GROUP BY age; -- HAVING 过滤分组结果 SELECT age, COUNT(*) as count FROM users GROUP BY age HAVING count \u0026gt; 5; 聚合函数 -- 计数 SELECT COUNT(*) FROM users; SELECT COUNT(DISTINCT age) FROM users; -- 求和、平均、最大、最小 SELECT SUM(age) FROM users; SELECT AVG(age) FROM users; SELECT MAX(age) FROM users; SELECT MIN(age) FROM users; -- 多个聚合函数 SELECT COUNT(*) as total, AVG(age) as avg_age, MAX(age) as max_age FROM users; 连接查询（JOIN） -- 内连接（INNER JOIN） SELECT users.username, orders.order_no FROM users INNER JOIN orders ON users.id = orders.user_id; -- 左连接（LEFT JOIN） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id; -- 右连接（RIGHT JOIN） SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 全连接（FULL JOIN，MySQL不直接支持，需要用UNION） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id UNION SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 自连接 SELECT a.username, b.username as friend FROM users a INNER JOIN users b ON a.friend_id = b.id; -- 多表连接 SELECT u.username, o.order_no, p.product_name FROM users u INNER JOIN orders o ON u.id = o.user_id INNER JOIN order_items oi ON o.id = oi.order_id INNER JOIN products p ON oi.product_id = p.id; 子查询 -- WHERE 子查询 SELECT * FROM users WHERE id IN (SELECT user_id FROM orders WHERE amount \u0026gt; 1000); -- FROM 子查询 SELECT avg_age FROM (SELECT AVG(age) as avg_age FROM users GROUP BY city) as subquery; -- EXISTS 子查询 SELECT * FROM users WHERE EXISTS (SELECT 1 FROM orders WHERE orders.user_id = users.id); -- 标量子查询 SELECT username, (SELECT COUNT(*) FROM orders WHERE user_id = users.id) as order_count FROM users; 联合查询（UNION） -- UNION（去重） SELECT username FROM users WHERE age \u0026gt; 30 UNION SELECT username FROM admins WHERE age \u0026gt; 30; -- UNION ALL（不去重，性能更好） SELECT username FROM users WHERE age \u0026gt; 30 UNION ALL SELECT username FROM admins WHERE age \u0026gt; 30; 3.3 更新数据（UPDATE） -- 更新单列 UPDATE users SET age = 26 WHERE username = \u0026#39;张三\u0026#39;; -- 更新多列 UPDATE users SET age = 26, email = \u0026#39;new@example.com\u0026#39; WHERE username = \u0026#39;张三\u0026#39;; -- 批量更新 UPDATE users SET age = age + 1 WHERE age \u0026lt; 30; -- 使用表达式更新 UPDATE users SET updated_at = NOW() WHERE id = 1; -- 基于其他表更新 UPDATE users u INNER JOIN orders o ON u.id = o.user_id SET u.total_orders = u.total_orders + 1 WHERE o.created_at \u0026gt; \u0026#39;2024-01-01\u0026#39;; -- 条件更新（CASE） UPDATE users SET level = CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END; 3.4 删除数据（DELETE） -- 删除指定数据 DELETE FROM users WHERE id = 1; -- 批量删除 DELETE FROM users WHERE age \u0026lt; 18; -- 删除所有数据 DELETE FROM users; -- 基于其他表删除 DELETE u FROM users u INNER JOIN orders o ON u.id = o.user_id WHERE o.status = \u0026#39;cancelled\u0026#39;; 四、索引管理 4.1 创建索引 -- 普通索引 CREATE INDEX idx_username ON users(username); -- 唯一索引 CREATE UNIQUE INDEX idx_email ON users(email); -- 复合索引 CREATE INDEX idx_name_age ON users(username, age); -- 全文索引 CREATE FULLTEXT INDEX idx_content ON articles(content); -- 在创建表时添加索引 CREATE TABLE users ( id INT PRIMARY KEY, username VARCHAR(50), email VARCHAR(100), INDEX idx_username (username), UNIQUE INDEX idx_email (email) ); 4.2 查看和删除索引 -- 查看索引 SHOW INDEX FROM users; -- 删除索引 DROP INDEX idx_username ON users; ALTER TABLE users DROP INDEX idx_username; 五、约束管理 5.1 主键约束 -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键（需要先删除 AUTO_INCREMENT 属性） ALTER TABLE users MODIFY id INT; ALTER TABLE users DROP PRIMARY KEY; 5.2 外键约束 -- 添加外键 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id); -- 添加外键时设置级联操作 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE; -- 删除外键 ALTER TABLE orders DROP FOREIGN KEY fk_user_id; 5.3 其他约束 -- 唯一约束 ALTER TABLE users ADD UNIQUE (email); -- 非空约束 ALTER TABLE users MODIFY username VARCHAR(50) NOT NULL; -- 检查约束（MySQL 8.0.16+） ALTER TABLE users ADD CONSTRAINT chk_age CHECK (age \u0026gt;= 0 AND age \u0026lt;= 150); -- 默认值约束 ALTER TABLE users ALTER COLUMN status SET DEFAULT \u0026#39;active\u0026#39;; 六、视图 -- 创建视图 CREATE VIEW active_users AS SELECT id, username, email FROM users WHERE status = \u0026#39;active\u0026#39;; -- 创建或替换视图 CREATE OR REPLACE VIEW active_users AS SELECT id, username, email, age FROM users WHERE status = \u0026#39;active\u0026#39;; -- 查询视图 SELECT * FROM active_users; -- 查看视图定义 SHOW CREATE VIEW active_users; -- 删除视图 DROP VIEW active_users; DROP VIEW IF EXISTS active_users; 七、事务处理 -- 开启事务 START TRANSACTION; -- 或 BEGIN; -- 提交事务 COMMIT; -- 回滚事务 ROLLBACK; -- 设置保存点 SAVEPOINT sp1; ROLLBACK TO sp1; -- 完整示例 START TRANSACTION; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; COMMIT; -- 设置自动提交 SET autocommit = 0; -- 关闭自动提交 SET autocommit = 1; -- 开启自动提交 八、存储过程和函数 8.1 存储过程 -- 创建存储过程 DELIMITER // CREATE PROCEDURE GetUserById(IN userId INT) BEGIN SELECT * FROM users WHERE id = userId; END // DELIMITER ; -- 调用存储过程 CALL GetUserById(1); -- 带输出参数的存储过程 DELIMITER // CREATE PROCEDURE GetUserCount(OUT total INT) BEGIN SELECT COUNT(*) INTO total FROM users; END // DELIMITER ; CALL GetUserCount(@count); SELECT @count; -- 删除存储过程 DROP PROCEDURE IF EXISTS GetUserById; -- 查看存储过程 SHOW PROCEDURE STATUS; SHOW CREATE PROCEDURE GetUserById; 8.2 函数 -- 创建函数 DELIMITER // CREATE FUNCTION GetUserAge(userId INT) RETURNS INT BEGIN DECLARE userAge INT; SELECT age INTO userAge FROM users WHERE id = userId; RETURN userAge; END // DELIMITER ; -- 使用函数 SELECT GetUserAge(1); -- 删除函数 DROP FUNCTION IF EXISTS GetUserAge; 九、触发器 -- 创建 BEFORE INSERT 触发器 DELIMITER // CREATE TRIGGER before_user_insert BEFORE INSERT ON users FOR EACH ROW BEGIN SET NEW.created_at = NOW(); END // DELIMITER ; -- 创建 AFTER UPDATE 触发器 DELIMITER // CREATE TRIGGER after_user_update AFTER UPDATE ON users FOR EACH ROW BEGIN INSERT INTO user_logs (user_id, action, created_at) VALUES (OLD.id, \u0026#39;update\u0026#39;, NOW()); END // DELIMITER ; -- 查看触发器 SHOW TRIGGERS; -- 删除触发器 DROP TRIGGER IF EXISTS before_user_insert; 十、用户和权限管理 -- 创建用户 CREATE USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; CREATE USER \u0026#39;username\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; -- 允许任何主机 -- 授予权限 GRANT ALL PRIVILEGES ON database_name.* TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; GRANT SELECT, INSERT, UPDATE ON database_name.table_name TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 刷新权限 FLUSH PRIVILEGES; -- 查看用户权限 SHOW GRANTS FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 撤销权限 REVOKE INSERT, UPDATE ON database_name.* FROM \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 修改密码 ALTER USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;new_password\u0026#39;; SET PASSWORD FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; = PASSWORD(\u0026#39;new_password\u0026#39;); -- 删除用户 DROP USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; 十一、备份和恢复 -- 使用 mysqldump 备份（在命令行执行） mysqldump -u username -p database_name \u0026gt; backup.sql mysqldump -u username -p database_name table_name \u0026gt; table_backup.sql mysqldump -u username -p --all-databases \u0026gt; all_databases.sql -- 恢复数据库（在命令行执行） mysql -u username -p database_name \u0026lt; backup.sql -- 导出为 CSV SELECT * FROM users INTO OUTFILE \u0026#39;/tmp/users.csv\u0026#39; FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; -- 从 CSV 导入 LOAD DATA INFILE \u0026#39;/tmp/users.csv\u0026#39; INTO TABLE users FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; 十二、性能优化相关 12.1 EXPLAIN 分析查询 -- 分析查询执行计划 EXPLAIN SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; -- 详细分析 EXPLAIN EXTENDED SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SHOW WARNINGS; -- JSON 格式 EXPLAIN FORMAT=JSON SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; 12.2 查询优化 -- 使用索引提示 SELECT * FROM users USE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users FORCE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users IGNORE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; -- 优化 COUNT SELECT COUNT(1) FROM users; -- 比 COUNT(*) 快一点 -- 分页优化（避免大 OFFSET） SELECT * FROM users WHERE id \u0026gt; 10000 ORDER BY id LIMIT 20; 12.3 查看状态和变量 -- 查看数据库状态 SHOW STATUS; SHOW STATUS LIKE \u0026#39;Threads%\u0026#39;; -- 查看系统变量 SHOW VARIABLES; SHOW VARIABLES LIKE \u0026#39;max_connections\u0026#39;; -- 查看进程列表 SHOW PROCESSLIST; SHOW FULL PROCESSLIST; -- 杀死进程 KILL process_id; 十三、常用字符串和日期函数 13.1 字符串函数 -- 字符串连接 SELECT CONCAT(\u0026#39;Hello\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;World\u0026#39;); SELECT CONCAT_WS(\u0026#39;-\u0026#39;, \u0026#39;2024\u0026#39;, \u0026#39;12\u0026#39;, \u0026#39;10\u0026#39;); -- 字符串长度 SELECT LENGTH(\u0026#39;Hello\u0026#39;), CHAR_LENGTH(\u0026#39;你好\u0026#39;); -- 大小写转换 SELECT UPPER(\u0026#39;hello\u0026#39;), LOWER(\u0026#39;HELLO\u0026#39;); -- 截取字符串 SELECT SUBSTRING(\u0026#39;Hello World\u0026#39;, 1, 5); SELECT LEFT(\u0026#39;Hello World\u0026#39;, 5), RIGHT(\u0026#39;Hello World\u0026#39;, 5); -- 替换和删除 SELECT REPLACE(\u0026#39;Hello World\u0026#39;, \u0026#39;World\u0026#39;, \u0026#39;MySQL\u0026#39;); SELECT TRIM(\u0026#39; Hello \u0026#39;), LTRIM(\u0026#39; Hello\u0026#39;), RTRIM(\u0026#39;Hello \u0026#39;); -- 查找位置 SELECT POSITION(\u0026#39;World\u0026#39; IN \u0026#39;Hello World\u0026#39;); SELECT LOCATE(\u0026#39;World\u0026#39;, \u0026#39;Hello World\u0026#39;); 13.2 日期时间函数 -- 获取当前时间 SELECT NOW(), CURDATE(), CURTIME(); SELECT CURRENT_TIMESTAMP(), CURRENT_DATE(), CURRENT_TIME(); -- 日期格式化 SELECT DATE_FORMAT(NOW(), \u0026#39;%Y-%m-%d %H:%i:%s\u0026#39;); SELECT DATE_FORMAT(NOW(), \u0026#39;%Y年%m月%d日\u0026#39;); -- 日期计算 SELECT date_add(\u0026#39;2023-01-01\u0026#39;, interval 1 day) 输出 \u0026#39;2023-01-02\u0026#39; SELECT date_sub(\u0026#39;2023-01-01\u0026#39;, interval 1 day) 输出 \u0026#39;2022-12-31\u0026#39; SELECT datediff(\u0026#39;2023-02-01\u0026#39;, \u0026#39;2023-01-01\u0026#39;) 输出31 -- 提取日期部分 SELECT YEAR(NOW()), MONTH(NOW()), DAY(NOW()); SELECT HOUR(NOW()), MINUTE(NOW()), SECOND(NOW()); -- 时间戳转换 SELECT UNIX_TIMESTAMP(NOW()); SELECT FROM_UNIXTIME(1702195200); 13.3 数学和其他函数 -- 数学函数 SELECT ROUND(3.14159, 2), CEIL(3.2), FLOOR(3.8); SELECT ABS(-5), MOD(10, 3), POWER(2, 3); SELECT RAND(), RAND()*100; -- 条件函数 SELECT IF(age \u0026gt; 18, \u0026#39;成年\u0026#39;, \u0026#39;未成年\u0026#39;) FROM users; SELECT IFNULL(email, \u0026#39;无邮箱\u0026#39;) FROM users; SELECT COALESCE(NULL, NULL, \u0026#39;default\u0026#39;, \u0026#39;value\u0026#39;); -- CASE 表达式 SELECT username, CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END as age_group FROM users; 十四、JSON 操作（MySQL 5.7+） -- 创建 JSON 列 CREATE TABLE products ( id INT PRIMARY KEY, name VARCHAR(100), attributes JSON ); -- 插入 JSON 数据 INSERT INTO products VALUES (1, \u0026#39;iPhone\u0026#39;, \u0026#39;{\u0026#34;color\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;storage\u0026#34;: \u0026#34;128GB\u0026#34;}\u0026#39;); -- 查询 JSON 数据 SELECT JSON_EXTRACT(attributes, \u0026#39;$.color\u0026#39;) as color FROM products; SELECT attributes-\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; SELECT attributes-\u0026gt;\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; -- 去除引号 -- 修改 JSON 数据 UPDATE products SET attributes = JSON_SET(attributes, \u0026#39;$.color\u0026#39;, \u0026#39;white\u0026#39;) WHERE id = 1; UPDATE products SET attributes = JSON_INSERT(attributes, \u0026#39;$.price\u0026#39;, 999) WHERE id = 1; UPDATE products SET attributes = JSON_REMOVE(attributes, \u0026#39;$.storage\u0026#39;) WHERE id = 1; -- JSON 数组操作 SELECT JSON_ARRAY(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;); SELECT JSON_CONTAINS(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;, \u0026#39;\u0026#34;a\u0026#34;\u0026#39;); SELECT JSON_LENGTH(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;); 十五、窗口函数（MySQL 8.0+） -- ROW_NUMBER：行号 SELECT username, age, ROW_NUMBER() OVER (ORDER BY age DESC) as row_num FROM users; -- RANK：排名（有并列，跳号） SELECT username, score, RANK() OVER (ORDER BY score DESC) as rank FROM students; -- DENSE_RANK：密集排名（有并列，不跳号） SELECT username, score, DENSE_RANK() OVER (ORDER BY score DESC) as rank FROM students; -- 分组窗口 SELECT department, username, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank FROM employees; -- 累计求和 SELECT username, amount, SUM(amount) OVER (ORDER BY created_at) as running_total FROM transactions; -- LAG 和 LEAD：访问上下行 SELECT username, salary, LAG(salary, 1) OVER (ORDER BY id) as prev_salary, LEAD(salary, 1) OVER (ORDER BY id) as next_salary FROM employees; 十六、常见问题和技巧 16.1 查找重复数据 -- 查找重复的用户名 SELECT username, COUNT(*) as count FROM users GROUP BY username HAVING count \u0026gt; 1; -- 删除重复数据（保留ID最小的） DELETE u1 FROM users u1 INNER JOIN users u2 WHERE u1.id \u0026gt; u2.id AND u1.username = u2.username; 16.2 随机获取数据 -- 随机获取一条数据 SELECT * FROM users ORDER BY RAND() LIMIT 1; -- 更高效的随机（大表适用） SELECT * FROM users WHERE id \u0026gt;= (SELECT FLOOR(MAX(id) * RAND()) FROM users) LIMIT 1; 16.3 行转列 -- 使用 CASE WHEN SELECT name, SUM(CASE WHEN subject = \u0026#39;语文\u0026#39; THEN score ELSE 0 END) as chinese, SUM(CASE WHEN subject = \u0026#39;数学\u0026#39; THEN score ELSE 0 END) as math FROM scores GROUP BY name; 16.4 列转行 -- 使用 UNION ALL SELECT name, \u0026#39;语文\u0026#39; as subject, chinese as score FROM scores UNION ALL SELECT name, \u0026#39;数学\u0026#39; as subject, math as score FROM scores; 十七、常用管理命令 -- 查看 MySQL 版本 SELECT VERSION(); -- 查看当前用户 SELECT USER(), CURRENT_USER(); -- 查看数据库大小 SELECT table_schema AS \u0026#39;Database\u0026#39;, ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables GROUP BY table_schema; -- 查看表大小 SELECT table_name AS \u0026#39;Table\u0026#39;, ROUND(((data_length + index_length) / 1024 / 1024), 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables WHERE table_schema = \u0026#39;database_name\u0026#39; ORDER BY (data_length + index_length) DESC; -- 修复表 REPAIR TABLE users; -- 优化表 OPTIMIZE TABLE users; -- 分析表 ANALYZE TABLE users; -- 检查表 CHECK TABLE users; 总结 这份笔记涵盖了 MySQL 从基础到进阶的大部分常用操作，当然也适合在刷题中补充，包括：\n数据库和表的管理 完整的 CRUD 操作 索引和约束 视图、事务、存储过程 用户权限管理 性能优化技巧 常用函数和 JSON、窗口函数！ ","permalink":"http://localhost:1313/posts/mysql-cheatsheet/","summary":"MySQL 常用语句全面速查手册，涵盖从基础 CRUD 到高级特性（索引、事务、存储过程、窗口函数等）的所有常用操作，适合快速查阅和刷题使用","title":"MySQL 语句速查笔记"},{"content":"论文基本信息 标题: Linking Souls to Humans: Blockchain Accounts with Credible Anonymity for Web 3.0 Decentralized Identity 作者: Taotao Wang, Zibin Lin, Shengli Zhang, Long Shi, Qing Yang, Boris Düdder 会议: WWW \u0026lsquo;25 (ACM Web Conference 2025) 时间: 2025年4月28日-5月2日，悉尼 机构: 深圳大学、南京理工大学、哥本哈根大学 研究背景 数字身份的三个发展阶段 数字身份系统经历了三个演进阶段，分别对应互联网的三个时代：\n阶段 身份类型 对应时代 特点 问题 1 中心化身份 Web 1.0 用户创建，应用提供商管理 多账户管理复杂，数据泄露风险 2 联盟身份 Web 2.0 少数大型提供商管理，可跨应用使用 数据霸权，用户数据集中在少数巨头手中 3 去中心化身份 Web 3.0 用户自主创建和管理（自主权身份） 完全匿名导致无法追溯真实社交关系 Web 3.0的核心价值 Web 3.0的革命性转变在于：\n用户拥有数据主权 数据不被应用提供商占有 需要去中心化身份系统支撑 当前区块链账户系统的问题 区块链账户系统是Web 3.0去中心化身份的理想原型，但存在以下问题：\n完全匿名的缺陷： 用户可以无需认证创建多个账户 无法准确记录真实用户之间的社交关系和互动 用户与区块链身份之间的映射关系模糊 Soulbound Token的局限性： Vitalik Buterin提出的\u0026quot;灵魂\u0026quot;（Soul）概念和\u0026quot;灵魂绑定代币\u0026quot;（Soulbound Token） 用户仍可创建多个\u0026quot;灵魂\u0026quot;账户来抹除、转移或隐藏关系 无法真实反映人类社会中的真实关系 研究方案：zkBID 核心目标 zkBID（Zero-Knowledge Blockchain-account-based Web 3.0 decentralized IDentity）旨在实现：\n一对一映射：将灵魂（区块链账户）与人类（用户）建立一对一关联 去中心化：无需第三方中心化机构参与 隐私保护：隐藏身份与账户之间的绑定关系（即匿名） 可信性：每个账户在区块链上的信用与对应的真实用户一对一映射 关键技术 zkBID采用三大核心技术：\n零知识证明（zkSNARK） 可链接环签名（Linkable Ring Signature） 区块链智能合约（Smart Contracts） 技术预备知识 1. 可验证凭证（Verifiable Credentials, VC） 由W3C提出的去中心化标识符（DID）体系中的关键组件。\n三个主要角色：\n颁发者（Issuer）：签发凭证 持有者（Holder）：拥有凭证 验证者（Verifier）：验证凭证 VC的数据结构（JSON对象）：\n{ \u0026#34;metadata\u0026#34;: \u0026#34;包含颁发者DID、颁发日期、声明类型\u0026#34;, \u0026#34;claims\u0026#34;: \u0026#34;关于持有者的断言，包括持有者DID\u0026#34;, \u0026#34;proofs\u0026#34;: \u0026#34;颁发者的数字签名\u0026#34; } 2. 人格凭证（Personhood Credentials, PHC） 定义：证明用户是真人而非AI的数字凭证\n运作流程：\n注册流程 用户向PHC颁发者证明自己是真人 → 颁发者签发PHC\n使用流程 第三方服务可要求用户出示PHC作为授权过程的一部分\n验证方法（颁发者确保用户是真人的三种主要方式）：\n现有身份文件 基于政府签发的身份证件 利用现有可信来源 生物识别信息 测量持久且唯一的人体特征（掌纹、虹膜、指纹） 确保是真人且限制每人只注册一次 信任网络（Web of Trust） 通过社交图谱分析区分真人和机器 检测用户是否曾获得过凭证 在zkBID中的应用：\nPHC以VC形式作为每个人类用户的身份凭证 3. zkSNARK算法 全称：Zero-knowledge Succinct Non-interactive Argument of Knowledge\n优势：\n简洁性（Succinct）：证明大小仅几个字节，验证时间短 非交互性（Non-interactive）：证明者和验证者无需同步通信 工作原理：\n使用算术电路表示，包含基本运算：加、减、乘、除\nF-算术电路：\n输入：$x \\in \\mathbb{F}^n$ 辅助输入（见证）：$w \\in \\mathbb{F}^h$ 输出：$C(x, w) \\in \\mathbb{F}^l$ 三个算法组件：\n密钥生成（KEYGEN）\n(PK, VK) ← KEYGEN(1^λ, C) 输入：安全参数λ和电路C 输出：证明密钥PK和验证密钥VK 证明生成（PROVE）\nπ ← PROVE(PK, x, W) 输入：PK、公开输入x、私密见证W 输出：证明π 证明验证（VERIFY）\n1/0 ← VERIFY(VK, x, π) 输入：VK、公开输入x、证明π 输出：接受（1）或拒绝（0） zkBID采用的算法：Groth16\n原因：验证速度快，证明紧凑 适用于大规模应用和大型区块链网络 4. 可链接环签名（Linkable Ring Signature） 基本环签名：\n验证者可以确认签名由预定义集合中的某个成员创建 但无法确定具体是哪个成员 可链接环签名的额外特性：\n允许验证者确定两个签名是否由同一签名者生成 四个算法组件：\n密钥生成（GEN）\n(pk, sk) ← GEN(1^k) 签名生成（SIG）\nσ ← SIG(1^k, 1^n, m, L, sk) 输入：安全参数k、环大小n、消息m、公钥环L、私钥sk 输出：签名σ 签名验证（VER）\n1/0 ← VER(1^k, 1^n, m, L, σ) 可链接性检查（LINK）\n1/0 ← LINK(1^k, 1^n, m1, m2, σ1, σ2, L1, L2) 判断两个签名是否由同一签名者生成 关键属性：\n签名者模糊性（Signer Ambiguity）： 攻击者正确猜测真实签名者的概率不超过 1/(n-t) 其中n是环大小，t是攻击者拥有的私钥数量 可链接性（Linkability）： 同一签名者（相同私钥）签名的两条消息可被验证为关联 zkBID采用的算法：MLSAGS（Multilayered Linkable Spontaneous Anonymous Group Signature）\n原因：实现可链接性的技术复杂度较低，适合在智能合约上实现 密钥图像（Key Image）机制：\ny₀ ← sk * Hₚ(pk) y₀对于给定的(sk, pk)对是唯一的 所有由同一签名者产生的签名都带有相同的密钥图像 即使环中的公钥改变，签名仍可链接 zkBID系统设计 整体架构 映射关系图 真实用户 → PHC（人格凭证）→ PHC哈希 → 种子公钥 → 灵魂账户 关系说明：\n实线：可见的一对一关系 虚线：不可见但可验证的关系 箭头：单向计算关系 核心设计理念 隐私保护： PHC的具体内容不上链，只存储零知识证明 灵魂账户与种子公钥的关联不可见 可信匿名： 账户是匿名的（无法追踪到真实身份） 账户是可信的（确实与真实用户一对一绑定） 完全去中心化： 所有数据由用户生成 通过区块链上的智能合约验证 IVAC流程（Identity Verification and Account Certification） zkBID通过三个子流程生成具有可信匿名性的灵魂账户：\n[用户] → [注册信息生成] → [用户身份验证] → [灵魂账户认证] → [灵魂账户] ↓ ↓ ↓ 零知识证明 智能合约验证 可链接环签名 详细设计 阶段1：注册信息生成 目标：生成隐私保护的注册信息，不泄露PHC的具体内容\nPHC格式设计 zkBID中的PHC采用VC格式，包含三个关键字段：\n{ \u0026#34;credentialSubject\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_holder\u0026#34; // 持有者公钥 }, \u0026#34;proof\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_issuer\u0026#34;, // 颁发者公钥 \u0026#34;signature\u0026#34;: \u0026#34;sig_issuer\u0026#34; // 颁发者签名 } } 零知识证明生成流程 Protocol 1: PHC的ZK证明生成\n输入： - hash_PHC：PHC的哈希值 - sig_holder：持有者的签名 - pk_issuer：颁发者的公钥 - PHC：完整的PHC数据 设置： (PK, VK) ← zkSNARK.KEYGEN(1^λ, C) 生成证明： 1. 公开输入 x ← (hash_PHC, sig_holder, pk_issuer) 2. 私密见证 W ← PHC 3. π ← zkSNARK.PROVE(PK, x, W) 输出：π（零知识证明） 算术电路验证逻辑 graph TD A[私密输入: PHC] --\u0026gt; B[计算PHC的哈希] C[公开输入: hash_PHC] --\u0026gt; B B --\u0026gt; D{哈希值是否相等?} A --\u0026gt; E[提取pk_holder] F[公开输入: sig_holder] --\u0026gt; G[验证sig_holder] E --\u0026gt; G G --\u0026gt; H{签名是否有效?} A --\u0026gt; I[提取sig_issuer] J[公开输入: pk_issuer] --\u0026gt; K[验证sig_issuer] I --\u0026gt; K K --\u0026gt; L{签名是否有效?} D --\u0026gt; M[AND] H --\u0026gt; M L --\u0026gt; M M --\u0026gt; N{输出TRUE/FALSE} 验证步骤：\n验证哈希正确性： 计算PHC的哈希 检查是否等于公开输入中的hash_PHC 确保hash_PHC确实从PHC计算得出 验证所有权： 从PHC中提取持有者公钥pk_holder 用pk_holder验证sig_holder 证明用户拥有PHC 验证PHC有效性： 从PHC中提取颁发者签名sig_issuer 用pk_issuer验证sig_issuer 证明PHC由可信颁发者签发 输出：\n如果所有检查通过：输出TRUE和证明π π证明的声明：\u0026ldquo;PHC哈希正确，持有者拥有PHC，PHC由颁发者签发\u0026rdquo; 关键：不泄露PHC的具体内容 阶段2：用户身份验证 目标：\n验证用户的真人身份（通过验证ZK证明） 防止重复注册（检查PHC哈希未被使用） 智能合约流程 Protocol 2: 用户身份验证智能合约\n输入： - π：零知识证明 - hash_PHC：PHC哈希 - sig_holder：持有者签名 - pk_seed：种子公钥 执行步骤： 1. pk_issuer ← GetIssuerPK() // 获取预定义的颁发者公钥 2. validation ← zkSNARK.VERIFY(VK, hash_PHC, pk_issuer, π) 3. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 4. stored ← Traverse(hash_PHC) // 检查是否已注册 5. if stored ≠ 0: return \u0026#34;已经注册\u0026#34; 6. Store(hash_PHC, pk_seed) // 存储为键值对 7. return \u0026#34;认证成功\u0026#34; 用户操作步骤 生成种子密钥对：\n(pk_seed, sk_seed) ← MLSAGS.GEN(1^k) 构造交易：\n数据字段包含：π, hash_PHC, sig_holder, pk_issuer, pk_seed 发送到身份验证合约地址 合约验证：\n验证颁发者公钥匹配 验证零知识证明 检查PHC哈希未被使用 链上记录：\n存储键值对：(hash_PHC, pk_seed) hash_PHC用于防止重复注册 pk_seed作为用户在下一阶段创建灵魂账户的凭证 安全保证：\nPHC的具体内容不上链 仍能验证PHC的所有权和有效性 防止同一PHC多次注册 阶段3：灵魂账户认证 目标：认证灵魂账户与合法种子公钥的一对一关联\n整体流程 生成灵魂账户（普通以太坊账户） 建立关联（使用可链接环签名） 链上验证（智能合约验证签名） 可链接环签名的生成和验证 graph LR A[用户端] --\u0026gt; B[签名生成] B --\u0026gt; C[智能合约] C --\u0026gt; D[签名验证] E[输入] --\u0026gt; B E --\u0026gt; |选择的L-1个种子公钥| B E --\u0026gt; |用户的种子公钥pk_seed| B E --\u0026gt; |用户的种子私钥sk_seed| B E --\u0026gt; |灵魂账户地址addr_soul| B E --\u0026gt; |密钥图像y₀| B B --\u0026gt; |签名σ| C F[公钥环L] --\u0026gt; C G[addr_soul] --\u0026gt; C D --\u0026gt; H{验证结果} H --\u0026gt; |True| I[认证成功] H --\u0026gt; |False| J[认证失败] 详细步骤 步骤1：生成灵魂账户\n(addr_soul, pk_soul, sk_soul) = 生成以太坊账户 步骤2：构造公钥环\n从已注册的种子公钥中选择L-1个 加上用户自己的pk_seed 形成大小为L的公钥环 步骤3：计算密钥图像\ny₀ ← sk_seed * Hₚ(pk_seed) y₀对于给定的(sk_seed, pk_seed)是唯一的 用于防止重复注册 步骤4：生成可链接环签名\nσ ← MLSAGS.SIG(1^k, 1^n, addr_soul, L, sk_seed) 消息m = addr_soul（要签名的是灵魂账户地址） 签名格式：σ = (y₀, \u0026hellip;) y₀作为签名的一部分 步骤5：智能合约验证\nProtocol 3: 灵魂账户认证智能合约\n输入： - σ：可链接环签名 - L：公钥环 - addr_soul：灵魂账户地址 执行步骤： 1. validation ← LRS.VER(1^k, 1^n, addr_soul, L, σ) 2. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 3. stored ← Traverse(σ.y₀) // 检查密钥图像是否已使用 4. if stored ≠ 0: return \u0026#34;已经认证\u0026#34; 5. Store(σ.y₀, addr_soul) // 存储密钥图像和灵魂账户 6. return \u0026#34;认证成功\u0026#34; 隐私保护机制 关键特性：\n签名者模糊性： 签名可以被验证为有效 但无法确定环L中哪个公钥是真正的签名者 攻击者猜对的概率：1/(n-t)，其中n是环大小，t是攻击者拥有的私钥数 一对一保证： 密钥图像y₀唯一对应一个种子密钥对 同一种子密钥对只能生成一个有效签名 确保一个PHC只能关联一个灵魂账户 可验证的匿名性： 任何人都可以验证灵魂账户与某个合法种子公钥关联 但无法确定具体是哪个种子公钥 实现\u0026quot;可信匿名\u0026quot; 链上数据 存储内容：\n(σ.y₀, addr_soul) 键值对 可见信息：\n所有种子公钥（从阶段2） 所有灵魂账户地址 所有密钥图像 不可见关联：\n哪个种子公钥对应哪个灵魂账户 哪个PHC哈希对应哪个灵魂账户 哪个真实用户对应哪个灵魂账户 安全性分析 安全前提条件 计算对手受限：攻击者为多项式时间的计算对手 验证者诚实：智能合约不会接受虚假验证请求 PHC唯一性：每个用户只能从颁发者获得一个PHC 安全目标 zkBID需要满足三个核心安全属性：\n安全属性 定义 目标 身份唯一性 防止重复注册 一个用户不能注册多个灵魂账户 不可伪造性 防止身份伪造 攻击者不能冒充诚实用户认证灵魂账户 匿名性 保护身份隐私 攻击者无法检测用户身份(PHC)与灵魂账户的关联 威胁模型与防御 1. 女巫攻击（Sybil Attack） 攻击场景： 攻击者已拥有一个灵魂账户，试图获取新的灵魂账户\n攻击方法：\n方法A：使用相同PHC关联新的种子公钥 → 用新种子公钥认证新灵魂账户\n方法B：直接使用已用过的种子公钥认证新灵魂账户\n防御分析：\n方法A的防御：\n在用户身份验证合约中： 1. 合约检查hash_PHC是否已存储 2. 由于哈希函数的抗碰撞性，每个PHC只能生成一个唯一哈希 3. zkSNARK的可靠性保证：攻击者通过伪造哈希成功的概率可忽略不计 4. 因此无法用同一PHC注册两个种子账户 方法B的防御：\n在灵魂账户认证合约中： 1. 合约检查密钥图像y₀是否已使用 2. 由于可链接环签名的可链接性，同一种子私钥无法构造两个不同y₀的有效签名 3. 因此无法用同一种子密钥对认证两个灵魂账户 结论：无法使用相同PHC或种子公钥注册两个灵魂账户\n2. 链接攻击（Linkage Attack） 攻击场景： 攻击者试图通过破解环签名的真实签名者，建立用户身份（PHC哈希）与灵魂账户的链接\n攻击方法： 分析链上存储的环签名，推断哪个种子公钥是真正的签名者\n防御分析：\n基于可链接环签名的签名者模糊性： - 假设环大小为n - 攻击者拥有t个私钥 - 攻击者正确识别真实签名者的概率 = 1/(n-t) 示例： - 环大小 n = 100 - 攻击者拥有 t = 10 个私钥 - 成功概率 = 1/90 ≈ 1.1% 结论：攻击者无法有效建立身份与账户的链接 环大小的影响：\n环越大 → 匿名性越强 但签名生成和验证成本增加 需要在匿名性和效率之间权衡 3. 伪造攻击（Forgery Attack） 攻击场景： 攻击者试图冒充诚实用户获取灵魂账户\n攻击方法：\n方法A：伪造holder签名生成有效zkSNARK证明\n攻击者获得诚实用户的PHC ↓ 伪造sig_holder ↓ 生成通过验证的zkSNARK证明 ↓ 注册种子公钥 ↓ 认证灵魂账户 方法B：伪造种子账户的环签名\n已注册的种子公钥公开可见 ↓ 伪造某个诚实用户的环签名sig_seed ↓ 认证新的灵魂账户 防御分析：\n方法A的防御：\n依赖两个密码学保证： 1. EdDSA算法的不可伪造性 → 攻击者无法伪造任何诚实用户的sig_holder 2. zkSNARK的可靠性 → 没有有效签名，无法创建有效的zkSNARK证明 结论：攻击者无法通过伪造签名获得种子公钥 方法B的防御：\n依赖可链接环签名的不可伪造性： - 攻击者无法伪造任何已注册种子账户的有效签名 - 即使种子公钥公开可见 结论：攻击者无法冒充诚实用户认证灵魂账户 总结：zkBID协议能够抵御伪造攻击\n安全性总结表 攻击类型 攻击目标 依赖的安全属性 防御结果 女巫攻击-方法A 重复注册PHC 哈希抗碰撞性 + zkSNARK可靠性 ✅ 安全 女巫攻击-方法B 重复使用种子密钥 可链接环签名的可链接性 ✅ 安全 链接攻击 破坏匿名性 可链接环签名的签名者模糊性 ✅ 安全 伪造攻击-方法A 伪造身份验证 EdDSA不可伪造性 + zkSNARK可靠性 ✅ 安全 伪造攻击-方法B 伪造账户认证 可链接环签名不可伪造性 ✅ 安全 实验评估 实验环境 测试网络配置 区块链测试网络：\n平台：阿里云 节点数：6个以太坊全节点 共识协议：工作量证明（PoW） 客户端：Go-Ethereum 网络拓扑：全连接（每个节点有独立IP） 用户节点：\n1个用户节点连接到1个以太坊节点 运行用户端功能 硬件配置（所有节点）：\n操作系统：Ubuntu 20.04 CPU：Intel(R) Core(TM) i7-10700 @ 2.90GHz 内存：48GB RAM 实现技术栈 智能合约：\n语言：Solidity 部署：以太坊测试网络 zkSNARK：\n算法：Groth16 平台：Circom 2 功能：Setup和证明生成 可链接环签名：\n算法：MLSAGS 用户端实现：Python（密钥生成、签名算法） 合约实现：Solidity（签名验证） 性能评估指标 指标 说明 重要性 ZK证明生成时间 Groth16证明算法的执行时间 影响用户体验 ZK证明大小 证明所占字节数 影响链上存储 ZK证明验证成本 智能合约验证所需Gas 影响使用成本 算术电路大小 R1CS约束数量 影响系统复杂度 MLSAGS签名生成时间 环签名生成的执行时间 影响用户体验 MLSAGS签名验证成本 智能合约验证所需Gas 影响使用成本 实验结果 1. Groth16性能测试 测试方案：\n使用单个算术电路验证多个PHC批次 测试不同批次大小下的性能表现 图表 6(a)：电路大小和证明大小 PHC批次大小 R1CS约束数量 ZK证明大小 1 ~19,000 192 Bytes 2 ~38,000 192 Bytes 4 ~76,000 192 Bytes 8 ~152,000 192 Bytes 16 ~304,000 192 Bytes 32 ~608,000 192 Bytes 64 ~1,216,000 192 Bytes 128 ~2,432,000 192 Bytes 关键发现：\n✨ 证明大小恒定：无论批次大小如何，证明始终为192字节 这是Groth16的核心优势：简洁性（Succinctness） 电路大小随批次线性增长 图表 6(b)：证明生成时间和验证成本 证明生成时间：\nPHC批次大小 生成时间 (ms) 增长趋势 1 ~2,000 基准 2 ~4,000 2x 4 ~8,000 4x 8 ~16,000 8x 16 ~32,000 16x 32 ~64,000 32x 证明验证成本（Gas）：\nPHC批次大小 验证Gas消耗 单个PHC平均Gas 1 215.7K 215.7K 2 247.2K 123.6K 4 310.2K 77.6K 8 436.2K 54.5K 16 688.2K 43.0K 32 1,040.0K 32.5K 关键发现：\n📈 线性增长：生成时间和验证成本都与批次大小呈线性关系\n💰\n批处理优势\n：批次大小为32时，单个PHC的Gas消耗仅为32.5K\n相比单独验证（215.7K），节省约85% 效率提升约7倍 ⚠️ 部署限制：批次大小≥64时，验证合约因以太坊合约大小限制无法部署\n最佳实践建议：\n推荐批次大小：16-32个PHC - 在合约大小限制内 - 获得显著的Gas优化 - 用户体验可接受 2. MLSAGS性能测试 测试方案：\n测试不同环大小L下的签名生成和验证性能 环大小影响匿名性和性能的权衡 图表 6(c)：MLSAGS性能指标 签名生成时间：\n环大小 L 生成时间 (ms) 增量时间 1 ~40 - 2 ~80 +40ms 4 ~160 +40ms 8 ~320 +40ms 16 ~640 +40ms 32 ~1,280 +40ms 64 ~2,560 +40ms 128 ~5,120 +40ms 签名验证成本（Gas）：\n环大小 L 验证Gas消耗 增量Gas 1 ~57K - 2 ~114K +57K 4 ~228K +57K 8 ~456K +57K 16 ~912K +57K 32 ~1,824K +57K 64 ~3,648K +57K 128 ~7,296K +57K 关键发现：\n📏\n完美线性关系\n：\n每增加1个公钥，生成时间增加约40ms 每增加1个公钥，验证Gas增加约57K ⚖️\n匿名性vs效率权衡\n：\n环越大 → 匿名性越强（攻击者猜中概率 = 1/L） 环越大 → 成本越高（时间和Gas） 匿名性分析：\n环大小 L 攻击者成功率 匿名性等级 Gas成本 10 10% 较弱 570K 50 2% 中等 2,850K 100 1% 强 5,700K 1000 0.1% 非常强 57,000K 实际应用建议：\n小规模应用（\u0026lt; 1000用户）： 环大小：10-20 匿名性：10%-5%攻击成功率 Gas成本：570K-1,140K（可接受） 中等规模应用（1000-10000用户）： 环大小：50-100 匿名性：2%-1%攻击成功率 Gas成本：2,850K-5,700K（需要优化） 大规模应用（\u0026gt; 10000用户）： 环大小：100+ 匿名性：\u0026lt; 1%攻击成功率 Gas成本：\u0026gt; 5,700K（需要Layer 2或批处理） 性能优化建议 1. 对于zkSNARK部分 批处理策略：\n低频场景（个人注册）： - 批次大小：1-4 - 适用：个人用户单次注册 - 优点：即时处理 - 缺点：Gas成本较高（215K-310K） 高频场景（批量注册）： - 批次大小：16-32 - 适用：组织批量入职、大规模注册活动 - 优点：Gas效率提升7倍 - 缺点：需要等待批次凑齐 2. 对于MLSAGS部分 环大小配置：\n# 根据用户总数动态调整 def calculate_ring_size(total_users, target_anonymity=0.01): \u0026#34;\u0026#34;\u0026#34; total_users: 系统总用户数 target_anonymity: 目标攻击成功率（如0.01 = 1%） \u0026#34;\u0026#34;\u0026#34; # 环大小不超过总用户数 ring_size = min(int(1 / target_anonymity), total_users) # 考虑Gas成本限制（假设单笔交易Gas上限为8M） max_affordable_ring = 8_000_000 / 57_000 # ≈ 140 return min(ring_size, max_affordable_ring) # 示例 calculate_ring_size(1000, 0.01) # 返回 100 calculate_ring_size(10000, 0.01) # 返回 100（受成本限制） calculate_ring_size(50, 0.01) # 返回 50（受用户数限制） 分层匿名策略：\nVIP用户/高价值账户： - 使用较大环（100+） - 提供更强匿名性 - 愿意支付更高Gas 普通用户： - 使用中等环（20-50） - 平衡匿名性和成本 - 实际应用最常见 测试/低价值账户： - 使用小环（10-20） - 基本匿名性 - 成本最低 实验结论 zkSNARK的优势： ✅ 证明大小恒定（192字节）：不受批次影响 ✅ 批处理优化显著：32个PHC可节省85% Gas ✅ 验证快速：链上验证成本可接受 MLSAGS的特性： ✅ 性能可预测：完美线性关系 ⚠️ 需要权衡：匿名性与成本呈正比 ✅ 灵活配置：可根据场景调整环大小 系统可行性： ✅ 在实际以太坊网络上完全可行 ✅ 通过参数优化可适应不同规模 ✅ 性能瓶颈明确且可优化 相关工作对比 现有方案分析 论文对比了8个相关的区块链身份方案：\n方案 年份 主要技术 应用场景 TradeMap [12] 2019 ZKP 符合FINMA的匿名KYC平台 Pauwels et al. [14] 2022 zkSNARK DeFi协议的KYC系统 Aydar et al. [3] 2019 Blockchain 数字身份验证框架 Singh et al. [18] 2020 Credential Protocol 保护个人属性的身份系统 Abraham et al. [1] 2020 SSI Model 支持凭证撤销的自主身份 ZEBRA [15] 2022 zkSNARK 链上匿名凭证验证 Zhang et al. [26] 2024 ZKP 能源交易身份认证 Kim et al. [10] 2023 SBT + DID 元宇宙的KYC系统 设计目标对比 方案 DG1 技术灵活性 DG2 身份匿名性 DG3 身份可信性 DG4 隐私存储 TradeMap [12] ✅ ❌ ❌ ❌ Pauwels [14] ✅ ❌ ✅ ✅ Aydar [3] ❌ ✅ ❌ ❌ Singh [18] ❌ ✅ ✅ ✅ Abraham [1] ✅ ✅ ❌ ❌ ZEBRA [15] ❌ ✅ ❌ ❌ Zhang [26] ✅ ❌ ✅ ❌ Kim [10] ❌ ✅ ❌ ❌ zkBID ✅ ✅ ✅ ✅ 设计目标说明：\nDG1 - 技术灵活性：不局限于特定的ZKP算法或区块链平台 DG2 - 身份匿名性：无法从链上活动推断用户真实身份 DG3 - 身份可信性：每个身份可信地连接到真实世界用户 DG4 - 隐私存储：身份文档保密存储，不公开可见 zkBID的独特优势 1. 唯一全面满足所有设计目标 其他方案的局限： ├─ TradeMap: 只关注合规性，缺乏匿名性和可信映射 ├─ Pauwels: DeFi场景，但身份匿名性不足 ├─ Aydar/Singh: 技术灵活性差，绑定特定实现 ├─ Abraham/ZEBRA: 缺乏与真实用户的可信绑定 ├─ Zhang: 特定场景（能源交易），匿名性不足 └─ Kim: 元宇宙场景，技术灵活性和可信性不足 zkBID的创新： ✅ 同时实现匿名性和可信性（看似矛盾的目标） ✅ 完全去中心化（无需可信第三方） ✅ 技术灵活（可替换ZKP算法和环签名方案） ✅ 隐私保护（身份信息不上链） 2. 技术组合的创新性 现有方案的技术使用：\n大多只使用zkSNARK进行凭证验证 少数使用环签名，但未实现身份-账户绑定 没有方案同时使用zkSNARK + 可链接环签名 zkBID的技术创新：\nzkSNARK（阶段1-2）： 目的：验证PHC有效性 优势：不泄露PHC内容 创新：批处理优化 可链接环签名（阶段3）： 目的：建立身份-账户映射 优势：保持匿名性的同时确保一对一 创新：使用密钥图像防止重复绑定 组合效果： = 可验证的身份 + 不可追踪的账户绑定 = 可信匿名（Credible Anonymity） 3. 实际应用价值 传统KYC系统的问题：\n中心化KYC： ❌ 隐私泄露风险 ❌ 数据被服务商控制 ❌ 跨平台不互通 区块链匿名账户： ❌ 无法防止女巫攻击 ❌ 信誉系统难以建立 ❌ 监管合规困难 zkBID的解决方案：\n对用户： ✅ 保护隐私（身份信息不泄露） ✅ 自主控制（无需信任中心化机构） ✅ 一次认证，多处使用 对平台： ✅ 防止女巫攻击（一人一账户） ✅ 建立信誉系统（账户可信） ✅ 满足监管要求（有认证机制） 对监管： ✅ 可验证的身份（PHC由可信机构签发） ✅ 可追责性（必要时可追踪） ✅ 隐私保护合规 应用场景 1. 去中心化社交网络 问题：\nTwitter/X上的机器人和假账户泛滥 难以区分真人和AI生成的内容 水军和虚假舆论操纵 zkBID解决方案：\n用户注册： 1. 用政府ID获取PHC 2. 通过zkBID认证获得灵魂账户 3. 使用灵魂账户在社交网络发布内容 效果： ✅ 每个账户对应一个真人 ✅ 保持用户匿名性 ✅ 机器人和假账户显著减少 ✅ 信誉系统可以建立在灵魂账户上 2. DAO治理 问题：\n一人多账户操纵投票 女巫攻击破坏治理公平性 难以验证投票者资格 zkBID解决方案：\n治理流程： 1. DAO成员通过zkBID认证 2. 每个灵魂账户 = 一个真实成员 3. 投票时保持匿名 4. 防止多重投票 效果： ✅ 一人一票（真正的民主） ✅ 投票匿名（防止胁迫和贿赂） ✅ 可验证（确保只有成员投票） ✅ 信誉加权（可基于历史贡献） 3. DeFi空投和激励 问题：\n空投被羊毛党多账户瓜分 难以识别真实用户 激励机制被滥用 zkBID解决方案：\n空投流程： 1. 要求使用zkBID认证的灵魂账户 2. 每个灵魂账户只能领取一次 3. 基于链上行为的信誉评分 效果： ✅ 公平分配（每人一份） ✅ 防止女巫攻击 ✅ 识别真实活跃用户 ✅ 建立长期激励机制 4. Web3游戏和元宇宙 问题：\n工作室多开刷金币 游戏经济被破坏 难以建立公平竞技环境 zkBID解决方案：\n游戏应用： 1. 玩家使用灵魂账户登录 2. 游戏内资产绑定到灵魂账户 3. 排行榜和竞技只认可灵魂账户 效果： ✅ 一人一号（公平竞争） ✅ 资产真实归属 ✅ 游戏经济稳定 ✅ 社交关系可信 5. 去中心化信用系统 问题：\n传统信用系统中心化 跨平台信用不互通 隐私泄露风险 zkBID解决方案：\n信用体系： 1. 灵魂账户作为信用载体 2. 链上行为建立信用历史 3. 跨DApp信用互认 4. 保护用户隐私 效果： ✅ 去中心化信用（不被单一机构控制） ✅ 可移植性（跨平台使用） ✅ 隐私保护（匿名但可信） ✅ 防止信用欺诈（一人一信用档案） 局限性与未来工作 当前局限性 1. 性能限制 Gas成本：\n当前状态： - 单次PHC验证：215.7K Gas - 环大小100的签名验证：5,700K Gas - 在以太坊主网上成本较高 影响： ❌ 大规模应用成本高 ❌ 限制了环大小（影响匿名性） 可能的解决方案：\nLayer 2方案（如Optimism、Arbitrum） 侧链部署 批处理优化 2. PHC依赖 当前状态：\n依赖可信的PHC颁发机构： - 政府机构 - 大型科技公司 - 其他可信第三方 问题： ❌ PHC系统尚未广泛部署 ❌ 不同颁发者的互操作性 ❌ 颁发者可能成为中心化风险点 3. 隐私权衡 匿名性级别：\n环大小的限制： - 小环（\u0026lt;20）：匿名性较弱 - 大环（100+）：成本高昂 - 实际应用中需要权衡 4. 撤销机制 当前缺失：\n无法撤销已认证的灵魂账户： ❌ 如果PHC被吊销怎么办？ ❌ 如果用户想注销怎么办？ ❌ 如果发现欺诈怎么办？ 需要设计： - 灵活的撤销机制 - 保持匿名性的撤销 - 防止滥用撤销权 未来研究方向 1. 性能优化 方向A：递归证明：\n使用递归zkSNARK： - 将多个证明聚合成一个 - 减少链上验证成本 - 提高批处理效率 预期效果： - Gas成本降低50%+ - 支持更大批次 方向B：量子抗性：\n替换为抗量子密码算法： - 格基密码学 - 哈希基签名 - 为后量子时代做准备 2. PHC生态系统 多颁发者互操作：\n标准化PHC格式： - 统一的VC模板 - 跨颁发者互认 - 去中心化颁发者网络 目标： - 减少单点故障 - 提高可用性 - 增强去中心化 去中心化PHC颁发：\n探索无需中心化颁发者的方案： - 基于生物识别的去中心化验证 - 社交图谱验证 - 组合多种验证方式 3. 隐私增强 方向A：动态环：\n允许用户动态选择环大小： - 根据交易重要性调整 - 重要交易用大环 - 普通交易用小环 效果： - 灵活性提高 - 成本优化 方向B：分层匿名：\n不同隐私级别的灵魂账户： - 公开级：最小匿名性，低成本 - 标准级：中等匿名性，中等成本 - 隐私级：高匿名性，高成本 4. 跨链支持 多链部署：\n扩展到其他区块链： - Polkadot/Cosmos生态 - 高性能链（Solana、Aptos） - 专用隐私链（Zcash、Monero概念） 跨链身份： - 一个PHC，多链认证 - 统一的身份层 5. 撤销和恢复机制 优雅的撤销：\n设计保护隐私的撤销： - 使用累加器（Accumulator） - 撤销列表不泄露身份 - 高效的撤销验证 恢复机制： - PHC过期后的更新流程 - 密钥丢失的恢复方案 - 保持连续性的信誉迁移 6. 合规和监管 可选的透明性：\n为监管场景设计： - 选择性披露机制 - 紧急情况下的去匿名化 - 法院命令的执行 平衡： - 保护普通用户隐私 - 满足反洗钱（AML）要求 - 支持合法调查 关键takeaways 技术创新 可信匿名的突破： 首次在区块链上实现\u0026quot;可信\u0026quot;+\u0026ldquo;匿名\u0026quot;的结合 通过零知识证明保护隐私 通过可链接环签名确保一对一映射 完全去中心化： 无需可信第三方参与验证 所有逻辑在智能合约中执行 用户完全控制自己的身份 实用性验证： 在真实以太坊测试网络上实现 性能指标明确可测 成本可接受且可优化 理论贡献 身份模型创新：\n传统模型：身份 → 账户（可见映射） zkBID模型：身份 → [ZK层] → 种子 → [环签名层] → 账户 创新点： - 两层隐私保护 - 可验证但不可追踪 - 数学上可证明的安全性 密码学组合：\nzkSNARK + 可链接环签名的首次组合应用 各取所长，弥补对方不足 为未来类似系统提供范式 实践意义 Web3基础设施： 为Web3提供关键的身份层 解决匿名性与可信性的矛盾 使去中心化应用更实用 防止AI冒充： 在AI时代区分人类和机器 PHC作为\u0026quot;数字人格证\u0026rdquo; 保护在线空间的人类性 新经济模式： 支持基于信誉的去中心化经济 公平的激励分配机制 可持续的社区治理 结论 zkBID是一个创新的Web 3.0去中心化身份方案，成功解决了区块链账户系统中匿名性与可信性的矛盾。\n核心成就 ✅ 技术突破：\n零知识证明保护身份隐私 可链接环签名确保一对一映射 完全去中心化的验证机制 ✅ 安全保证：\n抵御女巫攻击 抵御链接攻击 抵御伪造攻击 ✅ 实用验证：\n以太坊测试网络成功部署 性能指标满足实际应用需求 成本可通过参数优化控制 未来展望 zkBID为Web3去中心化身份提供了一个可行的解决方案，但仍有改进空间：\n继续优化性能和成本 推动PHC生态系统发展 探索跨链和多链支持 完善撤销和恢复机制 平衡隐私保护 ","permalink":"http://localhost:1313/posts/linking-souls-to-humans/","summary":"zkBID通过零知识证明和可链接环签名技术，首次实现了区块链账户的\u0026quot;可信匿名\u0026quot;：每个账户与真实用户一对一绑定（可信），但外界无法追踪具体对应关系（匿名）。系统采用三阶段IVAC流程，将人格凭证(PHC)通过零知识证明验证后绑定到种子公钥，再用环签名将种子公钥关联到灵魂账户。实验显示批处理可将验证成本降低85%，环大小灵活可调以平衡匿名性与效率。该方案为Web3提供了关键身份基础设施，可有效防止女巫攻击，支持去中心化社交、DAO治理、DeFi空投等场景。","title":"zkBID: 区块链账户与Web 3.0去中心化身份"},{"content":"📚 Part 1: Java 集合使用手册 0.String - 不可变字符串 // 初始化 String s = \u0026#34;hello\u0026#34;; String s2 = new String(\u0026#34;world\u0026#34;); String s3 = String.valueOf(123); // 数字转字符串 // 基本属性 int len = s.length(); // 长度 boolean empty = s.isEmpty(); // 是否为空 char ch = s.charAt(0); // 获取字符 // 查找 int index = s.indexOf(\u0026#34;ll\u0026#34;); // 查找子串位置 int lastIndex = s.lastIndexOf(\u0026#34;l\u0026#34;); // 最后出现位置 boolean contains = s.contains(\u0026#34;el\u0026#34;); // 是否包含 // 截取 String sub = s.substring(1, 4); // [1, 4) 截取 String sub2 = s.substring(2); // 从索引2到结尾 // 替换 String replaced = s.replace(\u0026#34;l\u0026#34;, \u0026#34;L\u0026#34;); // 替换所有 String replaced2 = s.replaceFirst(\u0026#34;l\u0026#34;, \u0026#34;L\u0026#34;); // 替换第一个 String replaced3 = s.replaceAll(\u0026#34;[aeiou]\u0026#34;, \u0026#34;*\u0026#34;); // 正则替换 // 分割 String[] parts = \u0026#34;a,b,c\u0026#34;.split(\u0026#34;,\u0026#34;); // 按分隔符分割 String[] parts2 = \u0026#34;a b c\u0026#34;.split(\u0026#34;\\\\s+\u0026#34;); // 按空格分割 // 拼接 String joined = String.join(\u0026#34;,\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); // \u0026#34;a,b,c\u0026#34; String concat = s.concat(\u0026#34; world\u0026#34;); // 拼接 // 大小写 String upper = s.toUpperCase(); String lower = s.toUpperCase().toLowerCase(); // 去空格 String trimmed = \u0026#34; hello \u0026#34;.trim(); // 去两端空格 String stripped = \u0026#34; hello \u0026#34;.strip(); // Java 11+ // 比较 boolean equals = s.equals(\u0026#34;hello\u0026#34;); boolean equalsIgnoreCase = s.equalsIgnoreCase(\u0026#34;HELLO\u0026#34;); int compare = s.compareTo(\u0026#34;world\u0026#34;); // 字典序比较 // 判断 boolean startsWith = s.startsWith(\u0026#34;he\u0026#34;); boolean endsWith = s.endsWith(\u0026#34;lo\u0026#34;); // 转换 char[] chars = s.toCharArray(); // 转字符数组 byte[] bytes = s.getBytes(); // 转字节数组 StringBuilder - 可变字符串 使用场景：单线程环境下需要频繁修改字符串\n// 初始化 StringBuilder sb = new StringBuilder(); StringBuilder sb2 = new StringBuilder(\u0026#34;hello\u0026#34;); StringBuilder sb3 = new StringBuilder(100); // 指定初始容量 // 添加（拼接） sb.append(\u0026#34;hello\u0026#34;); // 尾部添加 sb.append(123); // 添加数字 sb.append(\u0026#39;!\u0026#39;); // 添加字符 sb.insert(0, \u0026#34;start \u0026#34;); // 指定位置插入 // 删除 sb.delete(0, 5); // 删除 [0, 5) sb.deleteCharAt(0); // 删除指定位置 sb.setLength(0); // 清空（重置长度为0） // 修改 sb.replace(0, 5, \u0026#34;world\u0026#34;); // 替换 [0, 5) sb.setCharAt(0, \u0026#39;H\u0026#39;); // 修改指定位置字符 // 反转 sb.reverse(); // 查询 int len = sb.length(); char ch = sb.charAt(0); String sub = sb.substring(0, 5); // 转换为 String String result = sb.toString(); // 常见应用：循环拼接字符串 StringBuilder result = new StringBuilder(); for (int i = 0; i \u0026lt; 1000; i++) { result.append(i).append(\u0026#34;,\u0026#34;); } // 比用 String + 拼接快得多！ StringBuffer - 可变字符串 使用场景：多线程环境下需要频繁修改字符串\n// API 与 StringBuilder 完全相同 StringBuffer sb = new StringBuffer(); sb.append(\u0026#34;hello\u0026#34;); sb.append(\u0026#34; world\u0026#34;); String result = sb.toString(); // 区别：StringBuffer 的方法都是 synchronized 的 // 多线程安全，但性能比 StringBuilder 差 常用字符串操作技巧 // 1. 字符串转数字 int num = Integer.parseInt(\u0026#34;123\u0026#34;); long l = Long.parseLong(\u0026#34;123\u0026#34;); double d = Double.parseDouble(\u0026#34;3.14\u0026#34;); // 2. 数字转字符串 String s1 = String.valueOf(123); String s2 = Integer.toString(123); String s3 = \u0026#34;\u0026#34; + 123; // 不推荐 // 3. 字符串数组拼接 String[] arr = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; String joined = String.join(\u0026#34;,\u0026#34;, arr); // \u0026#34;a,b,c\u0026#34; // 4. 重复字符串（Java 11+） String repeated = \u0026#34;ab\u0026#34;.repeat(3); // \u0026#34;ababab\u0026#34; // 5. 判断空字符串 if (s != null \u0026amp;\u0026amp; !s.isEmpty()) { } if (s != null \u0026amp;\u0026amp; !s.isBlank()) { } // Java 11+，忽略空白字符 // 6. 字符串格式化 String formatted = String.format(\u0026#34;Hello %s, you are %d years old\u0026#34;, \u0026#34;Alice\u0026#34;, 25); 1. List - 列表 ArrayList - 动态数组 // 初始化 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); List\u0026lt;Integer\u0026gt; list3 = new ArrayList\u0026lt;\u0026gt;(100); // 指定初始容量 // 增 list.add(1); // 尾部添加 list.add(0, 10); // 指定位置添加 list.addAll(Arrays.asList(2,3,4)); // 批量添加 // 删 list.remove(0); // 删除指定索引 list.remove(Integer.valueOf(1)); // 删除指定元素 list.clear(); // 清空 // 改 list.set(0, 100); // 修改指定位置 // 查 int val = list.get(0); // 获取元素 int size = list.size(); // 获取大小 boolean empty = list.isEmpty(); // 是否为空 boolean contains = list.contains(1); // 是否包含 int index = list.indexOf(1); // 查找索引 // 遍历 for (int num : list) { System.out.println(num); } // 或使用迭代器 Iterator\u0026lt;Integer\u0026gt; it = list.iterator(); while (it.hasNext()) { System.out.println(it.next()); } LinkedList - 双向链表 LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 头部操作 list.addFirst(1); list.removeFirst(); int first = list.getFirst(); // 尾部操作 list.addLast(2); list.removeLast(); int last = list.getLast(); // 作为队列使用 list.offer(3); // 入队 int head = list.poll(); // 出队 // 作为栈使用 list.push(4); // 入栈 int top = list.pop(); // 出栈 2. Set - 集合 HashSet - 无序不重复 // 初始化 Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); // 增 set.add(1); set.addAll(Arrays.asList(2, 3, 4)); // 删 set.remove(1); set.clear(); // 查 boolean contains = set.contains(1); int size = set.size(); boolean empty = set.isEmpty(); // 遍历 for (int num : set) { System.out.println(num); } TreeSet - 有序集合（红黑树） TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 基本操作同 HashSet set.add(3); set.add(1); set.add(2); System.out.println(set); // [1, 2, 3] 自动排序 // 特有方法 int first = set.first(); // 最小元素 int last = set.last(); // 最大元素 int lower = set.lower(2); // 小于 2 的最大元素 int higher = set.higher(2); // 大于 2 的最小元素 int floor = set.floor(2); // ≤ 2 的最大元素 int ceiling = set.ceiling(2); // ≥ 2 的最小元素 // 子集操作 SortedSet\u0026lt;Integer\u0026gt; subset = set.subSet(1, 3); // [1, 3) SortedSet\u0026lt;Integer\u0026gt; headSet = set.headSet(2); // \u0026lt; 2 SortedSet\u0026lt;Integer\u0026gt; tailSet = set.tailSet(2); // \u0026gt;= 2 LinkedHashSet - 保持插入顺序 Set\u0026lt;Integer\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); set.add(3); set.add(1); set.add(2); System.out.println(set); // [3, 1, 2] 保持插入顺序 3. Map - 映射 HashMap - 键值对 // 初始化 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 增/改 map.put(\u0026#34;apple\u0026#34;, 1); map.put(\u0026#34;banana\u0026#34;, 2); map.putIfAbsent(\u0026#34;apple\u0026#34;, 10); // 键不存在时才添加 // 删 map.remove(\u0026#34;apple\u0026#34;); map.clear(); // 查 int val = map.get(\u0026#34;apple\u0026#34;); int valOrDefault = map.getOrDefault(\u0026#34;orange\u0026#34;, 0); boolean hasKey = map.containsKey(\u0026#34;apple\u0026#34;); boolean hasValue = map.containsValue(1); int size = map.size(); // 遍历键值对 for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { String key = entry.getKey(); int value = entry.getValue(); } // 遍历键 for (String key : map.keySet()) { System.out.println(key); } // 遍历值 for (int value : map.values()) { System.out.println(value); } // Java 8+ 新方法 map.computeIfAbsent(\u0026#34;cherry\u0026#34;, k -\u0026gt; 3); map.merge(\u0026#34;apple\u0026#34;, 1, Integer::sum); // 累加 TreeMap - 有序映射（红黑树） TreeMap\u0026lt;Integer, String\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); map.put(3, \u0026#34;c\u0026#34;); map.put(1, \u0026#34;a\u0026#34;); map.put(2, \u0026#34;b\u0026#34;); // 基本操作同 HashMap // 特有方法 int firstKey = map.firstKey(); int lastKey = map.lastKey(); Map.Entry\u0026lt;Integer, String\u0026gt; firstEntry = map.firstEntry(); Map.Entry\u0026lt;Integer, String\u0026gt; lastEntry = map.lastEntry(); int lowerKey = map.lowerKey(2); // \u0026lt; 2 的最大键 int higherKey = map.higherKey(2); // \u0026gt; 2 的最小键 int floorKey = map.floorKey(2); // \u0026lt;= 2 的最大键 int ceilingKey = map.ceilingKey(2); // \u0026gt;= 2 的最小键 LinkedHashMap - 保持插入顺序 Map\u0026lt;String, Integer\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;c\u0026#34;, 3); map.put(\u0026#34;a\u0026#34;, 1); map.put(\u0026#34;b\u0026#34;, 2); // 遍历时保持插入顺序: c, a, b 4. Queue - 队列 普通队列 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 入队 queue.offer(1); queue.add(2); // 队列满时抛异常 // 出队 int head = queue.poll(); // 空时返回 null int head2 = queue.remove(); // 空时抛异常 // 查看队首 int peek = queue.peek(); // 空时返回 null int peek2 = queue.element(); // 空时抛异常 PriorityQueue - 优先队列（堆） // 小根堆（默认） PriorityQueue\u0026lt;Integer\u0026gt; minHeap = new PriorityQueue\u0026lt;\u0026gt;(); // 大根堆 PriorityQueue\u0026lt;Integer\u0026gt; maxHeap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); // 自定义对象 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); minHeap.offer(3); minHeap.offer(1); minHeap.offer(2); while (!minHeap.isEmpty()) { System.out.println(minHeap.poll()); // 1, 2, 3 } Deque - 双端队列 Deque\u0026lt;Integer\u0026gt; deque = new ArrayDeque\u0026lt;\u0026gt;(); // 头部操作 deque.offerFirst(1); deque.pollFirst(); deque.peekFirst(); // 尾部操作 deque.offerLast(2); deque.pollLast(); deque.peekLast(); // 作为栈使用 deque.push(3); int top = deque.pop(); 5. Stack - 栈 Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(1); // 入栈 int top = stack.pop(); // 出栈 int peek = stack.peek(); // 查看栈顶 boolean empty = stack.isEmpty(); int size = stack.size(); // 推荐使用 Deque 代替 Stack Deque\u0026lt;Integer\u0026gt; stack2 = new ArrayDeque\u0026lt;\u0026gt;(); 🧮 Part 2: 算法模板 1. 树的遍历 二叉树定义 class TreeNode { int val; // 节点值 TreeNode left; // 左子节点 TreeNode right; // 右子节点 TreeNode(int val) { this.val = val; } } DFS - 深度优先遍历 前序遍历（根-左-右） // 递归版本 - 最简洁直观 void preorder(TreeNode root) { if (root == null) return; // 递归终止条件：空节点 System.out.println(root.val); // 1. 先访问根节点 preorder(root.left); // 2. 再遍历左子树 preorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 使用栈模拟递归 List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); // 根节点入栈 while (!stack.isEmpty()) { TreeNode node = stack.pop(); // 弹出栈顶节点 res.add(node.val); // 访问该节点 // 关键：先压右子节点，再压左子节点 // 这样出栈时左子节点先出（栈是后进先出） if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); } return res; } 中序遍历（左-根-右） // 递归版本 void inorder(TreeNode root) { if (root == null) return; // 递归终止条件 inorder(root.left); // 1. 先遍历左子树 System.out.println(root.val); // 2. 再访问根节点 inorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 一直向左走到底 List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode curr = root; while (curr != null || !stack.isEmpty()) { // 第一步：一直向左走到底，沿途节点入栈 while (curr != null) { stack.push(curr); curr = curr.left; } // 第二步：弹出栈顶（当前最左节点），访问它 curr = stack.pop(); res.add(curr.val); // 第三步：转向右子树 curr = curr.right; } return res; } 后序遍历（左-右-根） // 递归版本 void postorder(TreeNode root) { if (root == null) return; // 递归终止条件 postorder(root.left); // 1. 先遍历左子树 postorder(root.right); // 2. 再遍历右子树 System.out.println(root.val); // 3. 最后访问根节点 } // 迭代版本 - 巧妙方法：前序遍历变形 + 反转 // 思路：前序是\u0026#34;根左右\u0026#34;，改成\u0026#34;根右左\u0026#34;，反转后得到\u0026#34;左右根\u0026#34; List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); res.add(node.val); // 添加到结果（根右左顺序） // 注意：这里先左后右，出栈时就是先右后左 if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); } Collections.reverse(res); // 反转得到左右根 return res; } BFS - 层序遍历 // 按层遍历二叉树，每层的节点放在一个列表中 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); // 根节点入队 while (!queue.isEmpty()) { int size = queue.size(); // 当前层的节点数（重要！） List\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); // 遍历当前层的所有节点 for (int i = 0; i \u0026lt; size; i++) { TreeNode node = queue.poll(); // 出队 level.add(node.val); // 记录节点值 // 将下一层的节点入队 if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } res.add(level); // 保存当前层结果 } return res; } 线段树（Segment Tree） /** * 线段树：用于高效处理区间查询和单点修改 * 时间复杂度：构建 O(n)，查询 O(log n)，更新 O(log n) */ class SegmentTree { private int[] tree; // 线段树数组 private int n; // 原数组大小 public SegmentTree(int[] nums) { n = nums.length; tree = new int[4 * n]; // 线段树最多需要 4n 空间 build(nums, 0, 0, n - 1); } // 构建线段树：递归构建 // node: 当前节点在 tree 中的索引 // start, end: 当前节点代表的区间 [start, end] private void build(int[] nums, int node, int start, int end) { if (start == end) { // 叶子节点：直接存储原数组的值 tree[node] = nums[start]; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; // 左子节点索引 int rightNode = 2 * node + 2; // 右子节点索引 // 递归构建左右子树 build(nums, leftNode, start, mid); build(nums, rightNode, mid + 1, end); // 当前节点的值 = 左子树 + 右子树（区间和） tree[node] = tree[leftNode] + tree[rightNode]; } // 区间查询：查询区间 [l, r] 的和 public int query(int l, int r) { return query(0, 0, n - 1, l, r); } private int query(int node, int start, int end, int l, int r) { // 情况1：当前区间与查询区间完全不相交 if (l \u0026gt; end || r \u0026lt; start) return 0; // 情况2：当前区间完全包含在查询区间内 if (l \u0026lt;= start \u0026amp;\u0026amp; end \u0026lt;= r) return tree[node]; // 情况3：部分相交，需要递归查询左右子树 int mid = start + (end - start) / 2; int leftSum = query(2 * node + 1, start, mid, l, r); int rightSum = query(2 * node + 2, mid + 1, end, l, r); return leftSum + rightSum; } // 单点更新：将 index 位置的值更新为 val public void update(int index, int val) { update(0, 0, n - 1, index, val); } private void update(int node, int start, int end, int index, int val) { if (start == end) { // 找到叶子节点，更新值 tree[node] = val; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; int rightNode = 2 * node + 2; // 判断 index 在左子树还是右子树 if (index \u0026lt;= mid) { update(leftNode, start, mid, index, val); } else { update(rightNode, mid + 1, end, index, val); } // 更新完子树后，更新当前节点 tree[node] = tree[leftNode] + tree[rightNode]; } } 2. 图算法 图的表示 // 方式1：邻接表（适合稀疏图） Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; graph = new HashMap\u0026lt;\u0026gt;(); // 或使用 ArrayList List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); // 方式2：邻接矩阵（适合密集图） int[][] graph = new int[n][n]; // graph[i][j] 表示 i 到 j 的边权 DFS - 图的深度优先遍历 // 递归实现 DFS void dfs(int node, Set\u0026lt;Integer\u0026gt; visited, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { visited.add(node); // 标记当前节点已访问 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { // 如果邻居未访问 dfs(neighbor, visited, graph); // 递归访问邻居 } } } // 使用示例 Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); dfs(0, visited, graph); // 从节点 0 开始 DFS BFS - 图的广度优先遍历 // 使用队列实现 BFS void bfs(int start, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(start); // 起始节点入队 visited.add(start); // 标记已访问 while (!queue.isEmpty()) { int node = queue.poll(); // 出队 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { queue.offer(neighbor); // 邻居入队 visited.add(neighbor); // 标记已访问 } } } } 拓扑排序（Kahn 算法） /** * 拓扑排序：将有向无环图(DAG)转换为线性序列 * 应用：课程安排、任务调度等 * 核心思想：不断移除入度为0的节点 */ List\u0026lt;Integer\u0026gt; topologicalSort(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] inDegree = new int[n]; // 记录每个节点的入度 for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } // 构建图并计算入度 for (int[] edge : edges) { graph.get(edge[0]).add(edge[1]); // edge[0] -\u0026gt; edge[1] inDegree[edge[1]]++; // edge[1] 的入度+1 } // 将所有入度为0的节点入队 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (inDegree[i] == 0) { queue.offer(i); } } List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); while (!queue.isEmpty()) { int node = queue.poll(); res.add(node); // 将节点加入结果 // 删除该节点的所有出边 for (int neighbor : graph.get(node)) { inDegree[neighbor]--; // 邻居的入度-1 if (inDegree[neighbor] == 0) { // 入度变为0，入队 queue.offer(neighbor); } } } // 如果所有节点都被访问，说明无环，返回结果；否则返回空 return res.size() == n ? res : new ArrayList\u0026lt;\u0026gt;(); } Dijkstra 最短路径算法 /** * Dijkstra算法：单源最短路径（不能有负权边） * 时间复杂度：O(E log V)，E是边数，V是顶点数 * 核心思想：贪心，每次选择距离最小的未访问节点 */ int[] dijkstra(int n, int[][] edges, int start) { // 构建邻接表: {neighbor, weight} List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // edge = [from, to, weight] graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); } // dist[i] 表示从 start 到 i 的最短距离 int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 优先队列: {distance, node}，按距离从小到大排序 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); pq.offer(new int[]{0, start}); while (!pq.isEmpty()) { int[] curr = pq.poll(); int d = curr[0], node = curr[1]; // 如果当前距离大于已知最短距离，跳过 if (d \u0026gt; dist[node]) continue; // 遍历所有邻居，尝试松弛操作 for (int[] neighbor : graph.get(node)) { int next = neighbor[0], weight = neighbor[1]; int newDist = d + weight; // 如果找到更短的路径，更新距离 if (newDist \u0026lt; dist[next]) { dist[next] = newDist; pq.offer(new int[]{newDist, next}); } } } return dist; } Bellman-Ford 算法（可处理负权边） /** * Bellman-Ford算法：单源最短路径，可处理负权边 * 时间复杂度：O(V * E) * 可以检测负环 */ int[] bellmanFord(int n, int[][] edges, int start) { int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 松弛操作：最多进行 n-1 次 // 原理：最短路径最多包含 n-1 条边 for (int i = 0; i \u0026lt; n - 1; i++) { for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; // 松弛操作：如果经过 u 到 v 更短，则更新 if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { dist[v] = dist[u] + w; } } } // 第 n 次松弛：如果还能更新，说明存在负环 for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { return null; // 存在负环 } } return dist; } Floyd-Warshall 全源最短路径 /** * Floyd-Warshall算法：计算所有点对之间的最短路径 * 时间复杂度：O(V³) * 核心思想：动态规划，逐步加入中间节点 */ int[][] floydWarshall(int n, int[][] edges) { int[][] dist = new int[n][n]; // 初始化距离矩阵 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(dist[i], Integer.MAX_VALUE / 2); // 除以2防止溢出 dist[i][i] = 0; // 自己到自己距离为0 } // 填入边的权重 for (int[] edge : edges) { dist[edge[0]][edge[1]] = edge[2]; } // 动态规划：k 是中间节点 // dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) for (int k = 0; k \u0026lt; n; k++) { // 枚举中间节点 for (int i = 0; i \u0026lt; n; i++) { // 枚举起点 for (int j = 0; j \u0026lt; n; j++) { // 枚举终点 // 如果经过 k 中转更短，则更新 dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]); } } } return dist; } Prim 最小生成树 /** * Prim算法：构建最小生成树 * 时间复杂度：O(E log V) * 核心思想：从一个节点开始，逐步扩展，每次选最小边 */ int prim(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // 无向图：添加双向边 graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); graph.get(edge[1]).add(new int[]{edge[0], edge[2]}); } boolean[] visited = new boolean[n]; // 优先队列：{node, weight}，按权重从小到大 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[1] - b[1]); pq.offer(new int[]{0, 0}); // 从节点0开始，权重0 int totalWeight = 0; // 最小生成树的总权重 int edgeCount = 0; // 已添加的边数 while (!pq.isEmpty() \u0026amp;\u0026amp; edgeCount \u0026lt; n) { int[] curr = pq.poll(); int node = curr[0], weight = curr[1]; if (visited[node]) continue; // 已访问，跳过 visited[node] = true; totalWeight += weight; // 加入最小生成树 edgeCount++; // 将邻居节点的边加入优先队列 for (int[] neighbor : graph.get(node)) { if (!visited[neighbor[0]]) { pq.offer(neighbor); } } } // 如果所有节点都连通，返回总权重；否则返回-1 return edgeCount == n ? totalWeight : -1; } Kruskal 最小生成树（并查集） /** * 并查集：用于判断连通性和合并集合 */ class UnionFind { int[] parent; // parent[i] 表示 i 的父节点 int[] rank; // rank[i] 表示以 i 为根的树的高度 public UnionFind(int n) { parent = new int[n]; rank = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; // 初始时每个节点的父节点是自己 } } // 查找：找到 x 所在集合的代表元素（路径压缩） public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); // 路径压缩：直接连到根节点 } return parent[x]; } // 合并：将 x 和 y 所在的集合合并（按秩合并） public boolean union(int x, int y) { int rootX = find(x), rootY = find(y); if (rootX == rootY) return false; // 已经在同一集合 // 按秩合并：将矮树挂到高树上 if (rank[rootX] \u0026lt; rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] \u0026gt; rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; // 高度相同，随便挂，高度+1 } return true; } } /** * Kruskal算法：构建最小生成树 * 时间复杂度：O(E log E) * 核心思想：按边权从小到大排序，用并查集避免成环 */ int kruskal(int n, int[][] edges) { // 按边权从小到大排序 Arrays.sort(edges, (a, b) -\u0026gt; a[2] - b[2]); UnionFind uf = new UnionFind(n); int totalWeight = 0; int edgeCount = 0; for (int[] edge : edges) { // 如果两个节点不在同一集合，添加这条边 if (uf.union(edge[0], edge[1])) { totalWeight += edge[2]; edgeCount++; if (edgeCount == n - 1) break; // 最小生成树有 n-1 条边 } } return edgeCount == n - 1 ? totalWeight : -1; } 3. 回溯算法 组合问题 /** * 组合问题：从 n 个数中选 k 个数的所有组合 * 例如：n=4, k=2 -\u0026gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), 1, n, k); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int start, int n, int k) { // 递归终止条件：已选择 k 个数 if (path.size() == k) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 注意：要复制一份 return; } // 从 start 开始枚举，避免重复 for (int i = start; i \u0026lt;= n; i++) { path.add(i); // 做选择 backtrack(res, path, i + 1, n, k); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } 全排列 /** * 全排列问题：给定数组，返回所有可能的排列 * 例如：[1,2,3] -\u0026gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, new boolean[nums.length]); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, boolean[] used) { // 递归终止条件：所有数字都已使用 if (path.size() == nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } // 枚举所有数字 for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) continue; // 已使用过，跳过 path.add(nums[i]); // 做选择 used[i] = true; // 标记已使用 backtrack(res, path, nums, used); // 递归 used[i] = false; // 撤销标记（回溯） path.remove(path.size() - 1); // 撤销选择（回溯） } } 子集问题 /** * 子集问题：返回数组的所有子集（幂集） * 例如：[1,2,3] -\u0026gt; [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, int start) { // 每个状态都是一个子集 res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 枚举后续元素 for (int i = start; i \u0026lt; nums.length; i++) { path.add(nums[i]); // 做选择 backtrack(res, path, nums, i + 1); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } N 皇后问题 /** * N皇后问题：在 n×n 的棋盘上放置 n 个皇后，使它们互不攻击 * 规则：任意两个皇后不能在同一行、同一列、同一对角线 */ List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); char[][] board = new char[n][n]; // 初始化棋盘：\u0026#39;.\u0026#39; 表示空位 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(board[i], \u0026#39;.\u0026#39;); } backtrack(res, board, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res, char[][] board, int row) { // 递归终止条件：所有行都放置完成 if (row == board.length) { res.add(construct(board)); // 将棋盘转换为字符串列表 return; } // 尝试在当前行的每一列放置皇后 for (int col = 0; col \u0026lt; board.length; col++) { if (!isValid(board, row, col)) continue; // 不合法，跳过 board[row][col] = \u0026#39;Q\u0026#39;; // 放置皇后 backtrack(res, board, row + 1); // 递归下一行 board[row][col] = \u0026#39;.\u0026#39;; // 撤销放置（回溯） } } // 检查在 (row, col) 位置放置皇后是否合法 boolean isValid(char[][] board, int row, int col) { int n = board.length; // 检查列：同一列不能有其他皇后 for (int i = 0; i \u0026lt; row; i++) { if (board[i][col] == \u0026#39;Q\u0026#39;) return false; } // 检查左上对角线 for (int i = row - 1, j = col - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } // 检查右上对角线 for (int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } return true; } // 将棋盘转换为字符串列表 List\u0026lt;String\u0026gt; construct(char[][] board) { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for (char[] row : board) { res.add(new String(row)); } return res; } 4. 动态规划 0-1 背包问题 /** * 0-1背包：每个物品只能选一次 * weights[i]: 第i个物品的重量 * values[i]: 第i个物品的价值 * capacity: 背包容量 * 返回：最大价值 */ int knapsack(int[] weights, int[] values, int capacity) { int n = weights.length; // dp[i][w] 表示前 i 个物品，背包容量为 w 时的最大价值 int[][] dp = new int[n + 1][capacity + 1]; for (int i = 1; i \u0026lt;= n; i++) { for (int w = 0; w \u0026lt;= capacity; w++) { // 如果当前物品的重量 \u0026lt;= 背包容量 if (weights[i - 1] \u0026lt;= w) { // 选择：max(不拿, 拿) dp[i][w] = Math.max( dp[i - 1][w], // 不拿第i个物品 dp[i - 1][w - weights[i - 1]] + values[i - 1] // 拿第i个物品 ); } else { // 放不下，只能不拿 dp[i][w] = dp[i - 1][w]; } } } return dp[n][capacity]; } /** * 0-1背包 - 空间优化版本 * 时间复杂度：O(n * capacity) * 空间复杂度：O(capacity) */ int knapsackOptimized(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：必须从后往前遍历，避免重复使用同一物品 for (int w = capacity; w \u0026gt;= weights[i]; w--) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 完全背包问题 /** * 完全背包：每个物品可以选无限次 * 与0-1背包的区别：内层循环从前往后遍历 */ int completeKnapsack(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：从前往后遍历，允许重复使用物品 for (int w = weights[i]; w \u0026lt;= capacity; w++) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 最长公共子序列（LCS） /** * 最长公共子序列：找两个字符串的最长公共子序列长度 * 子序列：不要求连续 * 例如：\u0026#34;abcde\u0026#34; 和 \u0026#34;ace\u0026#34; 的LCS是 \u0026#34;ace\u0026#34;，长度为3 */ int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); // dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的LCS长度 int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (text1.charAt(i - 1) == text2.charAt(j - 1)) { // 字符相同：LCS长度+1 dp[i][j] = dp[i - 1][j - 1] + 1; } else { // 字符不同：取两种情况的最大值 dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; } 最长递增子序列（LIS） /** * 最长递增子序列 - O(n²) 动态规划解法 * dp[i] 表示以 nums[i] 结尾的最长递增子序列长度 */ int lengthOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; Arrays.fill(dp, 1); // 初始每个元素自己构成长度为1的子序列 int maxLen = 1; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { // 如果 nums[i] 可以接在 nums[j] 后面 if (nums[i] \u0026gt; nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } maxLen = Math.max(maxLen, dp[i]); } return maxLen; } /** * 最长递增子序列 - O(n log n) 二分解法 * tails[i] 表示长度为 i+1 的递增子序列的最小尾部元素 */ int lengthOfLISBinary(int[] nums) { List\u0026lt;Integer\u0026gt; tails = new ArrayList\u0026lt;\u0026gt;(); for (int num : nums) { // 二分查找：找到第一个 \u0026gt;= num 的位置 int left = 0, right = tails.size(); while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (tails.get(mid) \u0026lt; num) { left = mid + 1; } else { right = mid; } } // 如果 num 比所有元素都大，追加到末尾 if (left == tails.size()) { tails.add(num); } else { // 否则替换找到的位置 tails.set(left, num); } } return tails.size(); } 编辑距离 /** * 编辑距离：将 word1 转换为 word2 的最少操作次数 * 操作：插入、删除、替换 * 例如：\u0026#34;horse\u0026#34; -\u0026gt; \u0026#34;ros\u0026#34; 需要3步（删除h、删除r、替换s） */ int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); // dp[i][j] 表示 word1[0..i-1] 转换为 word2[0..j-1] 的最少操作数 int[][] dp = new int[m + 1][n + 1]; // 边界条件：一个字符串为空 for (int i = 0; i \u0026lt;= m; i++) dp[i][0] = i; // word1 -\u0026gt; 空串：删除i个字符 for (int j = 0; j \u0026lt;= n; j++) dp[0][j] = j; // 空串 -\u0026gt; word2：插入j个字符 for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { // 字符相同：不需要操作 dp[i][j] = dp[i - 1][j - 1]; } else { // 字符不同：三种操作取最小 dp[i][j] = Math.min( Math.min( dp[i - 1][j], // 删除 word1[i-1] dp[i][j - 1] // 插入 word2[j-1] ), dp[i - 1][j - 1] // 替换 word1[i-1] 为 word2[j-1] ) + 1; } } } return dp[m][n]; } 股票买卖问题 只能买卖一次\n/** * 买卖股票的最佳时机 I：只能买卖一次 * 贪心思想：记录最低价格，计算每天卖出的最大利润 */ int maxProfit(int[] prices) { int minPrice = Integer.MAX_VALUE; // 记录目前为止的最低价格 int maxProfit = 0; // 记录最大利润 for (int price : prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; } 可以买卖多次\n/** * 买卖股票的最佳时机 II：可以买卖多次 * 贪心思想：只要今天价格比昨天高，就在昨天买今天卖 */ int maxProfitMultiple(int[] prices) { int profit = 0; for (int i = 1; i \u0026lt; prices.length; i++) { // 如果今天价格更高，累加差价 if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } 最多买卖 k 次\n/** * 买卖股票的最佳时机 III/IV：最多买卖 k 次 * dp[i][j] 表示第 i 次交易后，第 j 天的最大利润 */ int maxProfitK(int k, int[] prices) { if (prices.length == 0) return 0; int n = prices.length; // 如果 k \u0026gt;= n/2，相当于无限次交易 if (k \u0026gt;= n / 2) { int profit = 0; for (int i = 1; i \u0026lt; n; i++) { if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } int[][] dp = new int[k + 1][n]; for (int i = 1; i \u0026lt;= k; i++) { int maxDiff = -prices[0]; // 第 i-1 次交易后买入的最大收益 for (int j = 1; j \u0026lt; n; j++) { // 不操作 vs 卖出 dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff); // 更新买入的最大收益 maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]); } } return dp[k][n - 1]; } 打家劫舍 /** * 打家劫舍 I：线性排列的房屋 * 不能抢相邻的房屋 * dp[i] = max(dp[i-1], dp[i-2] + nums[i]) */ int rob(int[] nums) { if (nums.length == 0) return 0; if (nums.length == 1) return nums[0]; int prev2 = 0, prev1 = 0; // prev2: dp[i-2], prev1: dp[i-1] for (int num : nums) { int temp = prev1; // 不抢 vs 抢 prev1 = Math.max(prev1, prev2 + num); prev2 = temp; } return prev1; } /** * 打家劫舍 II：环形排列的房屋 * 第一个和最后一个房屋相邻 * 思路：分两种情况，取最大值 * 1. 抢第一个房屋，不抢最后一个 * 2. 不抢第一个房屋，抢最后一个 */ int robCircular(int[] nums) { if (nums.length == 1) return nums[0]; return Math.max( robRange(nums, 0, nums.length - 2), robRange(nums, 1, nums.length - 1) ); } int robRange(int[] nums, int start, int end) { int prev2 = 0, prev1 = 0; for (int i = start; i \u0026lt;= end; i++) { int temp = prev1; prev1 = Math.max(prev1, prev2 + nums[i]); prev2 = temp; } return prev1; } 分割等和子集 /** * 分割等和子集：判断是否能将数组分成两个和相等的子集 * 本质：0-1背包问题，目标是找到和为 sum/2 的子集 */ boolean canPartition(int[] nums) { int sum = 0; for (int num : nums) sum += num; if (sum % 2 != 0) return false; // 和为奇数，不可能分割 int target = sum / 2; // dp[j] 表示能否凑出和为 j boolean[] dp = new boolean[target + 1]; dp[0] = true; // 和为0总是可以（不选任何数） for (int num : nums) { // 从后往前遍历，避免重复使用 for (int j = target; j \u0026gt;= num; j--) { dp[j] = dp[j] || dp[j - num]; // 不选 num 或 选 num } } return dp[target]; } 零钱兑换 /** * 零钱兑换 I：最少硬币数 * dp[i] 表示凑出金额 i 所需的最少硬币数 */ int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); // 初始化为不可能的大值 dp[0] = 0; // 凑出0元需要0个硬币 for (int i = 1; i \u0026lt;= amount; i++) { for (int coin : coins) { if (i \u0026gt;= coin) { // 选择使用当前硬币 dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } } return dp[amount] \u0026gt; amount ? -1 : dp[amount]; } /** * 零钱兑换 II：组成方案数 * dp[i] 表示凑出金额 i 的方案数 */ int change(int amount, int[] coins) { int[] dp = new int[amount + 1]; dp[0] = 1; // 凑出0元有1种方案（不选） // 外层遍历硬币，内层遍历金额（避免重复计数） for (int coin : coins) { for (int i = coin; i \u0026lt;= amount; i++) { dp[i] += dp[i - coin]; } } return dp[amount]; } 5. 双指针 对撞指针 // 两数之和（有序数组） int[] twoSum(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[left] + nums[right]; if (sum == target) { return new int[]{left, right}; } else if (sum \u0026lt; target) { left++; } else { right--; } } return new int[]{-1, -1}; } // 三数之和 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length - 2; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { res.add(Arrays.asList(nums[i], nums[left], nums[right])); while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; left++; right--; } else if (sum \u0026lt; 0) { left++; } else { right--; } } } return res; } 快慢指针 // 链表中点 ListNode findMiddle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } // 环形链表 boolean hasCycle(ListNode head) { if (head == null) return false; ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) return true; } return false; } // 找环的入口 ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { slow = head; while (slow != fast) { slow = slow.next; fast = fast.next; } return slow; } } return null; } 6. 单调栈 // 下一个更大元素 int[] nextGreaterElement(int[] nums) { int n = nums.length; int[] res = new int[n]; Arrays.fill(res, -1); Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; nums[stack.peek()] \u0026lt; nums[i]) { int idx = stack.pop(); res[idx] = nums[i]; } stack.push(i); } return res; } // 每日温度 int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] res = new int[n]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[stack.peek()] \u0026lt; temperatures[i]) { int idx = stack.pop(); res[idx] = i - idx; } stack.push(i); } return res; } // 柱状图中最大的矩形 int largestRectangleArea(int[] heights) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(-1); int maxArea = 0; for (int i = 0; i \u0026lt; heights.length; i++) { while (stack.peek() != -1 \u0026amp;\u0026amp; heights[stack.peek()] \u0026gt;= heights[i]) { int h = heights[stack.pop()]; int w = i - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } stack.push(i); } while (stack.peek() != -1) { int h = heights[stack.pop()]; int w = heights.length - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } return maxArea; } 7. 前缀和 // 一维前缀和 class PrefixSum { private int[] preSum; public PrefixSum(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 0; i \u0026lt; nums.length; i++) { preSum[i + 1] = preSum[i] + nums[i]; } } // 查询区间 [left, right] 的和 public int query(int left, int right) { return preSum[right + 1] - preSum[left]; } } // 二维前缀和 class MatrixPrefixSum { private int[][] preSum; public MatrixPrefixSum(int[][] matrix) { int m = matrix.length, n = matrix[0].length; preSum = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } // 查询子矩阵 [row1, col1] 到 [row2, col2] 的和 public int query(int row1, int col1, int row2, int col2) { return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]; } } 📌 总结 这份文档涵盖了：\nJava 集合框架：List、Set、Map、Queue、Stack 的完整使用方法 树算法：DFS、BFS、线段树 图算法：遍历、最短路径、最小生成树 经典算法：回溯、动态规划、二分查找、滑动窗口、双指针、单调栈、前缀和 建议配合 LeetCode 刷题使用，遇到问题时可以快速查阅对应的模板代码。\n持续更新中\u0026hellip; 🚀\n","permalink":"http://localhost:1313/posts/algorithm-with-java/","summary":"详细介绍java集合的使用,以及在刷算法题中需要使用到的一些板子","title":"算法刷题必备：Java集合与算法模板"},{"content":"一、Hugo 常用指令 1.1 创建新站点 # 创建一个新的 Hugo 站点 hugo new site mysite # 进入站点目录 cd mysite 1.2 创建新文章 # 在 content/posts 目录下创建新文章 hugo new posts/my-first-post.md # 在 content 目录下创建文章 hugo new about.md # 创建在特定子目录 hugo new blog/2024/new-post.md 1.3 本地预览 # 启动本地开发服务器（默认 http://localhost:1313） hugo server # 启动并显示草稿文章 hugo server -D # 启动并显示草稿、未来日期和过期的文章 hugo server -DEF # 指定端口 hugo server --port 8080 # 实时重载并打开浏览器 hugo server -D --navigateToChanged 1.4 主题管理 # 添加主题（使用 Git submodule） git submodule add https://github.com/username/theme-name.git themes/theme-name # 更新主题 git submodule update --remote --merge # 删除主题 git submodule deinit -f themes/theme-name rm -rf .git/modules/themes/theme-name git rm -f themes/theme-name 1.5 其他常用指令 # 查看 Hugo 版本 hugo version # 查看帮助 hugo help # 查看配置信息 hugo config # 列出所有内容 hugo list all # 列出草稿 hugo list drafts 二、Markdown Front Matter 配置 2.1 完整配置示例 --- # 基本信息 title: \u0026#34;我的第一篇文章\u0026#34; date: 2025-12-06T15:04:05+08:00 lastmod: 2025-12-07T10:00:00+08:00 draft: false # 作者信息 author: \u0026#34;Minjie\u0026#34; authorLink: \u0026#34;https://github.com/Minjie2003\u0026#34; # 分类和标签 categories: [\u0026#34;技术\u0026#34;] tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;, \u0026#34;博客\u0026#34;] series: [\u0026#34;Hugo教程\u0026#34;] # 摘要和描述 summary: \u0026#34;这是一篇关于 Hugo 和 Markdown 的完整指南\u0026#34; description: \u0026#34;详细介绍 Hugo 的使用方法和 Markdown 配置\u0026#34; # 特色图片 image: \u0026#34;/images/featured.jpg\u0026#34; cover: image: \u0026#34;/images/cover.jpg\u0026#34; alt: \u0026#34;封面图片描述\u0026#34; caption: \u0026#34;图片说明文字\u0026#34; # SEO 相关 keywords: [\u0026#34;Hugo\u0026#34;, \u0026#34;静态博客\u0026#34;, \u0026#34;Markdown\u0026#34;] slug: \u0026#34;hugo-markdown-guide\u0026#34; url: \u0026#34;/posts/hugo-guide/\u0026#34; # 显示控制 toc: true # 显示目录 comments: true # 允许评论 showToc: true # 显示目录 TocOpen: false # 默认展开目录 hidemeta: false # 隐藏元信息 disableShare: false # 禁用分享按钮 hideSummary: false # 隐藏摘要 ShowReadingTime: true # 显示阅读时间 ShowBreadCrumbs: true # 显示面包屑导航 ShowPostNavLinks: true # 显示文章导航链接 # 权重（用于排序） weight: 1 # 外部链接 externalLink: \u0026#34;https://example.com\u0026#34; # 是否在首页显示 showhome: true --- 2.2 常用字段说明 字段 说明 示例 title 文章标题 \u0026quot;我的文章\u0026quot; date 发布日期 2025-12-06 或 2025-12-06T15:04:05+08:00 draft 是否为草稿 true / false tags 标签（数组） [\u0026quot;Hugo\u0026quot;, \u0026quot;博客\u0026quot;] categories 分类（数组） [\u0026quot;技术\u0026quot;, \u0026quot;教程\u0026quot;] summary 文章摘要 \u0026quot;这是摘要\u0026quot; description SEO 描述 \u0026quot;页面描述\u0026quot; slug URL 友好名称 \u0026quot;my-post\u0026quot; url 自定义完整 URL \u0026quot;/posts/my-post/\u0026quot; weight 排序权重 1 (数字越小越靠前) toc 是否显示目录 true / false 三、Hugo Shortcodes（短代码） 3.1 内置 Shortcodes # 显示图片 {{\u0026lt; figure src=\u0026#34;/images/photo.jpg\u0026#34; title=\u0026#34;图片标题\u0026#34; \u0026gt;}} # 高亮文本 {{\u0026lt; highlight python \u0026gt;}} def hello(): print(\u0026#34;Hello!\u0026#34;) {{\u0026lt; /highlight \u0026gt;}} # YouTube 视频 {{\u0026lt; youtube VIDEO_ID \u0026gt;}} # X (Twitter) 推文（新版） {{\u0026lt; x user=\u0026#34;USERNAME\u0026#34; id=\u0026#34;TWEET_ID\u0026#34; \u0026gt;}} # GitHub Gist（已废弃，建议直接嵌入代码） # 可以使用 highlight 或直接用代码块替代 # 参数传递（需要在 Front Matter 中定义参数） {{\u0026lt; param \u0026#34;description\u0026#34; \u0026gt;}} 3.2 自定义 Shortcode 示例 在 layouts/shortcodes/note.html 创建：\n\u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; 使用时：\n{{\u0026lt; note \u0026gt;}} 这是一个提示框 {{\u0026lt; /note \u0026gt;}} 四、Markdown 基本语法 4.1 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 4.2 文本样式 **粗体文字** *斜体文字* ***粗斜体*** ~~删除线~~ `行内代码` 4.3 列表 # 无序列表 - 项目 1 - 项目 2 - 子项目 2.1 - 子项目 2.2 # 有序列表 1. 第一项 2. 第二项 1. 子项 2.1 2. 子项 2.2 4.4 链接和图片 # 链接 [链接文字](https://example.com) [带标题的链接](https://example.com \u0026#34;鼠标悬停显示\u0026#34;) # 图片 ![图片描述](/images/photo.jpg) ![图片](https://example.com/image.jpg \u0026#34;图片标题\u0026#34;) 4.5 引用 \u0026gt; 这是一段引用文字 \u0026gt; 可以多行 \u0026gt;\u0026gt; 嵌套引用 4.6 代码块 ```python def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) ``` ```javascript console.log(\u0026#34;Hello, World!\u0026#34;); ``` 4.7 表格 | 列1 | 列2 | 列3 | |-----|-----|-----| | 数据1 | 数据2 | 数据3 | | 数据4 | 数据5 | 数据6 | # 对齐方式 | 左对齐 | 居中 | 右对齐 | |:-------|:----:|-------:| | 内容 | 内容 | 内容 | 4.8 分隔线 --- *** ___ 4.9 任务列表 - [x] 已完成的任务 - [ ] 未完成的任务 - [ ] 另一个任务 五、实用技巧 5.1 文章模板 在 archetypes/default.md 创建默认模板：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true tags: [] categories: [] summary: \u0026#34;\u0026#34; --- ## 简介 内容开始... 5.2 多语言配置 在 Front Matter 中：\n--- title: \u0026#34;English Title\u0026#34; title.zh: \u0026#34;中文标题\u0026#34; --- 5.3 自定义 URL 结构 在 hugo.toml 中：\n[permalinks] posts = \u0026#34;/:year/:month/:slug/\u0026#34; 5.4 草稿快速发布 # 将草稿改为发布状态 sed -i \u0026#39;s/draft: true/draft: false/\u0026#39; content/posts/my-post.md ","permalink":"http://localhost:1313/posts/hugo-readme/","summary":"详细介绍 Hugo 常用指令、Markdown Front Matter 配置、基本语法和实用技巧的完整指南","title":"Hugo 常用指令与 Markdown 配置指南"},{"content":"👋 嗨，我是 Minjie 很高兴你能来到这里！这是我在互联网上的一个小角落，用来记录代码、想法和生活的点滴。\n🧑‍💻 关于我 我是一名在读研究生，研究方向包括区块链，web3.0，数据库管理等。当然，目前更加专注于 Java 后端开发。相比起\u0026quot;全栈工程师\u0026quot;这样的标签，我更喜欢把自己定义为一个对计算机技术充满好奇心的探索者。\n📖 这个博客写什么 这里主要记录我在技术道路上的成长轨迹，你可能会看到：\n技术笔记 - Java 后端开发的实践经验、框架使用心得、踩过的坑和解决方案\n项目复盘 - 从需求分析到上线部署，记录项目中的思考和收获\n学习记录 - 新技术的探索、算法题的思路、计算机基础知识的整理\n随笔杂谈 - 偶尔也会写写读书笔记、游戏感想，或者对技术趋势的一些思考\n我希望这里不仅是我个人的知识库,也能给同样在技术路上摸索的你带来一些启发或共鸣。\n🎯 技术栈 \u0026amp; 兴趣方向 后端开发：Java、Spring Boot、MyBatis、MySQL、Redis - 这是我的主战场\n折腾爱好：除了后端，我还喜欢写点爬虫玩玩，做些自动化小工具来解决日常遇到的重复性工作。总觉得能用代码解决的事情，就不该浪费时间手动操作。有时候为了实现一个自动化脚本，花的时间可能比手动做还多，但那种\u0026quot;一劳永逸\u0026quot;的快感真的很上头。\n探索中：对各种能提高效率的技术和工具都充满兴趣，正在不断拓展技术边界\u0026hellip;\n🎮 代码之外 游戏时光：Steam 上收藏了不少游戏，也会玩玩王者、原神这些。\n音乐陪伴：写代码的时候总要听点什么。古典音乐能让思路更清晰，ACG 音乐带来满满的回忆，偶尔也会跟着流行音乐哼哼唱唱。喜欢洗澡的时候k歌······当然，也是个半吊子吉他选手\n运动爱好：除了敲键盘，也喜欢出去动一动。篮球、羽毛球、乒乓球都有涉猎，虽然都不算精通，但也能过上两招。过去打篮球多一点，现在更想尝试羽毛球。\n历史爱好者：对历史有种莫名的着迷，喜欢看历史书籍、纪录片。主要包括近现代欧洲历史，唐史，春秋战国。\n💬 来聊聊？ 如果你也对后端开发感兴趣，或者想交流技术、分享项目经验，甚至只是想推荐个好玩的游戏或好听的歌，都欢迎联系我：\n📧 邮箱：zhongnagisa01@gmail.com 🐙 GitHub：Minjie2003 \u0026ldquo;流水不争先，争的是滔滔不绝\u0026rdquo;\n感谢你的访问，希望我们能在这里有更多交流！✨\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于我"},{"content":"论文基本信息 标题: Enhancing trust and privacy in distributed networks: a comprehensive survey on blockchain-based federated learning\n作者: Ji Liu, Chunlu Chen, Yu Li, Lin Sun, Yulun Song, Jingbo Zhou, Bo Jing, Dejing Dou\n发表: Knowledge and Information Systems (2024) 66:4377–4403\n机构: 恒生电子、九州大学、百度、联通数科、波士顿咨询\n一、研究背景 1.1 区块链技术概述 论文首先介绍了区块链的基本概念和特性：\n核心特性：\n去中心化架构：将验证系统从中心化转变为去中心化，通过多个用户的共识来促进验证过程 不可篡改性：通过哈希函数将数据块链接成链，任何篡改尝试都会破坏哈希链，导致不匹配 加密安全：使用哈希函数、数字签名和加密技术保护数据完整性和安全性 透明性：区块链上记录的每笔交易对所有网络参与者透明可见 智能合约：自动执行的协议，按预定义规则执行交易，无需中介 区块链类型：\n类型 访问方式 典型代表 常用共识 无许可链 匿名访问，任何人可加入 Bitcoin, Ethereum PoW, PoS 有许可链 需要注册，限制访问 Hyperledger Fabric Kafka, Raft, PBFT 分布式系统特性：\n去中心化：控制和决策分布在各个节点 共识机制：确保所有节点对系统状态达成一致 容错性：通过冗余、复制和错误处理机制实现 可扩展性：通过增加节点水平扩展 1.2 联邦学习基础 FL基本流程：\n中央服务器初始化模型参数并分发给所有客户端 客户端使用本地数据训练模型 客户端上传训练后的模型参数到中央服务器 中央服务器聚合参数，更新全局模型 重复以上步骤直到模型收敛 FL分类：\n按网络拓扑：\n中心化FL 去中心化FL 按数据可用性：\n跨孤岛FL (Cross-silo) 跨设备FL (Cross-device) 按数据分区：\n横向FL：特征空间相同，样本不同 纵向FL：样本相同，特征空间不同 联邦迁移学习：样本和特征都不同 常见优化算法：FedAvg, FedProx, SCAFFOLD, FedPD, FedBN\n1.3 FL面临的主要挑战 论文总结了FL的三大核心挑战：\n挑战1：数据异构性 三种异构：\n特征异构：参与设备拥有不同的特征集，使模型聚合和对齐变得困难 数据分布异构：由于用户群体、地理位置、数据收集实践的差异，导致数据分布不同，可能引入偏见 数据格式异构：来自不同来源或平台的数据可能具有不同的格式、表示或结构 解决技术：\n模型架构调整和特征工程 元学习和域适应 多格式设计的模型 挑战2：隐私与安全 主要威胁：\n数据泄露：共享模型可能包含训练数据的敏感信息 成员推理攻击：对手试图确定特定数据点是否属于训练数据集 模型投毒攻击：对手注入恶意数据或操纵本地更新以毒化共享模型 防御技术：\n差分隐私(DP)：向数据或模型更新添加噪声以模糊个体贡献 同态加密(HE)：允许对加密数据进行计算 安全多方计算(SMPC)：多方在不暴露私有数据的情况下联合计算 可信执行环境(TEE)：如TrustFL方案 挑战3：可追溯性与问责性 可追溯性需求：\n模型审计：通过记录元数据（模型架构、超参数、数据源）跟踪和审计FL中训练的模型 数据溯源：追踪训练数据的来源和历史，确保真实性并评估潜在偏见 问责性需求：\n参与者问责：参与者应遵守商定的协议、隐私措施和安全实践 安全与信任维护：实施适当的安全措施，保护数据机密性，防止未授权访问或恶意活动 面临的困难：\nFL的去中心化结构使协调和建立共识变得复杂 在保护隐私的同时确保可追溯性需要平衡 数据分散在不同参与者之间，追踪数据来源和血统面临挑战 1.4 整合区块链与FL的必要性 论文论述了结合区块链和FL的三大核心价值：\n价值1：激励机制 传统FL中，许多客户端由于经济理性不愿分享有价值的数据 区块链原生的加密货币或代币系统可建立激励机制 通过奖励数据贡献者、模型验证者和其他参与者，激励积极参与、数据共享和模型改进 价值2：增强数据隐私与安全 解决中心化风险：传统FL严重依赖单一中央服务器，如果服务器恶意行为，整个系统可能崩溃 防御客户端攻击：现有设计容易受到恶意客户端的攻击，可能上传有毒模型攻击FL网络 区块链优势： 去中心化和不可变的特性提供安全透明的数据共享和存储框架 加密方法显著增强数据隐私和安全 参与者可以验证共享模型的完整性和真实性，而不暴露敏感信息 价值3：信任与透明 区块链固有的透明性和可审计性可以解决FL中的信任问题 使参与者能够追踪数据、模型和计算的历史和来源 透明性在参与者之间培养信任，因为他们可以验证FL过程的公平性和可靠性 二、BCFL系统架构 2.1 整体架构概览 论文提出从底向上的五层架构（加上贯穿的区块链共识层）：\n┌─────────────────────────────────────────────┐ │ 应用层 (Application Layer) │ │ 医疗 | 车联网 | 边缘计算 | 能源 | 资源分配 │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 区块链共识层 (Blockchain Consensus) │ │ PoW | PoS | DPoS | PBFT | PoQ | PoF | Raft │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 算法层 (Algorithm Layer) │ │ 聚合算法 | 安全算法 | 优化算法 | 激励算法 │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 通信层 (Communication Layer) │ │ 加密技术 | 网络协议 | 同步机制 | P2P框架 │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 网络层 (Network Layer) │ │ 中心化 | 多中心化 | 去中心化 (P2P) │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 基础设施层 (Infrastructure Layer) │ │ L1/L2架构 | 存储资源 | 计算资源(CPU/GPU/TPU)│ └─────────────────────────────────────────────┘ 2.2 架构分类：三种耦合方式 论文根据操作动态将BCFL系统分为三种架构：\n完全耦合 (Fully Coupled) 定义：客户端同时作为训练节点和区块链节点\n特点：\n提供去中心化 要求高设备性能 适用场景：参与者设备能力强的环境\n灵活耦合 (Flexibly Coupled) 定义：分离区块链和FL操作以减轻网络通信负担\n实现方式：\n委员会选择：选择部分节点参与共识 智能合约：通过智能合约实现分离 特点：平衡了去中心化和效率\n松散耦合 (Loosely Coupled) 定义：优先考虑声誉来衡量参与者可靠性\n关注点：\n主要关注模型更新验证 在账本上进行声誉管理 特点：轻量级，适合大规模异构设备\n三、六层架构详解 3.1 基础设施层 L1与L2架构 L1层架构：\nFL直接集成到区块链 提供去中心化的P2P框架 对等方自由加入 由共识机制支持系统可靠性 L2层架构：\nFL构建在区块链节点之上 强调分层数据处理和模型训练 存储方案 去中心化存储：\n采用去中心化存储模型 通过高级加密方法确保隐私： 安全多方计算(SMPC) 同态加密 优势：\n促进安全、私密的数据共享和模型聚合 区块链的可审计性提高透明度和信任 计算资源 本地计算：\n本地满足计算需求 利用CPU、GPU、TPU 异构性处理：\n通过轻量级架构处理设备异构性 模型压缩技术 联邦蒸馏(Federated Distillation) 优化性能和资源分配 3.2 网络层 论文将区块链网络结构分为三类：\n中心化网络 特点：\n所有通信和交易通过中央节点路由 常见于有许可区块链系统 优势：\n简化效率 由于单一控制点，共识更快 劣势：\n显著的安全风险 中央节点成为攻击的主要目标 可能损害整个网络的完整性和隐私 多中心化网络（联邦区块链） 特点：\n引入多个中央节点而非单一节点 通常用于平衡多个组织或方之间的控制 优势：\n增强协作 维持一定程度的中心化治理 改善安全性，减少单点故障风险 劣势：\n仍可能面临可扩展性限制 中心化控制问题 去中心化网络 特点：\n以无许可区块链为代表（如Bitcoin、Ethereum） 在广泛的节点阵列中分布数据验证和交易处理 P2P网络结构 无单点控制或故障 每个节点以平等地位运行 优势：\n最高级别的安全性和数据完整性 显著增强对审查、篡改和攻击的抵抗力 劣势：\n可能在可扩展性方面面临挑战 由于决策过程的分布式性质，共识速度可能较慢 论文总结：网络设置的选择深刻影响BCFL系统的性能和安全性\n3.3 通信层 核心任务 通信层在BCFL系统中扮演关键角色，负责：\n编排参与者之间的数据传输和消息交换 促进协作学习过程 高效、安全地传输模型更新、聚合结果和协调指令 关键技术 加密技术：\n在传输前加密数据 防止未授权访问 确保维护数据隐私 网络协议：\n采用可靠高效的网络协议管理消息传递 确保数据包可靠有序地到达目的地 即使在网络中断或拥塞情况下 同步机制：\n在BCFL系统的分布式特性下，同步机制至关重要 协调参与者之间的通信 确保及时共享模型更新 管理数据传输的异步性质 对齐来自不同参与者的更新 去中心化通信框架：\n采用去中心化框架（如P2P网络或区块链） 促进参与者之间的直接通信 消除中心化中介的需要 增强系统的韧性和去中心化 减少潜在瓶颈和故障点 案例 - BLADE-FL：\n论文提到的完全去中心化框架 将训练和挖矿的责任都分配给全节点 增强去中心化和系统韧性 面临的挑战 延迟和有限带宽：\n通过数据压缩技术解决 最小化数据传输的大小 提高交换速度 优化策略：\n自适应网络路由 拥塞控制算法 优化数据流 减少延迟 提高通信效率 批处理和缓存：\n降低数据传输的频率和数量 减轻网络约束的影响 3.4 算法层 论文将算法层分为四个关键方面：\n1. 聚合算法 经典算法：\nFedAvg：\n参与者上传本地模型权重到区块链网络 通过智能合约计算权重平均值获得全局模型 进阶算法：\nFedProx：处理异构性 SCAFFOLD：减少方差 FedPD：原对偶优化 FedBN：批归一化层处理 异步FL系统：\n解决中心化模型带来的安全挑战 实现隐私、容错和可靠的数据共享 基于有许可区块链的FL异步聚合协议 通过将学习模型集成到区块链并执行二阶聚合计算 有效缓解同步FL算法的问题 2. 安全算法 论文详细介绍了三种核心隐私保护技术：\n安全多方计算(SMPC)：\n定义：保护数据隐私的计算模型，允许多方在不披露私有数据的情况下进行计算\n特点：\n各方持有部分私有数据 可以对加密数据执行计算以维护隐私 各方通过协议进行通信和交互 共同计算最终结果而无需直接暴露私有数据 技术组成：\n同态加密 秘密共享(Secret Sharing) 零知识证明(Zero-Knowledge Proof) 安全多方计算协议 同态加密(HE)：\n定义：满足密文同态运算性质的加密算法\n核心特性：\n数据经过同态加密后 对密文执行特定计算 密文计算结果经相应同态解密后 等价于对明文数据直接执行相同计算 实现数据的\u0026quot;可计算但不可见\u0026quot;状态 优势：\n可以在密文上进行计算而无需密钥 减少通信成本 平衡各方的计算成本 差分隐私(DP)：\n定义：通过添加扰动噪声保护底层用户隐私信息的技术\n原理：\n确保即使攻击者掌握除一条信息外的所有其他信息 仍无法推断该条信息 方法：\n向结果添加符合特定分布的噪声 随机化查询结果 挑战：需要解决数据可用性问题（由于需要在查询结果中加入随机性，可能导致数据可用性下降）\n3. 优化算法 目标：\n优化FL性能 减少训练轮次 降低通信开销 提高模型准确性 常用方法：\n梯度压缩：减少通信开销 梯度剪枝：减少通信开销 异步更新：减少训练轮次 本地更新：减少训练轮次 4. 激励算法 论文强调：虽然FL在保护数据隐私的同时实现协作学习展现了巨大优势，但仍面临如何激励人们通过贡献计算能力和数据加入FL的开放挑战。\n基于声誉的FL：\n核心思想：通过设计安全机制衡量参与者的可靠性\n代表性工作：\n区块链声誉系统\n增加贡献正确有用模型参数的客户端的声誉值 降低上传恶意参数的客户端的声誉值 影响后续训练轮次的客户端选择 RepBFL框架\n结合区块链和FL应用于车联网(IoV) 利用区块链确保共享数据保护 选择高声誉节点进行FL 评估IoV中车辆的可靠性 基于模型质量参数的评估\n使用模型质量参数进行声誉评估 区块链衡量工作者可靠性并维护声誉值 CFFL协作公平框架\n引入基于经验个体模型性能的声誉机制 调节参与者奖励以保持通信轮次间的公平性 多权重主观逻辑模型\n将声誉作为量化移动设备可靠性和可信度的指标 采用多权重主观逻辑模型进行声誉计算 联盟区块链技术以去中心化方式保护声誉存储 基于支付的FL：\nFedCoin\n采用Shapley值(SVs)进行可行的基于SV的利润分配 公平反映对全局FL模型的贡献 区块链共识实体部署Shapley权益证明协议(PoSap) 用于计算SVs和创建新区块 公共区块链上的FL协议\n解决监控工作者行为和保证协议遵守的挑战 将竞争嵌入BCFL 仅奖励贡献有价值的工作者 自然抑制偏离协议的行为 移动群体FL系统\n通过根据个人贡献提供奖励来激励移动设备训练准确模型 Stackelberg博弈建模服务器和设备间的交互 比较基于规模和基于准确性的两种奖励策略 跨孤岛横向FL的贡献评估\n解决透明评估不同数据所有者贡献的挑战 使用可调精度量化数据所有者基于SV的贡献 保护隐私 DeepChain：\n特点：\n客户端联合参与训练深度学习模型的协作框架 保证数据机密性和计算可验证性 为参与者提供激励 激励机制：\n围绕超时检查和货币惩罚编排 促进参与者之间的公平性 在参与者未能满足截止日期或不准确执行函数的情况下采取惩罚措施 施加货币惩罚，没收不诚实参与者的预存资金 在诚实参与者之间重新分配 机制设计综述：\n论文引用的综述工作：\n基于关键技术对现有激励机制进行分类 包括：Stackelberg博弈、拍卖、合约理论、Shapley值、强化学习、区块链 Refiner系统：\n部署在Ethereum公共区块链平台 运行激励机制，根据训练数据量和本地更新性能奖励参与者 处理大规模协作中的恶意参与者 部署随机选择的验证者委员会 验证者惩罚不道德参与者，拒绝奖励并从全局模型中消除腐败更新 3.5 区块链共识层 论文强调：在FL系统实现的背景下，共识涉及参与者同步模型并集体做出决策所采用的协议。共识算法确保所有参与者对模型更新的有效性达成一致，并防止恶意行为者篡改系统。\n共识机制的重要性 共识机制的作用：\n在极短时间内完成交易验证和确认 通过特殊节点的投票完成 如果利益不同的节点能对交易达成共识，则可以认为整个网络也能达成共识 主要共识机制 1. Proof of Work (PoW)\n特点：\nBitcoin使用PoW工作量证明机制 Ethereum曾使用PoW和PoS混合共识机制 相当于解决一个随时间变难的数学难题 挑战：\n计算消耗大量能源 可能间接影响碳排放和环境 应用案例：\nBCFL系统：引入分布式哈希表用于高效区块生成，采用PoW共识机制确保全局模型一致性 LearningChain：去中心化联邦系统，利用基于PoW共识的拜占庭容错聚合算法（l-nearest aggregation），通过竞争选择领导者，使用l-nearest算法聚合梯度 Swarm Learning (SL)：去中心化机器学习方法，结合边缘计算和基于区块链的P2P网络，数据和参数保留在边缘，消除中央协调者的需求 2. Proof of Stake (PoS)\n特点：\n被视为PoW的环保替代方案 验证者基于持有和愿意\u0026quot;质押\u0026quot;作为抵押品的加密货币数量被选择创建新区块 3. Delegated Proof of Stake (DPoS)\n特点：\n利益相关者选举一定数量的代表来验证交易和创建区块 设计为比传统PoS更民主和高效 4. Proof of Training Quality (PoQ)\n背景：现有共识机制（如PoW）消耗大量计算和通信资源，或对数据共享的额外贡献有限\n解决方案：\n论文提到提出了结合FL与差分隐私的共识机制PoQ 将数据模型训练与共识过程集成 用模型参数准确性的认证替代PoW中寻找随机数的无意义计算工作 5. Byzantine Fault Tolerance (BFT)\n目标：抵御\u0026quot;拜占庭\u0026quot;故障（组件可能失败且对组件是否失败的信息不完善）\n变体：\nPBFT (Practical Byzantine Fault Tolerance)：用于Hyperledger Fabric FBA (Federated Byzantine Agreement)：用于Stellar 6. Proof of Federation (PoF)\nBiscotti系统：\n将PoF与一致性哈希和可验证随机函数(VRF)结合 为对等节点选择关键角色，协助协调模型更新的隐私和安全 通过Multi-Krum防御防止对等点毒化模型 采用差分化私有噪声提供隐私 利用Shamir秘密共享进行安全聚合 挑战：当所有节点参与共识时，计算负载过大\n7. RAFT\n特点：\n在一组节点中选举领导者 领导者负责提出和验证区块 专注于简单性和容错性 设计为比其他共识算法更易理解和实现 应用：一些有许可区块链网络\n8. Proof of Federated Training (PoFT)\n特点：\n实现跨多个区块链网络的可验证模型训练的框架 解决PoW中的功耗/资源浪费问题 解决区块链中的数据隐私问题 扩展 - PoFL：\n联邦学习证明 应用于车辆网络 车辆通过遵守区块链网络内的FL共识证明竞争成为矿工 IPFS和PoFL用于确保连接自动驾驶车辆的去中心化联邦学习安全 9. 委员会共识\nBFLC框架：\n基于区块链的委员会共识FL框架 利用区块链进行全局模型存储和本地模型更新交换 消除中心化服务器需求 引入创新的委员会共识机制减少计算负载并缓解恶意攻击 论文总结：\n所有这些共识算法都有其优势和劣势 适合不同的用例 选择正确的共识机制对区块链网络的安全性、可扩展性和效率至关重要 共识算法的选择受期望的去中心化程度、安全性、可扩展性以及区块链网络的特定需求等因素影响 3.6 应用层 论文探讨了FL在不同领域的应用，这些领域可以提供基于该技术的服务。\n车联网 (Internet of Vehicles) 应用背景：\n车辆日益成为数据生成源 GPS位置、速度、道路状况等数据可以为更好的交通管理、路线规划和事故预防做出贡献 但这些数据也是敏感的 BCFL的价值：\n能够聚合来自多辆车辆的数据来训练模型，而无需共享原始数据 区块链还可以用于维护网络中车辆交互和交易的防篡改记录 相关研究：论文引用了多篇关于BCFL在车联网应用的研究工作\n资源分配 应用价值：\n在大型分布式系统中，有效的资源分配对于最大化效率至关重要 通过在区块链网络之上应用FL，可以根据从网络使用模式中学习的知识动态分配资源 将区块链与FL集成不仅加强隐私和可靠性，还为高效的资源分配和利用提供平台 边缘计算 应用潜力：\nBCFL在边缘计算应用方面具有巨大潜力 为数据共享、资源协作和共享、模型更新和升级以及抗干扰和容错提供安全机制 实现方式：\n通过利用边缘设备的计算资源和数据 使智能应用能够高效安全地执行推理和决策任务 解决的挑战：\n数据隐私 资源约束 边缘计算中常见的不稳定环境 应用现状：\n已在移动电话场景中进行了广泛研究和应用 预计将为更多边缘计算场景的发展和扩展提供解决方案 医疗健康 应用价值：\n患者数据敏感但对检测疾病和改善治疗极有价值 BCFL允许医疗机构协作并从大量患者数据中学习，而不损害患者隐私 区块链优势：\n可以提供数据和计算的可追溯性 增加对学习模型的信任 相关应用：\n疾病检测 治疗改进 电子健康记录系统的安全性、隐私和互操作性 能源 应用场景：\n智能电网：\n优化电网运营 促进微电网间的P2P能源交易和共享 工业物联网(IIoT)：\n解决无线网络中与信用数据共享相关的安全和隐私问题 可再生能源：\n应用于风能涡轮机的叶片结冰检测 风能是快速增长的可再生能源部门 四、关键框架案例 论文介绍了多个具有代表性的BCFL框架：\nBML-ES 基于区块链的工业物联网(IIoT)边缘服务机器学习框架 利用智能合约实现聚合策略 采用SM2公钥密码系统保护隐私并提高模型准确性 TrustFed 将区块链集成到跨设备FL系统中 防止模型投毒 确保公平训练 维护参与者声誉 使用智能合约管理声誉并排除恶意行为者 确保可靠的训练环境 基于状态通道的信任监督机制 使用区块链和FL为分布式数据共享创建可信环境 采用状态通道为FL任务建立安全沙箱 确保整个过程的完整性和监督 Proof of Federated Training (PoFT) 实现跨区块链网络可验证模型训练的框架 增强协作训练过程中的透明度和信任 去中心化模型训练和梯度聚合 提出基于区块链的安全模型训练架构 引入旨在提高模型准确性、隐私和性能的梯度聚合方法 Blockchain-in-the-loop FL 将传统FL与Hyperledger Fabric合并 结合游戏化以增强参与度和效率 Swarm Learning 去中心化机器学习方法 结合边缘计算和基于区块链的P2P网络 数据和参数保留在边缘 消除中央协调者的需求 发表在Nature上，应用于COVID-19等疾病的去中心化临床机器学习 五、挑战与未来研究方向 论文在结尾部分识别了BCFL面临的主要挑战并提出未来研究方向：\n5.1 数据安全与隐私保护 挑战：\n在FL与区块链结合的环境中，确保数据安全和隐私成为首要关注点 在网络环境中有效管理敏感信息（如医疗记录或个人身份）是一项挑战 需要深入探索在不暴露其真实内容的情况下处理此类数据的密码技术 研究方向：\n未来研究应深入研究针对这个集成系统定制的新密码解决方案 5.2 模型效率与性能优化 挑战：\n分布式数据和模型的高效计算是FL的基本要求 该领域的核心挑战涉及： 设计降低计算复杂度的算法 最小化通信开销 提高模型训练和推理的效率 研究方向：\n未来研究工作应集中于微调分布式优化方法 整合先进的压缩策略以减轻通信负担 探索硬件增强以提高计算效率 调查混合模型，合并中心化和去中心化训练方法，也具有相当大的前景 5.3 可扩展性 问题描述：\n随着区块链和FL融合以创建安全、私密的数据管理框架 可扩展性成为一个关键瓶颈 特别是当系统规模扩大和需求增加时 解决方案： 论文提出的前瞻性方法：\n链下计算 (Off-chain Calculations)：卸载密集任务，减少主区块链负载 侧链 (Sidechains)：单独管理交易以减少拥塞 Layer-2技术： 状态通道(State Channels) Plasma 在现有区块链之上促进快速交易，同时保持安全性 目标：\n这些方法利用区块链和FL的核心原则 旨在培育可扩展、安全和去中心化的学习生态系统 六、论文贡献总结 论文明确指出其核心贡献：\n分类法提出\n从三个方面呈现BCFL的分类： 去中心化架构 分离网络 基于声誉的架构 通用架构总结\n总结了BCFL系统的通用架构 提供了基于区块链的FL架构的全面视角 包括六个关键层： 基础设施层 网络层 通信层 算法层 区块链共识层 应用层 应用分析\n分析了BCFL在以下领域的应用： 医疗健康 物联网 其他隐私敏感领域 未来方向识别\n识别了BCFL的未来研究方向 综合视角\n本研究旨在提供BCFL系统的全面视角 为BCFL系统领域的未来研究提供基础 七、个人理解 说明：以下是我基于论文内容的理解和思考，并非论文原文\n论文的核心价值 这篇综述的主要价值在于：\n系统性整合：将分散的BCFL研究整合到统一框架中 架构清晰：六层架构为理解BCFL系统提供了清晰的分析框架 全面覆盖：从底层基础设施到上层应用都有涉及 论文的特点 优势：\n文献综述全面，引用了大量相关工作 分类清晰，便于理解不同方法的特点 对各种技术（共识机制、激励机制、隐私保护）都有介绍 可能的不足：\n对各种方案的性能对比分析较少 部分技术介绍较为概念化，实现细节不足 缺少对不同方案适用场景的明确指导 对未来研究的启示 BCFL是一个跨学科领域，需要区块链、机器学习、密码学等多方面知识 不同应用场景可能需要不同的架构选择（完全耦合 vs 灵活耦合 vs 松散耦合） 隐私保护、效率、去中心化程度之间的权衡是核心问题 实际应用还需要考虑工程实现、成本、监管合规等问题 引用 @article{liu2024enhancing, title={Enhancing trust and privacy in distributed networks: a comprehensive survey on blockchain-based federated learning}, author={Liu, Ji and Chen, Chunlu and Li, Yu and Sun, Lin and Song, Yulun and Zhou, Jingbo and Jing, Bo and Dou, Dejing}, journal={Knowledge and Information Systems}, volume={66}, pages={4377--4403}, year={2024}, publisher={Springer} } ","permalink":"http://localhost:1313/posts/blockchain-federated-learning-survey/","summary":"本文系统性地综述了区块链联邦学习（BCFL）技术，从架构分类、基础设施层、网络层、通信层、算法层到共识机制进行了深入分析，并探讨了其在医疗、物联网车辆、边缘计算等领域的应用，为构建安全、隐私保护的分布式学习系统提供了理论框架","title":"区块链联邦学习综述：增强分布式网络中的信任与隐私"},{"content":"第一题：线性回归梯度下降 题目： 对线性模型 $h_\\theta(x) = \\theta^\\top x$，给定训练集 $\\{(x^{(i)}, y^{(i)})\\}$，推导其向量形式的最小二乘损失梯度下降更新公式为：\n$$\\theta := \\theta + \\alpha \\sum_{i=1}^{n} (y^{(i)} - h_\\theta(x^{(i)})) x^{(i)}$$解：\n最小二乘损失函数为：\n$$J(\\theta) = \\frac{1}{2}\\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)})^2 = \\frac{1}{2}\\sum_{i=1}^{n}(\\theta^\\top x^{(i)} - y^{(i)})^2$$对 $\\theta$ 求梯度：\n$$\\begin{aligned} \\nabla_\\theta J(\\theta) \u0026= \\sum_{i=1}^{n}(\\theta^\\top x^{(i)} - y^{(i)}) \\cdot x^{(i)} \\\\ \u0026= \\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} \\end{aligned}$$梯度下降更新规则为 $\\theta := \\theta - \\alpha \\nabla_\\theta J(\\theta)$，因此：\n$$\\theta := \\theta - \\alpha \\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} = \\theta + \\alpha \\sum_{i=1}^{n}(y^{(i)} - h_\\theta(x^{(i)})) x^{(i)}$$ 第二题：交叉熵损失梯度 题目： Cross Entropy Loss 定义如下：\n$$l_{ce}((t_1,\\ldots,t_k),y) = -\\log\\left(\\frac{\\exp(t_y)}{\\sum_j \\exp(t_j)}\\right)$$令向量 $t = (t_1,t_2,\\ldots,t_k)$，推导 CEL 对任意 $t_i$ 求导为：\n$$\\frac{\\partial l_{ce}(t,y)}{\\partial t_i} = \\phi_i - \\mathbb{1}\\{y=i\\}$$解：\n记 $\\phi_i = \\frac{\\exp(t_i)}{\\sum_j \\exp(t_j)}$ 为 softmax 函数。\n首先简化损失函数：\n$$l_{ce}(t,y) = -\\log(\\phi_y) = -t_y + \\log\\left(\\sum_j \\exp(t_j)\\right)$$对 $t_i$ 求导：\n$$\\begin{aligned} \\frac{\\partial l_{ce}(t,y)}{\\partial t_i} \u0026= -\\frac{\\partial t_y}{\\partial t_i} + \\frac{\\partial}{\\partial t_i}\\log\\left(\\sum_j \\exp(t_j)\\right) \\\\ \u0026= -\\mathbb{1}\\{y=i\\} + \\frac{\\exp(t_i)}{\\sum_j \\exp(t_j)} \\\\ \u0026= \\phi_i - \\mathbb{1}\\{y=i\\} \\end{aligned}$$其中 $\\mathbb{1}\\{y=i\\}$ 是指示函数，当 $y=i$ 时为1，否则为0。\n第三题：高斯假设下的最大似然估计 题目： 证明在高斯差异假定下，对线性模型 $h_\\theta(x) = \\theta^\\top x$，最大化参数似然 $L(\\theta)$ 等价于最小化二乘损失 $\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2$。\n解：\n假设误差 $\\epsilon^{(i)} = y^{(i)} - \\theta^\\top x^{(i)}$ 服从独立同分布的高斯分布 $\\mathcal{N}(0, \\sigma^2)$，即：\n$$p(\\epsilon^{(i)}) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(\\epsilon^{(i)})^2}{2\\sigma^2}\\right)$$因此：\n$$p(y^{(i)} | x^{(i)}; \\theta) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right)$$似然函数为：\n$$\\begin{aligned} L(\\theta) \u0026= \\prod_{i=1}^{n} p(y^{(i)} | x^{(i)}; \\theta) \\\\ \u0026= \\prod_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right) \\end{aligned}$$对数似然为：\n$$\\begin{aligned} \\log L(\\theta) \u0026= \\sum_{i=1}^{n}\\left[\\log\\frac{1}{\\sqrt{2\\pi}\\sigma} - \\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right] \\\\ \u0026= n\\log\\frac{1}{\\sqrt{2\\pi}\\sigma} - \\frac{1}{2\\sigma^2}\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2 \\end{aligned}$$最大化 $\\log L(\\theta)$ 等价于最小化 $\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2$。\n第四题：Logistic回归的NLL损失 题目： 对Logistic回归模型 $h_\\theta(x) = g(\\theta^\\top x) = \\frac{1}{1+e^{-\\theta^\\top x}}$，推导其在单样本 $(x,y)$ 下的NLL（negative log likelihood）损失，以及损失对特定参数 $\\theta_j$ 的导数为 $(h_\\theta(x) - y)x_j$。\n提示：Logistic回归预测概率的统一形式为 $P(y|x;\\theta) = (h_\\theta(x))^y(1-h_\\theta(x))^{1-y}$\n解：\n根据提示，Logistic回归的概率模型为：\n$$P(y|x;\\theta) = (h_\\theta(x))^y(1-h_\\theta(x))^{1-y}$$其中 $y \\in \\{0,1\\}$，$h_\\theta(x) = g(\\theta^\\top x) = \\frac{1}{1+e^{-\\theta^\\top x}}$。\n对数似然为：\n$$\\log P(y|x;\\theta) = y\\log(h_\\theta(x)) + (1-y)\\log(1-h_\\theta(x))$$NLL损失为：\n$$\\text{NLL}(x,y;\\theta) = -\\log P(y|x;\\theta) = -y\\log(h_\\theta(x)) - (1-y)\\log(1-h_\\theta(x))$$对 $\\theta_j$ 求导。首先注意到：\n$$\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j} = h_\\theta(x)(1-h_\\theta(x)) \\cdot x_j$$这是因为 $g'(z) = g(z)(1-g(z))$。\n因此：\n$$\\begin{aligned} \\frac{\\partial \\text{NLL}}{\\partial \\theta_j} \u0026= -y\\frac{1}{h_\\theta(x)}\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j} - (1-y)\\frac{1}{1-h_\\theta(x)}\\left(-\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j}\\right) \\\\ \u0026= -y\\frac{1}{h_\\theta(x)} \\cdot h_\\theta(x)(1-h_\\theta(x))x_j + (1-y)\\frac{1}{1-h_\\theta(x)} \\cdot h_\\theta(x)(1-h_\\theta(x))x_j \\\\ \u0026= -y(1-h_\\theta(x))x_j + (1-y)h_\\theta(x)x_j \\\\ \u0026= (h_\\theta(x) - y)x_j \\end{aligned}$$ 第五题：Poisson分布的指数族形式 题目： 已知指数分布族定义如下：$p(y;\\eta) = b(y)\\exp(\\eta^\\top y - a(\\eta))$。推导Poisson分布的指数分布族形式，并构建Poisson分布对应的广义线性模型。其中，Poisson分布 $\\text{Pois}(\\lambda)$ 的概率密度函数如下：\n$$P(X=k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}$$解：\n将Poisson分布改写为指数族形式：\n$$\\begin{aligned} P(X=k) \u0026= \\frac{\\lambda^k e^{-\\lambda}}{k!} \\\\ \u0026= \\frac{1}{k!}\\exp(k\\log\\lambda - \\lambda) \\\\ \u0026= \\frac{1}{k!}\\exp(\\eta \\cdot k - e^\\eta) \\end{aligned}$$其中 $\\eta = \\log\\lambda$（自然参数），因此 $\\lambda = e^\\eta$。\n对应指数族形式：\n$b(y) = \\frac{1}{y!}$ $\\eta = \\log\\lambda$ $a(\\eta) = e^\\eta = \\lambda$ $y$ 的充分统计量就是 $y$ 本身 构建广义线性模型：\n假设 $y|x;\\theta \\sim \\text{Pois}(\\lambda)$ 自然参数 $\\eta = \\theta^\\top x$ 因为 $\\lambda = e^\\eta$，所以 $\\lambda = e^{\\theta^\\top x}$ 响应函数（期望）为：$h_\\theta(x) = \\mathbb{E}[y|x;\\theta] = \\lambda = e^{\\theta^\\top x}$ 这就是Poisson回归模型。\n第六题：Shapley值计算 题目： 计算以下3人团队的Shapley值 $\\phi_1$、$\\phi_2$、$\\phi_3$。\n给定：\n$C_{123} = 10000$，$C_0 = 0$ $C_{12} = 7500$，$C_{13} = 7500$，$C_{23} = 5000$ $C_1 = 5000$，$C_2 = 5000$，$C_3 = 0$ 解：\nShapley值的公式为：\n$$\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(|N|-|S|-1)!}{|N|!}[C(S \\cup \\{i\\}) - C(S)]$$对于3人团队，$|N| = 3$，计算每个玩家的边际贡献：\n玩家1的Shapley值：\n$$\\begin{aligned} \\phi_1 \u0026= \\frac{0!2!}{3!}[C_1 - C_0] + \\frac{1!1!}{3!}[C_{12} - C_2] + \\frac{1!1!}{3!}[C_{13} - C_3] + \\frac{2!0!}{3!}[C_{123} - C_{23}] \\\\ \u0026= \\frac{1}{3}[5000 - 0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[7500 - 0] + \\frac{1}{3}[10000 - 5000] \\\\ \u0026= \\frac{5000}{3} + \\frac{2500}{6} + \\frac{7500}{6} + \\frac{5000}{3} \\\\ \u0026= \\frac{10000}{3} + \\frac{10000}{6} = \\frac{20000 + 10000}{6} = 5000 \\end{aligned}$$玩家2的Shapley值：\n$$\\begin{aligned} \\phi_2 \u0026= \\frac{0!2!}{3!}[C_2 - C_0] + \\frac{1!1!}{3!}[C_{12} - C_1] + \\frac{1!1!}{3!}[C_{23} - C_3] + \\frac{2!0!}{3!}[C_{123} - C_{13}] \\\\ \u0026= \\frac{1}{3}[5000 - 0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[5000 - 0] + \\frac{1}{3}[10000 - 7500] \\\\ \u0026= \\frac{5000}{3} + \\frac{2500}{6} + \\frac{5000}{6} + \\frac{2500}{3} \\\\ \u0026= \\frac{15000 + 2500 + 5000 + 5000}{6} = \\frac{27500}{6} \\approx 4583.33 \\end{aligned}$$玩家3的Shapley值：\n由对称性或直接计算：\n$$\\phi_3 = 10000 - \\phi_1 - \\phi_2 = 10000 - 5000 - 4583.33 = 416.67$$或直接计算：\n$$\\begin{aligned} \\phi_3 \u0026= \\frac{1}{3}[0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[5000 - 5000] + \\frac{1}{3}[10000 - 7500] \\\\ \u0026= 0 + \\frac{2500}{6} + 0 + \\frac{2500}{3} = \\frac{5000}{6} \\approx 416.67 \\end{aligned}$$答案： $\\phi_1 = 5000$，$\\phi_2 \\approx 4583.33$，$\\phi_3 \\approx 416.67$\n第七题：协方差矩阵性质 题目： 基于协方差矩阵定义 $\\Sigma = \\text{Cov}(X)$ 证明：\n$\\Sigma$ 为对称矩阵； $\\Sigma$ 半正定，记 $\\Sigma \\geq 0$，即对任意向量 $z \\in \\mathbb{R}^d$ 有 $z^\\top \\Sigma z \\geq 0$。 解：\n设 $X \\in \\mathbb{R}^d$ 为随机向量，$\\mu = \\mathbb{E}[X]$，则：\n$$\\Sigma = \\text{Cov}(X) = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top]$$(1) 证明 $\\Sigma$ 为对称矩阵：\n$$\\Sigma^\\top = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top]^\\top = \\mathbb{E}[((X-\\mu)(X-\\mu)^\\top)^\\top] = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top] = \\Sigma$$因此 $\\Sigma$ 是对称矩阵。\n(2) 证明 $\\Sigma$ 半正定：\n对任意 $z \\in \\mathbb{R}^d$：\n$$\\begin{aligned} z^\\top \\Sigma z \u0026= z^\\top \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top] z \\\\ \u0026= \\mathbb{E}[z^\\top(X-\\mu)(X-\\mu)^\\top z] \\\\ \u0026= \\mathbb{E}[(z^\\top(X-\\mu))^2] \\\\ \u0026\\geq 0 \\end{aligned}$$最后一步是因为期望中的项是平方项，必然非负。因此 $\\Sigma$ 半正定。\n第八题：高斯判别分析的MLE 题目： 对高斯判别分析，已知各变量概率分布为：\n$$\\begin{aligned} p(y) \u0026= \\phi^y(1-\\phi)^{1-y} \\\\ p(x|y=0) \u0026= \\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}\\exp\\left(-\\frac{1}{2}(x-\\mu_0)^\\top\\Sigma^{-1}(x-\\mu_0)\\right) \\\\ p(x|y=1) \u0026= \\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}\\exp\\left(-\\frac{1}{2}(x-\\mu_1)^\\top\\Sigma^{-1}(x-\\mu_1)\\right) \\end{aligned}$$证明在极大似然估计下，参数 $\\phi$、$\\mu_0$、$\\mu_1$ 的形式为：\n$$\\begin{aligned} \\phi \u0026= \\frac{1}{n}\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\} \\\\ \\mu_0 \u0026= \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}} \\\\ \\mu_1 \u0026= \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}} \\end{aligned}$$解：\n对数似然函数为：\n$$\\log L = \\sum_{i=1}^{n}\\left[\\log p(y^{(i)}) + \\log p(x^{(i)}|y^{(i)})\\right]$$估计 $\\phi$：\n$$\\log L_\\phi = \\sum_{i=1}^{n}\\log p(y^{(i)}) = \\sum_{i=1}^{n}[y^{(i)}\\log\\phi + (1-y^{(i)})\\log(1-\\phi)]$$令 $\\frac{\\partial \\log L_\\phi}{\\partial \\phi} = 0$：\n$$\\sum_{i=1}^{n}\\left[\\frac{y^{(i)}}{\\phi} - \\frac{1-y^{(i)}}{1-\\phi}\\right] = 0$$解得：\n$$\\phi = \\frac{1}{n}\\sum_{i=1}^{n}y^{(i)} = \\frac{1}{n}\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}$$估计 $\\mu_0$：\n只考虑 $y=0$ 的样本：\n$$\\log L_{\\mu_0} = \\sum_{i:y^{(i)}=0}\\left[-\\frac{1}{2}(x^{(i)}-\\mu_0)^\\top\\Sigma^{-1}(x^{(i)}-\\mu_0) + \\text{const}\\right]$$令 $\\frac{\\partial \\log L_{\\mu_0}}{\\partial \\mu_0} = 0$：\n$$\\sum_{i:y^{(i)}=0}\\Sigma^{-1}(x^{(i)}-\\mu_0) = 0$$解得：\n$$\\mu_0 = \\frac{\\sum_{i:y^{(i)}=0}x^{(i)}}{\\sum_{i:y^{(i)}=0}1} = \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}}$$同理可得 $\\mu_1$ 的估计。\n第九题：GDA可转化为Logistic回归 题目： 证明GDA可转化为Logistic回归。提示：\n$p(y=1|x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=1)p(y=1) + p(x|y=0)p(y=0)}$ 可记 $r(x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)}$ 给出 $p(x|y=0)$, $p(x|y=1)$, $p(y=1)$ 的表达式 解：\n根据贝叶斯定理：\n$$p(y=1|x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=1)p(y=1) + p(x|y=0)p(y=0)} = \\frac{1}{1 + \\frac{p(x|y=0)p(y=0)}{p(x|y=1)p(y=1)}} = \\frac{1}{1 + \\frac{1}{r(x)}}$$其中：\n$$r(x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)}$$计算 $\\log r(x)$：\n$$\\begin{aligned} \\log r(x) \u0026= \\log p(x|y=1) + \\log p(y=1) - \\log p(x|y=0) - \\log p(y=0) \\\\ \u0026= -\\frac{1}{2}(x-\\mu_1)^\\top\\Sigma^{-1}(x-\\mu_1) + \\frac{1}{2}(x-\\mu_0)^\\top\\Sigma^{-1}(x-\\mu_0) + \\log\\frac{\\phi}{1-\\phi} \\end{aligned}$$展开：\n$$\\begin{aligned} \\log r(x) \u0026= -\\frac{1}{2}x^\\top\\Sigma^{-1}x + x^\\top\\Sigma^{-1}\\mu_1 - \\frac{1}{2}\\mu_1^\\top\\Sigma^{-1}\\mu_1 \\\\ \u0026\\quad + \\frac{1}{2}x^\\top\\Sigma^{-1}x - x^\\top\\Sigma^{-1}\\mu_0 + \\frac{1}{2}\\mu_0^\\top\\Sigma^{-1}\\mu_0 + \\log\\frac{\\phi}{1-\\phi} \\\\ \u0026= x^\\top\\Sigma^{-1}(\\mu_1 - \\mu_0) + \\frac{1}{2}(\\mu_0^\\top\\Sigma^{-1}\\mu_0 - \\mu_1^\\top\\Sigma^{-1}\\mu_1) + \\log\\frac{\\phi}{1-\\phi} \\\\ \u0026= \\theta^\\top x + \\theta_0 \\end{aligned}$$其中：\n$$\\theta = \\Sigma^{-1}(\\mu_1 - \\mu_0), \\quad \\theta_0 = \\frac{1}{2}(\\mu_0^\\top\\Sigma^{-1}\\mu_0 - \\mu_1^\\top\\Sigma^{-1}\\mu_1) + \\log\\frac{\\phi}{1-\\phi}$$因此：\n$$p(y=1|x) = \\frac{1}{1+e^{-\\theta^\\top x - \\theta_0}} = \\frac{1}{1+e^{-\\tilde{\\theta}^\\top \\tilde{x}}}$$这正是Logistic回归的形式（其中 $\\tilde{x}$ 包含截距项）。\n第十题：Kernel Method分析 题目： Kernel method中，若Kernel function $K(x,z) = (x^\\top z + c)^2$，推导对应的feature mapping $\\phi$，并讨论对于 $n$ 个样本一轮SGD，使用Kernel method和在feature map上的计算效率优化比。\n提示：\n基于feature map的参数更新方法为：$\\theta := \\theta + \\alpha\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top\\phi(x^{(i)}))\\phi(x^{(i)})$ Kernel method的参数更新方法为：$\\theta := \\theta + \\alpha(\\tilde{y} - K\\theta)$，其中 $K_j = K(x^{(i)}, x^{(j)})$ 解：\n推导feature mapping：\n对于 $x,z \\in \\mathbb{R}^d$，展开核函数：\n$$\\begin{aligned} K(x,z) \u0026= (x^\\top z + c)^2 \\\\ \u0026= (x_1z_1 + x_2z_2 + \\cdots + x_dz_d + c)^2 \\\\ \u0026= \\sum_{i=1}^{d}x_i^2z_i^2 + \\sum_{i \\neq j}2x_ix_jz_iz_j + 2c\\sum_{i=1}^{d}x_iz_i + c^2 \\end{aligned}$$因此，feature mapping为：\n$$\\phi(x) = (x_1^2, x_2^2, \\ldots, x_d^2, \\sqrt{2}x_1x_2, \\sqrt{2}x_1x_3, \\ldots, \\sqrt{2}x_{d-1}x_d, \\sqrt{2c}x_1, \\ldots, \\sqrt{2c}x_d, c)$$维度为：$d + \\binom{d}{2} + d + 1 = d + \\frac{d(d-1)}{2} + d + 1 = \\frac{d(d+3)}{2} + 1 = O(d^2)$\n计算效率比较：\nFeature map方法： 计算 $\\phi(x^{(i)})$：$O(d^2)$ 每个样本 内积 $\\theta^\\top\\phi(x^{(i)})$：$O(d^2)$ 更新 $\\theta$：$O(d^2)$ 总计：$O(nd^2)$ 每轮SGD Kernel method： 计算核矩阵 $K$：$O(n^2d)$（一次性预计算） 更新参数：$O(n^2)$（矩阵向量乘法） 总计：$O(n^2d + n^2) = O(n^2d)$ 每轮 效率比：\n$$\\frac{\\text{Feature map}}{\\text{Kernel method}} = \\frac{O(nd^2)}{O(n^2d)} = \\frac{d}{n}$$ 当 $n \\ll d$ 时（样本少，特征多），Kernel method更高效 当 $n \\gg d$ 时（样本多，特征少），Feature map方法更高效 第十一题：超平面的函数间隔和几何间隔 题目： 对超平面 $w^\\top x + b = 0$，样本 $x^{(i)}$ 到的函数间隔 $\\hat{\\gamma}^{(i)}$ 与几何间隔 $\\gamma^{(i)}$ 满足何关系？直接给出答案即可。\n解：\n函数间隔定义为：\n$$\\hat{\\gamma}^{(i)} = y^{(i)}(w^\\top x^{(i)} + b)$$几何间隔定义为：\n$\\gamma^{(i)} = \\frac{y^{(i)}(w^\\top x^{(i)} + b)}{|w|} = \\frac{\\hat{\\gamma}^{(i)}}{|w|}$\n关系：\n$\\gamma^{(i)} = \\frac{\\hat{\\gamma}^{(i)}}{|w|}$\n几何间隔是函数间隔除以权重向量的范数，表示点到超平面的真实距离。\n第十二题：SVM的Lagrange函数和对偶形式 题目： 已知SVM的优化目标为：\n$$ \\min_{w,b} \\quad \\frac{1}{2}\\|w\\|^2 \\qquad (1) $$$$ \\text{s.t.} \\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1, \\quad i=1,\\ldots,n $$请构造其Lagrange函数 $\\mathcal{L}(w,b,\\alpha)$。\n已知 $\\mathcal{L}(w,b,\\alpha)$ 满足Slater条件，因此强对偶成立，问题(1)最终可转化为 $\\max_{\\alpha;\\alpha_i\\geq 0}\\min_w \\mathcal{L}(w,b,\\alpha)$，证明该对偶形式问题可进一步转化为：\n$$ \\max_\\alpha W(\\alpha) = \\max_\\alpha \\left(\\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle\\right) \\qquad (2) $$约束条件：\n$$ \\alpha_i \\geq 0, \\quad i=1,\\ldots,n $$$$ \\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0 $$解：\n步骤1：构造Lagrange函数\n$\\mathcal{L}(w,b,\\alpha) = \\frac{1}{2}|w|^2 - \\sum_{i=1}^{n}\\alpha_i[y^{(i)}(w^\\top x^{(i)} + b) - 1]$\n其中 $\\alpha_i \\geq 0$ 为Lagrange乘子。\n步骤2：固定 $\\alpha$，对 $w$ 求导\n$\\frac{\\partial \\mathcal{L}}{\\partial w} = w - \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)} = 0$\n因此：\n$w = \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}$\n步骤3：固定 $\\alpha$，对 $b$ 求导\n$\\frac{\\partial \\mathcal{L}}{\\partial b} = -\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$\n因此：\n$\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$\n步骤4：代入Lagrange函数\n将 $w = \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}$ 代入 $\\mathcal{L}$：\n$\\begin{aligned} \\mathcal{L}(w,b,\\alpha) \u0026= \\frac{1}{2}w^\\top w - \\sum_{i=1}^{n}\\alpha_i y^{(i)} w^\\top x^{(i)} - b\\sum_{i=1}^{n}\\alpha_i y^{(i)} + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\frac{1}{2}\\left(\\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}\\right)^\\top\\left(\\sum_{j=1}^{n}\\alpha_j y^{(j)} x^{(j)}\\right) - \\sum_{i=1}^{n}\\alpha_i y^{(i)} \\left(\\sum_{j=1}^{n}\\alpha_j y^{(j)} x^{(j)}\\right)^\\top x^{(i)} + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle - \\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle \\end{aligned}$\n其中使用了 $\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$，所以 $b$ 项消失。\n因此对偶问题为：\n$\\max_\\alpha W(\\alpha) = \\max_\\alpha \\left(\\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle\\right)$\n约束条件为：\n$\\begin{aligned} \\alpha_i \u0026\\geq 0, \\quad i=1,\\ldots,n \\\\ \\sum_{i=1}^{n}\\alpha_i y^{(i)} \u0026= 0 \\end{aligned}$\n第十三题：线性不可分的SVM与L1正则 题目： 对线性不可分的训练集，SVM对应带L1正则的优化目标是什么？已知对线性可分情况的优化为：\n$$ \\min_{w,b} \\quad \\frac{1}{2}\\|w\\|^2 \\qquad (1) $$ $$ \\text{s.t.} \\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1, \\quad i=1,\\ldots,n $$解：\n对于线性不可分的情况，引入松弛变量 $\\xi_i \\geq 0$，允许某些样本违反间隔约束。\n带L1正则的软间隔SVM优化目标为：\n$\\begin{aligned} \\min_{w,b,\\xi} \u0026\\quad \\frac{1}{2}|w|^2 + C\\sum_{i=1}^{n}\\xi_i \\\\ \\text{s.t.} \u0026\\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1 - \\xi_i, \\quad i=1,\\ldots,n \\\\ \u0026\\quad \\xi_i \\geq 0, \\quad i=1,\\ldots,n \\end{aligned}$\n其中：\n$\\xi_i$ 是松弛变量，表示样本 $i$ 违反间隔的程度 $C \u003e 0$ 是惩罚参数，控制间隔最大化与违反程度之间的权衡 $C\\sum_{i=1}^{n}\\xi_i$ 是L1正则项（对松弛变量的惩罚） 这个目标函数平衡了两个目标：\n最大化间隔（通过最小化 $|w|^2$） 最小化分类错误（通过最小化 $\\sum\\xi_i$） 第十四题：SVM最优化问题分析 题目： 已知SVM的最终优化目标为：\n$W(\\alpha) = \\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle$\n假设此时正在优化 $\\alpha_1$ 与 $\\alpha_2$，并有 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$。请推导此时 $\\alpha_2$ 应当更新的值。\n解：\n简化目标函数：\n在固定其他 $\\alpha_i$ ($i \\geq 3$) 的情况下，目标函数关于 $\\alpha_1, \\alpha_2$ 可写为：\n$W(\\alpha_1, \\alpha_2) = \\alpha_1 + \\alpha_2 + W_0 - \\frac{1}{2}[K_{11}\\alpha_1^2 + K_{22}\\alpha_2^2 + 2K_{12}\\alpha_1\\alpha_2y^{(1)}y^{(2)}] + \\text{线性项}$\n其中 $K_{ij} = \\langle x^{(i)}, x^{(j)}\\rangle$，$W_0$ 是常数项。\n利用约束 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$：\n这个约束来自 $\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$，可以改写为：\n$\\alpha_1 y^{(1)} + \\alpha_2 y^{(2)} = -\\sum_{i=3}^{n}\\alpha_i y^{(i)} = \\zeta \\quad \\text{（常数）}$\n将 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$ 代入目标函数，得到关于 $\\alpha_2$ 的单变量优化问题。\n对 $\\alpha_2$ 求导并令其为0，经过复杂推导（涉及预测误差），得到 $\\alpha_2$ 的无约束最优解：\n$\\alpha_2^{\\text{new, unc}} = \\alpha_2^{\\text{old}} + \\frac{y^{(2)}(E_1 - E_2)}{\\eta}$\n其中：\n$E_i = f(x^{(i)}) - y^{(i)}$ 是预测误差 $\\eta = K_{11} + K_{22} - 2K_{12} = \\|x^{(1)} - x^{(2)}\\|^2$（特征空间距离） 考虑约束 $0 \\leq \\alpha_2 \\leq C$：\n根据约束 $\\alpha_1 y^{(1)} + \\alpha_2 y^{(2)} = \\zeta$：\n若 $y^{(1)} \\neq y^{(2)}$： $L = \\max(0, \\alpha_2^{\\text{old}} - \\alpha_1^{\\text{old}}), \\quad H = \\min(C, C + \\alpha_2^{\\text{old}} - \\alpha_1^{\\text{old}})$ 若 $y^{(1)} = y^{(2)}$： $L = \\max(0, \\alpha_1^{\\text{old}} + \\alpha_2^{\\text{old}} - C), \\quad H = \\min(C, \\alpha_1^{\\text{old}} + \\alpha_2^{\\text{old}})$ 最终更新公式：\n$\\alpha_2^{\\text{new}} = \\begin{cases} H \u0026 \\text{if } \\alpha_2^{\\text{new, unc}} \u003e H \\\\ \\alpha_2^{\\text{new, unc}} \u0026 \\text{if } L \\leq \\alpha_2^{\\text{new, unc}} \\leq H \\\\ L \u0026 \\text{if } \\alpha_2^{\\text{new, unc}} \u003c L \\end{cases}$\n然后通过约束更新 $\\alpha_1$：\n$\\alpha_1^{\\text{new}} = \\alpha_1^{\\text{old}} + y^{(1)}y^{(2)}(\\alpha_2^{\\text{old}} - \\alpha_2^{\\text{new}})$\n第十五题：信息增益比计算 题目： 计算给定数据集中四个特征的信息增益比。可保留log项，统一底数为2。\n解：\n首先计算数据集的熵。类别分布：否=6，是=9，总计15。\n$H(D) = -\\frac{6}{15}\\log_2\\frac{6}{15} - \\frac{9}{15}\\log_2\\frac{9}{15} = -0.4\\log_2(0.4) - 0.6\\log_2(0.6) = 0.971$\n特征1：年龄 青年(5个)：否=3，是=2，$H = 0.971$ 中年(5个)：否=1，是=4，$H = 0.722$ 老年(5个)：否=2，是=3，$H = 0.971$ 条件熵：\n$H(D|\\text{年龄}) = \\frac{5}{15}(0.971) + \\frac{5}{15}(0.722) + \\frac{5}{15}(0.971) = 0.888$\n信息增益：\n$\\text{Gain}(\\text{年龄}) = 0.971 - 0.888 = 0.083$\n特征熵（分裂信息）：\n$H_A(\\text{年龄}) = -3 \\times \\frac{5}{15}\\log_2\\frac{5}{15} = \\log_2 3 = 1.585$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{年龄}) = \\frac{0.083}{1.585} = 0.052 $$特征2：有工作 否(8个)：否=4，是=4，$H = 1.0$ 是(7个)：否=2，是=5，$H = 0.863$ 条件熵：$H(D|\\text{有工作}) = 0.936$\n信息增益：$\\text{Gain}(\\text{有工作}) = 0.035$\n特征熵：$H_A(\\text{有工作}) = 0.997$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{有工作}) = 0.035 $$特征3：有自己的房子 否(9个)：否=3，是=6，$H = 0.918$ 是(6个)：否=3，是=3，$H = 1.0$ 条件熵：$H(D|\\text{有房}) = 0.951$\n信息增益：$\\text{Gain}(\\text{有房}) = 0.020$\n特征熵：$H_A(\\text{有房}) = 0.971$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{有房}) = 0.021 $$特征4：信贷情况 一般(5个)：否=4，是=1，$H = 0.722$ 好(6个)：否=2，是=4，$H = 0.918$ 非常好(4个)：否=0，是=4，$H = 0$ 条件熵：$H(D|\\text{信贷}) = 0.608$\n信息增益：$\\text{Gain}(\\text{信贷}) = 0.363$\n特征熵：$H_A(\\text{信贷}) = 1.557$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{信贷}) = 0.233 $$总结（信息增益比排序） 信贷情况：0.233 ⭐（最佳分裂特征） 年龄：0.052 有工作：0.035 有自己的房子：0.021 应选择\u0026quot;信贷情况\u0026quot;作为根节点的分裂特征。\n第十六题：XGBoost损失函数二阶泰勒展开 题目： 已知XGBoost优化第t棵树时的损失函数为：\n$\\mathcal{L}^{(t)} = \\sum_{i=1}^{n}l(y_i, \\hat{y}*i^{(t-1)} + f_t(x_i)) + \\gamma T + \\frac{1}{2}\\lambda\\sum*{j=1}^{T}w_j^2$\n请推导 $l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i))$ 在 $l(y_i, \\hat{y}_i^{(t-1)})$ 处对于 $f_t(x_i)$ 的二阶泰勒展开。其中，一阶和二阶导数可使用：\n$g_i = \\frac{\\partial l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i}\\Big|*{\\hat{y}_i^{(t-1)}}, \\quad h_i = \\frac{\\partial^2 l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i^2}\\Big|*{\\hat{y}_i^{(t-1)}}$\n在此基础上，推导叶子节点 $j$ 对应的 $w_j^*$ 满足：\n$w_j^* = -\\frac{\\sum_{i \\in \\mathcal{I}*j}g_i}{\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda}$\n其中，$\\mathcal{I}_j = \\{i \\mid q(x_i) = j\\}$ 表示属于叶子节点 $j$ 的样本集合。\n解：\n二阶泰勒展开 在 $\\hat{y}_i^{(t-1)}$ 处对 $l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i))$ 关于 $f_t(x_i)$ 进行二阶泰勒展开：\n$\\begin{aligned} l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i)) \u0026\\approx l(y_i, \\hat{y}_i^{(t-1)}) + \\frac{\\partial l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i}\\Big|*{\\hat{y}_i^{(t-1)}} \\cdot f_t(x_i) \\\\ \u0026\\quad + \\frac{1}{2}\\frac{\\partial^2 l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i^2}\\Big|*{\\hat{y}_i^{(t-1)}} \\cdot f_t(x_i)^2 \\\\ \u0026= l(y_i, \\hat{y}_i^{(t-1)}) + g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2 \\end{aligned}$\n因此损失函数变为：\n$\\mathcal{L}^{(t)} \\approx \\sum_{i=1}^{n}[l(y_i, \\hat{y}*i^{(t-1)}) + g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2] + \\gamma T + \\frac{1}{2}\\lambda\\sum*{j=1}^{T}w_j^2$\n去掉常数项 $\\sum_{i=1}^{n}l(y_i, \\hat{y}_i^{(t-1)})$：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{i=1}^{n}[g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2] + \\gamma T + \\frac{1}{2}\\lambda\\sum_{j=1}^{T}w_j^2$\n推导叶子权重 $w_j^*$ 对于树模型，$f_t(x_i) = w_{q(x_i)}$，其中 $q(x_i)$ 表示样本 $i$ 落在的叶子节点。\n将样本按叶子节点分组：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{j=1}^{T}\\left[\\left(\\sum_{i \\in \\mathcal{I}*j}g_i\\right)w_j + \\frac{1}{2}\\left(\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda\\right)w_j^2\\right] + \\gamma T$\n记 $G_j = \\sum_{i \\in \\mathcal{I}*j}g_i$，$H_j = \\sum*{i \\in \\mathcal{I}_j}h_i$，则：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{j=1}^{T}\\left[G_j w_j + \\frac{1}{2}(H_j + \\lambda)w_j^2\\right] + \\gamma T$\n对 $w_j$ 求导并令其为0：\n$\\frac{\\partial \\tilde{\\mathcal{L}}^{(t)}}{\\partial w_j} = G_j + (H_j + \\lambda)w_j = 0$\n解得：\n$w_j^* = -\\frac{G_j}{H_j + \\lambda} = -\\frac{\\sum_{i \\in \\mathcal{I}*j}g_i}{\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda}$\n这就是叶子节点的最优权重。将其代入损失函数，得到：\n$\\tilde{\\mathcal{L}}^{(t)} = -\\frac{1}{2}\\sum_{j=1}^{T}\\frac{G_j^2}{H_j + \\lambda} + \\gamma T$\n这个公式用于评估树结构的质量，指导分裂决策。\n","permalink":"http://localhost:1313/posts/ml-exercise-set/","summary":"胡老师上的机器学习课程习题集解答汇总","title":"机器学习习题集"},{"content":"前言 四川麻将，又称成都麻将或血战麻将，是中国最流行的麻将玩法之一。与传统麻将相比，四川麻将节奏快、变化多，充满了刺激性和趣味性。本文将带你从零开始，系统学习四川麻将的规则和技巧。\n一、基础规则入门 1.1 牌面组成 四川麻将使用108张牌，包括：\n万子：一万到九万，各4张（36张） 条子：一条到九条，各4张（36张） 筒子：一筒到九筒，各4张（36张） 注意：四川麻将没有东南西北中发白这些字牌和花牌。\n1.2 基本概念 刻子：三张相同的牌（如：三张五万） 顺子：三张连续的同花色牌（如：三四五条） 对子：两张相同的牌（如：两张八筒） 杠：四张相同的牌\n1.3 胡牌基本型 标准胡牌牌型：3n+2 结构（n个刻子或顺子 + 1个对子）\n例如：\n一一一 + 二三四 + 五六七 + 八八八 + 九九（4组3张+1对） 1.4 游戏流程 定庄：掷骰子决定庄家 配牌：每人抓13张牌，庄家多抓一张（14张） 出牌：庄家先出一张牌，其他玩家依次摸牌、出牌 胡牌：谁先凑齐胡牌牌型谁获胜 血战到底：已胡牌的玩家退出，剩余玩家继续游戏，直到3人胡牌或流局 二、四川麻将特色规则 2.1 缺一门 四川麻将的核心规则：必须缺一门才能胡牌\n也就是说，你的手牌中只能有两种花色（万、条、筒三选二）。\n例如：\n✅ 可以胡：万子+条子（缺筒） ✅ 可以胡：万子+筒子（缺条） ❌ 不能胡：万子+条子+筒子（三门齐全） 2.2 杠牌规则 明杠：\n碰牌后，再摸到第四张，可以杠牌 别人打出的牌，自己有三张，可以直接杠 暗杠：\n自己摸到四张相同的牌，可以暗杠 杠牌后：\n摸一张牌 多算一番（底分×2） 杠后可以继续杠或胡牌 2.3 血战到底 这是四川麻将最大的特色：\n第一个人胡牌后不结束游戏 剩余三人继续打，直到有第二、第三个人胡牌 最后没胡的人要赔给所有胡牌的人 第一个胡牌的人可以继续胡（查叫） 2.4 查叫 游戏结束时，如果有人没胡牌：\n如果他已听牌（只差一张就能胡），他只赔给胡牌的人 如果他未听牌（没有听牌），他要加倍赔偿 三、番型与计分 3.1 基础番型 番型 番数 说明 平胡 1番 基础胡牌 自摸 1番 自己摸牌胡 根（杠） 1番 每杠一次+1番 对对胡 2番 全是刻子+对子，没有顺子 清一色 4番 全部是一种花色 龙七对 4番 七个对子 天胡 封顶 庄家起手就胡 地胡 封顶 闲家第一轮胡 3.2 计分方式 基础公式：底分 × 2^(番数)\n例如：\n底分1元，平胡（1番）= 1×2¹ = 2元 底分1元，清一色（4番）= 1×2⁴ = 16元 底分1元，清一色+对对胡（6番）= 1×2⁶ = 64元 封顶：很多地方设置封顶番数（如10番），防止输赢过大\n四、进阶技巧 4.1 定缺策略 游戏开始后，要快速决定缺哪一门：\n判断依据：\n数量最少的门：哪门牌少就缺哪门 孤张多的门：有很多不连续的孤张，这门不好组合 对子情况：如果某门有对子，考虑留下，可能组成刻子 例子：\n手牌：一万 三万 五万 六万 | 二条 七条 | 一筒 二筒 三筒 四筒 八筒 九筒 分析：万子4张分散，条子2张，筒子6张且有顺子潜力 建议：缺条子 4.2 听牌技巧 多面听优于单钓：\n单钓：只有一种牌能胡（如：等一张五万） 两面听：能胡两种牌（如：三四条，等二条或五条） 多面听：能胡多种牌（如：卡张、边张、对子等组合） 例子：\n手牌：一万 二万 | 三万 四万 | 五万 六万 | 七万 八万 | 九万 拆牌选择： - 打九万：听二万和五万（两面） - 打一万：听三万和六万和九万（多面） 建议打一万，听牌面更多 4.3 防守策略 观察舍牌：\n对手打出的牌反映他要什么、不要什么 如果对手大量打某一门，可能在做清一色 如果对手突然不打某种牌，可能在攒那个牌 生张和熟张：\n生张：桌面上没出现过的牌，危险度较高 熟张：已经有人打过的牌，相对安全 听牌信号：\n出牌犹豫 打牌速度突然变化 开始打生张或中张 4.4 做大牌策略 什么时候做大牌：\n起手牌型好（比如某门很多，可以做清一色） 当前领先或持平，可以冒险 对手没有明显听牌迹象 做大牌风险：\n听牌较慢，容易被别人截胡 如果未听牌查叫，要加倍赔偿 建议新手以稳为主，先保证听牌 4.5 心理战术 诱敌出牌：\n故意打出中张，引诱对手出你需要的牌 注意节奏，不要过于明显 藏牌意图：\n不要急于碰牌或杠牌，暴露自己的牌型 暗刻比明刻更有迷惑性 施压策略：\n快速出牌，给对手压力 适当沉默，让对手摸不清你的意图 五、常见错误与避免 5.1 新手常犯错误 忘记缺门：手牌三门齐全还以为能胡 盲目做大牌：不顾牌型强行做清一色，最后未听牌 不会算番：不知道自己多少番，糊里糊涂胡牌 乱碰乱杠：过早暴露牌型，让对手防范 不看舍牌：只顾自己手牌，不观察对手 5.2 进阶常犯错误 过度防守：太在意对手，错失自己的听牌机会 贪大求全：总想胡大牌，反而听牌慢 不会放弃：明知牌型不好还死撑，最后查叫 心态失衡：连续点炮后急躁，决策失误 六、实战案例分析 案例1：定缺选择 起手牌：\n二万 四万 六万 八万 九万 一条 二条 三条 五筒 六筒 七筒 八筒 分析：\n万子：5张但分散，不易组合 条子：3张成顺，很好 筒子：4张有两个顺子潜力 决策：缺万子，保留条筒两门\n案例2：听牌选择 当前牌型：\n二万 三万 四万 | 五万 六万 七万 | 一条 二条 三条 | 五筒 六筒 | 八筒 八筒 选择1：打五筒或六筒，听七筒（单钓） 选择2：打八筒，听四筒或七筒（两面）\n决策：选择2更优，两面听更容易胡牌\n案例3：要不要做清一色 当前牌型（已缺条）：\n一万 二万 三万 四万 五万 六万 | 二筒 五筒 七筒 | 八筒 八筒 分析：\n距离清一色还差3张筒子替换万子 如果做清一色，需要拆掉现有的顺子 当前可以快速听牌（1-2轮） 决策：不做清一色，保证快速听牌，除非后续摸牌特别好\n七、练习建议 7.1 新手阶段 熟悉规则：先玩小局，熟悉缺门、血战等规则 记住番型：至少记住基础番型和分数 多观察：看别人怎么打，学习经验 求稳为主：不要急于做大牌，先学会稳定胡牌 7.2 进阶阶段 提高速度：加快判断和决策速度 学习算牌：记住哪些牌出过，推测剩余牌 心理博弈：学会观察对手，做出针对性策略 复盘总结：每局结束后思考得失 7.3 推荐练习方式 线上平台：在手机或电脑上玩四川麻将游戏，方便练习 观战学习：看高手直播或录像，学习思路 实战练习：找朋友线下对局，积累实战经验 理论学习：阅读麻将书籍或教程，系统提升 八、总结 四川麻将规则简单但策略丰富，从新手到高手需要：\n扎实的基本功：熟练掌握规则和番型 灵活的战术：根据牌型和局势调整策略 敏锐的观察力：读懂对手意图，做出正确判断 稳定的心态：胜不骄败不馁，理性决策 记住：麻将三分靠运气，七分靠技术。多练习、多思考，你一定能成为四川麻将高手！\n祝你好运，胡牌多多！🀄\n","permalink":"http://localhost:1313/posts/sichuan-mahjong-guide/","summary":"四川麻将完全攻略：从基础规则到高阶技巧，涵盖缺一门、血战到底、番型计分、定缺策略、听牌技巧、防守要点和实战案例分析。无论你是零基础| 新手还是想提升的进阶玩家，这篇指南都能帮你系统掌握四川麻将的精髓，快速从入门到精通。","title":"四川麻将指南"},{"content":"Windows PowerShell 常用指令 文件和目录操作 列出目录内容\nGet-ChildItem / ls - 列出当前目录内容 ls -Force - 显示隐藏文件 ls -Recurse - 递归列出所有子目录 ls | Sort-Object Length -Descending - 按文件大小排序 切换目录\nSet-Location \u0026lt;路径\u0026gt; / cd - 切换目录 cd ~ - 返回用户主目录 cd .. - 返回上级目录 cd - - 返回上一个目录 创建文件和目录\nNew-Item -ItemType Directory \u0026lt;名称\u0026gt; / mkdir - 创建目录 New-Item -ItemType File \u0026lt;名称\u0026gt; / ni - 创建文件 复制、移动和删除\nCopy-Item \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; 复制文件\nMove-Item \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; / mv - 移动/重命名文件\nRemove-Item \u0026lt;路径\u0026gt; 删除文件\n查看文件\nGet-Content \u0026lt;文件\u0026gt; / cat - 查看文件内容 Get-Content \u0026lt;文件\u0026gt; -Tail 10 - 查看最后 10 行 Get-Content \u0026lt;文件\u0026gt; -Wait - 实时查看文件更新（类似 tail -f） Test-Path \u0026lt;路径\u0026gt; - 检查路径是否存在 以默认方式打开文件或目录\nstart filename打开当前目录下的指定文件 code filename使用vscode打开 code .使用vscode打开当前目录 文本处理和搜索 Select-String \u0026lt;模式\u0026gt; \u0026lt;文件\u0026gt; - 在文件中搜索文本（类似 grep） Select-String \u0026quot;error\u0026quot; *.log - 在所有 log 文件中搜索 ls -Recurse | Select-String \u0026quot;TODO\u0026quot; - 递归搜索 Out-File \u0026lt;文件\u0026gt; - 输出重定向到文件 Tee-Object \u0026lt;文件\u0026gt; - 同时输出到控制台和文件 系统信息和管理 进程管理\nGet-Process / ps - 查看进程列表 Get-Process | Sort-Object CPU -Descending | Select-Object -First 5 - CPU 占用最高的 5 个进程 Stop-Process -Name \u0026lt;进程名\u0026gt; - 结束进程 服务管理\nGet-Service - 查看服务列表 Get-Service | Where-Object {$_.Status -eq \u0026quot;Running\u0026quot;} - 只显示运行中的服务 Start-Service \u0026lt;服务名\u0026gt; - 启动服务 Stop-Service \u0026lt;服务名\u0026gt; - 停止服务 系统信息\nGet-ComputerInfo - 查看计算机信息 Get-NetIPAddress - 查看网络配置 Get-Disk - 查看磁盘信息 Get-Volume - 查看卷信息 systeminfo - 显示详细系统信息 环境变量 $env:PATH - 查看 PATH 环境变量 $env:变量名 = \u0026quot;值\u0026quot; - 设置临时环境变量 [Environment]::SetEnvironmentVariable(\u0026quot;变量名\u0026quot;, \u0026quot;值\u0026quot;, \u0026quot;User\u0026quot;) - 永久设置 网络操作 Test-Connection \u0026lt;主机\u0026gt; / ping - 测试网络连接 Invoke-WebRequest \u0026lt;URL\u0026gt; / curl - 发送 HTTP 请求 Invoke-WebRequest -Uri \u0026lt;URL\u0026gt; -OutFile \u0026lt;文件\u0026gt; - 下载文件 Get-NetTCPConnection - 查看 TCP 连接 ipconfig - 查看 IP 配置 ipconfig /flushdns - 刷新 DNS 缓存 实用命令 Clear-Host / cls - 清屏 Get-History / history - 查看命令历史 Get-Help \u0026lt;命令\u0026gt; - 获取帮助 Get-Help \u0026lt;命令\u0026gt; -Examples - 查看使用示例 Get-Command - 列出所有可用命令 Get-Command *process* - 搜索包含 process 的命令 Get-Alias - 查看所有别名 Measure-Object - 统计对象 Start-Process \u0026lt;程序\u0026gt; - 启动程序 Get-Location / pwd - 显示当前路径 Linux Terminal 常用指令 文件和目录操作 列出目录\nls - 列出目录内容 ls -l - 长格式显示（详细信息） ls -a - 显示隐藏文件 ls -lh - 人性化显示文件大小 ls -lt - 按修改时间排序 ls -lS - 按文件大小排序 ls -R - 递归列出所有子目录 切换目录\ncd \u0026lt;路径\u0026gt; - 切换目录 cd / cd ~ - 返回主目录 cd .. - 返回上级目录 cd - - 返回上一个目录 pwd - 显示当前完整路径 创建\nmkdir \u0026lt;目录名\u0026gt; - 创建目录 mkdir -p a/b/c - 递归创建多级目录 touch \u0026lt;文件名\u0026gt; - 创建空文件或更新时间戳 复制、移动和删除\ncp \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 复制文件 cp -r \u0026lt;源目录\u0026gt; \u0026lt;目标\u0026gt; - 递归复制目录 cp -i \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 交互式复制（覆盖前询问） mv \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 移动/重命名文件 rm \u0026lt;文件\u0026gt; - 删除文件 rm -r \u0026lt;目录\u0026gt; - 递归删除目录 rm -f \u0026lt;文件\u0026gt; - 强制删除 rm -rf \u0026lt;目录\u0026gt; - 强制递归删除（危险！） rm -i \u0026lt;文件\u0026gt; - 交互式删除（推荐） 链接\nln -s \u0026lt;源\u0026gt; \u0026lt;链接名\u0026gt; - 创建符号链接 readlink -f \u0026lt;链接\u0026gt; - 查看链接目标 文件查看和编辑 查看文件\ncat \u0026lt;文件\u0026gt; - 显示文件内容 cat -n \u0026lt;文件\u0026gt; - 显示行号 less \u0026lt;文件\u0026gt; - 分页查看（可前后翻页） more \u0026lt;文件\u0026gt; - 分页查看（只能向前） head \u0026lt;文件\u0026gt; - 查看文件开头 head -n 20 \u0026lt;文件\u0026gt; - 查看前 20 行 tail \u0026lt;文件\u0026gt; - 查看文件末尾 tail -n 20 \u0026lt;文件\u0026gt; - 查看最后 20 行 tail -f \u0026lt;文件\u0026gt; - 实时查看文件更新 tail -f \u0026lt;文件\u0026gt; | grep \u0026quot;error\u0026quot; - 实时过滤查看 编辑文件\nnano \u0026lt;文件\u0026gt; - 简单文本编辑器 vim \u0026lt;文件\u0026gt; / vi \u0026lt;文件\u0026gt; - 强大的文本编辑器 统计文件\nwc \u0026lt;文件\u0026gt; - 统计文件 wc -l \u0026lt;文件\u0026gt; - 统计行数 wc -w \u0026lt;文件\u0026gt; - 统计单词数 wc -c \u0026lt;文件\u0026gt; - 统计字节数 文件搜索和查找 find 命令\nfind \u0026lt;路径\u0026gt; -name \u0026lt;名称\u0026gt; - 按名称查找 find . -name \u0026quot;*.txt\u0026quot; - 查找所有 txt 文件 find . -type f -name \u0026quot;*.log\u0026quot; - 查找文件（不含目录） find . -type d -name \u0026quot;node_modules\u0026quot; - 查找目录 find . -mtime -7 - 查找 7 天内修改的文件 find . -size +100M - 查找大于 100MB 的文件 find . -name \u0026quot;*.tmp\u0026quot; -delete - 查找并删除 grep 命令\ngrep \u0026lt;模式\u0026gt; \u0026lt;文件\u0026gt; - 搜索文本 grep -r \u0026quot;TODO\u0026quot; . - 递归搜索当前目录 grep -i \u0026quot;error\u0026quot; log.txt - 忽略大小写 grep -n \u0026quot;function\u0026quot; code.js - 显示行号 grep -v \u0026quot;debug\u0026quot; log.txt - 反向匹配（不包含） grep -E \u0026quot;error|warning\u0026quot; log.txt - 使用正则表达式 grep -c \u0026quot;error\u0026quot; log.txt - 统计匹配行数 其他查找工具\nlocate \u0026lt;文件名\u0026gt; - 快速查找文件 updatedb - 更新 locate 数据库 which \u0026lt;命令\u0026gt; - 查找命令位置 whereis \u0026lt;程序\u0026gt; - 查找程序位置 文件权限 chmod \u0026lt;权限\u0026gt; \u0026lt;文件\u0026gt; - 修改文件权限 chmod 755 script.sh - 数字方式（rwxr-xr-x） chmod +x script.sh - 添加执行权限 chmod -R 644 directory/ - 递归修改 chown \u0026lt;用户\u0026gt;:\u0026lt;组\u0026gt; \u0026lt;文件\u0026gt; - 修改所有者 chgrp \u0026lt;组\u0026gt; \u0026lt;文件\u0026gt; - 修改所属组 umask - 查看或设置默认权限掩码 进程管理 查看进程\nps - 查看进程 ps aux - 查看所有进程详细信息 ps -ef - 另一种格式 ps aux | grep \u0026lt;进程名\u0026gt; - 搜索特定进程 top - 实时查看系统资源（按 q 退出） htop - 增强版 top 管理进程\nkill \u0026lt;PID\u0026gt; - 结束进程 kill -9 \u0026lt;PID\u0026gt; - 强制结束 killall \u0026lt;进程名\u0026gt; - 按名称结束进程 pkill \u0026lt;进程名\u0026gt; - 按模式匹配结束 bg - 将任务放到后台 fg - 将后台任务调到前台 jobs - 查看后台任务 nohup \u0026lt;命令\u0026gt; \u0026amp; - 后台运行，不受终端关闭影响 磁盘和存储 df -h - 查看磁盘使用情况 du -sh \u0026lt;目录\u0026gt; - 查看目录大小 du -h --max-depth=1 - 查看各子目录大小 du -sh * | sort -h - 按大小排序 free -h - 查看内存使用 lsblk - 列出块设备 mount - 挂载文件系统 umount - 卸载文件系统 系统信息 uname -a - 完整系统信息 uname -r - 内核版本 hostname - 主机名 whoami - 当前用户 id - 用户 ID 和组 ID uptime - 系统运行时间和负载 date - 系统时间 cal - 日历 lsb_release -a - Linux 发行版信息（Ubuntu/Debian） cat /etc/os-release - 系统版本信息 网络操作 连接测试\nping \u0026lt;地址\u0026gt; - 测试网络连接 ping -c 4 google.com - 发送 4 个包后停止 traceroute \u0026lt;地址\u0026gt; - 追踪路由路径 文件传输\ncurl \u0026lt;URL\u0026gt; - 发送 HTTP 请求 curl -O \u0026lt;URL\u0026gt; - 下载文件（保持原文件名） curl -o \u0026lt;文件名\u0026gt; \u0026lt;URL\u0026gt; - 下载并重命名 curl -I \u0026lt;URL\u0026gt; - 只获取 HTTP 头 curl -X POST -d \u0026quot;data\u0026quot; \u0026lt;URL\u0026gt; - 发送 POST 请求 wget \u0026lt;URL\u0026gt; - 下载文件 wget -c \u0026lt;URL\u0026gt; - 断点续传 远程连接\nssh \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt; - SSH 连接 ssh -p \u0026lt;端口\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt; - 指定端口 scp \u0026lt;源\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt;:\u0026lt;目标\u0026gt; - 安全复制文件 scp -r \u0026lt;目录\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt;:\u0026lt;目标\u0026gt; - 复制目录 网络信息\nnetstat -tuln - 查看网络端口（传统） ss -tuln - 查看网络端口（现代） ip addr / ifconfig - 查看网络接口 nslookup \u0026lt;域名\u0026gt; - DNS 查询 dig \u0026lt;域名\u0026gt; - DNS 详细查询 压缩和解压 tar 格式\ntar -czf \u0026lt;文件.tar.gz\u0026gt; \u0026lt;目录\u0026gt; - 压缩为 tar.gz tar -xzf \u0026lt;文件.tar.gz\u0026gt; - 解压 tar.gz tar -xzf \u0026lt;文件.tar.gz\u0026gt; -C \u0026lt;目标目录\u0026gt; - 解压到指定目录 tar -tvf \u0026lt;文件.tar.gz\u0026gt; - 查看压缩包内容 zip 格式\nzip -r \u0026lt;文件.zip\u0026gt; \u0026lt;目录\u0026gt; - 创建 zip 压缩包 unzip \u0026lt;文件.zip\u0026gt; - 解压 zip unzip \u0026lt;文件.zip\u0026gt; -d \u0026lt;目标目录\u0026gt; - 解压到指定目录 gzip 格式\ngzip \u0026lt;文件\u0026gt; - 压缩为 .gz gunzip \u0026lt;文件.gz\u0026gt; - 解压 .gz 文本处理工具 sed（流编辑器）\nsed 's/old/new/g' file.txt - 替换文本 sed -i 's/old/new/g' file.txt - 直接修改文件 awk（文本处理）\nawk '{print $1}' file.txt - 打印第一列 awk -F',' '{print $2}' file.csv - 指定分隔符 排序和去重\nsort \u0026lt;文件\u0026gt; - 排序 sort -r \u0026lt;文件\u0026gt; - 反向排序 sort -n \u0026lt;文件\u0026gt; - 按数字排序 uniq \u0026lt;文件\u0026gt; - 去除重复行 sort file.txt | uniq - 配合使用 uniq -c \u0026lt;文件\u0026gt; - 统计重复次数 其他工具\ncut -d',' -f1,3 file.csv - 按分隔符提取列 tr 'a-z' 'A-Z' \u0026lt; file.txt - 字符转换 系统管理 用户管理\nsudo \u0026lt;命令\u0026gt; - 以管理员权限执行 su - 切换用户 su - - 切换到 root passwd - 修改密码 useradd \u0026lt;用户名\u0026gt; - 创建用户 userdel \u0026lt;用户名\u0026gt; - 删除用户 usermod -aG \u0026lt;组\u0026gt; \u0026lt;用户\u0026gt; - 添加用户到组 服务管理（systemd）\nsystemctl start \u0026lt;服务\u0026gt; - 启动服务 systemctl stop \u0026lt;服务\u0026gt; - 停止服务 systemctl restart \u0026lt;服务\u0026gt; - 重启服务 systemctl status \u0026lt;服务\u0026gt; - 查看状态 systemctl enable \u0026lt;服务\u0026gt; - 设置开机启动 journalctl -u \u0026lt;服务\u0026gt; - 查看服务日志 实用快捷键 Ctrl + C - 终止当前命令 Ctrl + Z - 暂停当前命令 Ctrl + D - 退出终端 Ctrl + L - 清屏 Ctrl + A - 光标移到行首 Ctrl + E - 光标移到行尾 Ctrl + U - 删除光标前的内容 Ctrl + K - 删除光标后的内容 Ctrl + R - 搜索命令历史 Tab - 自动补全 !! - 执行上一条命令 !$ - 上一条命令的最后一个参数 其他实用命令 clear - 清屏 history - 查看命令历史 history | grep \u0026lt;关键词\u0026gt; - 搜索历史命令 echo \u0026lt;文本\u0026gt; - 输出文本 echo \u0026quot;text\u0026quot; \u0026gt; file.txt - 覆盖写入 echo \u0026quot;text\u0026quot; \u0026gt;\u0026gt; file.txt - 追加写入 alias \u0026lt;别名\u0026gt;='\u0026lt;命令\u0026gt;' - 创建别名 watch \u0026lt;命令\u0026gt; - 定期执行命令 watch -n 2 df -h - 每 2 秒更新 xargs - 将标准输入转换为命令参数 tee \u0026lt;文件\u0026gt; - 同时输出到文件和标准输出 Git 常用指令 初始化和配置 初始化仓库\ngit init - 初始化新仓库 git clone \u0026lt;URL\u0026gt; - 克隆远程仓库 git clone \u0026lt;URL\u0026gt; \u0026lt;目录名\u0026gt; - 克隆到指定目录 git clone --depth 1 \u0026lt;URL\u0026gt; - 浅克隆（只克隆最新提交） git clone -b \u0026lt;分支名\u0026gt; \u0026lt;URL\u0026gt; - 克隆指定分支 配置 Git\ngit config --global user.name \u0026quot;\u0026lt;名字\u0026gt;\u0026quot; - 设置用户名 git config --global user.email \u0026quot;\u0026lt;邮箱\u0026gt;\u0026quot; - 设置邮箱 git config --list - 查看所有配置 git config --global core.editor \u0026quot;vim\u0026quot; - 设置编辑器 git config --global alias.st status - 设置别名 基本操作 查看状态\ngit status - 查看工作区状态 git status -s - 简短格式 添加和提交\ngit add \u0026lt;文件\u0026gt; - 添加文件到暂存区 git add . - 添加所有修改 git add -A - 添加所有变化（包括删除） git add -p - 交互式添加 git commit -m \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 提交 git commit -am \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 添加并提交已跟踪文件 git commit --amend - 修改最后一次提交 git commit --amend --no-edit - 修改提交但不改消息 推送和拉取\ngit push - 推送到远程 git push origin \u0026lt;分支名\u0026gt; - 推送指定分支 git push -u origin \u0026lt;分支名\u0026gt; - 推送并设置上游 git push --force / git push -f - 强制推送（危险！） git push --tags - 推送标签 git pull - 拉取并合并 git pull --rebase - 使用 rebase 方式拉取 git fetch - 获取但不合并 git fetch --all - 获取所有远程分支 git fetch --prune - 获取并清理已删除的远程分支 分支操作 查看分支\ngit branch - 查看本地分支 git branch -a - 查看所有分支（包括远程） git branch -r - 只查看远程分支 git branch -v - 查看分支及最后一次提交 创建和切换分支\ngit branch \u0026lt;分支名\u0026gt; - 创建分支 git checkout \u0026lt;分支名\u0026gt; - 切换分支 git checkout -b \u0026lt;分支名\u0026gt; - 创建并切换 git checkout -b \u0026lt;分支名\u0026gt; origin/\u0026lt;分支名\u0026gt; - 从远程分支创建 git switch \u0026lt;分支名\u0026gt; - 切换分支（新语法） git switch -c \u0026lt;分支名\u0026gt; - 创建并切换（新语法） 合并和删除分支\ngit merge \u0026lt;分支名\u0026gt; - 合并分支 git merge --no-ff \u0026lt;分支名\u0026gt; - 非快进合并 git merge --squash \u0026lt;分支名\u0026gt; - 压缩合并 git branch -d \u0026lt;分支名\u0026gt; - 删除已合并分支 git branch -D \u0026lt;分支名\u0026gt; - 强制删除分支 git branch -m \u0026lt;旧名\u0026gt; \u0026lt;新名\u0026gt; - 重命名分支 git push origin --delete \u0026lt;分支名\u0026gt; - 删除远程分支 查看历史 日志查看\ngit log - 查看提交历史 git log --oneline - 每个提交一行 git log --graph - 图形化显示 git log --oneline --graph --all - 图形化显示所有分支 git log -p - 显示详细差异 git log --author=\u0026quot;\u0026lt;作者\u0026gt;\u0026quot; - 按作者筛选 git log --since=\u0026quot;2 weeks ago\u0026quot; - 按时间筛选 git log --grep=\u0026quot;\u0026lt;关键词\u0026gt;\u0026quot; - 搜索提交消息 git log \u0026lt;文件\u0026gt; - 查看文件历史 git log --stat - 显示文件统计 差异比较\ngit diff - 查看未暂存的更改 git diff --staged / git diff --cached - 查看已暂存的更改 git diff \u0026lt;分支1\u0026gt; \u0026lt;分支2\u0026gt; - 比较分支 git diff \u0026lt;提交1\u0026gt; \u0026lt;提交2\u0026gt; - 比较提交 git diff HEAD - 比较工作区和最新提交 其他查看命令\ngit show \u0026lt;提交\u0026gt; - 查看提交详情 git show HEAD - 查看最新提交 git blame \u0026lt;文件\u0026gt; - 查看每行的修改者 git shortlog - 按作者分组显示 撤销和回退 撤销修改\ngit restore \u0026lt;文件\u0026gt; - 撤销工作区修改（新语法） git restore --staged \u0026lt;文件\u0026gt; - 取消暂存（新语法） git checkout -- \u0026lt;文件\u0026gt; - 撤销修改（旧语法） 重置提交\ngit reset \u0026lt;文件\u0026gt; - 取消暂存 git reset HEAD~ - 撤销最后一次提交，保留更改 git reset --soft HEAD~ - 撤销提交，更改在暂存区 git reset --hard HEAD~ - 撤销提交并丢弃更改（危险！） git reset --hard \u0026lt;提交\u0026gt; - 重置到指定提交 回退操作\ngit revert \u0026lt;提交\u0026gt; - 创建新提交来撤销 git revert HEAD - 撤销最新提交 git clean -fd - 删除未跟踪的文件 git clean -n - 预览将要删除的文件 暂存操作（Stash） git stash - 暂存当前更改 git stash save \u0026quot;描述\u0026quot; - 暂存并添加描述 git stash list - 查看暂存列表 git stash pop - 恢复并删除最新暂存 git stash apply - 恢复但不删除暂存 git stash apply stash@{0} - 恢复指定暂存 git stash drop - 删除最新暂存 git stash drop stash@{0} - 删除指定暂存 git stash clear - 清空所有暂存 git stash show - 查看暂存内容 远程仓库 查看远程\ngit remote - 查看远程仓库 git remote -v - 查看详细信息 管理远程\ngit remote add \u0026lt;名称\u0026gt; \u0026lt;URL\u0026gt; - 添加远程仓库 git remote add origin \u0026lt;URL\u0026gt; - 添加 origin git remote remove \u0026lt;名称\u0026gt; - 删除远程仓库 git remote rename \u0026lt;旧名\u0026gt; \u0026lt;新名\u0026gt; - 重命名 git remote set-url \u0026lt;名称\u0026gt; \u0026lt;新URL\u0026gt; - 修改 URL git remote show \u0026lt;名称\u0026gt; - 查看详细信息 git remote prune origin - 清理已删除的远程分支引用 标签操作 git tag - 查看所有标签 git tag \u0026lt;标签名\u0026gt; - 创建轻量标签 git tag -a \u0026lt;标签名\u0026gt; -m \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 创建带注释的标签 git tag -d \u0026lt;标签名\u0026gt; - 删除本地标签 git push origin \u0026lt;标签名\u0026gt; - 推送标签 git push origin --tags - 推送所有标签 git push origin :refs/tags/\u0026lt;标签名\u0026gt; - 删除远程标签 高级操作 变基（Rebase）\ngit rebase \u0026lt;分支\u0026gt; - 变基到指定分支 git rebase -i HEAD~3 - 交互式变基最近 3 个提交 git rebase --continue - 解决冲突后继续 git rebase --abort - 取消变基 其他高级命令\ngit cherry-pick \u0026lt;提交\u0026gt; - 将指定提交应用到当前分支 git reflog - 查看引用日志（恢复丢失的提交） git bisect start - 开始二分查找问题提交 git submodule add \u0026lt;URL\u0026gt; - 添加子模块 git submodule update --init - 初始化并更新子模块 .gitignore 配置 New-Item -ItemType File .gitignore创建 .gitignore 文件来忽略不需要跟踪的文件：\n# 忽略日志文件 *.log # 忽略 node_modules 目录 node_modules/ # 忽略环境变量文件 .env .env.local # 忽略构建输出 dist/ build/ # 忽略操作系统文件 .DS_Store Thumbs.db # 忽略 IDE 配置 .vscode/ .idea/ GitHub CLI 常用指令 认证 gh auth login - 登录 GitHub 账号 gh auth status - 查看认证状态 gh auth logout - 登出 gh auth refresh - 刷新令牌 gh config set editor vim - 设置编辑器 仓库操作 创建和克隆\ngh repo create - 创建仓库 gh repo create \u0026lt;名称\u0026gt; - 创建指定名称的仓库 gh repo create --public - 创建公开仓库 gh repo create --private - 创建私有仓库 gh repo create --clone - 创建并克隆 gh repo clone \u0026lt;仓库\u0026gt; - 克隆仓库 gh repo clone owner/repo - 克隆指定仓库 查看和管理\ngh repo view - 查看仓库信息 gh repo view --web - 在浏览器中打开 gh repo list - 列出仓库 gh repo list \u0026lt;用户名\u0026gt; - 列出指定用户的仓库 gh repo list --limit 50 - 限制显示数量 gh repo fork - Fork 仓库 gh repo fork --clone - Fork 并克隆 gh repo delete \u0026lt;仓库\u0026gt; - 删除仓库 gh repo rename \u0026lt;新名称\u0026gt; - 重命名仓库 or gh repo rename owner/repo 新名字 gh repo sync - 同步 fork Pull Request 创建 PR\ngh pr create - 创建 PR gh pr create --title \u0026quot;标题\u0026quot; --body \u0026quot;描述\u0026quot; - 指定标题和描述 gh pr create --web - 在浏览器中创建 gh pr create --draft - 创建草稿 PR 查看 PR\ngh pr list - 列出 PR gh pr list --state open - 只显示开放的 gh pr list --author \u0026lt;用户名\u0026gt; - 按作者筛选 gh pr list --label \u0026lt;标签\u0026gt; - 按标签筛选 gh pr view \u0026lt;编号\u0026gt; - 查看详情 gh pr view \u0026lt;编号\u0026gt; --web - 在浏览器中查看 gh pr view \u0026lt;编号\u0026gt; --comments - 查看评论 操作 PR\ngh pr checkout \u0026lt;编号\u0026gt; - 检出 PR 分支 gh pr diff \u0026lt;编号\u0026gt; - 查看差异 gh pr merge \u0026lt;编号\u0026gt; - 合并 PR gh pr merge \u0026lt;编号\u0026gt; --squash - 压缩合并 gh pr merge \u0026lt;编号\u0026gt; --rebase - 变基合并 gh pr close \u0026lt;编号\u0026gt; - 关闭 PR gh pr reopen \u0026lt;编号\u0026gt; - 重新打开 gh pr ready \u0026lt;编号\u0026gt; - 标记为准备好 审查 PR\ngh pr review \u0026lt;编号\u0026gt; - 审查 PR gh pr review \u0026lt;编号\u0026gt; --approve - 批准 gh pr review \u0026lt;编号\u0026gt; --request-changes - 请求更改 gh pr review \u0026lt;编号\u0026gt; --comment - 添加评论 gh pr checks \u0026lt;编号\u0026gt; - 查看 CI/CD 状态 Issue 创建 Issue\ngh issue create - 创建 Issue gh issue create --title \u0026quot;标题\u0026quot; --body \u0026quot;描述\u0026quot; - 指定内容 gh issue create --web - 在浏览器中创建 gh issue create --label \u0026quot;bug,help wanted\u0026quot; - 添加标签 查看 Issue\ngh issue list - 列出 Issues gh issue list --state open - 只显示开放的 gh issue list --assignee \u0026lt;用户名\u0026gt; - 按指派人筛选 gh issue list --label \u0026lt;标签\u0026gt; - 按标签筛选 gh issue list --author \u0026lt;用户名\u0026gt; - 按作者筛选 gh issue view \u0026lt;编号\u0026gt; - 查看详情 gh issue view \u0026lt;编号\u0026gt; --web - 在浏览器中查看 操作 Issue\ngh issue close \u0026lt;编号\u0026gt; - 关闭 Issue gh issue close \u0026lt;编号\u0026gt; --comment \u0026quot;已修复\u0026quot; - 关闭并评论 gh issue reopen \u0026lt;编号\u0026gt; - 重新打开 gh issue edit \u0026lt;编号\u0026gt; - 编辑 Issue gh issue edit \u0026lt;编号\u0026gt; --add-label \u0026quot;bug\u0026quot; - 添加标签 gh issue comment \u0026lt;编号\u0026gt; - 添加评论 gh issue status - 查看状态 Gist gh gist create \u0026lt;文件\u0026gt; - 创建 Gist gh gist create --public \u0026lt;文件\u0026gt; - 创建公开 Gist gh gist create --desc \u0026quot;描述\u0026quot; \u0026lt;文件\u0026gt; - 添加描述 gh gist list - 列出 Gists gh gist view \u0026lt;ID\u0026gt; - 查看 Gist gh gist view \u0026lt;ID\u0026gt; --web - 在浏览器中查看 gh gist edit \u0026lt;ID\u0026gt; - 编辑 Gist gh gist delete \u0026lt;ID\u0026gt; - 删除 Gist gh gist clone \u0026lt;ID\u0026gt; - 克隆到本地 Release 创建和查看\ngh release create \u0026lt;标签\u0026gt; - 创建 Release gh release create v1.0.0 --title \u0026quot;版本 1.0.0\u0026quot; --notes \u0026quot;说明\u0026quot; - 指定内容 gh release create v1.0.0 *.zip - 附加文件 gh release create v1.0.0 --draft - 创建草稿 gh release list - 列出所有 Releases gh release view \u0026lt;标签\u0026gt; - 查看详情 gh release view \u0026lt;标签\u0026gt; --web - 在浏览器中查看 下载和管理\ngh release download \u0026lt;标签\u0026gt; - 下载资源 gh release download \u0026lt;标签\u0026gt; --pattern \u0026quot;*.zip\u0026quot; - 下载匹配文件 gh release delete \u0026lt;标签\u0026gt; - 删除 Release gh release upload \u0026lt;标签\u0026gt; \u0026lt;文件\u0026gt; - 上传文件 GitHub Actions 工作流管理\ngh workflow list - 列出工作流 gh workflow view \u0026lt;工作流\u0026gt; - 查看详情 gh workflow view \u0026lt;工作流\u0026gt; --web - 在浏览器中查看 gh workflow run \u0026lt;工作流\u0026gt; - 触发工作流 gh workflow run \u0026lt;工作流\u0026gt; --ref \u0026lt;分支\u0026gt; - 在指定分支运行 运行管理\ngh run list - 列出运行记录 gh run list --workflow \u0026lt;工作流名\u0026gt; - 按工作流筛选 gh run view \u0026lt;运行ID\u0026gt; - 查看详情 gh run view \u0026lt;运行ID\u0026gt; --log - 查看日志 gh run watch \u0026lt;运行ID\u0026gt; - 实时查看状态 gh run rerun \u0026lt;运行ID\u0026gt; - 重新运行 gh run cancel \u0026lt;运行ID\u0026gt; - 取消运行 其他功能 浏览和搜索\ngh browse - 在浏览器中打开仓库 gh browse \u0026lt;文件\u0026gt; - 打开指定文件 gh browse --settings - 打开设置 gh search repos \u0026lt;关键词\u0026gt; - 搜索仓库 gh search repos --stars \u0026quot;\u0026gt;1000\u0026quot; - 按星标搜索 gh search repos --language python - 按语言搜索 gh search issues \u0026lt;关键词\u0026gt; - 搜索 Issues gh search prs \u0026lt;关键词\u0026gt; - 搜索 PRs API 和扩展\ngh api \u0026lt;端点\u0026gt; - 调用 GitHub API gh api user - 获取用户信息 gh alias set \u0026lt;别名\u0026gt; \u0026lt;命令\u0026gt; - 创建别名 gh extension install \u0026lt;扩展\u0026gt; - 安装扩展 gh extension list - 列出扩展 标签和项目\ngh label list - 列出标签 gh label create \u0026lt;名称\u0026gt; - 创建标签 gh project list - 列出项目 gh project view \u0026lt;编号\u0026gt; - 查看项目 ","permalink":"http://localhost:1313/posts/command-reference/","summary":"详细的命令行指令参考手册，包含 Windows PowerShell、Linux Terminal、Git 和 GitHub CLI 的常用命令及实用技巧","title":"常用命令行指令参考"},{"content":"一、数据库操作 1.1 创建和删除数据库 -- 创建数据库 CREATE DATABASE database_name; CREATE DATABASE IF NOT EXISTS database_name CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; -- 删除数据库 DROP DATABASE database_name; DROP DATABASE IF EXISTS database_name; -- 查看所有数据库 SHOW DATABASES; -- 选择数据库 USE database_name; -- 查看当前数据库 SELECT DATABASE(); 二、数据表操作 2.1 创建表 -- 基础创建表 CREATE TABLE users ( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(50) NOT NULL UNIQUE, email VARCHAR(100), age INT DEFAULT 0, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ); -- 创建表时指定引擎和字符集 CREATE TABLE products ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(100) NOT NULL, price DECIMAL(10, 2), stock INT DEFAULT 0 ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; -- 从查询结果创建表 CREATE TABLE users_backup AS SELECT * FROM users; 2.2 修改表结构 -- 添加列 ALTER TABLE users ADD COLUMN phone VARCHAR(20); ALTER TABLE users ADD COLUMN address TEXT AFTER email; -- 修改列 ALTER TABLE users MODIFY COLUMN age TINYINT; ALTER TABLE users CHANGE COLUMN username user_name VARCHAR(60); -- 删除列 ALTER TABLE users DROP COLUMN phone; -- 重命名表 RENAME TABLE users TO members; ALTER TABLE members RENAME TO users; -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键 ALTER TABLE users DROP PRIMARY KEY; -- 添加索引 ALTER TABLE users ADD INDEX idx_username (username); ALTER TABLE users ADD UNIQUE INDEX idx_email (email); -- 删除索引 ALTER TABLE users DROP INDEX idx_username; 2.3 查看表信息 -- 查看所有表 SHOW TABLES; -- 查看表结构 DESC users; DESCRIBE users; SHOW COLUMNS FROM users; -- 查看创建表的语句 SHOW CREATE TABLE users; -- 查看表状态 SHOW TABLE STATUS LIKE \u0026#39;users\u0026#39;; 2.4 删除和清空表 -- 删除表 DROP TABLE users; DROP TABLE IF EXISTS users; -- 清空表数据（保留结构） TRUNCATE TABLE users; DELETE FROM users; -- 与 TRUNCATE 的区别是可以回滚 三、数据操作（CRUD） 3.1 插入数据（INSERT） -- 插入单条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;, 25); -- 插入多条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;李四\u0026#39;, \u0026#39;lisi@example.com\u0026#39;, 28), (\u0026#39;王五\u0026#39;, \u0026#39;wangwu@example.com\u0026#39;, 30); -- 插入所有列（可省略列名） INSERT INTO users VALUES (NULL, \u0026#39;赵六\u0026#39;, \u0026#39;zhaoliu@example.com\u0026#39;, 22, NOW(), NOW()); -- 插入或更新（存在则更新） INSERT INTO users (id, username, email) VALUES (1, \u0026#39;张三\u0026#39;, \u0026#39;new@example.com\u0026#39;) ON DUPLICATE KEY UPDATE email = \u0026#39;new@example.com\u0026#39;; -- 忽略重复插入错误 INSERT IGNORE INTO users (username, email) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;); -- 从其他表插入数据 INSERT INTO users_backup SELECT * FROM users WHERE age \u0026gt; 25; 3.2 查询数据（SELECT） 基础查询 -- 查询所有列 SELECT * FROM users; -- 查询指定列 SELECT username, email FROM users; -- 使用别名 SELECT username AS name, email AS mail FROM users; -- 去重查询 SELECT DISTINCT age FROM users; -- 限制结果数量 SELECT * FROM users LIMIT 10; SELECT * FROM users LIMIT 10, 20; -- 跳过前10条，取20条 SELECT * FROM users LIMIT 20 OFFSET 10; -- 同上 WHERE 条件查询 -- 基本条件 SELECT * FROM users WHERE age \u0026gt; 25; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users WHERE email IS NULL; SELECT * FROM users WHERE email IS NOT NULL; -- 多条件组合 SELECT * FROM users WHERE age \u0026gt; 20 AND age \u0026lt; 30; SELECT * FROM users WHERE age BETWEEN 20 AND 30; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39; OR username = \u0026#39;李四\u0026#39;; SELECT * FROM users WHERE username IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;); SELECT * FROM users WHERE username NOT IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;); -- 模糊查询 SELECT * FROM users WHERE username LIKE \u0026#39;张%\u0026#39;; -- 以\u0026#34;张\u0026#34;开头 SELECT * FROM users WHERE username LIKE \u0026#39;%三\u0026#39;; -- 以\u0026#34;三\u0026#34;结尾 SELECT * FROM users WHERE username LIKE \u0026#39;%张%\u0026#39;; -- 包含\u0026#34;张\u0026#34; SELECT * FROM users WHERE username LIKE \u0026#39;张_\u0026#39;; -- 张+一个字符 SELECT * FROM users WHERE username NOT LIKE \u0026#39;张%\u0026#39;; 排序和分组 -- 排序 SELECT * FROM users ORDER BY age ASC; -- 升序（默认） SELECT * FROM users ORDER BY age DESC; -- 降序 SELECT * FROM users ORDER BY age DESC, username ASC; -- 多列排序 -- 分组 SELECT age, COUNT(*) as count FROM users GROUP BY age; SELECT age, AVG(age) as avg_age FROM users GROUP BY age; -- HAVING 过滤分组结果 SELECT age, COUNT(*) as count FROM users GROUP BY age HAVING count \u0026gt; 5; 聚合函数 -- 计数 SELECT COUNT(*) FROM users; SELECT COUNT(DISTINCT age) FROM users; -- 求和、平均、最大、最小 SELECT SUM(age) FROM users; SELECT AVG(age) FROM users; SELECT MAX(age) FROM users; SELECT MIN(age) FROM users; -- 多个聚合函数 SELECT COUNT(*) as total, AVG(age) as avg_age, MAX(age) as max_age FROM users; 连接查询（JOIN） -- 内连接（INNER JOIN） SELECT users.username, orders.order_no FROM users INNER JOIN orders ON users.id = orders.user_id; -- 左连接（LEFT JOIN） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id; -- 右连接（RIGHT JOIN） SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 全连接（FULL JOIN，MySQL不直接支持，需要用UNION） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id UNION SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 自连接 SELECT a.username, b.username as friend FROM users a INNER JOIN users b ON a.friend_id = b.id; -- 多表连接 SELECT u.username, o.order_no, p.product_name FROM users u INNER JOIN orders o ON u.id = o.user_id INNER JOIN order_items oi ON o.id = oi.order_id INNER JOIN products p ON oi.product_id = p.id; 子查询 -- WHERE 子查询 SELECT * FROM users WHERE id IN (SELECT user_id FROM orders WHERE amount \u0026gt; 1000); -- FROM 子查询 SELECT avg_age FROM (SELECT AVG(age) as avg_age FROM users GROUP BY city) as subquery; -- EXISTS 子查询 SELECT * FROM users WHERE EXISTS (SELECT 1 FROM orders WHERE orders.user_id = users.id); -- 标量子查询 SELECT username, (SELECT COUNT(*) FROM orders WHERE user_id = users.id) as order_count FROM users; 联合查询（UNION） -- UNION（去重） SELECT username FROM users WHERE age \u0026gt; 30 UNION SELECT username FROM admins WHERE age \u0026gt; 30; -- UNION ALL（不去重，性能更好） SELECT username FROM users WHERE age \u0026gt; 30 UNION ALL SELECT username FROM admins WHERE age \u0026gt; 30; 3.3 更新数据（UPDATE） -- 更新单列 UPDATE users SET age = 26 WHERE username = \u0026#39;张三\u0026#39;; -- 更新多列 UPDATE users SET age = 26, email = \u0026#39;new@example.com\u0026#39; WHERE username = \u0026#39;张三\u0026#39;; -- 批量更新 UPDATE users SET age = age + 1 WHERE age \u0026lt; 30; -- 使用表达式更新 UPDATE users SET updated_at = NOW() WHERE id = 1; -- 基于其他表更新 UPDATE users u INNER JOIN orders o ON u.id = o.user_id SET u.total_orders = u.total_orders + 1 WHERE o.created_at \u0026gt; \u0026#39;2024-01-01\u0026#39;; -- 条件更新（CASE） UPDATE users SET level = CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END; 3.4 删除数据（DELETE） -- 删除指定数据 DELETE FROM users WHERE id = 1; -- 批量删除 DELETE FROM users WHERE age \u0026lt; 18; -- 删除所有数据 DELETE FROM users; -- 基于其他表删除 DELETE u FROM users u INNER JOIN orders o ON u.id = o.user_id WHERE o.status = \u0026#39;cancelled\u0026#39;; 四、索引管理 4.1 创建索引 -- 普通索引 CREATE INDEX idx_username ON users(username); -- 唯一索引 CREATE UNIQUE INDEX idx_email ON users(email); -- 复合索引 CREATE INDEX idx_name_age ON users(username, age); -- 全文索引 CREATE FULLTEXT INDEX idx_content ON articles(content); -- 在创建表时添加索引 CREATE TABLE users ( id INT PRIMARY KEY, username VARCHAR(50), email VARCHAR(100), INDEX idx_username (username), UNIQUE INDEX idx_email (email) ); 4.2 查看和删除索引 -- 查看索引 SHOW INDEX FROM users; -- 删除索引 DROP INDEX idx_username ON users; ALTER TABLE users DROP INDEX idx_username; 五、约束管理 5.1 主键约束 -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键（需要先删除 AUTO_INCREMENT 属性） ALTER TABLE users MODIFY id INT; ALTER TABLE users DROP PRIMARY KEY; 5.2 外键约束 -- 添加外键 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id); -- 添加外键时设置级联操作 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE; -- 删除外键 ALTER TABLE orders DROP FOREIGN KEY fk_user_id; 5.3 其他约束 -- 唯一约束 ALTER TABLE users ADD UNIQUE (email); -- 非空约束 ALTER TABLE users MODIFY username VARCHAR(50) NOT NULL; -- 检查约束（MySQL 8.0.16+） ALTER TABLE users ADD CONSTRAINT chk_age CHECK (age \u0026gt;= 0 AND age \u0026lt;= 150); -- 默认值约束 ALTER TABLE users ALTER COLUMN status SET DEFAULT \u0026#39;active\u0026#39;; 六、视图 -- 创建视图 CREATE VIEW active_users AS SELECT id, username, email FROM users WHERE status = \u0026#39;active\u0026#39;; -- 创建或替换视图 CREATE OR REPLACE VIEW active_users AS SELECT id, username, email, age FROM users WHERE status = \u0026#39;active\u0026#39;; -- 查询视图 SELECT * FROM active_users; -- 查看视图定义 SHOW CREATE VIEW active_users; -- 删除视图 DROP VIEW active_users; DROP VIEW IF EXISTS active_users; 七、事务处理 -- 开启事务 START TRANSACTION; -- 或 BEGIN; -- 提交事务 COMMIT; -- 回滚事务 ROLLBACK; -- 设置保存点 SAVEPOINT sp1; ROLLBACK TO sp1; -- 完整示例 START TRANSACTION; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; COMMIT; -- 设置自动提交 SET autocommit = 0; -- 关闭自动提交 SET autocommit = 1; -- 开启自动提交 八、存储过程和函数 8.1 存储过程 -- 创建存储过程 DELIMITER // CREATE PROCEDURE GetUserById(IN userId INT) BEGIN SELECT * FROM users WHERE id = userId; END // DELIMITER ; -- 调用存储过程 CALL GetUserById(1); -- 带输出参数的存储过程 DELIMITER // CREATE PROCEDURE GetUserCount(OUT total INT) BEGIN SELECT COUNT(*) INTO total FROM users; END // DELIMITER ; CALL GetUserCount(@count); SELECT @count; -- 删除存储过程 DROP PROCEDURE IF EXISTS GetUserById; -- 查看存储过程 SHOW PROCEDURE STATUS; SHOW CREATE PROCEDURE GetUserById; 8.2 函数 -- 创建函数 DELIMITER // CREATE FUNCTION GetUserAge(userId INT) RETURNS INT BEGIN DECLARE userAge INT; SELECT age INTO userAge FROM users WHERE id = userId; RETURN userAge; END // DELIMITER ; -- 使用函数 SELECT GetUserAge(1); -- 删除函数 DROP FUNCTION IF EXISTS GetUserAge; 九、触发器 -- 创建 BEFORE INSERT 触发器 DELIMITER // CREATE TRIGGER before_user_insert BEFORE INSERT ON users FOR EACH ROW BEGIN SET NEW.created_at = NOW(); END // DELIMITER ; -- 创建 AFTER UPDATE 触发器 DELIMITER // CREATE TRIGGER after_user_update AFTER UPDATE ON users FOR EACH ROW BEGIN INSERT INTO user_logs (user_id, action, created_at) VALUES (OLD.id, \u0026#39;update\u0026#39;, NOW()); END // DELIMITER ; -- 查看触发器 SHOW TRIGGERS; -- 删除触发器 DROP TRIGGER IF EXISTS before_user_insert; 十、用户和权限管理 -- 创建用户 CREATE USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; CREATE USER \u0026#39;username\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; -- 允许任何主机 -- 授予权限 GRANT ALL PRIVILEGES ON database_name.* TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; GRANT SELECT, INSERT, UPDATE ON database_name.table_name TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 刷新权限 FLUSH PRIVILEGES; -- 查看用户权限 SHOW GRANTS FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 撤销权限 REVOKE INSERT, UPDATE ON database_name.* FROM \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 修改密码 ALTER USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;new_password\u0026#39;; SET PASSWORD FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; = PASSWORD(\u0026#39;new_password\u0026#39;); -- 删除用户 DROP USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; 十一、备份和恢复 -- 使用 mysqldump 备份（在命令行执行） mysqldump -u username -p database_name \u0026gt; backup.sql mysqldump -u username -p database_name table_name \u0026gt; table_backup.sql mysqldump -u username -p --all-databases \u0026gt; all_databases.sql -- 恢复数据库（在命令行执行） mysql -u username -p database_name \u0026lt; backup.sql -- 导出为 CSV SELECT * FROM users INTO OUTFILE \u0026#39;/tmp/users.csv\u0026#39; FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; -- 从 CSV 导入 LOAD DATA INFILE \u0026#39;/tmp/users.csv\u0026#39; INTO TABLE users FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; 十二、性能优化相关 12.1 EXPLAIN 分析查询 -- 分析查询执行计划 EXPLAIN SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; -- 详细分析 EXPLAIN EXTENDED SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SHOW WARNINGS; -- JSON 格式 EXPLAIN FORMAT=JSON SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; 12.2 查询优化 -- 使用索引提示 SELECT * FROM users USE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users FORCE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users IGNORE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; -- 优化 COUNT SELECT COUNT(1) FROM users; -- 比 COUNT(*) 快一点 -- 分页优化（避免大 OFFSET） SELECT * FROM users WHERE id \u0026gt; 10000 ORDER BY id LIMIT 20; 12.3 查看状态和变量 -- 查看数据库状态 SHOW STATUS; SHOW STATUS LIKE \u0026#39;Threads%\u0026#39;; -- 查看系统变量 SHOW VARIABLES; SHOW VARIABLES LIKE \u0026#39;max_connections\u0026#39;; -- 查看进程列表 SHOW PROCESSLIST; SHOW FULL PROCESSLIST; -- 杀死进程 KILL process_id; 十三、常用字符串和日期函数 13.1 字符串函数 -- 字符串连接 SELECT CONCAT(\u0026#39;Hello\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;World\u0026#39;); SELECT CONCAT_WS(\u0026#39;-\u0026#39;, \u0026#39;2024\u0026#39;, \u0026#39;12\u0026#39;, \u0026#39;10\u0026#39;); -- 字符串长度 SELECT LENGTH(\u0026#39;Hello\u0026#39;), CHAR_LENGTH(\u0026#39;你好\u0026#39;); -- 大小写转换 SELECT UPPER(\u0026#39;hello\u0026#39;), LOWER(\u0026#39;HELLO\u0026#39;); -- 截取字符串 SELECT SUBSTRING(\u0026#39;Hello World\u0026#39;, 1, 5); SELECT LEFT(\u0026#39;Hello World\u0026#39;, 5), RIGHT(\u0026#39;Hello World\u0026#39;, 5); -- 替换和删除 SELECT REPLACE(\u0026#39;Hello World\u0026#39;, \u0026#39;World\u0026#39;, \u0026#39;MySQL\u0026#39;); SELECT TRIM(\u0026#39; Hello \u0026#39;), LTRIM(\u0026#39; Hello\u0026#39;), RTRIM(\u0026#39;Hello \u0026#39;); -- 查找位置 SELECT POSITION(\u0026#39;World\u0026#39; IN \u0026#39;Hello World\u0026#39;); SELECT LOCATE(\u0026#39;World\u0026#39;, \u0026#39;Hello World\u0026#39;); 13.2 日期时间函数 -- 获取当前时间 SELECT NOW(), CURDATE(), CURTIME(); SELECT CURRENT_TIMESTAMP(), CURRENT_DATE(), CURRENT_TIME(); -- 日期格式化 SELECT DATE_FORMAT(NOW(), \u0026#39;%Y-%m-%d %H:%i:%s\u0026#39;); SELECT DATE_FORMAT(NOW(), \u0026#39;%Y年%m月%d日\u0026#39;); -- 日期计算 SELECT date_add(\u0026#39;2023-01-01\u0026#39;, interval 1 day) 输出 \u0026#39;2023-01-02\u0026#39; SELECT date_sub(\u0026#39;2023-01-01\u0026#39;, interval 1 day) 输出 \u0026#39;2022-12-31\u0026#39; SELECT datediff(\u0026#39;2023-02-01\u0026#39;, \u0026#39;2023-01-01\u0026#39;) 输出31 -- 提取日期部分 SELECT YEAR(NOW()), MONTH(NOW()), DAY(NOW()); SELECT HOUR(NOW()), MINUTE(NOW()), SECOND(NOW()); -- 时间戳转换 SELECT UNIX_TIMESTAMP(NOW()); SELECT FROM_UNIXTIME(1702195200); 13.3 数学和其他函数 -- 数学函数 SELECT ROUND(3.14159, 2), CEIL(3.2), FLOOR(3.8); SELECT ABS(-5), MOD(10, 3), POWER(2, 3); SELECT RAND(), RAND()*100; -- 条件函数 SELECT IF(age \u0026gt; 18, \u0026#39;成年\u0026#39;, \u0026#39;未成年\u0026#39;) FROM users; SELECT IFNULL(email, \u0026#39;无邮箱\u0026#39;) FROM users; SELECT COALESCE(NULL, NULL, \u0026#39;default\u0026#39;, \u0026#39;value\u0026#39;); -- CASE 表达式 SELECT username, CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END as age_group FROM users; 十四、JSON 操作（MySQL 5.7+） -- 创建 JSON 列 CREATE TABLE products ( id INT PRIMARY KEY, name VARCHAR(100), attributes JSON ); -- 插入 JSON 数据 INSERT INTO products VALUES (1, \u0026#39;iPhone\u0026#39;, \u0026#39;{\u0026#34;color\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;storage\u0026#34;: \u0026#34;128GB\u0026#34;}\u0026#39;); -- 查询 JSON 数据 SELECT JSON_EXTRACT(attributes, \u0026#39;$.color\u0026#39;) as color FROM products; SELECT attributes-\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; SELECT attributes-\u0026gt;\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; -- 去除引号 -- 修改 JSON 数据 UPDATE products SET attributes = JSON_SET(attributes, \u0026#39;$.color\u0026#39;, \u0026#39;white\u0026#39;) WHERE id = 1; UPDATE products SET attributes = JSON_INSERT(attributes, \u0026#39;$.price\u0026#39;, 999) WHERE id = 1; UPDATE products SET attributes = JSON_REMOVE(attributes, \u0026#39;$.storage\u0026#39;) WHERE id = 1; -- JSON 数组操作 SELECT JSON_ARRAY(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;); SELECT JSON_CONTAINS(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;, \u0026#39;\u0026#34;a\u0026#34;\u0026#39;); SELECT JSON_LENGTH(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;); 十五、窗口函数（MySQL 8.0+） -- ROW_NUMBER：行号 SELECT username, age, ROW_NUMBER() OVER (ORDER BY age DESC) as row_num FROM users; -- RANK：排名（有并列，跳号） SELECT username, score, RANK() OVER (ORDER BY score DESC) as rank FROM students; -- DENSE_RANK：密集排名（有并列，不跳号） SELECT username, score, DENSE_RANK() OVER (ORDER BY score DESC) as rank FROM students; -- 分组窗口 SELECT department, username, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank FROM employees; -- 累计求和 SELECT username, amount, SUM(amount) OVER (ORDER BY created_at) as running_total FROM transactions; -- LAG 和 LEAD：访问上下行 SELECT username, salary, LAG(salary, 1) OVER (ORDER BY id) as prev_salary, LEAD(salary, 1) OVER (ORDER BY id) as next_salary FROM employees; 十六、常见问题和技巧 16.1 查找重复数据 -- 查找重复的用户名 SELECT username, COUNT(*) as count FROM users GROUP BY username HAVING count \u0026gt; 1; -- 删除重复数据（保留ID最小的） DELETE u1 FROM users u1 INNER JOIN users u2 WHERE u1.id \u0026gt; u2.id AND u1.username = u2.username; 16.2 随机获取数据 -- 随机获取一条数据 SELECT * FROM users ORDER BY RAND() LIMIT 1; -- 更高效的随机（大表适用） SELECT * FROM users WHERE id \u0026gt;= (SELECT FLOOR(MAX(id) * RAND()) FROM users) LIMIT 1; 16.3 行转列 -- 使用 CASE WHEN SELECT name, SUM(CASE WHEN subject = \u0026#39;语文\u0026#39; THEN score ELSE 0 END) as chinese, SUM(CASE WHEN subject = \u0026#39;数学\u0026#39; THEN score ELSE 0 END) as math FROM scores GROUP BY name; 16.4 列转行 -- 使用 UNION ALL SELECT name, \u0026#39;语文\u0026#39; as subject, chinese as score FROM scores UNION ALL SELECT name, \u0026#39;数学\u0026#39; as subject, math as score FROM scores; 十七、常用管理命令 -- 查看 MySQL 版本 SELECT VERSION(); -- 查看当前用户 SELECT USER(), CURRENT_USER(); -- 查看数据库大小 SELECT table_schema AS \u0026#39;Database\u0026#39;, ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables GROUP BY table_schema; -- 查看表大小 SELECT table_name AS \u0026#39;Table\u0026#39;, ROUND(((data_length + index_length) / 1024 / 1024), 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables WHERE table_schema = \u0026#39;database_name\u0026#39; ORDER BY (data_length + index_length) DESC; -- 修复表 REPAIR TABLE users; -- 优化表 OPTIMIZE TABLE users; -- 分析表 ANALYZE TABLE users; -- 检查表 CHECK TABLE users; 总结 这份笔记涵盖了 MySQL 从基础到进阶的大部分常用操作，当然也适合在刷题中补充，包括：\n数据库和表的管理 完整的 CRUD 操作 索引和约束 视图、事务、存储过程 用户权限管理 性能优化技巧 常用函数和 JSON、窗口函数！ ","permalink":"http://localhost:1313/posts/mysql-cheatsheet/","summary":"MySQL 常用语句全面速查手册，涵盖从基础 CRUD 到高级特性（索引、事务、存储过程、窗口函数等）的所有常用操作，适合快速查阅和刷题使用","title":"MySQL 语句速查笔记"},{"content":"论文基本信息 标题: Linking Souls to Humans: Blockchain Accounts with Credible Anonymity for Web 3.0 Decentralized Identity 作者: Taotao Wang, Zibin Lin, Shengli Zhang, Long Shi, Qing Yang, Boris Düdder 会议: WWW \u0026lsquo;25 (ACM Web Conference 2025) 时间: 2025年4月28日-5月2日，悉尼 机构: 深圳大学、南京理工大学、哥本哈根大学 研究背景 数字身份的三个发展阶段 数字身份系统经历了三个演进阶段，分别对应互联网的三个时代：\n阶段 身份类型 对应时代 特点 问题 1 中心化身份 Web 1.0 用户创建，应用提供商管理 多账户管理复杂，数据泄露风险 2 联盟身份 Web 2.0 少数大型提供商管理，可跨应用使用 数据霸权，用户数据集中在少数巨头手中 3 去中心化身份 Web 3.0 用户自主创建和管理（自主权身份） 完全匿名导致无法追溯真实社交关系 Web 3.0的核心价值 Web 3.0的革命性转变在于：\n用户拥有数据主权 数据不被应用提供商占有 需要去中心化身份系统支撑 当前区块链账户系统的问题 区块链账户系统是Web 3.0去中心化身份的理想原型，但存在以下问题：\n完全匿名的缺陷： 用户可以无需认证创建多个账户 无法准确记录真实用户之间的社交关系和互动 用户与区块链身份之间的映射关系模糊 Soulbound Token的局限性： Vitalik Buterin提出的\u0026quot;灵魂\u0026quot;（Soul）概念和\u0026quot;灵魂绑定代币\u0026quot;（Soulbound Token） 用户仍可创建多个\u0026quot;灵魂\u0026quot;账户来抹除、转移或隐藏关系 无法真实反映人类社会中的真实关系 研究方案：zkBID 核心目标 zkBID（Zero-Knowledge Blockchain-account-based Web 3.0 decentralized IDentity）旨在实现：\n一对一映射：将灵魂（区块链账户）与人类（用户）建立一对一关联 去中心化：无需第三方中心化机构参与 隐私保护：隐藏身份与账户之间的绑定关系（即匿名） 可信性：每个账户在区块链上的信用与对应的真实用户一对一映射 关键技术 zkBID采用三大核心技术：\n零知识证明（zkSNARK） 可链接环签名（Linkable Ring Signature） 区块链智能合约（Smart Contracts） 技术预备知识 1. 可验证凭证（Verifiable Credentials, VC） 由W3C提出的去中心化标识符（DID）体系中的关键组件。\n三个主要角色：\n颁发者（Issuer）：签发凭证 持有者（Holder）：拥有凭证 验证者（Verifier）：验证凭证 VC的数据结构（JSON对象）：\n{ \u0026#34;metadata\u0026#34;: \u0026#34;包含颁发者DID、颁发日期、声明类型\u0026#34;, \u0026#34;claims\u0026#34;: \u0026#34;关于持有者的断言，包括持有者DID\u0026#34;, \u0026#34;proofs\u0026#34;: \u0026#34;颁发者的数字签名\u0026#34; } 2. 人格凭证（Personhood Credentials, PHC） 定义：证明用户是真人而非AI的数字凭证\n运作流程：\n注册流程 用户向PHC颁发者证明自己是真人 → 颁发者签发PHC\n使用流程 第三方服务可要求用户出示PHC作为授权过程的一部分\n验证方法（颁发者确保用户是真人的三种主要方式）：\n现有身份文件 基于政府签发的身份证件 利用现有可信来源 生物识别信息 测量持久且唯一的人体特征（掌纹、虹膜、指纹） 确保是真人且限制每人只注册一次 信任网络（Web of Trust） 通过社交图谱分析区分真人和机器 检测用户是否曾获得过凭证 在zkBID中的应用：\nPHC以VC形式作为每个人类用户的身份凭证 3. zkSNARK算法 全称：Zero-knowledge Succinct Non-interactive Argument of Knowledge\n优势：\n简洁性（Succinct）：证明大小仅几个字节，验证时间短 非交互性（Non-interactive）：证明者和验证者无需同步通信 工作原理：\n使用算术电路表示，包含基本运算：加、减、乘、除\nF-算术电路：\n输入：$x \\in \\mathbb{F}^n$ 辅助输入（见证）：$w \\in \\mathbb{F}^h$ 输出：$C(x, w) \\in \\mathbb{F}^l$ 三个算法组件：\n密钥生成（KEYGEN）\n(PK, VK) ← KEYGEN(1^λ, C) 输入：安全参数λ和电路C 输出：证明密钥PK和验证密钥VK 证明生成（PROVE）\nπ ← PROVE(PK, x, W) 输入：PK、公开输入x、私密见证W 输出：证明π 证明验证（VERIFY）\n1/0 ← VERIFY(VK, x, π) 输入：VK、公开输入x、证明π 输出：接受（1）或拒绝（0） zkBID采用的算法：Groth16\n原因：验证速度快，证明紧凑 适用于大规模应用和大型区块链网络 4. 可链接环签名（Linkable Ring Signature） 基本环签名：\n验证者可以确认签名由预定义集合中的某个成员创建 但无法确定具体是哪个成员 可链接环签名的额外特性：\n允许验证者确定两个签名是否由同一签名者生成 四个算法组件：\n密钥生成（GEN）\n(pk, sk) ← GEN(1^k) 签名生成（SIG）\nσ ← SIG(1^k, 1^n, m, L, sk) 输入：安全参数k、环大小n、消息m、公钥环L、私钥sk 输出：签名σ 签名验证（VER）\n1/0 ← VER(1^k, 1^n, m, L, σ) 可链接性检查（LINK）\n1/0 ← LINK(1^k, 1^n, m1, m2, σ1, σ2, L1, L2) 判断两个签名是否由同一签名者生成 关键属性：\n签名者模糊性（Signer Ambiguity）： 攻击者正确猜测真实签名者的概率不超过 1/(n-t) 其中n是环大小，t是攻击者拥有的私钥数量 可链接性（Linkability）： 同一签名者（相同私钥）签名的两条消息可被验证为关联 zkBID采用的算法：MLSAGS（Multilayered Linkable Spontaneous Anonymous Group Signature）\n原因：实现可链接性的技术复杂度较低，适合在智能合约上实现 密钥图像（Key Image）机制：\ny₀ ← sk * Hₚ(pk) y₀对于给定的(sk, pk)对是唯一的 所有由同一签名者产生的签名都带有相同的密钥图像 即使环中的公钥改变，签名仍可链接 zkBID系统设计 整体架构 映射关系图 真实用户 → PHC（人格凭证）→ PHC哈希 → 种子公钥 → 灵魂账户 关系说明：\n实线：可见的一对一关系 虚线：不可见但可验证的关系 箭头：单向计算关系 核心设计理念 隐私保护： PHC的具体内容不上链，只存储零知识证明 灵魂账户与种子公钥的关联不可见 可信匿名： 账户是匿名的（无法追踪到真实身份） 账户是可信的（确实与真实用户一对一绑定） 完全去中心化： 所有数据由用户生成 通过区块链上的智能合约验证 IVAC流程（Identity Verification and Account Certification） zkBID通过三个子流程生成具有可信匿名性的灵魂账户：\n[用户] → [注册信息生成] → [用户身份验证] → [灵魂账户认证] → [灵魂账户] ↓ ↓ ↓ 零知识证明 智能合约验证 可链接环签名 详细设计 阶段1：注册信息生成 目标：生成隐私保护的注册信息，不泄露PHC的具体内容\nPHC格式设计 zkBID中的PHC采用VC格式，包含三个关键字段：\n{ \u0026#34;credentialSubject\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_holder\u0026#34; // 持有者公钥 }, \u0026#34;proof\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_issuer\u0026#34;, // 颁发者公钥 \u0026#34;signature\u0026#34;: \u0026#34;sig_issuer\u0026#34; // 颁发者签名 } } 零知识证明生成流程 Protocol 1: PHC的ZK证明生成\n输入： - hash_PHC：PHC的哈希值 - sig_holder：持有者的签名 - pk_issuer：颁发者的公钥 - PHC：完整的PHC数据 设置： (PK, VK) ← zkSNARK.KEYGEN(1^λ, C) 生成证明： 1. 公开输入 x ← (hash_PHC, sig_holder, pk_issuer) 2. 私密见证 W ← PHC 3. π ← zkSNARK.PROVE(PK, x, W) 输出：π（零知识证明） 算术电路验证逻辑 graph TD A[私密输入: PHC] --\u0026gt; B[计算PHC的哈希] C[公开输入: hash_PHC] --\u0026gt; B B --\u0026gt; D{哈希值是否相等?} A --\u0026gt; E[提取pk_holder] F[公开输入: sig_holder] --\u0026gt; G[验证sig_holder] E --\u0026gt; G G --\u0026gt; H{签名是否有效?} A --\u0026gt; I[提取sig_issuer] J[公开输入: pk_issuer] --\u0026gt; K[验证sig_issuer] I --\u0026gt; K K --\u0026gt; L{签名是否有效?} D --\u0026gt; M[AND] H --\u0026gt; M L --\u0026gt; M M --\u0026gt; N{输出TRUE/FALSE} 验证步骤：\n验证哈希正确性： 计算PHC的哈希 检查是否等于公开输入中的hash_PHC 确保hash_PHC确实从PHC计算得出 验证所有权： 从PHC中提取持有者公钥pk_holder 用pk_holder验证sig_holder 证明用户拥有PHC 验证PHC有效性： 从PHC中提取颁发者签名sig_issuer 用pk_issuer验证sig_issuer 证明PHC由可信颁发者签发 输出：\n如果所有检查通过：输出TRUE和证明π π证明的声明：\u0026ldquo;PHC哈希正确，持有者拥有PHC，PHC由颁发者签发\u0026rdquo; 关键：不泄露PHC的具体内容 阶段2：用户身份验证 目标：\n验证用户的真人身份（通过验证ZK证明） 防止重复注册（检查PHC哈希未被使用） 智能合约流程 Protocol 2: 用户身份验证智能合约\n输入： - π：零知识证明 - hash_PHC：PHC哈希 - sig_holder：持有者签名 - pk_seed：种子公钥 执行步骤： 1. pk_issuer ← GetIssuerPK() // 获取预定义的颁发者公钥 2. validation ← zkSNARK.VERIFY(VK, hash_PHC, pk_issuer, π) 3. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 4. stored ← Traverse(hash_PHC) // 检查是否已注册 5. if stored ≠ 0: return \u0026#34;已经注册\u0026#34; 6. Store(hash_PHC, pk_seed) // 存储为键值对 7. return \u0026#34;认证成功\u0026#34; 用户操作步骤 生成种子密钥对：\n(pk_seed, sk_seed) ← MLSAGS.GEN(1^k) 构造交易：\n数据字段包含：π, hash_PHC, sig_holder, pk_issuer, pk_seed 发送到身份验证合约地址 合约验证：\n验证颁发者公钥匹配 验证零知识证明 检查PHC哈希未被使用 链上记录：\n存储键值对：(hash_PHC, pk_seed) hash_PHC用于防止重复注册 pk_seed作为用户在下一阶段创建灵魂账户的凭证 安全保证：\nPHC的具体内容不上链 仍能验证PHC的所有权和有效性 防止同一PHC多次注册 阶段3：灵魂账户认证 目标：认证灵魂账户与合法种子公钥的一对一关联\n整体流程 生成灵魂账户（普通以太坊账户） 建立关联（使用可链接环签名） 链上验证（智能合约验证签名） 可链接环签名的生成和验证 graph LR A[用户端] --\u0026gt; B[签名生成] B --\u0026gt; C[智能合约] C --\u0026gt; D[签名验证] E[输入] --\u0026gt; B E --\u0026gt; |选择的L-1个种子公钥| B E --\u0026gt; |用户的种子公钥pk_seed| B E --\u0026gt; |用户的种子私钥sk_seed| B E --\u0026gt; |灵魂账户地址addr_soul| B E --\u0026gt; |密钥图像y₀| B B --\u0026gt; |签名σ| C F[公钥环L] --\u0026gt; C G[addr_soul] --\u0026gt; C D --\u0026gt; H{验证结果} H --\u0026gt; |True| I[认证成功] H --\u0026gt; |False| J[认证失败] 详细步骤 步骤1：生成灵魂账户\n(addr_soul, pk_soul, sk_soul) = 生成以太坊账户 步骤2：构造公钥环\n从已注册的种子公钥中选择L-1个 加上用户自己的pk_seed 形成大小为L的公钥环 步骤3：计算密钥图像\ny₀ ← sk_seed * Hₚ(pk_seed) y₀对于给定的(sk_seed, pk_seed)是唯一的 用于防止重复注册 步骤4：生成可链接环签名\nσ ← MLSAGS.SIG(1^k, 1^n, addr_soul, L, sk_seed) 消息m = addr_soul（要签名的是灵魂账户地址） 签名格式：σ = (y₀, \u0026hellip;) y₀作为签名的一部分 步骤5：智能合约验证\nProtocol 3: 灵魂账户认证智能合约\n输入： - σ：可链接环签名 - L：公钥环 - addr_soul：灵魂账户地址 执行步骤： 1. validation ← LRS.VER(1^k, 1^n, addr_soul, L, σ) 2. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 3. stored ← Traverse(σ.y₀) // 检查密钥图像是否已使用 4. if stored ≠ 0: return \u0026#34;已经认证\u0026#34; 5. Store(σ.y₀, addr_soul) // 存储密钥图像和灵魂账户 6. return \u0026#34;认证成功\u0026#34; 隐私保护机制 关键特性：\n签名者模糊性： 签名可以被验证为有效 但无法确定环L中哪个公钥是真正的签名者 攻击者猜对的概率：1/(n-t)，其中n是环大小，t是攻击者拥有的私钥数 一对一保证： 密钥图像y₀唯一对应一个种子密钥对 同一种子密钥对只能生成一个有效签名 确保一个PHC只能关联一个灵魂账户 可验证的匿名性： 任何人都可以验证灵魂账户与某个合法种子公钥关联 但无法确定具体是哪个种子公钥 实现\u0026quot;可信匿名\u0026quot; 链上数据 存储内容：\n(σ.y₀, addr_soul) 键值对 可见信息：\n所有种子公钥（从阶段2） 所有灵魂账户地址 所有密钥图像 不可见关联：\n哪个种子公钥对应哪个灵魂账户 哪个PHC哈希对应哪个灵魂账户 哪个真实用户对应哪个灵魂账户 安全性分析 安全前提条件 计算对手受限：攻击者为多项式时间的计算对手 验证者诚实：智能合约不会接受虚假验证请求 PHC唯一性：每个用户只能从颁发者获得一个PHC 安全目标 zkBID需要满足三个核心安全属性：\n安全属性 定义 目标 身份唯一性 防止重复注册 一个用户不能注册多个灵魂账户 不可伪造性 防止身份伪造 攻击者不能冒充诚实用户认证灵魂账户 匿名性 保护身份隐私 攻击者无法检测用户身份(PHC)与灵魂账户的关联 威胁模型与防御 1. 女巫攻击（Sybil Attack） 攻击场景： 攻击者已拥有一个灵魂账户，试图获取新的灵魂账户\n攻击方法：\n方法A：使用相同PHC关联新的种子公钥 → 用新种子公钥认证新灵魂账户\n方法B：直接使用已用过的种子公钥认证新灵魂账户\n防御分析：\n方法A的防御：\n在用户身份验证合约中： 1. 合约检查hash_PHC是否已存储 2. 由于哈希函数的抗碰撞性，每个PHC只能生成一个唯一哈希 3. zkSNARK的可靠性保证：攻击者通过伪造哈希成功的概率可忽略不计 4. 因此无法用同一PHC注册两个种子账户 方法B的防御：\n在灵魂账户认证合约中： 1. 合约检查密钥图像y₀是否已使用 2. 由于可链接环签名的可链接性，同一种子私钥无法构造两个不同y₀的有效签名 3. 因此无法用同一种子密钥对认证两个灵魂账户 结论：无法使用相同PHC或种子公钥注册两个灵魂账户\n2. 链接攻击（Linkage Attack） 攻击场景： 攻击者试图通过破解环签名的真实签名者，建立用户身份（PHC哈希）与灵魂账户的链接\n攻击方法： 分析链上存储的环签名，推断哪个种子公钥是真正的签名者\n防御分析：\n基于可链接环签名的签名者模糊性： - 假设环大小为n - 攻击者拥有t个私钥 - 攻击者正确识别真实签名者的概率 = 1/(n-t) 示例： - 环大小 n = 100 - 攻击者拥有 t = 10 个私钥 - 成功概率 = 1/90 ≈ 1.1% 结论：攻击者无法有效建立身份与账户的链接 环大小的影响：\n环越大 → 匿名性越强 但签名生成和验证成本增加 需要在匿名性和效率之间权衡 3. 伪造攻击（Forgery Attack） 攻击场景： 攻击者试图冒充诚实用户获取灵魂账户\n攻击方法：\n方法A：伪造holder签名生成有效zkSNARK证明\n攻击者获得诚实用户的PHC ↓ 伪造sig_holder ↓ 生成通过验证的zkSNARK证明 ↓ 注册种子公钥 ↓ 认证灵魂账户 方法B：伪造种子账户的环签名\n已注册的种子公钥公开可见 ↓ 伪造某个诚实用户的环签名sig_seed ↓ 认证新的灵魂账户 防御分析：\n方法A的防御：\n依赖两个密码学保证： 1. EdDSA算法的不可伪造性 → 攻击者无法伪造任何诚实用户的sig_holder 2. zkSNARK的可靠性 → 没有有效签名，无法创建有效的zkSNARK证明 结论：攻击者无法通过伪造签名获得种子公钥 方法B的防御：\n依赖可链接环签名的不可伪造性： - 攻击者无法伪造任何已注册种子账户的有效签名 - 即使种子公钥公开可见 结论：攻击者无法冒充诚实用户认证灵魂账户 总结：zkBID协议能够抵御伪造攻击\n安全性总结表 攻击类型 攻击目标 依赖的安全属性 防御结果 女巫攻击-方法A 重复注册PHC 哈希抗碰撞性 + zkSNARK可靠性 ✅ 安全 女巫攻击-方法B 重复使用种子密钥 可链接环签名的可链接性 ✅ 安全 链接攻击 破坏匿名性 可链接环签名的签名者模糊性 ✅ 安全 伪造攻击-方法A 伪造身份验证 EdDSA不可伪造性 + zkSNARK可靠性 ✅ 安全 伪造攻击-方法B 伪造账户认证 可链接环签名不可伪造性 ✅ 安全 实验评估 实验环境 测试网络配置 区块链测试网络：\n平台：阿里云 节点数：6个以太坊全节点 共识协议：工作量证明（PoW） 客户端：Go-Ethereum 网络拓扑：全连接（每个节点有独立IP） 用户节点：\n1个用户节点连接到1个以太坊节点 运行用户端功能 硬件配置（所有节点）：\n操作系统：Ubuntu 20.04 CPU：Intel(R) Core(TM) i7-10700 @ 2.90GHz 内存：48GB RAM 实现技术栈 智能合约：\n语言：Solidity 部署：以太坊测试网络 zkSNARK：\n算法：Groth16 平台：Circom 2 功能：Setup和证明生成 可链接环签名：\n算法：MLSAGS 用户端实现：Python（密钥生成、签名算法） 合约实现：Solidity（签名验证） 性能评估指标 指标 说明 重要性 ZK证明生成时间 Groth16证明算法的执行时间 影响用户体验 ZK证明大小 证明所占字节数 影响链上存储 ZK证明验证成本 智能合约验证所需Gas 影响使用成本 算术电路大小 R1CS约束数量 影响系统复杂度 MLSAGS签名生成时间 环签名生成的执行时间 影响用户体验 MLSAGS签名验证成本 智能合约验证所需Gas 影响使用成本 实验结果 1. Groth16性能测试 测试方案：\n使用单个算术电路验证多个PHC批次 测试不同批次大小下的性能表现 图表 6(a)：电路大小和证明大小 PHC批次大小 R1CS约束数量 ZK证明大小 1 ~19,000 192 Bytes 2 ~38,000 192 Bytes 4 ~76,000 192 Bytes 8 ~152,000 192 Bytes 16 ~304,000 192 Bytes 32 ~608,000 192 Bytes 64 ~1,216,000 192 Bytes 128 ~2,432,000 192 Bytes 关键发现：\n✨ 证明大小恒定：无论批次大小如何，证明始终为192字节 这是Groth16的核心优势：简洁性（Succinctness） 电路大小随批次线性增长 图表 6(b)：证明生成时间和验证成本 证明生成时间：\nPHC批次大小 生成时间 (ms) 增长趋势 1 ~2,000 基准 2 ~4,000 2x 4 ~8,000 4x 8 ~16,000 8x 16 ~32,000 16x 32 ~64,000 32x 证明验证成本（Gas）：\nPHC批次大小 验证Gas消耗 单个PHC平均Gas 1 215.7K 215.7K 2 247.2K 123.6K 4 310.2K 77.6K 8 436.2K 54.5K 16 688.2K 43.0K 32 1,040.0K 32.5K 关键发现：\n📈 线性增长：生成时间和验证成本都与批次大小呈线性关系\n💰\n批处理优势\n：批次大小为32时，单个PHC的Gas消耗仅为32.5K\n相比单独验证（215.7K），节省约85% 效率提升约7倍 ⚠️ 部署限制：批次大小≥64时，验证合约因以太坊合约大小限制无法部署\n最佳实践建议：\n推荐批次大小：16-32个PHC - 在合约大小限制内 - 获得显著的Gas优化 - 用户体验可接受 2. MLSAGS性能测试 测试方案：\n测试不同环大小L下的签名生成和验证性能 环大小影响匿名性和性能的权衡 图表 6(c)：MLSAGS性能指标 签名生成时间：\n环大小 L 生成时间 (ms) 增量时间 1 ~40 - 2 ~80 +40ms 4 ~160 +40ms 8 ~320 +40ms 16 ~640 +40ms 32 ~1,280 +40ms 64 ~2,560 +40ms 128 ~5,120 +40ms 签名验证成本（Gas）：\n环大小 L 验证Gas消耗 增量Gas 1 ~57K - 2 ~114K +57K 4 ~228K +57K 8 ~456K +57K 16 ~912K +57K 32 ~1,824K +57K 64 ~3,648K +57K 128 ~7,296K +57K 关键发现：\n📏\n完美线性关系\n：\n每增加1个公钥，生成时间增加约40ms 每增加1个公钥，验证Gas增加约57K ⚖️\n匿名性vs效率权衡\n：\n环越大 → 匿名性越强（攻击者猜中概率 = 1/L） 环越大 → 成本越高（时间和Gas） 匿名性分析：\n环大小 L 攻击者成功率 匿名性等级 Gas成本 10 10% 较弱 570K 50 2% 中等 2,850K 100 1% 强 5,700K 1000 0.1% 非常强 57,000K 实际应用建议：\n小规模应用（\u0026lt; 1000用户）： 环大小：10-20 匿名性：10%-5%攻击成功率 Gas成本：570K-1,140K（可接受） 中等规模应用（1000-10000用户）： 环大小：50-100 匿名性：2%-1%攻击成功率 Gas成本：2,850K-5,700K（需要优化） 大规模应用（\u0026gt; 10000用户）： 环大小：100+ 匿名性：\u0026lt; 1%攻击成功率 Gas成本：\u0026gt; 5,700K（需要Layer 2或批处理） 性能优化建议 1. 对于zkSNARK部分 批处理策略：\n低频场景（个人注册）： - 批次大小：1-4 - 适用：个人用户单次注册 - 优点：即时处理 - 缺点：Gas成本较高（215K-310K） 高频场景（批量注册）： - 批次大小：16-32 - 适用：组织批量入职、大规模注册活动 - 优点：Gas效率提升7倍 - 缺点：需要等待批次凑齐 2. 对于MLSAGS部分 环大小配置：\n# 根据用户总数动态调整 def calculate_ring_size(total_users, target_anonymity=0.01): \u0026#34;\u0026#34;\u0026#34; total_users: 系统总用户数 target_anonymity: 目标攻击成功率（如0.01 = 1%） \u0026#34;\u0026#34;\u0026#34; # 环大小不超过总用户数 ring_size = min(int(1 / target_anonymity), total_users) # 考虑Gas成本限制（假设单笔交易Gas上限为8M） max_affordable_ring = 8_000_000 / 57_000 # ≈ 140 return min(ring_size, max_affordable_ring) # 示例 calculate_ring_size(1000, 0.01) # 返回 100 calculate_ring_size(10000, 0.01) # 返回 100（受成本限制） calculate_ring_size(50, 0.01) # 返回 50（受用户数限制） 分层匿名策略：\nVIP用户/高价值账户： - 使用较大环（100+） - 提供更强匿名性 - 愿意支付更高Gas 普通用户： - 使用中等环（20-50） - 平衡匿名性和成本 - 实际应用最常见 测试/低价值账户： - 使用小环（10-20） - 基本匿名性 - 成本最低 实验结论 zkSNARK的优势： ✅ 证明大小恒定（192字节）：不受批次影响 ✅ 批处理优化显著：32个PHC可节省85% Gas ✅ 验证快速：链上验证成本可接受 MLSAGS的特性： ✅ 性能可预测：完美线性关系 ⚠️ 需要权衡：匿名性与成本呈正比 ✅ 灵活配置：可根据场景调整环大小 系统可行性： ✅ 在实际以太坊网络上完全可行 ✅ 通过参数优化可适应不同规模 ✅ 性能瓶颈明确且可优化 相关工作对比 现有方案分析 论文对比了8个相关的区块链身份方案：\n方案 年份 主要技术 应用场景 TradeMap [12] 2019 ZKP 符合FINMA的匿名KYC平台 Pauwels et al. [14] 2022 zkSNARK DeFi协议的KYC系统 Aydar et al. [3] 2019 Blockchain 数字身份验证框架 Singh et al. [18] 2020 Credential Protocol 保护个人属性的身份系统 Abraham et al. [1] 2020 SSI Model 支持凭证撤销的自主身份 ZEBRA [15] 2022 zkSNARK 链上匿名凭证验证 Zhang et al. [26] 2024 ZKP 能源交易身份认证 Kim et al. [10] 2023 SBT + DID 元宇宙的KYC系统 设计目标对比 方案 DG1 技术灵活性 DG2 身份匿名性 DG3 身份可信性 DG4 隐私存储 TradeMap [12] ✅ ❌ ❌ ❌ Pauwels [14] ✅ ❌ ✅ ✅ Aydar [3] ❌ ✅ ❌ ❌ Singh [18] ❌ ✅ ✅ ✅ Abraham [1] ✅ ✅ ❌ ❌ ZEBRA [15] ❌ ✅ ❌ ❌ Zhang [26] ✅ ❌ ✅ ❌ Kim [10] ❌ ✅ ❌ ❌ zkBID ✅ ✅ ✅ ✅ 设计目标说明：\nDG1 - 技术灵活性：不局限于特定的ZKP算法或区块链平台 DG2 - 身份匿名性：无法从链上活动推断用户真实身份 DG3 - 身份可信性：每个身份可信地连接到真实世界用户 DG4 - 隐私存储：身份文档保密存储，不公开可见 zkBID的独特优势 1. 唯一全面满足所有设计目标 其他方案的局限： ├─ TradeMap: 只关注合规性，缺乏匿名性和可信映射 ├─ Pauwels: DeFi场景，但身份匿名性不足 ├─ Aydar/Singh: 技术灵活性差，绑定特定实现 ├─ Abraham/ZEBRA: 缺乏与真实用户的可信绑定 ├─ Zhang: 特定场景（能源交易），匿名性不足 └─ Kim: 元宇宙场景，技术灵活性和可信性不足 zkBID的创新： ✅ 同时实现匿名性和可信性（看似矛盾的目标） ✅ 完全去中心化（无需可信第三方） ✅ 技术灵活（可替换ZKP算法和环签名方案） ✅ 隐私保护（身份信息不上链） 2. 技术组合的创新性 现有方案的技术使用：\n大多只使用zkSNARK进行凭证验证 少数使用环签名，但未实现身份-账户绑定 没有方案同时使用zkSNARK + 可链接环签名 zkBID的技术创新：\nzkSNARK（阶段1-2）： 目的：验证PHC有效性 优势：不泄露PHC内容 创新：批处理优化 可链接环签名（阶段3）： 目的：建立身份-账户映射 优势：保持匿名性的同时确保一对一 创新：使用密钥图像防止重复绑定 组合效果： = 可验证的身份 + 不可追踪的账户绑定 = 可信匿名（Credible Anonymity） 3. 实际应用价值 传统KYC系统的问题：\n中心化KYC： ❌ 隐私泄露风险 ❌ 数据被服务商控制 ❌ 跨平台不互通 区块链匿名账户： ❌ 无法防止女巫攻击 ❌ 信誉系统难以建立 ❌ 监管合规困难 zkBID的解决方案：\n对用户： ✅ 保护隐私（身份信息不泄露） ✅ 自主控制（无需信任中心化机构） ✅ 一次认证，多处使用 对平台： ✅ 防止女巫攻击（一人一账户） ✅ 建立信誉系统（账户可信） ✅ 满足监管要求（有认证机制） 对监管： ✅ 可验证的身份（PHC由可信机构签发） ✅ 可追责性（必要时可追踪） ✅ 隐私保护合规 应用场景 1. 去中心化社交网络 问题：\nTwitter/X上的机器人和假账户泛滥 难以区分真人和AI生成的内容 水军和虚假舆论操纵 zkBID解决方案：\n用户注册： 1. 用政府ID获取PHC 2. 通过zkBID认证获得灵魂账户 3. 使用灵魂账户在社交网络发布内容 效果： ✅ 每个账户对应一个真人 ✅ 保持用户匿名性 ✅ 机器人和假账户显著减少 ✅ 信誉系统可以建立在灵魂账户上 2. DAO治理 问题：\n一人多账户操纵投票 女巫攻击破坏治理公平性 难以验证投票者资格 zkBID解决方案：\n治理流程： 1. DAO成员通过zkBID认证 2. 每个灵魂账户 = 一个真实成员 3. 投票时保持匿名 4. 防止多重投票 效果： ✅ 一人一票（真正的民主） ✅ 投票匿名（防止胁迫和贿赂） ✅ 可验证（确保只有成员投票） ✅ 信誉加权（可基于历史贡献） 3. DeFi空投和激励 问题：\n空投被羊毛党多账户瓜分 难以识别真实用户 激励机制被滥用 zkBID解决方案：\n空投流程： 1. 要求使用zkBID认证的灵魂账户 2. 每个灵魂账户只能领取一次 3. 基于链上行为的信誉评分 效果： ✅ 公平分配（每人一份） ✅ 防止女巫攻击 ✅ 识别真实活跃用户 ✅ 建立长期激励机制 4. Web3游戏和元宇宙 问题：\n工作室多开刷金币 游戏经济被破坏 难以建立公平竞技环境 zkBID解决方案：\n游戏应用： 1. 玩家使用灵魂账户登录 2. 游戏内资产绑定到灵魂账户 3. 排行榜和竞技只认可灵魂账户 效果： ✅ 一人一号（公平竞争） ✅ 资产真实归属 ✅ 游戏经济稳定 ✅ 社交关系可信 5. 去中心化信用系统 问题：\n传统信用系统中心化 跨平台信用不互通 隐私泄露风险 zkBID解决方案：\n信用体系： 1. 灵魂账户作为信用载体 2. 链上行为建立信用历史 3. 跨DApp信用互认 4. 保护用户隐私 效果： ✅ 去中心化信用（不被单一机构控制） ✅ 可移植性（跨平台使用） ✅ 隐私保护（匿名但可信） ✅ 防止信用欺诈（一人一信用档案） 局限性与未来工作 当前局限性 1. 性能限制 Gas成本：\n当前状态： - 单次PHC验证：215.7K Gas - 环大小100的签名验证：5,700K Gas - 在以太坊主网上成本较高 影响： ❌ 大规模应用成本高 ❌ 限制了环大小（影响匿名性） 可能的解决方案：\nLayer 2方案（如Optimism、Arbitrum） 侧链部署 批处理优化 2. PHC依赖 当前状态：\n依赖可信的PHC颁发机构： - 政府机构 - 大型科技公司 - 其他可信第三方 问题： ❌ PHC系统尚未广泛部署 ❌ 不同颁发者的互操作性 ❌ 颁发者可能成为中心化风险点 3. 隐私权衡 匿名性级别：\n环大小的限制： - 小环（\u0026lt;20）：匿名性较弱 - 大环（100+）：成本高昂 - 实际应用中需要权衡 4. 撤销机制 当前缺失：\n无法撤销已认证的灵魂账户： ❌ 如果PHC被吊销怎么办？ ❌ 如果用户想注销怎么办？ ❌ 如果发现欺诈怎么办？ 需要设计： - 灵活的撤销机制 - 保持匿名性的撤销 - 防止滥用撤销权 未来研究方向 1. 性能优化 方向A：递归证明：\n使用递归zkSNARK： - 将多个证明聚合成一个 - 减少链上验证成本 - 提高批处理效率 预期效果： - Gas成本降低50%+ - 支持更大批次 方向B：量子抗性：\n替换为抗量子密码算法： - 格基密码学 - 哈希基签名 - 为后量子时代做准备 2. PHC生态系统 多颁发者互操作：\n标准化PHC格式： - 统一的VC模板 - 跨颁发者互认 - 去中心化颁发者网络 目标： - 减少单点故障 - 提高可用性 - 增强去中心化 去中心化PHC颁发：\n探索无需中心化颁发者的方案： - 基于生物识别的去中心化验证 - 社交图谱验证 - 组合多种验证方式 3. 隐私增强 方向A：动态环：\n允许用户动态选择环大小： - 根据交易重要性调整 - 重要交易用大环 - 普通交易用小环 效果： - 灵活性提高 - 成本优化 方向B：分层匿名：\n不同隐私级别的灵魂账户： - 公开级：最小匿名性，低成本 - 标准级：中等匿名性，中等成本 - 隐私级：高匿名性，高成本 4. 跨链支持 多链部署：\n扩展到其他区块链： - Polkadot/Cosmos生态 - 高性能链（Solana、Aptos） - 专用隐私链（Zcash、Monero概念） 跨链身份： - 一个PHC，多链认证 - 统一的身份层 5. 撤销和恢复机制 优雅的撤销：\n设计保护隐私的撤销： - 使用累加器（Accumulator） - 撤销列表不泄露身份 - 高效的撤销验证 恢复机制： - PHC过期后的更新流程 - 密钥丢失的恢复方案 - 保持连续性的信誉迁移 6. 合规和监管 可选的透明性：\n为监管场景设计： - 选择性披露机制 - 紧急情况下的去匿名化 - 法院命令的执行 平衡： - 保护普通用户隐私 - 满足反洗钱（AML）要求 - 支持合法调查 关键takeaways 技术创新 可信匿名的突破： 首次在区块链上实现\u0026quot;可信\u0026quot;+\u0026ldquo;匿名\u0026quot;的结合 通过零知识证明保护隐私 通过可链接环签名确保一对一映射 完全去中心化： 无需可信第三方参与验证 所有逻辑在智能合约中执行 用户完全控制自己的身份 实用性验证： 在真实以太坊测试网络上实现 性能指标明确可测 成本可接受且可优化 理论贡献 身份模型创新：\n传统模型：身份 → 账户（可见映射） zkBID模型：身份 → [ZK层] → 种子 → [环签名层] → 账户 创新点： - 两层隐私保护 - 可验证但不可追踪 - 数学上可证明的安全性 密码学组合：\nzkSNARK + 可链接环签名的首次组合应用 各取所长，弥补对方不足 为未来类似系统提供范式 实践意义 Web3基础设施： 为Web3提供关键的身份层 解决匿名性与可信性的矛盾 使去中心化应用更实用 防止AI冒充： 在AI时代区分人类和机器 PHC作为\u0026quot;数字人格证\u0026rdquo; 保护在线空间的人类性 新经济模式： 支持基于信誉的去中心化经济 公平的激励分配机制 可持续的社区治理 结论 zkBID是一个创新的Web 3.0去中心化身份方案，成功解决了区块链账户系统中匿名性与可信性的矛盾。\n核心成就 ✅ 技术突破：\n零知识证明保护身份隐私 可链接环签名确保一对一映射 完全去中心化的验证机制 ✅ 安全保证：\n抵御女巫攻击 抵御链接攻击 抵御伪造攻击 ✅ 实用验证：\n以太坊测试网络成功部署 性能指标满足实际应用需求 成本可通过参数优化控制 未来展望 zkBID为Web3去中心化身份提供了一个可行的解决方案，但仍有改进空间：\n继续优化性能和成本 推动PHC生态系统发展 探索跨链和多链支持 完善撤销和恢复机制 平衡隐私保护 ","permalink":"http://localhost:1313/posts/linking-souls-to-humans/","summary":"zkBID通过零知识证明和可链接环签名技术，首次实现了区块链账户的\u0026quot;可信匿名\u0026quot;：每个账户与真实用户一对一绑定（可信），但外界无法追踪具体对应关系（匿名）。系统采用三阶段IVAC流程，将人格凭证(PHC)通过零知识证明验证后绑定到种子公钥，再用环签名将种子公钥关联到灵魂账户。实验显示批处理可将验证成本降低85%，环大小灵活可调以平衡匿名性与效率。该方案为Web3提供了关键身份基础设施，可有效防止女巫攻击，支持去中心化社交、DAO治理、DeFi空投等场景。","title":"zkBID: 区块链账户与Web 3.0去中心化身份"},{"content":"📚 Part 1: Java 集合使用手册 0.String - 不可变字符串 // 初始化 String s = \u0026#34;hello\u0026#34;; String s2 = new String(\u0026#34;world\u0026#34;); String s3 = String.valueOf(123); // 数字转字符串 // 基本属性 int len = s.length(); // 长度 boolean empty = s.isEmpty(); // 是否为空 char ch = s.charAt(0); // 获取字符 // 查找 int index = s.indexOf(\u0026#34;ll\u0026#34;); // 查找子串位置 int lastIndex = s.lastIndexOf(\u0026#34;l\u0026#34;); // 最后出现位置 boolean contains = s.contains(\u0026#34;el\u0026#34;); // 是否包含 // 截取 String sub = s.substring(1, 4); // [1, 4) 截取 String sub2 = s.substring(2); // 从索引2到结尾 // 替换 String replaced = s.replace(\u0026#34;l\u0026#34;, \u0026#34;L\u0026#34;); // 替换所有 String replaced2 = s.replaceFirst(\u0026#34;l\u0026#34;, \u0026#34;L\u0026#34;); // 替换第一个 String replaced3 = s.replaceAll(\u0026#34;[aeiou]\u0026#34;, \u0026#34;*\u0026#34;); // 正则替换 // 分割 String[] parts = \u0026#34;a,b,c\u0026#34;.split(\u0026#34;,\u0026#34;); // 按分隔符分割 String[] parts2 = \u0026#34;a b c\u0026#34;.split(\u0026#34;\\\\s+\u0026#34;); // 按空格分割 // 拼接 String joined = String.join(\u0026#34;,\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); // \u0026#34;a,b,c\u0026#34; String concat = s.concat(\u0026#34; world\u0026#34;); // 拼接 // 大小写 String upper = s.toUpperCase(); String lower = s.toUpperCase().toLowerCase(); // 去空格 String trimmed = \u0026#34; hello \u0026#34;.trim(); // 去两端空格 String stripped = \u0026#34; hello \u0026#34;.strip(); // Java 11+ // 比较 boolean equals = s.equals(\u0026#34;hello\u0026#34;); boolean equalsIgnoreCase = s.equalsIgnoreCase(\u0026#34;HELLO\u0026#34;); int compare = s.compareTo(\u0026#34;world\u0026#34;); // 字典序比较 // 判断 boolean startsWith = s.startsWith(\u0026#34;he\u0026#34;); boolean endsWith = s.endsWith(\u0026#34;lo\u0026#34;); // 转换 char[] chars = s.toCharArray(); // 转字符数组 byte[] bytes = s.getBytes(); // 转字节数组 StringBuilder - 可变字符串 使用场景：单线程环境下需要频繁修改字符串\n// 初始化 StringBuilder sb = new StringBuilder(); StringBuilder sb2 = new StringBuilder(\u0026#34;hello\u0026#34;); StringBuilder sb3 = new StringBuilder(100); // 指定初始容量 // 添加（拼接） sb.append(\u0026#34;hello\u0026#34;); // 尾部添加 sb.append(123); // 添加数字 sb.append(\u0026#39;!\u0026#39;); // 添加字符 sb.insert(0, \u0026#34;start \u0026#34;); // 指定位置插入 // 删除 sb.delete(0, 5); // 删除 [0, 5) sb.deleteCharAt(0); // 删除指定位置 sb.setLength(0); // 清空（重置长度为0） // 修改 sb.replace(0, 5, \u0026#34;world\u0026#34;); // 替换 [0, 5) sb.setCharAt(0, \u0026#39;H\u0026#39;); // 修改指定位置字符 // 反转 sb.reverse(); // 查询 int len = sb.length(); char ch = sb.charAt(0); String sub = sb.substring(0, 5); // 转换为 String String result = sb.toString(); // 常见应用：循环拼接字符串 StringBuilder result = new StringBuilder(); for (int i = 0; i \u0026lt; 1000; i++) { result.append(i).append(\u0026#34;,\u0026#34;); } // 比用 String + 拼接快得多！ StringBuffer - 可变字符串 使用场景：多线程环境下需要频繁修改字符串\n// API 与 StringBuilder 完全相同 StringBuffer sb = new StringBuffer(); sb.append(\u0026#34;hello\u0026#34;); sb.append(\u0026#34; world\u0026#34;); String result = sb.toString(); // 区别：StringBuffer 的方法都是 synchronized 的 // 多线程安全，但性能比 StringBuilder 差 常用字符串操作技巧 // 1. 字符串转数字 int num = Integer.parseInt(\u0026#34;123\u0026#34;); long l = Long.parseLong(\u0026#34;123\u0026#34;); double d = Double.parseDouble(\u0026#34;3.14\u0026#34;); // 2. 数字转字符串 String s1 = String.valueOf(123); String s2 = Integer.toString(123); String s3 = \u0026#34;\u0026#34; + 123; // 不推荐 // 3. 字符串数组拼接 String[] arr = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; String joined = String.join(\u0026#34;,\u0026#34;, arr); // \u0026#34;a,b,c\u0026#34; // 4. 重复字符串（Java 11+） String repeated = \u0026#34;ab\u0026#34;.repeat(3); // \u0026#34;ababab\u0026#34; // 5. 判断空字符串 if (s != null \u0026amp;\u0026amp; !s.isEmpty()) { } if (s != null \u0026amp;\u0026amp; !s.isBlank()) { } // Java 11+，忽略空白字符 // 6. 字符串格式化 String formatted = String.format(\u0026#34;Hello %s, you are %d years old\u0026#34;, \u0026#34;Alice\u0026#34;, 25); 1. List - 列表 ArrayList - 动态数组 // 初始化 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); List\u0026lt;Integer\u0026gt; list3 = new ArrayList\u0026lt;\u0026gt;(100); // 指定初始容量 // 增 list.add(1); // 尾部添加 list.add(0, 10); // 指定位置添加 list.addAll(Arrays.asList(2,3,4)); // 批量添加 // 删 list.remove(0); // 删除指定索引 list.remove(Integer.valueOf(1)); // 删除指定元素 list.clear(); // 清空 // 改 list.set(0, 100); // 修改指定位置 // 查 int val = list.get(0); // 获取元素 int size = list.size(); // 获取大小 boolean empty = list.isEmpty(); // 是否为空 boolean contains = list.contains(1); // 是否包含 int index = list.indexOf(1); // 查找索引 // 遍历 for (int num : list) { System.out.println(num); } // 或使用迭代器 Iterator\u0026lt;Integer\u0026gt; it = list.iterator(); while (it.hasNext()) { System.out.println(it.next()); } LinkedList - 双向链表 LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 头部操作 list.addFirst(1); list.removeFirst(); int first = list.getFirst(); // 尾部操作 list.addLast(2); list.removeLast(); int last = list.getLast(); // 作为队列使用 list.offer(3); // 入队 int head = list.poll(); // 出队 // 作为栈使用 list.push(4); // 入栈 int top = list.pop(); // 出栈 2. Set - 集合 HashSet - 无序不重复 // 初始化 Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); // 增 set.add(1); set.addAll(Arrays.asList(2, 3, 4)); // 删 set.remove(1); set.clear(); // 查 boolean contains = set.contains(1); int size = set.size(); boolean empty = set.isEmpty(); // 遍历 for (int num : set) { System.out.println(num); } TreeSet - 有序集合（红黑树） TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 基本操作同 HashSet set.add(3); set.add(1); set.add(2); System.out.println(set); // [1, 2, 3] 自动排序 // 特有方法 int first = set.first(); // 最小元素 int last = set.last(); // 最大元素 int lower = set.lower(2); // 小于 2 的最大元素 int higher = set.higher(2); // 大于 2 的最小元素 int floor = set.floor(2); // ≤ 2 的最大元素 int ceiling = set.ceiling(2); // ≥ 2 的最小元素 // 子集操作 SortedSet\u0026lt;Integer\u0026gt; subset = set.subSet(1, 3); // [1, 3) SortedSet\u0026lt;Integer\u0026gt; headSet = set.headSet(2); // \u0026lt; 2 SortedSet\u0026lt;Integer\u0026gt; tailSet = set.tailSet(2); // \u0026gt;= 2 LinkedHashSet - 保持插入顺序 Set\u0026lt;Integer\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); set.add(3); set.add(1); set.add(2); System.out.println(set); // [3, 1, 2] 保持插入顺序 3. Map - 映射 HashMap - 键值对 // 初始化 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 增/改 map.put(\u0026#34;apple\u0026#34;, 1); map.put(\u0026#34;banana\u0026#34;, 2); map.putIfAbsent(\u0026#34;apple\u0026#34;, 10); // 键不存在时才添加 // 删 map.remove(\u0026#34;apple\u0026#34;); map.clear(); // 查 int val = map.get(\u0026#34;apple\u0026#34;); int valOrDefault = map.getOrDefault(\u0026#34;orange\u0026#34;, 0); boolean hasKey = map.containsKey(\u0026#34;apple\u0026#34;); boolean hasValue = map.containsValue(1); int size = map.size(); // 遍历键值对 for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { String key = entry.getKey(); int value = entry.getValue(); } // 遍历键 for (String key : map.keySet()) { System.out.println(key); } // 遍历值 for (int value : map.values()) { System.out.println(value); } // Java 8+ 新方法 map.computeIfAbsent(\u0026#34;cherry\u0026#34;, k -\u0026gt; 3); map.merge(\u0026#34;apple\u0026#34;, 1, Integer::sum); // 累加 TreeMap - 有序映射（红黑树） TreeMap\u0026lt;Integer, String\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); map.put(3, \u0026#34;c\u0026#34;); map.put(1, \u0026#34;a\u0026#34;); map.put(2, \u0026#34;b\u0026#34;); // 基本操作同 HashMap // 特有方法 int firstKey = map.firstKey(); int lastKey = map.lastKey(); Map.Entry\u0026lt;Integer, String\u0026gt; firstEntry = map.firstEntry(); Map.Entry\u0026lt;Integer, String\u0026gt; lastEntry = map.lastEntry(); int lowerKey = map.lowerKey(2); // \u0026lt; 2 的最大键 int higherKey = map.higherKey(2); // \u0026gt; 2 的最小键 int floorKey = map.floorKey(2); // \u0026lt;= 2 的最大键 int ceilingKey = map.ceilingKey(2); // \u0026gt;= 2 的最小键 LinkedHashMap - 保持插入顺序 Map\u0026lt;String, Integer\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;c\u0026#34;, 3); map.put(\u0026#34;a\u0026#34;, 1); map.put(\u0026#34;b\u0026#34;, 2); // 遍历时保持插入顺序: c, a, b 4. Queue - 队列 普通队列 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 入队 queue.offer(1); queue.add(2); // 队列满时抛异常 // 出队 int head = queue.poll(); // 空时返回 null int head2 = queue.remove(); // 空时抛异常 // 查看队首 int peek = queue.peek(); // 空时返回 null int peek2 = queue.element(); // 空时抛异常 PriorityQueue - 优先队列（堆） // 小根堆（默认） PriorityQueue\u0026lt;Integer\u0026gt; minHeap = new PriorityQueue\u0026lt;\u0026gt;(); // 大根堆 PriorityQueue\u0026lt;Integer\u0026gt; maxHeap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); // 自定义对象 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); minHeap.offer(3); minHeap.offer(1); minHeap.offer(2); while (!minHeap.isEmpty()) { System.out.println(minHeap.poll()); // 1, 2, 3 } Deque - 双端队列 Deque\u0026lt;Integer\u0026gt; deque = new ArrayDeque\u0026lt;\u0026gt;(); // 头部操作 deque.offerFirst(1); deque.pollFirst(); deque.peekFirst(); // 尾部操作 deque.offerLast(2); deque.pollLast(); deque.peekLast(); // 作为栈使用 deque.push(3); int top = deque.pop(); 5. Stack - 栈 Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(1); // 入栈 int top = stack.pop(); // 出栈 int peek = stack.peek(); // 查看栈顶 boolean empty = stack.isEmpty(); int size = stack.size(); // 推荐使用 Deque 代替 Stack Deque\u0026lt;Integer\u0026gt; stack2 = new ArrayDeque\u0026lt;\u0026gt;(); 🧮 Part 2: 算法模板 1. 树的遍历 二叉树定义 class TreeNode { int val; // 节点值 TreeNode left; // 左子节点 TreeNode right; // 右子节点 TreeNode(int val) { this.val = val; } } DFS - 深度优先遍历 前序遍历（根-左-右） // 递归版本 - 最简洁直观 void preorder(TreeNode root) { if (root == null) return; // 递归终止条件：空节点 System.out.println(root.val); // 1. 先访问根节点 preorder(root.left); // 2. 再遍历左子树 preorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 使用栈模拟递归 List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); // 根节点入栈 while (!stack.isEmpty()) { TreeNode node = stack.pop(); // 弹出栈顶节点 res.add(node.val); // 访问该节点 // 关键：先压右子节点，再压左子节点 // 这样出栈时左子节点先出（栈是后进先出） if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); } return res; } 中序遍历（左-根-右） // 递归版本 void inorder(TreeNode root) { if (root == null) return; // 递归终止条件 inorder(root.left); // 1. 先遍历左子树 System.out.println(root.val); // 2. 再访问根节点 inorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 一直向左走到底 List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode curr = root; while (curr != null || !stack.isEmpty()) { // 第一步：一直向左走到底，沿途节点入栈 while (curr != null) { stack.push(curr); curr = curr.left; } // 第二步：弹出栈顶（当前最左节点），访问它 curr = stack.pop(); res.add(curr.val); // 第三步：转向右子树 curr = curr.right; } return res; } 后序遍历（左-右-根） // 递归版本 void postorder(TreeNode root) { if (root == null) return; // 递归终止条件 postorder(root.left); // 1. 先遍历左子树 postorder(root.right); // 2. 再遍历右子树 System.out.println(root.val); // 3. 最后访问根节点 } // 迭代版本 - 巧妙方法：前序遍历变形 + 反转 // 思路：前序是\u0026#34;根左右\u0026#34;，改成\u0026#34;根右左\u0026#34;，反转后得到\u0026#34;左右根\u0026#34; List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); res.add(node.val); // 添加到结果（根右左顺序） // 注意：这里先左后右，出栈时就是先右后左 if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); } Collections.reverse(res); // 反转得到左右根 return res; } BFS - 层序遍历 // 按层遍历二叉树，每层的节点放在一个列表中 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); // 根节点入队 while (!queue.isEmpty()) { int size = queue.size(); // 当前层的节点数（重要！） List\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); // 遍历当前层的所有节点 for (int i = 0; i \u0026lt; size; i++) { TreeNode node = queue.poll(); // 出队 level.add(node.val); // 记录节点值 // 将下一层的节点入队 if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } res.add(level); // 保存当前层结果 } return res; } 线段树（Segment Tree） /** * 线段树：用于高效处理区间查询和单点修改 * 时间复杂度：构建 O(n)，查询 O(log n)，更新 O(log n) */ class SegmentTree { private int[] tree; // 线段树数组 private int n; // 原数组大小 public SegmentTree(int[] nums) { n = nums.length; tree = new int[4 * n]; // 线段树最多需要 4n 空间 build(nums, 0, 0, n - 1); } // 构建线段树：递归构建 // node: 当前节点在 tree 中的索引 // start, end: 当前节点代表的区间 [start, end] private void build(int[] nums, int node, int start, int end) { if (start == end) { // 叶子节点：直接存储原数组的值 tree[node] = nums[start]; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; // 左子节点索引 int rightNode = 2 * node + 2; // 右子节点索引 // 递归构建左右子树 build(nums, leftNode, start, mid); build(nums, rightNode, mid + 1, end); // 当前节点的值 = 左子树 + 右子树（区间和） tree[node] = tree[leftNode] + tree[rightNode]; } // 区间查询：查询区间 [l, r] 的和 public int query(int l, int r) { return query(0, 0, n - 1, l, r); } private int query(int node, int start, int end, int l, int r) { // 情况1：当前区间与查询区间完全不相交 if (l \u0026gt; end || r \u0026lt; start) return 0; // 情况2：当前区间完全包含在查询区间内 if (l \u0026lt;= start \u0026amp;\u0026amp; end \u0026lt;= r) return tree[node]; // 情况3：部分相交，需要递归查询左右子树 int mid = start + (end - start) / 2; int leftSum = query(2 * node + 1, start, mid, l, r); int rightSum = query(2 * node + 2, mid + 1, end, l, r); return leftSum + rightSum; } // 单点更新：将 index 位置的值更新为 val public void update(int index, int val) { update(0, 0, n - 1, index, val); } private void update(int node, int start, int end, int index, int val) { if (start == end) { // 找到叶子节点，更新值 tree[node] = val; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; int rightNode = 2 * node + 2; // 判断 index 在左子树还是右子树 if (index \u0026lt;= mid) { update(leftNode, start, mid, index, val); } else { update(rightNode, mid + 1, end, index, val); } // 更新完子树后，更新当前节点 tree[node] = tree[leftNode] + tree[rightNode]; } } 2. 图算法 图的表示 // 方式1：邻接表（适合稀疏图） Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; graph = new HashMap\u0026lt;\u0026gt;(); // 或使用 ArrayList List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); // 方式2：邻接矩阵（适合密集图） int[][] graph = new int[n][n]; // graph[i][j] 表示 i 到 j 的边权 DFS - 图的深度优先遍历 // 递归实现 DFS void dfs(int node, Set\u0026lt;Integer\u0026gt; visited, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { visited.add(node); // 标记当前节点已访问 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { // 如果邻居未访问 dfs(neighbor, visited, graph); // 递归访问邻居 } } } // 使用示例 Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); dfs(0, visited, graph); // 从节点 0 开始 DFS BFS - 图的广度优先遍历 // 使用队列实现 BFS void bfs(int start, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(start); // 起始节点入队 visited.add(start); // 标记已访问 while (!queue.isEmpty()) { int node = queue.poll(); // 出队 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { queue.offer(neighbor); // 邻居入队 visited.add(neighbor); // 标记已访问 } } } } 拓扑排序（Kahn 算法） /** * 拓扑排序：将有向无环图(DAG)转换为线性序列 * 应用：课程安排、任务调度等 * 核心思想：不断移除入度为0的节点 */ List\u0026lt;Integer\u0026gt; topologicalSort(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] inDegree = new int[n]; // 记录每个节点的入度 for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } // 构建图并计算入度 for (int[] edge : edges) { graph.get(edge[0]).add(edge[1]); // edge[0] -\u0026gt; edge[1] inDegree[edge[1]]++; // edge[1] 的入度+1 } // 将所有入度为0的节点入队 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (inDegree[i] == 0) { queue.offer(i); } } List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); while (!queue.isEmpty()) { int node = queue.poll(); res.add(node); // 将节点加入结果 // 删除该节点的所有出边 for (int neighbor : graph.get(node)) { inDegree[neighbor]--; // 邻居的入度-1 if (inDegree[neighbor] == 0) { // 入度变为0，入队 queue.offer(neighbor); } } } // 如果所有节点都被访问，说明无环，返回结果；否则返回空 return res.size() == n ? res : new ArrayList\u0026lt;\u0026gt;(); } Dijkstra 最短路径算法 /** * Dijkstra算法：单源最短路径（不能有负权边） * 时间复杂度：O(E log V)，E是边数，V是顶点数 * 核心思想：贪心，每次选择距离最小的未访问节点 */ int[] dijkstra(int n, int[][] edges, int start) { // 构建邻接表: {neighbor, weight} List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // edge = [from, to, weight] graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); } // dist[i] 表示从 start 到 i 的最短距离 int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 优先队列: {distance, node}，按距离从小到大排序 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); pq.offer(new int[]{0, start}); while (!pq.isEmpty()) { int[] curr = pq.poll(); int d = curr[0], node = curr[1]; // 如果当前距离大于已知最短距离，跳过 if (d \u0026gt; dist[node]) continue; // 遍历所有邻居，尝试松弛操作 for (int[] neighbor : graph.get(node)) { int next = neighbor[0], weight = neighbor[1]; int newDist = d + weight; // 如果找到更短的路径，更新距离 if (newDist \u0026lt; dist[next]) { dist[next] = newDist; pq.offer(new int[]{newDist, next}); } } } return dist; } Bellman-Ford 算法（可处理负权边） /** * Bellman-Ford算法：单源最短路径，可处理负权边 * 时间复杂度：O(V * E) * 可以检测负环 */ int[] bellmanFord(int n, int[][] edges, int start) { int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 松弛操作：最多进行 n-1 次 // 原理：最短路径最多包含 n-1 条边 for (int i = 0; i \u0026lt; n - 1; i++) { for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; // 松弛操作：如果经过 u 到 v 更短，则更新 if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { dist[v] = dist[u] + w; } } } // 第 n 次松弛：如果还能更新，说明存在负环 for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { return null; // 存在负环 } } return dist; } Floyd-Warshall 全源最短路径 /** * Floyd-Warshall算法：计算所有点对之间的最短路径 * 时间复杂度：O(V³) * 核心思想：动态规划，逐步加入中间节点 */ int[][] floydWarshall(int n, int[][] edges) { int[][] dist = new int[n][n]; // 初始化距离矩阵 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(dist[i], Integer.MAX_VALUE / 2); // 除以2防止溢出 dist[i][i] = 0; // 自己到自己距离为0 } // 填入边的权重 for (int[] edge : edges) { dist[edge[0]][edge[1]] = edge[2]; } // 动态规划：k 是中间节点 // dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) for (int k = 0; k \u0026lt; n; k++) { // 枚举中间节点 for (int i = 0; i \u0026lt; n; i++) { // 枚举起点 for (int j = 0; j \u0026lt; n; j++) { // 枚举终点 // 如果经过 k 中转更短，则更新 dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]); } } } return dist; } Prim 最小生成树 /** * Prim算法：构建最小生成树 * 时间复杂度：O(E log V) * 核心思想：从一个节点开始，逐步扩展，每次选最小边 */ int prim(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // 无向图：添加双向边 graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); graph.get(edge[1]).add(new int[]{edge[0], edge[2]}); } boolean[] visited = new boolean[n]; // 优先队列：{node, weight}，按权重从小到大 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[1] - b[1]); pq.offer(new int[]{0, 0}); // 从节点0开始，权重0 int totalWeight = 0; // 最小生成树的总权重 int edgeCount = 0; // 已添加的边数 while (!pq.isEmpty() \u0026amp;\u0026amp; edgeCount \u0026lt; n) { int[] curr = pq.poll(); int node = curr[0], weight = curr[1]; if (visited[node]) continue; // 已访问，跳过 visited[node] = true; totalWeight += weight; // 加入最小生成树 edgeCount++; // 将邻居节点的边加入优先队列 for (int[] neighbor : graph.get(node)) { if (!visited[neighbor[0]]) { pq.offer(neighbor); } } } // 如果所有节点都连通，返回总权重；否则返回-1 return edgeCount == n ? totalWeight : -1; } Kruskal 最小生成树（并查集） /** * 并查集：用于判断连通性和合并集合 */ class UnionFind { int[] parent; // parent[i] 表示 i 的父节点 int[] rank; // rank[i] 表示以 i 为根的树的高度 public UnionFind(int n) { parent = new int[n]; rank = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; // 初始时每个节点的父节点是自己 } } // 查找：找到 x 所在集合的代表元素（路径压缩） public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); // 路径压缩：直接连到根节点 } return parent[x]; } // 合并：将 x 和 y 所在的集合合并（按秩合并） public boolean union(int x, int y) { int rootX = find(x), rootY = find(y); if (rootX == rootY) return false; // 已经在同一集合 // 按秩合并：将矮树挂到高树上 if (rank[rootX] \u0026lt; rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] \u0026gt; rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; // 高度相同，随便挂，高度+1 } return true; } } /** * Kruskal算法：构建最小生成树 * 时间复杂度：O(E log E) * 核心思想：按边权从小到大排序，用并查集避免成环 */ int kruskal(int n, int[][] edges) { // 按边权从小到大排序 Arrays.sort(edges, (a, b) -\u0026gt; a[2] - b[2]); UnionFind uf = new UnionFind(n); int totalWeight = 0; int edgeCount = 0; for (int[] edge : edges) { // 如果两个节点不在同一集合，添加这条边 if (uf.union(edge[0], edge[1])) { totalWeight += edge[2]; edgeCount++; if (edgeCount == n - 1) break; // 最小生成树有 n-1 条边 } } return edgeCount == n - 1 ? totalWeight : -1; } 3. 回溯算法 组合问题 /** * 组合问题：从 n 个数中选 k 个数的所有组合 * 例如：n=4, k=2 -\u0026gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), 1, n, k); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int start, int n, int k) { // 递归终止条件：已选择 k 个数 if (path.size() == k) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 注意：要复制一份 return; } // 从 start 开始枚举，避免重复 for (int i = start; i \u0026lt;= n; i++) { path.add(i); // 做选择 backtrack(res, path, i + 1, n, k); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } 全排列 /** * 全排列问题：给定数组，返回所有可能的排列 * 例如：[1,2,3] -\u0026gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, new boolean[nums.length]); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, boolean[] used) { // 递归终止条件：所有数字都已使用 if (path.size() == nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } // 枚举所有数字 for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) continue; // 已使用过，跳过 path.add(nums[i]); // 做选择 used[i] = true; // 标记已使用 backtrack(res, path, nums, used); // 递归 used[i] = false; // 撤销标记（回溯） path.remove(path.size() - 1); // 撤销选择（回溯） } } 子集问题 /** * 子集问题：返回数组的所有子集（幂集） * 例如：[1,2,3] -\u0026gt; [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, int start) { // 每个状态都是一个子集 res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 枚举后续元素 for (int i = start; i \u0026lt; nums.length; i++) { path.add(nums[i]); // 做选择 backtrack(res, path, nums, i + 1); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } N 皇后问题 /** * N皇后问题：在 n×n 的棋盘上放置 n 个皇后，使它们互不攻击 * 规则：任意两个皇后不能在同一行、同一列、同一对角线 */ List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); char[][] board = new char[n][n]; // 初始化棋盘：\u0026#39;.\u0026#39; 表示空位 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(board[i], \u0026#39;.\u0026#39;); } backtrack(res, board, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res, char[][] board, int row) { // 递归终止条件：所有行都放置完成 if (row == board.length) { res.add(construct(board)); // 将棋盘转换为字符串列表 return; } // 尝试在当前行的每一列放置皇后 for (int col = 0; col \u0026lt; board.length; col++) { if (!isValid(board, row, col)) continue; // 不合法，跳过 board[row][col] = \u0026#39;Q\u0026#39;; // 放置皇后 backtrack(res, board, row + 1); // 递归下一行 board[row][col] = \u0026#39;.\u0026#39;; // 撤销放置（回溯） } } // 检查在 (row, col) 位置放置皇后是否合法 boolean isValid(char[][] board, int row, int col) { int n = board.length; // 检查列：同一列不能有其他皇后 for (int i = 0; i \u0026lt; row; i++) { if (board[i][col] == \u0026#39;Q\u0026#39;) return false; } // 检查左上对角线 for (int i = row - 1, j = col - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } // 检查右上对角线 for (int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } return true; } // 将棋盘转换为字符串列表 List\u0026lt;String\u0026gt; construct(char[][] board) { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for (char[] row : board) { res.add(new String(row)); } return res; } 4. 动态规划 0-1 背包问题 /** * 0-1背包：每个物品只能选一次 * weights[i]: 第i个物品的重量 * values[i]: 第i个物品的价值 * capacity: 背包容量 * 返回：最大价值 */ int knapsack(int[] weights, int[] values, int capacity) { int n = weights.length; // dp[i][w] 表示前 i 个物品，背包容量为 w 时的最大价值 int[][] dp = new int[n + 1][capacity + 1]; for (int i = 1; i \u0026lt;= n; i++) { for (int w = 0; w \u0026lt;= capacity; w++) { // 如果当前物品的重量 \u0026lt;= 背包容量 if (weights[i - 1] \u0026lt;= w) { // 选择：max(不拿, 拿) dp[i][w] = Math.max( dp[i - 1][w], // 不拿第i个物品 dp[i - 1][w - weights[i - 1]] + values[i - 1] // 拿第i个物品 ); } else { // 放不下，只能不拿 dp[i][w] = dp[i - 1][w]; } } } return dp[n][capacity]; } /** * 0-1背包 - 空间优化版本 * 时间复杂度：O(n * capacity) * 空间复杂度：O(capacity) */ int knapsackOptimized(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：必须从后往前遍历，避免重复使用同一物品 for (int w = capacity; w \u0026gt;= weights[i]; w--) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 完全背包问题 /** * 完全背包：每个物品可以选无限次 * 与0-1背包的区别：内层循环从前往后遍历 */ int completeKnapsack(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：从前往后遍历，允许重复使用物品 for (int w = weights[i]; w \u0026lt;= capacity; w++) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 最长公共子序列（LCS） /** * 最长公共子序列：找两个字符串的最长公共子序列长度 * 子序列：不要求连续 * 例如：\u0026#34;abcde\u0026#34; 和 \u0026#34;ace\u0026#34; 的LCS是 \u0026#34;ace\u0026#34;，长度为3 */ int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); // dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的LCS长度 int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (text1.charAt(i - 1) == text2.charAt(j - 1)) { // 字符相同：LCS长度+1 dp[i][j] = dp[i - 1][j - 1] + 1; } else { // 字符不同：取两种情况的最大值 dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; } 最长递增子序列（LIS） /** * 最长递增子序列 - O(n²) 动态规划解法 * dp[i] 表示以 nums[i] 结尾的最长递增子序列长度 */ int lengthOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; Arrays.fill(dp, 1); // 初始每个元素自己构成长度为1的子序列 int maxLen = 1; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { // 如果 nums[i] 可以接在 nums[j] 后面 if (nums[i] \u0026gt; nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } maxLen = Math.max(maxLen, dp[i]); } return maxLen; } /** * 最长递增子序列 - O(n log n) 二分解法 * tails[i] 表示长度为 i+1 的递增子序列的最小尾部元素 */ int lengthOfLISBinary(int[] nums) { List\u0026lt;Integer\u0026gt; tails = new ArrayList\u0026lt;\u0026gt;(); for (int num : nums) { // 二分查找：找到第一个 \u0026gt;= num 的位置 int left = 0, right = tails.size(); while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (tails.get(mid) \u0026lt; num) { left = mid + 1; } else { right = mid; } } // 如果 num 比所有元素都大，追加到末尾 if (left == tails.size()) { tails.add(num); } else { // 否则替换找到的位置 tails.set(left, num); } } return tails.size(); } 编辑距离 /** * 编辑距离：将 word1 转换为 word2 的最少操作次数 * 操作：插入、删除、替换 * 例如：\u0026#34;horse\u0026#34; -\u0026gt; \u0026#34;ros\u0026#34; 需要3步（删除h、删除r、替换s） */ int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); // dp[i][j] 表示 word1[0..i-1] 转换为 word2[0..j-1] 的最少操作数 int[][] dp = new int[m + 1][n + 1]; // 边界条件：一个字符串为空 for (int i = 0; i \u0026lt;= m; i++) dp[i][0] = i; // word1 -\u0026gt; 空串：删除i个字符 for (int j = 0; j \u0026lt;= n; j++) dp[0][j] = j; // 空串 -\u0026gt; word2：插入j个字符 for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { // 字符相同：不需要操作 dp[i][j] = dp[i - 1][j - 1]; } else { // 字符不同：三种操作取最小 dp[i][j] = Math.min( Math.min( dp[i - 1][j], // 删除 word1[i-1] dp[i][j - 1] // 插入 word2[j-1] ), dp[i - 1][j - 1] // 替换 word1[i-1] 为 word2[j-1] ) + 1; } } } return dp[m][n]; } 股票买卖问题 只能买卖一次\n/** * 买卖股票的最佳时机 I：只能买卖一次 * 贪心思想：记录最低价格，计算每天卖出的最大利润 */ int maxProfit(int[] prices) { int minPrice = Integer.MAX_VALUE; // 记录目前为止的最低价格 int maxProfit = 0; // 记录最大利润 for (int price : prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; } 可以买卖多次\n/** * 买卖股票的最佳时机 II：可以买卖多次 * 贪心思想：只要今天价格比昨天高，就在昨天买今天卖 */ int maxProfitMultiple(int[] prices) { int profit = 0; for (int i = 1; i \u0026lt; prices.length; i++) { // 如果今天价格更高，累加差价 if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } 最多买卖 k 次\n/** * 买卖股票的最佳时机 III/IV：最多买卖 k 次 * dp[i][j] 表示第 i 次交易后，第 j 天的最大利润 */ int maxProfitK(int k, int[] prices) { if (prices.length == 0) return 0; int n = prices.length; // 如果 k \u0026gt;= n/2，相当于无限次交易 if (k \u0026gt;= n / 2) { int profit = 0; for (int i = 1; i \u0026lt; n; i++) { if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } int[][] dp = new int[k + 1][n]; for (int i = 1; i \u0026lt;= k; i++) { int maxDiff = -prices[0]; // 第 i-1 次交易后买入的最大收益 for (int j = 1; j \u0026lt; n; j++) { // 不操作 vs 卖出 dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff); // 更新买入的最大收益 maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]); } } return dp[k][n - 1]; } 打家劫舍 /** * 打家劫舍 I：线性排列的房屋 * 不能抢相邻的房屋 * dp[i] = max(dp[i-1], dp[i-2] + nums[i]) */ int rob(int[] nums) { if (nums.length == 0) return 0; if (nums.length == 1) return nums[0]; int prev2 = 0, prev1 = 0; // prev2: dp[i-2], prev1: dp[i-1] for (int num : nums) { int temp = prev1; // 不抢 vs 抢 prev1 = Math.max(prev1, prev2 + num); prev2 = temp; } return prev1; } /** * 打家劫舍 II：环形排列的房屋 * 第一个和最后一个房屋相邻 * 思路：分两种情况，取最大值 * 1. 抢第一个房屋，不抢最后一个 * 2. 不抢第一个房屋，抢最后一个 */ int robCircular(int[] nums) { if (nums.length == 1) return nums[0]; return Math.max( robRange(nums, 0, nums.length - 2), robRange(nums, 1, nums.length - 1) ); } int robRange(int[] nums, int start, int end) { int prev2 = 0, prev1 = 0; for (int i = start; i \u0026lt;= end; i++) { int temp = prev1; prev1 = Math.max(prev1, prev2 + nums[i]); prev2 = temp; } return prev1; } 分割等和子集 /** * 分割等和子集：判断是否能将数组分成两个和相等的子集 * 本质：0-1背包问题，目标是找到和为 sum/2 的子集 */ boolean canPartition(int[] nums) { int sum = 0; for (int num : nums) sum += num; if (sum % 2 != 0) return false; // 和为奇数，不可能分割 int target = sum / 2; // dp[j] 表示能否凑出和为 j boolean[] dp = new boolean[target + 1]; dp[0] = true; // 和为0总是可以（不选任何数） for (int num : nums) { // 从后往前遍历，避免重复使用 for (int j = target; j \u0026gt;= num; j--) { dp[j] = dp[j] || dp[j - num]; // 不选 num 或 选 num } } return dp[target]; } 零钱兑换 /** * 零钱兑换 I：最少硬币数 * dp[i] 表示凑出金额 i 所需的最少硬币数 */ int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); // 初始化为不可能的大值 dp[0] = 0; // 凑出0元需要0个硬币 for (int i = 1; i \u0026lt;= amount; i++) { for (int coin : coins) { if (i \u0026gt;= coin) { // 选择使用当前硬币 dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } } return dp[amount] \u0026gt; amount ? -1 : dp[amount]; } /** * 零钱兑换 II：组成方案数 * dp[i] 表示凑出金额 i 的方案数 */ int change(int amount, int[] coins) { int[] dp = new int[amount + 1]; dp[0] = 1; // 凑出0元有1种方案（不选） // 外层遍历硬币，内层遍历金额（避免重复计数） for (int coin : coins) { for (int i = coin; i \u0026lt;= amount; i++) { dp[i] += dp[i - coin]; } } return dp[amount]; } 5. 双指针 对撞指针 // 两数之和（有序数组） int[] twoSum(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[left] + nums[right]; if (sum == target) { return new int[]{left, right}; } else if (sum \u0026lt; target) { left++; } else { right--; } } return new int[]{-1, -1}; } // 三数之和 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length - 2; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { res.add(Arrays.asList(nums[i], nums[left], nums[right])); while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; left++; right--; } else if (sum \u0026lt; 0) { left++; } else { right--; } } } return res; } 快慢指针 // 链表中点 ListNode findMiddle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } // 环形链表 boolean hasCycle(ListNode head) { if (head == null) return false; ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) return true; } return false; } // 找环的入口 ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { slow = head; while (slow != fast) { slow = slow.next; fast = fast.next; } return slow; } } return null; } 6. 单调栈 // 下一个更大元素 int[] nextGreaterElement(int[] nums) { int n = nums.length; int[] res = new int[n]; Arrays.fill(res, -1); Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; nums[stack.peek()] \u0026lt; nums[i]) { int idx = stack.pop(); res[idx] = nums[i]; } stack.push(i); } return res; } // 每日温度 int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] res = new int[n]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[stack.peek()] \u0026lt; temperatures[i]) { int idx = stack.pop(); res[idx] = i - idx; } stack.push(i); } return res; } // 柱状图中最大的矩形 int largestRectangleArea(int[] heights) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(-1); int maxArea = 0; for (int i = 0; i \u0026lt; heights.length; i++) { while (stack.peek() != -1 \u0026amp;\u0026amp; heights[stack.peek()] \u0026gt;= heights[i]) { int h = heights[stack.pop()]; int w = i - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } stack.push(i); } while (stack.peek() != -1) { int h = heights[stack.pop()]; int w = heights.length - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } return maxArea; } 7. 前缀和 // 一维前缀和 class PrefixSum { private int[] preSum; public PrefixSum(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 0; i \u0026lt; nums.length; i++) { preSum[i + 1] = preSum[i] + nums[i]; } } // 查询区间 [left, right] 的和 public int query(int left, int right) { return preSum[right + 1] - preSum[left]; } } // 二维前缀和 class MatrixPrefixSum { private int[][] preSum; public MatrixPrefixSum(int[][] matrix) { int m = matrix.length, n = matrix[0].length; preSum = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } // 查询子矩阵 [row1, col1] 到 [row2, col2] 的和 public int query(int row1, int col1, int row2, int col2) { return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]; } } 📌 总结 这份文档涵盖了：\nJava 集合框架：List、Set、Map、Queue、Stack 的完整使用方法 树算法：DFS、BFS、线段树 图算法：遍历、最短路径、最小生成树 经典算法：回溯、动态规划、二分查找、滑动窗口、双指针、单调栈、前缀和 建议配合 LeetCode 刷题使用，遇到问题时可以快速查阅对应的模板代码。\n持续更新中\u0026hellip; 🚀\n","permalink":"http://localhost:1313/posts/algorithm-with-java/","summary":"详细介绍java集合的使用,以及在刷算法题中需要使用到的一些板子","title":"算法刷题必备：Java集合与算法模板"},{"content":"一、Hugo 常用指令 1.1 创建新站点 # 创建一个新的 Hugo 站点 hugo new site mysite # 进入站点目录 cd mysite 1.2 创建新文章 # 在 content/posts 目录下创建新文章 hugo new posts/my-first-post.md # 在 content 目录下创建文章 hugo new about.md # 创建在特定子目录 hugo new blog/2024/new-post.md 1.3 本地预览 # 启动本地开发服务器（默认 http://localhost:1313） hugo server # 启动并显示草稿文章 hugo server -D # 启动并显示草稿、未来日期和过期的文章 hugo server -DEF # 指定端口 hugo server --port 8080 # 实时重载并打开浏览器 hugo server -D --navigateToChanged 1.4 主题管理 # 添加主题（使用 Git submodule） git submodule add https://github.com/username/theme-name.git themes/theme-name # 更新主题 git submodule update --remote --merge # 删除主题 git submodule deinit -f themes/theme-name rm -rf .git/modules/themes/theme-name git rm -f themes/theme-name 1.5 其他常用指令 # 查看 Hugo 版本 hugo version # 查看帮助 hugo help # 查看配置信息 hugo config # 列出所有内容 hugo list all # 列出草稿 hugo list drafts 二、Markdown Front Matter 配置 2.1 完整配置示例 --- # 基本信息 title: \u0026#34;我的第一篇文章\u0026#34; date: 2025-12-06T15:04:05+08:00 lastmod: 2025-12-07T10:00:00+08:00 draft: false # 作者信息 author: \u0026#34;Minjie\u0026#34; authorLink: \u0026#34;https://github.com/Minjie2003\u0026#34; # 分类和标签 categories: [\u0026#34;技术\u0026#34;] tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;, \u0026#34;博客\u0026#34;] series: [\u0026#34;Hugo教程\u0026#34;] # 摘要和描述 summary: \u0026#34;这是一篇关于 Hugo 和 Markdown 的完整指南\u0026#34; description: \u0026#34;详细介绍 Hugo 的使用方法和 Markdown 配置\u0026#34; # 特色图片 image: \u0026#34;/images/featured.jpg\u0026#34; cover: image: \u0026#34;/images/cover.jpg\u0026#34; alt: \u0026#34;封面图片描述\u0026#34; caption: \u0026#34;图片说明文字\u0026#34; # SEO 相关 keywords: [\u0026#34;Hugo\u0026#34;, \u0026#34;静态博客\u0026#34;, \u0026#34;Markdown\u0026#34;] slug: \u0026#34;hugo-markdown-guide\u0026#34; url: \u0026#34;/posts/hugo-guide/\u0026#34; # 显示控制 toc: true # 显示目录 comments: true # 允许评论 showToc: true # 显示目录 TocOpen: false # 默认展开目录 hidemeta: false # 隐藏元信息 disableShare: false # 禁用分享按钮 hideSummary: false # 隐藏摘要 ShowReadingTime: true # 显示阅读时间 ShowBreadCrumbs: true # 显示面包屑导航 ShowPostNavLinks: true # 显示文章导航链接 # 权重（用于排序） weight: 1 # 外部链接 externalLink: \u0026#34;https://example.com\u0026#34; # 是否在首页显示 showhome: true --- 2.2 常用字段说明 字段 说明 示例 title 文章标题 \u0026quot;我的文章\u0026quot; date 发布日期 2025-12-06 或 2025-12-06T15:04:05+08:00 draft 是否为草稿 true / false tags 标签（数组） [\u0026quot;Hugo\u0026quot;, \u0026quot;博客\u0026quot;] categories 分类（数组） [\u0026quot;技术\u0026quot;, \u0026quot;教程\u0026quot;] summary 文章摘要 \u0026quot;这是摘要\u0026quot; description SEO 描述 \u0026quot;页面描述\u0026quot; slug URL 友好名称 \u0026quot;my-post\u0026quot; url 自定义完整 URL \u0026quot;/posts/my-post/\u0026quot; weight 排序权重 1 (数字越小越靠前) toc 是否显示目录 true / false 三、Hugo Shortcodes（短代码） 3.1 内置 Shortcodes # 显示图片 {{\u0026lt; figure src=\u0026#34;/images/photo.jpg\u0026#34; title=\u0026#34;图片标题\u0026#34; \u0026gt;}} # 高亮文本 {{\u0026lt; highlight python \u0026gt;}} def hello(): print(\u0026#34;Hello!\u0026#34;) {{\u0026lt; /highlight \u0026gt;}} # YouTube 视频 {{\u0026lt; youtube VIDEO_ID \u0026gt;}} # X (Twitter) 推文（新版） {{\u0026lt; x user=\u0026#34;USERNAME\u0026#34; id=\u0026#34;TWEET_ID\u0026#34; \u0026gt;}} # GitHub Gist（已废弃，建议直接嵌入代码） # 可以使用 highlight 或直接用代码块替代 # 参数传递（需要在 Front Matter 中定义参数） {{\u0026lt; param \u0026#34;description\u0026#34; \u0026gt;}} 3.2 自定义 Shortcode 示例 在 layouts/shortcodes/note.html 创建：\n\u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; 使用时：\n{{\u0026lt; note \u0026gt;}} 这是一个提示框 {{\u0026lt; /note \u0026gt;}} 四、Markdown 基本语法 4.1 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 4.2 文本样式 **粗体文字** *斜体文字* ***粗斜体*** ~~删除线~~ `行内代码` 4.3 列表 # 无序列表 - 项目 1 - 项目 2 - 子项目 2.1 - 子项目 2.2 # 有序列表 1. 第一项 2. 第二项 1. 子项 2.1 2. 子项 2.2 4.4 链接和图片 # 链接 [链接文字](https://example.com) [带标题的链接](https://example.com \u0026#34;鼠标悬停显示\u0026#34;) # 图片 ![图片描述](/images/photo.jpg) ![图片](https://example.com/image.jpg \u0026#34;图片标题\u0026#34;) 4.5 引用 \u0026gt; 这是一段引用文字 \u0026gt; 可以多行 \u0026gt;\u0026gt; 嵌套引用 4.6 代码块 ```python def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) ``` ```javascript console.log(\u0026#34;Hello, World!\u0026#34;); ``` 4.7 表格 | 列1 | 列2 | 列3 | |-----|-----|-----| | 数据1 | 数据2 | 数据3 | | 数据4 | 数据5 | 数据6 | # 对齐方式 | 左对齐 | 居中 | 右对齐 | |:-------|:----:|-------:| | 内容 | 内容 | 内容 | 4.8 分隔线 --- *** ___ 4.9 任务列表 - [x] 已完成的任务 - [ ] 未完成的任务 - [ ] 另一个任务 五、实用技巧 5.1 文章模板 在 archetypes/default.md 创建默认模板：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true tags: [] categories: [] summary: \u0026#34;\u0026#34; --- ## 简介 内容开始... 5.2 多语言配置 在 Front Matter 中：\n--- title: \u0026#34;English Title\u0026#34; title.zh: \u0026#34;中文标题\u0026#34; --- 5.3 自定义 URL 结构 在 hugo.toml 中：\n[permalinks] posts = \u0026#34;/:year/:month/:slug/\u0026#34; 5.4 草稿快速发布 # 将草稿改为发布状态 sed -i \u0026#39;s/draft: true/draft: false/\u0026#39; content/posts/my-post.md ","permalink":"http://localhost:1313/posts/hugo-readme/","summary":"详细介绍 Hugo 常用指令、Markdown Front Matter 配置、基本语法和实用技巧的完整指南","title":"Hugo 常用指令与 Markdown 配置指南"},{"content":"👋 嗨，我是 Minjie 很高兴你能来到这里！这是我在互联网上的一个小角落，用来记录代码、想法和生活的点滴。\n🧑‍💻 关于我 我是一名在读研究生，研究方向包括区块链，web3.0，数据库管理等。当然，目前更加专注于 Java 后端开发。相比起\u0026quot;全栈工程师\u0026quot;这样的标签，我更喜欢把自己定义为一个对计算机技术充满好奇心的探索者。\n📖 这个博客写什么 这里主要记录我在技术道路上的成长轨迹，你可能会看到：\n技术笔记 - Java 后端开发的实践经验、框架使用心得、踩过的坑和解决方案\n项目复盘 - 从需求分析到上线部署，记录项目中的思考和收获\n学习记录 - 新技术的探索、算法题的思路、计算机基础知识的整理\n随笔杂谈 - 偶尔也会写写读书笔记、游戏感想，或者对技术趋势的一些思考\n我希望这里不仅是我个人的知识库,也能给同样在技术路上摸索的你带来一些启发或共鸣。\n🎯 技术栈 \u0026amp; 兴趣方向 后端开发：Java、Spring Boot、MyBatis、MySQL、Redis - 这是我的主战场\n折腾爱好：除了后端，我还喜欢写点爬虫玩玩，做些自动化小工具来解决日常遇到的重复性工作。总觉得能用代码解决的事情，就不该浪费时间手动操作。有时候为了实现一个自动化脚本，花的时间可能比手动做还多，但那种\u0026quot;一劳永逸\u0026quot;的快感真的很上头。\n探索中：对各种能提高效率的技术和工具都充满兴趣，正在不断拓展技术边界\u0026hellip;\n🎮 代码之外 游戏时光：Steam 上收藏了不少游戏，也会玩玩王者、原神这些。\n音乐陪伴：写代码的时候总要听点什么。古典音乐能让思路更清晰，ACG 音乐带来满满的回忆，偶尔也会跟着流行音乐哼哼唱唱。喜欢洗澡的时候k歌······当然，也是个半吊子吉他选手\n运动爱好：除了敲键盘，也喜欢出去动一动。篮球、羽毛球、乒乓球都有涉猎，虽然都不算精通，但也能过上两招。过去打篮球多一点，现在更想尝试羽毛球。\n历史爱好者：对历史有种莫名的着迷，喜欢看历史书籍、纪录片。主要包括近现代欧洲历史，唐史，春秋战国。\n💬 来聊聊？ 如果你也对后端开发感兴趣，或者想交流技术、分享项目经验，甚至只是想推荐个好玩的游戏或好听的歌，都欢迎联系我：\n📧 邮箱：zhongnagisa01@gmail.com 🐙 GitHub：Minjie2003 \u0026ldquo;流水不争先，争的是滔滔不绝\u0026rdquo;\n感谢你的访问，希望我们能在这里有更多交流！✨\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于我"},{"content":"论文基本信息 标题: Enhancing trust and privacy in distributed networks: a comprehensive survey on blockchain-based federated learning\n作者: Ji Liu, Chunlu Chen, Yu Li, Lin Sun, Yulun Song, Jingbo Zhou, Bo Jing, Dejing Dou\n发表: Knowledge and Information Systems (2024) 66:4377–4403\n机构: 恒生电子、九州大学、百度、联通数科、波士顿咨询\n一、研究背景 1.1 区块链技术概述 论文首先介绍了区块链的基本概念和特性：\n核心特性：\n去中心化架构：将验证系统从中心化转变为去中心化，通过多个用户的共识来促进验证过程 不可篡改性：通过哈希函数将数据块链接成链，任何篡改尝试都会破坏哈希链，导致不匹配 加密安全：使用哈希函数、数字签名和加密技术保护数据完整性和安全性 透明性：区块链上记录的每笔交易对所有网络参与者透明可见 智能合约：自动执行的协议，按预定义规则执行交易，无需中介 区块链类型：\n类型 访问方式 典型代表 常用共识 无许可链 匿名访问，任何人可加入 Bitcoin, Ethereum PoW, PoS 有许可链 需要注册，限制访问 Hyperledger Fabric Kafka, Raft, PBFT 分布式系统特性：\n去中心化：控制和决策分布在各个节点 共识机制：确保所有节点对系统状态达成一致 容错性：通过冗余、复制和错误处理机制实现 可扩展性：通过增加节点水平扩展 1.2 联邦学习基础 FL基本流程：\n中央服务器初始化模型参数并分发给所有客户端 客户端使用本地数据训练模型 客户端上传训练后的模型参数到中央服务器 中央服务器聚合参数，更新全局模型 重复以上步骤直到模型收敛 FL分类：\n按网络拓扑：\n中心化FL 去中心化FL 按数据可用性：\n跨孤岛FL (Cross-silo) 跨设备FL (Cross-device) 按数据分区：\n横向FL：特征空间相同，样本不同 纵向FL：样本相同，特征空间不同 联邦迁移学习：样本和特征都不同 常见优化算法：FedAvg, FedProx, SCAFFOLD, FedPD, FedBN\n1.3 FL面临的主要挑战 论文总结了FL的三大核心挑战：\n挑战1：数据异构性 三种异构：\n特征异构：参与设备拥有不同的特征集，使模型聚合和对齐变得困难 数据分布异构：由于用户群体、地理位置、数据收集实践的差异，导致数据分布不同，可能引入偏见 数据格式异构：来自不同来源或平台的数据可能具有不同的格式、表示或结构 解决技术：\n模型架构调整和特征工程 元学习和域适应 多格式设计的模型 挑战2：隐私与安全 主要威胁：\n数据泄露：共享模型可能包含训练数据的敏感信息 成员推理攻击：对手试图确定特定数据点是否属于训练数据集 模型投毒攻击：对手注入恶意数据或操纵本地更新以毒化共享模型 防御技术：\n差分隐私(DP)：向数据或模型更新添加噪声以模糊个体贡献 同态加密(HE)：允许对加密数据进行计算 安全多方计算(SMPC)：多方在不暴露私有数据的情况下联合计算 可信执行环境(TEE)：如TrustFL方案 挑战3：可追溯性与问责性 可追溯性需求：\n模型审计：通过记录元数据（模型架构、超参数、数据源）跟踪和审计FL中训练的模型 数据溯源：追踪训练数据的来源和历史，确保真实性并评估潜在偏见 问责性需求：\n参与者问责：参与者应遵守商定的协议、隐私措施和安全实践 安全与信任维护：实施适当的安全措施，保护数据机密性，防止未授权访问或恶意活动 面临的困难：\nFL的去中心化结构使协调和建立共识变得复杂 在保护隐私的同时确保可追溯性需要平衡 数据分散在不同参与者之间，追踪数据来源和血统面临挑战 1.4 整合区块链与FL的必要性 论文论述了结合区块链和FL的三大核心价值：\n价值1：激励机制 传统FL中，许多客户端由于经济理性不愿分享有价值的数据 区块链原生的加密货币或代币系统可建立激励机制 通过奖励数据贡献者、模型验证者和其他参与者，激励积极参与、数据共享和模型改进 价值2：增强数据隐私与安全 解决中心化风险：传统FL严重依赖单一中央服务器，如果服务器恶意行为，整个系统可能崩溃 防御客户端攻击：现有设计容易受到恶意客户端的攻击，可能上传有毒模型攻击FL网络 区块链优势： 去中心化和不可变的特性提供安全透明的数据共享和存储框架 加密方法显著增强数据隐私和安全 参与者可以验证共享模型的完整性和真实性，而不暴露敏感信息 价值3：信任与透明 区块链固有的透明性和可审计性可以解决FL中的信任问题 使参与者能够追踪数据、模型和计算的历史和来源 透明性在参与者之间培养信任，因为他们可以验证FL过程的公平性和可靠性 二、BCFL系统架构 2.1 整体架构概览 论文提出从底向上的五层架构（加上贯穿的区块链共识层）：\n┌─────────────────────────────────────────────┐ │ 应用层 (Application Layer) │ │ 医疗 | 车联网 | 边缘计算 | 能源 | 资源分配 │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 区块链共识层 (Blockchain Consensus) │ │ PoW | PoS | DPoS | PBFT | PoQ | PoF | Raft │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 算法层 (Algorithm Layer) │ │ 聚合算法 | 安全算法 | 优化算法 | 激励算法 │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 通信层 (Communication Layer) │ │ 加密技术 | 网络协议 | 同步机制 | P2P框架 │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 网络层 (Network Layer) │ │ 中心化 | 多中心化 | 去中心化 (P2P) │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 基础设施层 (Infrastructure Layer) │ │ L1/L2架构 | 存储资源 | 计算资源(CPU/GPU/TPU)│ └─────────────────────────────────────────────┘ 2.2 架构分类：三种耦合方式 论文根据操作动态将BCFL系统分为三种架构：\n完全耦合 (Fully Coupled) 定义：客户端同时作为训练节点和区块链节点\n特点：\n提供去中心化 要求高设备性能 适用场景：参与者设备能力强的环境\n灵活耦合 (Flexibly Coupled) 定义：分离区块链和FL操作以减轻网络通信负担\n实现方式：\n委员会选择：选择部分节点参与共识 智能合约：通过智能合约实现分离 特点：平衡了去中心化和效率\n松散耦合 (Loosely Coupled) 定义：优先考虑声誉来衡量参与者可靠性\n关注点：\n主要关注模型更新验证 在账本上进行声誉管理 特点：轻量级，适合大规模异构设备\n三、六层架构详解 3.1 基础设施层 L1与L2架构 L1层架构：\nFL直接集成到区块链 提供去中心化的P2P框架 对等方自由加入 由共识机制支持系统可靠性 L2层架构：\nFL构建在区块链节点之上 强调分层数据处理和模型训练 存储方案 去中心化存储：\n采用去中心化存储模型 通过高级加密方法确保隐私： 安全多方计算(SMPC) 同态加密 优势：\n促进安全、私密的数据共享和模型聚合 区块链的可审计性提高透明度和信任 计算资源 本地计算：\n本地满足计算需求 利用CPU、GPU、TPU 异构性处理：\n通过轻量级架构处理设备异构性 模型压缩技术 联邦蒸馏(Federated Distillation) 优化性能和资源分配 3.2 网络层 论文将区块链网络结构分为三类：\n中心化网络 特点：\n所有通信和交易通过中央节点路由 常见于有许可区块链系统 优势：\n简化效率 由于单一控制点，共识更快 劣势：\n显著的安全风险 中央节点成为攻击的主要目标 可能损害整个网络的完整性和隐私 多中心化网络（联邦区块链） 特点：\n引入多个中央节点而非单一节点 通常用于平衡多个组织或方之间的控制 优势：\n增强协作 维持一定程度的中心化治理 改善安全性，减少单点故障风险 劣势：\n仍可能面临可扩展性限制 中心化控制问题 去中心化网络 特点：\n以无许可区块链为代表（如Bitcoin、Ethereum） 在广泛的节点阵列中分布数据验证和交易处理 P2P网络结构 无单点控制或故障 每个节点以平等地位运行 优势：\n最高级别的安全性和数据完整性 显著增强对审查、篡改和攻击的抵抗力 劣势：\n可能在可扩展性方面面临挑战 由于决策过程的分布式性质，共识速度可能较慢 论文总结：网络设置的选择深刻影响BCFL系统的性能和安全性\n3.3 通信层 核心任务 通信层在BCFL系统中扮演关键角色，负责：\n编排参与者之间的数据传输和消息交换 促进协作学习过程 高效、安全地传输模型更新、聚合结果和协调指令 关键技术 加密技术：\n在传输前加密数据 防止未授权访问 确保维护数据隐私 网络协议：\n采用可靠高效的网络协议管理消息传递 确保数据包可靠有序地到达目的地 即使在网络中断或拥塞情况下 同步机制：\n在BCFL系统的分布式特性下，同步机制至关重要 协调参与者之间的通信 确保及时共享模型更新 管理数据传输的异步性质 对齐来自不同参与者的更新 去中心化通信框架：\n采用去中心化框架（如P2P网络或区块链） 促进参与者之间的直接通信 消除中心化中介的需要 增强系统的韧性和去中心化 减少潜在瓶颈和故障点 案例 - BLADE-FL：\n论文提到的完全去中心化框架 将训练和挖矿的责任都分配给全节点 增强去中心化和系统韧性 面临的挑战 延迟和有限带宽：\n通过数据压缩技术解决 最小化数据传输的大小 提高交换速度 优化策略：\n自适应网络路由 拥塞控制算法 优化数据流 减少延迟 提高通信效率 批处理和缓存：\n降低数据传输的频率和数量 减轻网络约束的影响 3.4 算法层 论文将算法层分为四个关键方面：\n1. 聚合算法 经典算法：\nFedAvg：\n参与者上传本地模型权重到区块链网络 通过智能合约计算权重平均值获得全局模型 进阶算法：\nFedProx：处理异构性 SCAFFOLD：减少方差 FedPD：原对偶优化 FedBN：批归一化层处理 异步FL系统：\n解决中心化模型带来的安全挑战 实现隐私、容错和可靠的数据共享 基于有许可区块链的FL异步聚合协议 通过将学习模型集成到区块链并执行二阶聚合计算 有效缓解同步FL算法的问题 2. 安全算法 论文详细介绍了三种核心隐私保护技术：\n安全多方计算(SMPC)：\n定义：保护数据隐私的计算模型，允许多方在不披露私有数据的情况下进行计算\n特点：\n各方持有部分私有数据 可以对加密数据执行计算以维护隐私 各方通过协议进行通信和交互 共同计算最终结果而无需直接暴露私有数据 技术组成：\n同态加密 秘密共享(Secret Sharing) 零知识证明(Zero-Knowledge Proof) 安全多方计算协议 同态加密(HE)：\n定义：满足密文同态运算性质的加密算法\n核心特性：\n数据经过同态加密后 对密文执行特定计算 密文计算结果经相应同态解密后 等价于对明文数据直接执行相同计算 实现数据的\u0026quot;可计算但不可见\u0026quot;状态 优势：\n可以在密文上进行计算而无需密钥 减少通信成本 平衡各方的计算成本 差分隐私(DP)：\n定义：通过添加扰动噪声保护底层用户隐私信息的技术\n原理：\n确保即使攻击者掌握除一条信息外的所有其他信息 仍无法推断该条信息 方法：\n向结果添加符合特定分布的噪声 随机化查询结果 挑战：需要解决数据可用性问题（由于需要在查询结果中加入随机性，可能导致数据可用性下降）\n3. 优化算法 目标：\n优化FL性能 减少训练轮次 降低通信开销 提高模型准确性 常用方法：\n梯度压缩：减少通信开销 梯度剪枝：减少通信开销 异步更新：减少训练轮次 本地更新：减少训练轮次 4. 激励算法 论文强调：虽然FL在保护数据隐私的同时实现协作学习展现了巨大优势，但仍面临如何激励人们通过贡献计算能力和数据加入FL的开放挑战。\n基于声誉的FL：\n核心思想：通过设计安全机制衡量参与者的可靠性\n代表性工作：\n区块链声誉系统\n增加贡献正确有用模型参数的客户端的声誉值 降低上传恶意参数的客户端的声誉值 影响后续训练轮次的客户端选择 RepBFL框架\n结合区块链和FL应用于车联网(IoV) 利用区块链确保共享数据保护 选择高声誉节点进行FL 评估IoV中车辆的可靠性 基于模型质量参数的评估\n使用模型质量参数进行声誉评估 区块链衡量工作者可靠性并维护声誉值 CFFL协作公平框架\n引入基于经验个体模型性能的声誉机制 调节参与者奖励以保持通信轮次间的公平性 多权重主观逻辑模型\n将声誉作为量化移动设备可靠性和可信度的指标 采用多权重主观逻辑模型进行声誉计算 联盟区块链技术以去中心化方式保护声誉存储 基于支付的FL：\nFedCoin\n采用Shapley值(SVs)进行可行的基于SV的利润分配 公平反映对全局FL模型的贡献 区块链共识实体部署Shapley权益证明协议(PoSap) 用于计算SVs和创建新区块 公共区块链上的FL协议\n解决监控工作者行为和保证协议遵守的挑战 将竞争嵌入BCFL 仅奖励贡献有价值的工作者 自然抑制偏离协议的行为 移动群体FL系统\n通过根据个人贡献提供奖励来激励移动设备训练准确模型 Stackelberg博弈建模服务器和设备间的交互 比较基于规模和基于准确性的两种奖励策略 跨孤岛横向FL的贡献评估\n解决透明评估不同数据所有者贡献的挑战 使用可调精度量化数据所有者基于SV的贡献 保护隐私 DeepChain：\n特点：\n客户端联合参与训练深度学习模型的协作框架 保证数据机密性和计算可验证性 为参与者提供激励 激励机制：\n围绕超时检查和货币惩罚编排 促进参与者之间的公平性 在参与者未能满足截止日期或不准确执行函数的情况下采取惩罚措施 施加货币惩罚，没收不诚实参与者的预存资金 在诚实参与者之间重新分配 机制设计综述：\n论文引用的综述工作：\n基于关键技术对现有激励机制进行分类 包括：Stackelberg博弈、拍卖、合约理论、Shapley值、强化学习、区块链 Refiner系统：\n部署在Ethereum公共区块链平台 运行激励机制，根据训练数据量和本地更新性能奖励参与者 处理大规模协作中的恶意参与者 部署随机选择的验证者委员会 验证者惩罚不道德参与者，拒绝奖励并从全局模型中消除腐败更新 3.5 区块链共识层 论文强调：在FL系统实现的背景下，共识涉及参与者同步模型并集体做出决策所采用的协议。共识算法确保所有参与者对模型更新的有效性达成一致，并防止恶意行为者篡改系统。\n共识机制的重要性 共识机制的作用：\n在极短时间内完成交易验证和确认 通过特殊节点的投票完成 如果利益不同的节点能对交易达成共识，则可以认为整个网络也能达成共识 主要共识机制 1. Proof of Work (PoW)\n特点：\nBitcoin使用PoW工作量证明机制 Ethereum曾使用PoW和PoS混合共识机制 相当于解决一个随时间变难的数学难题 挑战：\n计算消耗大量能源 可能间接影响碳排放和环境 应用案例：\nBCFL系统：引入分布式哈希表用于高效区块生成，采用PoW共识机制确保全局模型一致性 LearningChain：去中心化联邦系统，利用基于PoW共识的拜占庭容错聚合算法（l-nearest aggregation），通过竞争选择领导者，使用l-nearest算法聚合梯度 Swarm Learning (SL)：去中心化机器学习方法，结合边缘计算和基于区块链的P2P网络，数据和参数保留在边缘，消除中央协调者的需求 2. Proof of Stake (PoS)\n特点：\n被视为PoW的环保替代方案 验证者基于持有和愿意\u0026quot;质押\u0026quot;作为抵押品的加密货币数量被选择创建新区块 3. Delegated Proof of Stake (DPoS)\n特点：\n利益相关者选举一定数量的代表来验证交易和创建区块 设计为比传统PoS更民主和高效 4. Proof of Training Quality (PoQ)\n背景：现有共识机制（如PoW）消耗大量计算和通信资源，或对数据共享的额外贡献有限\n解决方案：\n论文提到提出了结合FL与差分隐私的共识机制PoQ 将数据模型训练与共识过程集成 用模型参数准确性的认证替代PoW中寻找随机数的无意义计算工作 5. Byzantine Fault Tolerance (BFT)\n目标：抵御\u0026quot;拜占庭\u0026quot;故障（组件可能失败且对组件是否失败的信息不完善）\n变体：\nPBFT (Practical Byzantine Fault Tolerance)：用于Hyperledger Fabric FBA (Federated Byzantine Agreement)：用于Stellar 6. Proof of Federation (PoF)\nBiscotti系统：\n将PoF与一致性哈希和可验证随机函数(VRF)结合 为对等节点选择关键角色，协助协调模型更新的隐私和安全 通过Multi-Krum防御防止对等点毒化模型 采用差分化私有噪声提供隐私 利用Shamir秘密共享进行安全聚合 挑战：当所有节点参与共识时，计算负载过大\n7. RAFT\n特点：\n在一组节点中选举领导者 领导者负责提出和验证区块 专注于简单性和容错性 设计为比其他共识算法更易理解和实现 应用：一些有许可区块链网络\n8. Proof of Federated Training (PoFT)\n特点：\n实现跨多个区块链网络的可验证模型训练的框架 解决PoW中的功耗/资源浪费问题 解决区块链中的数据隐私问题 扩展 - PoFL：\n联邦学习证明 应用于车辆网络 车辆通过遵守区块链网络内的FL共识证明竞争成为矿工 IPFS和PoFL用于确保连接自动驾驶车辆的去中心化联邦学习安全 9. 委员会共识\nBFLC框架：\n基于区块链的委员会共识FL框架 利用区块链进行全局模型存储和本地模型更新交换 消除中心化服务器需求 引入创新的委员会共识机制减少计算负载并缓解恶意攻击 论文总结：\n所有这些共识算法都有其优势和劣势 适合不同的用例 选择正确的共识机制对区块链网络的安全性、可扩展性和效率至关重要 共识算法的选择受期望的去中心化程度、安全性、可扩展性以及区块链网络的特定需求等因素影响 3.6 应用层 论文探讨了FL在不同领域的应用，这些领域可以提供基于该技术的服务。\n车联网 (Internet of Vehicles) 应用背景：\n车辆日益成为数据生成源 GPS位置、速度、道路状况等数据可以为更好的交通管理、路线规划和事故预防做出贡献 但这些数据也是敏感的 BCFL的价值：\n能够聚合来自多辆车辆的数据来训练模型，而无需共享原始数据 区块链还可以用于维护网络中车辆交互和交易的防篡改记录 相关研究：论文引用了多篇关于BCFL在车联网应用的研究工作\n资源分配 应用价值：\n在大型分布式系统中，有效的资源分配对于最大化效率至关重要 通过在区块链网络之上应用FL，可以根据从网络使用模式中学习的知识动态分配资源 将区块链与FL集成不仅加强隐私和可靠性，还为高效的资源分配和利用提供平台 边缘计算 应用潜力：\nBCFL在边缘计算应用方面具有巨大潜力 为数据共享、资源协作和共享、模型更新和升级以及抗干扰和容错提供安全机制 实现方式：\n通过利用边缘设备的计算资源和数据 使智能应用能够高效安全地执行推理和决策任务 解决的挑战：\n数据隐私 资源约束 边缘计算中常见的不稳定环境 应用现状：\n已在移动电话场景中进行了广泛研究和应用 预计将为更多边缘计算场景的发展和扩展提供解决方案 医疗健康 应用价值：\n患者数据敏感但对检测疾病和改善治疗极有价值 BCFL允许医疗机构协作并从大量患者数据中学习，而不损害患者隐私 区块链优势：\n可以提供数据和计算的可追溯性 增加对学习模型的信任 相关应用：\n疾病检测 治疗改进 电子健康记录系统的安全性、隐私和互操作性 能源 应用场景：\n智能电网：\n优化电网运营 促进微电网间的P2P能源交易和共享 工业物联网(IIoT)：\n解决无线网络中与信用数据共享相关的安全和隐私问题 可再生能源：\n应用于风能涡轮机的叶片结冰检测 风能是快速增长的可再生能源部门 四、关键框架案例 论文介绍了多个具有代表性的BCFL框架：\nBML-ES 基于区块链的工业物联网(IIoT)边缘服务机器学习框架 利用智能合约实现聚合策略 采用SM2公钥密码系统保护隐私并提高模型准确性 TrustFed 将区块链集成到跨设备FL系统中 防止模型投毒 确保公平训练 维护参与者声誉 使用智能合约管理声誉并排除恶意行为者 确保可靠的训练环境 基于状态通道的信任监督机制 使用区块链和FL为分布式数据共享创建可信环境 采用状态通道为FL任务建立安全沙箱 确保整个过程的完整性和监督 Proof of Federated Training (PoFT) 实现跨区块链网络可验证模型训练的框架 增强协作训练过程中的透明度和信任 去中心化模型训练和梯度聚合 提出基于区块链的安全模型训练架构 引入旨在提高模型准确性、隐私和性能的梯度聚合方法 Blockchain-in-the-loop FL 将传统FL与Hyperledger Fabric合并 结合游戏化以增强参与度和效率 Swarm Learning 去中心化机器学习方法 结合边缘计算和基于区块链的P2P网络 数据和参数保留在边缘 消除中央协调者的需求 发表在Nature上，应用于COVID-19等疾病的去中心化临床机器学习 五、挑战与未来研究方向 论文在结尾部分识别了BCFL面临的主要挑战并提出未来研究方向：\n5.1 数据安全与隐私保护 挑战：\n在FL与区块链结合的环境中，确保数据安全和隐私成为首要关注点 在网络环境中有效管理敏感信息（如医疗记录或个人身份）是一项挑战 需要深入探索在不暴露其真实内容的情况下处理此类数据的密码技术 研究方向：\n未来研究应深入研究针对这个集成系统定制的新密码解决方案 5.2 模型效率与性能优化 挑战：\n分布式数据和模型的高效计算是FL的基本要求 该领域的核心挑战涉及： 设计降低计算复杂度的算法 最小化通信开销 提高模型训练和推理的效率 研究方向：\n未来研究工作应集中于微调分布式优化方法 整合先进的压缩策略以减轻通信负担 探索硬件增强以提高计算效率 调查混合模型，合并中心化和去中心化训练方法，也具有相当大的前景 5.3 可扩展性 问题描述：\n随着区块链和FL融合以创建安全、私密的数据管理框架 可扩展性成为一个关键瓶颈 特别是当系统规模扩大和需求增加时 解决方案： 论文提出的前瞻性方法：\n链下计算 (Off-chain Calculations)：卸载密集任务，减少主区块链负载 侧链 (Sidechains)：单独管理交易以减少拥塞 Layer-2技术： 状态通道(State Channels) Plasma 在现有区块链之上促进快速交易，同时保持安全性 目标：\n这些方法利用区块链和FL的核心原则 旨在培育可扩展、安全和去中心化的学习生态系统 六、论文贡献总结 论文明确指出其核心贡献：\n分类法提出\n从三个方面呈现BCFL的分类： 去中心化架构 分离网络 基于声誉的架构 通用架构总结\n总结了BCFL系统的通用架构 提供了基于区块链的FL架构的全面视角 包括六个关键层： 基础设施层 网络层 通信层 算法层 区块链共识层 应用层 应用分析\n分析了BCFL在以下领域的应用： 医疗健康 物联网 其他隐私敏感领域 未来方向识别\n识别了BCFL的未来研究方向 综合视角\n本研究旨在提供BCFL系统的全面视角 为BCFL系统领域的未来研究提供基础 七、个人理解 说明：以下是我基于论文内容的理解和思考，并非论文原文\n论文的核心价值 这篇综述的主要价值在于：\n系统性整合：将分散的BCFL研究整合到统一框架中 架构清晰：六层架构为理解BCFL系统提供了清晰的分析框架 全面覆盖：从底层基础设施到上层应用都有涉及 论文的特点 优势：\n文献综述全面，引用了大量相关工作 分类清晰，便于理解不同方法的特点 对各种技术（共识机制、激励机制、隐私保护）都有介绍 可能的不足：\n对各种方案的性能对比分析较少 部分技术介绍较为概念化，实现细节不足 缺少对不同方案适用场景的明确指导 对未来研究的启示 BCFL是一个跨学科领域，需要区块链、机器学习、密码学等多方面知识 不同应用场景可能需要不同的架构选择（完全耦合 vs 灵活耦合 vs 松散耦合） 隐私保护、效率、去中心化程度之间的权衡是核心问题 实际应用还需要考虑工程实现、成本、监管合规等问题 引用 @article{liu2024enhancing, title={Enhancing trust and privacy in distributed networks: a comprehensive survey on blockchain-based federated learning}, author={Liu, Ji and Chen, Chunlu and Li, Yu and Sun, Lin and Song, Yulun and Zhou, Jingbo and Jing, Bo and Dou, Dejing}, journal={Knowledge and Information Systems}, volume={66}, pages={4377--4403}, year={2024}, publisher={Springer} } ","permalink":"http://localhost:1313/posts/blockchain-federated-learning-survey/","summary":"本文系统性地综述了区块链联邦学习（BCFL）技术，从架构分类、基础设施层、网络层、通信层、算法层到共识机制进行了深入分析，并探讨了其在医疗、物联网车辆、边缘计算等领域的应用，为构建安全、隐私保护的分布式学习系统提供了理论框架","title":"区块链联邦学习综述：增强分布式网络中的信任与隐私"},{"content":"第一题：线性回归梯度下降 题目： 对线性模型 $h_\\theta(x) = \\theta^\\top x$，给定训练集 $\\{(x^{(i)}, y^{(i)})\\}$，推导其向量形式的最小二乘损失梯度下降更新公式为：\n$$\\theta := \\theta + \\alpha \\sum_{i=1}^{n} (y^{(i)} - h_\\theta(x^{(i)})) x^{(i)}$$解：\n最小二乘损失函数为：\n$$J(\\theta) = \\frac{1}{2}\\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)})^2 = \\frac{1}{2}\\sum_{i=1}^{n}(\\theta^\\top x^{(i)} - y^{(i)})^2$$对 $\\theta$ 求梯度：\n$$\\begin{aligned} \\nabla_\\theta J(\\theta) \u0026= \\sum_{i=1}^{n}(\\theta^\\top x^{(i)} - y^{(i)}) \\cdot x^{(i)} \\\\ \u0026= \\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} \\end{aligned}$$梯度下降更新规则为 $\\theta := \\theta - \\alpha \\nabla_\\theta J(\\theta)$，因此：\n$$\\theta := \\theta - \\alpha \\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} = \\theta + \\alpha \\sum_{i=1}^{n}(y^{(i)} - h_\\theta(x^{(i)})) x^{(i)}$$ 第二题：交叉熵损失梯度 题目： Cross Entropy Loss 定义如下：\n$$l_{ce}((t_1,\\ldots,t_k),y) = -\\log\\left(\\frac{\\exp(t_y)}{\\sum_j \\exp(t_j)}\\right)$$令向量 $t = (t_1,t_2,\\ldots,t_k)$，推导 CEL 对任意 $t_i$ 求导为：\n$$\\frac{\\partial l_{ce}(t,y)}{\\partial t_i} = \\phi_i - \\mathbb{1}\\{y=i\\}$$解：\n记 $\\phi_i = \\frac{\\exp(t_i)}{\\sum_j \\exp(t_j)}$ 为 softmax 函数。\n首先简化损失函数：\n$$l_{ce}(t,y) = -\\log(\\phi_y) = -t_y + \\log\\left(\\sum_j \\exp(t_j)\\right)$$对 $t_i$ 求导：\n$$\\begin{aligned} \\frac{\\partial l_{ce}(t,y)}{\\partial t_i} \u0026= -\\frac{\\partial t_y}{\\partial t_i} + \\frac{\\partial}{\\partial t_i}\\log\\left(\\sum_j \\exp(t_j)\\right) \\\\ \u0026= -\\mathbb{1}\\{y=i\\} + \\frac{\\exp(t_i)}{\\sum_j \\exp(t_j)} \\\\ \u0026= \\phi_i - \\mathbb{1}\\{y=i\\} \\end{aligned}$$其中 $\\mathbb{1}\\{y=i\\}$ 是指示函数，当 $y=i$ 时为1，否则为0。\n第三题：高斯假设下的最大似然估计 题目： 证明在高斯差异假定下，对线性模型 $h_\\theta(x) = \\theta^\\top x$，最大化参数似然 $L(\\theta)$ 等价于最小化二乘损失 $\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2$。\n解：\n假设误差 $\\epsilon^{(i)} = y^{(i)} - \\theta^\\top x^{(i)}$ 服从独立同分布的高斯分布 $\\mathcal{N}(0, \\sigma^2)$，即：\n$$p(\\epsilon^{(i)}) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(\\epsilon^{(i)})^2}{2\\sigma^2}\\right)$$因此：\n$$p(y^{(i)} | x^{(i)}; \\theta) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right)$$似然函数为：\n$$\\begin{aligned} L(\\theta) \u0026= \\prod_{i=1}^{n} p(y^{(i)} | x^{(i)}; \\theta) \\\\ \u0026= \\prod_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right) \\end{aligned}$$对数似然为：\n$$\\begin{aligned} \\log L(\\theta) \u0026= \\sum_{i=1}^{n}\\left[\\log\\frac{1}{\\sqrt{2\\pi}\\sigma} - \\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right] \\\\ \u0026= n\\log\\frac{1}{\\sqrt{2\\pi}\\sigma} - \\frac{1}{2\\sigma^2}\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2 \\end{aligned}$$最大化 $\\log L(\\theta)$ 等价于最小化 $\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2$。\n第四题：Logistic回归的NLL损失 题目： 对Logistic回归模型 $h_\\theta(x) = g(\\theta^\\top x) = \\frac{1}{1+e^{-\\theta^\\top x}}$，推导其在单样本 $(x,y)$ 下的NLL（negative log likelihood）损失，以及损失对特定参数 $\\theta_j$ 的导数为 $(h_\\theta(x) - y)x_j$。\n提示：Logistic回归预测概率的统一形式为 $P(y|x;\\theta) = (h_\\theta(x))^y(1-h_\\theta(x))^{1-y}$\n解：\n根据提示，Logistic回归的概率模型为：\n$$P(y|x;\\theta) = (h_\\theta(x))^y(1-h_\\theta(x))^{1-y}$$其中 $y \\in \\{0,1\\}$，$h_\\theta(x) = g(\\theta^\\top x) = \\frac{1}{1+e^{-\\theta^\\top x}}$。\n对数似然为：\n$$\\log P(y|x;\\theta) = y\\log(h_\\theta(x)) + (1-y)\\log(1-h_\\theta(x))$$NLL损失为：\n$$\\text{NLL}(x,y;\\theta) = -\\log P(y|x;\\theta) = -y\\log(h_\\theta(x)) - (1-y)\\log(1-h_\\theta(x))$$对 $\\theta_j$ 求导。首先注意到：\n$$\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j} = h_\\theta(x)(1-h_\\theta(x)) \\cdot x_j$$这是因为 $g'(z) = g(z)(1-g(z))$。\n因此：\n$$\\begin{aligned} \\frac{\\partial \\text{NLL}}{\\partial \\theta_j} \u0026= -y\\frac{1}{h_\\theta(x)}\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j} - (1-y)\\frac{1}{1-h_\\theta(x)}\\left(-\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j}\\right) \\\\ \u0026= -y\\frac{1}{h_\\theta(x)} \\cdot h_\\theta(x)(1-h_\\theta(x))x_j + (1-y)\\frac{1}{1-h_\\theta(x)} \\cdot h_\\theta(x)(1-h_\\theta(x))x_j \\\\ \u0026= -y(1-h_\\theta(x))x_j + (1-y)h_\\theta(x)x_j \\\\ \u0026= (h_\\theta(x) - y)x_j \\end{aligned}$$ 第五题：Poisson分布的指数族形式 题目： 已知指数分布族定义如下：$p(y;\\eta) = b(y)\\exp(\\eta^\\top y - a(\\eta))$。推导Poisson分布的指数分布族形式，并构建Poisson分布对应的广义线性模型。其中，Poisson分布 $\\text{Pois}(\\lambda)$ 的概率密度函数如下：\n$$P(X=k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}$$解：\n将Poisson分布改写为指数族形式：\n$$\\begin{aligned} P(X=k) \u0026= \\frac{\\lambda^k e^{-\\lambda}}{k!} \\\\ \u0026= \\frac{1}{k!}\\exp(k\\log\\lambda - \\lambda) \\\\ \u0026= \\frac{1}{k!}\\exp(\\eta \\cdot k - e^\\eta) \\end{aligned}$$其中 $\\eta = \\log\\lambda$（自然参数），因此 $\\lambda = e^\\eta$。\n对应指数族形式：\n$b(y) = \\frac{1}{y!}$ $\\eta = \\log\\lambda$ $a(\\eta) = e^\\eta = \\lambda$ $y$ 的充分统计量就是 $y$ 本身 构建广义线性模型：\n假设 $y|x;\\theta \\sim \\text{Pois}(\\lambda)$ 自然参数 $\\eta = \\theta^\\top x$ 因为 $\\lambda = e^\\eta$，所以 $\\lambda = e^{\\theta^\\top x}$ 响应函数（期望）为：$h_\\theta(x) = \\mathbb{E}[y|x;\\theta] = \\lambda = e^{\\theta^\\top x}$ 这就是Poisson回归模型。\n第六题：Shapley值计算 题目： 计算以下3人团队的Shapley值 $\\phi_1$、$\\phi_2$、$\\phi_3$。\n给定：\n$C_{123} = 10000$，$C_0 = 0$ $C_{12} = 7500$，$C_{13} = 7500$，$C_{23} = 5000$ $C_1 = 5000$，$C_2 = 5000$，$C_3 = 0$ 解：\nShapley值的公式为：\n$$\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(|N|-|S|-1)!}{|N|!}[C(S \\cup \\{i\\}) - C(S)]$$对于3人团队，$|N| = 3$，计算每个玩家的边际贡献：\n玩家1的Shapley值：\n$$\\begin{aligned} \\phi_1 \u0026= \\frac{0!2!}{3!}[C_1 - C_0] + \\frac{1!1!}{3!}[C_{12} - C_2] + \\frac{1!1!}{3!}[C_{13} - C_3] + \\frac{2!0!}{3!}[C_{123} - C_{23}] \\\\ \u0026= \\frac{1}{3}[5000 - 0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[7500 - 0] + \\frac{1}{3}[10000 - 5000] \\\\ \u0026= \\frac{5000}{3} + \\frac{2500}{6} + \\frac{7500}{6} + \\frac{5000}{3} \\\\ \u0026= \\frac{10000}{3} + \\frac{10000}{6} = \\frac{20000 + 10000}{6} = 5000 \\end{aligned}$$玩家2的Shapley值：\n$$\\begin{aligned} \\phi_2 \u0026= \\frac{0!2!}{3!}[C_2 - C_0] + \\frac{1!1!}{3!}[C_{12} - C_1] + \\frac{1!1!}{3!}[C_{23} - C_3] + \\frac{2!0!}{3!}[C_{123} - C_{13}] \\\\ \u0026= \\frac{1}{3}[5000 - 0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[5000 - 0] + \\frac{1}{3}[10000 - 7500] \\\\ \u0026= \\frac{5000}{3} + \\frac{2500}{6} + \\frac{5000}{6} + \\frac{2500}{3} \\\\ \u0026= \\frac{15000 + 2500 + 5000 + 5000}{6} = \\frac{27500}{6} \\approx 4583.33 \\end{aligned}$$玩家3的Shapley值：\n由对称性或直接计算：\n$$\\phi_3 = 10000 - \\phi_1 - \\phi_2 = 10000 - 5000 - 4583.33 = 416.67$$或直接计算：\n$$\\begin{aligned} \\phi_3 \u0026= \\frac{1}{3}[0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[5000 - 5000] + \\frac{1}{3}[10000 - 7500] \\\\ \u0026= 0 + \\frac{2500}{6} + 0 + \\frac{2500}{3} = \\frac{5000}{6} \\approx 416.67 \\end{aligned}$$答案： $\\phi_1 = 5000$，$\\phi_2 \\approx 4583.33$，$\\phi_3 \\approx 416.67$\n第七题：协方差矩阵性质 题目： 基于协方差矩阵定义 $\\Sigma = \\text{Cov}(X)$ 证明：\n$\\Sigma$ 为对称矩阵； $\\Sigma$ 半正定，记 $\\Sigma \\geq 0$，即对任意向量 $z \\in \\mathbb{R}^d$ 有 $z^\\top \\Sigma z \\geq 0$。 解：\n设 $X \\in \\mathbb{R}^d$ 为随机向量，$\\mu = \\mathbb{E}[X]$，则：\n$$\\Sigma = \\text{Cov}(X) = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top]$$(1) 证明 $\\Sigma$ 为对称矩阵：\n$$\\Sigma^\\top = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top]^\\top = \\mathbb{E}[((X-\\mu)(X-\\mu)^\\top)^\\top] = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top] = \\Sigma$$因此 $\\Sigma$ 是对称矩阵。\n(2) 证明 $\\Sigma$ 半正定：\n对任意 $z \\in \\mathbb{R}^d$：\n$$\\begin{aligned} z^\\top \\Sigma z \u0026= z^\\top \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top] z \\\\ \u0026= \\mathbb{E}[z^\\top(X-\\mu)(X-\\mu)^\\top z] \\\\ \u0026= \\mathbb{E}[(z^\\top(X-\\mu))^2] \\\\ \u0026\\geq 0 \\end{aligned}$$最后一步是因为期望中的项是平方项，必然非负。因此 $\\Sigma$ 半正定。\n第八题：高斯判别分析的MLE 题目： 对高斯判别分析，已知各变量概率分布为：\n$$\\begin{aligned} p(y) \u0026= \\phi^y(1-\\phi)^{1-y} \\\\ p(x|y=0) \u0026= \\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}\\exp\\left(-\\frac{1}{2}(x-\\mu_0)^\\top\\Sigma^{-1}(x-\\mu_0)\\right) \\\\ p(x|y=1) \u0026= \\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}\\exp\\left(-\\frac{1}{2}(x-\\mu_1)^\\top\\Sigma^{-1}(x-\\mu_1)\\right) \\end{aligned}$$证明在极大似然估计下，参数 $\\phi$、$\\mu_0$、$\\mu_1$ 的形式为：\n$$\\begin{aligned} \\phi \u0026= \\frac{1}{n}\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\} \\\\ \\mu_0 \u0026= \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}} \\\\ \\mu_1 \u0026= \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}} \\end{aligned}$$解：\n对数似然函数为：\n$$\\log L = \\sum_{i=1}^{n}\\left[\\log p(y^{(i)}) + \\log p(x^{(i)}|y^{(i)})\\right]$$估计 $\\phi$：\n$$\\log L_\\phi = \\sum_{i=1}^{n}\\log p(y^{(i)}) = \\sum_{i=1}^{n}[y^{(i)}\\log\\phi + (1-y^{(i)})\\log(1-\\phi)]$$令 $\\frac{\\partial \\log L_\\phi}{\\partial \\phi} = 0$：\n$$\\sum_{i=1}^{n}\\left[\\frac{y^{(i)}}{\\phi} - \\frac{1-y^{(i)}}{1-\\phi}\\right] = 0$$解得：\n$$\\phi = \\frac{1}{n}\\sum_{i=1}^{n}y^{(i)} = \\frac{1}{n}\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}$$估计 $\\mu_0$：\n只考虑 $y=0$ 的样本：\n$$\\log L_{\\mu_0} = \\sum_{i:y^{(i)}=0}\\left[-\\frac{1}{2}(x^{(i)}-\\mu_0)^\\top\\Sigma^{-1}(x^{(i)}-\\mu_0) + \\text{const}\\right]$$令 $\\frac{\\partial \\log L_{\\mu_0}}{\\partial \\mu_0} = 0$：\n$$\\sum_{i:y^{(i)}=0}\\Sigma^{-1}(x^{(i)}-\\mu_0) = 0$$解得：\n$$\\mu_0 = \\frac{\\sum_{i:y^{(i)}=0}x^{(i)}}{\\sum_{i:y^{(i)}=0}1} = \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}}$$同理可得 $\\mu_1$ 的估计。\n第九题：GDA可转化为Logistic回归 题目： 证明GDA可转化为Logistic回归。提示：\n$p(y=1|x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=1)p(y=1) + p(x|y=0)p(y=0)}$ 可记 $r(x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)}$ 给出 $p(x|y=0)$, $p(x|y=1)$, $p(y=1)$ 的表达式 解：\n根据贝叶斯定理：\n$$p(y=1|x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=1)p(y=1) + p(x|y=0)p(y=0)} = \\frac{1}{1 + \\frac{p(x|y=0)p(y=0)}{p(x|y=1)p(y=1)}} = \\frac{1}{1 + \\frac{1}{r(x)}}$$其中：\n$$r(x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)}$$计算 $\\log r(x)$：\n$$\\begin{aligned} \\log r(x) \u0026= \\log p(x|y=1) + \\log p(y=1) - \\log p(x|y=0) - \\log p(y=0) \\\\ \u0026= -\\frac{1}{2}(x-\\mu_1)^\\top\\Sigma^{-1}(x-\\mu_1) + \\frac{1}{2}(x-\\mu_0)^\\top\\Sigma^{-1}(x-\\mu_0) + \\log\\frac{\\phi}{1-\\phi} \\end{aligned}$$展开：\n$$\\begin{aligned} \\log r(x) \u0026= -\\frac{1}{2}x^\\top\\Sigma^{-1}x + x^\\top\\Sigma^{-1}\\mu_1 - \\frac{1}{2}\\mu_1^\\top\\Sigma^{-1}\\mu_1 \\\\ \u0026\\quad + \\frac{1}{2}x^\\top\\Sigma^{-1}x - x^\\top\\Sigma^{-1}\\mu_0 + \\frac{1}{2}\\mu_0^\\top\\Sigma^{-1}\\mu_0 + \\log\\frac{\\phi}{1-\\phi} \\\\ \u0026= x^\\top\\Sigma^{-1}(\\mu_1 - \\mu_0) + \\frac{1}{2}(\\mu_0^\\top\\Sigma^{-1}\\mu_0 - \\mu_1^\\top\\Sigma^{-1}\\mu_1) + \\log\\frac{\\phi}{1-\\phi} \\\\ \u0026= \\theta^\\top x + \\theta_0 \\end{aligned}$$其中：\n$$\\theta = \\Sigma^{-1}(\\mu_1 - \\mu_0), \\quad \\theta_0 = \\frac{1}{2}(\\mu_0^\\top\\Sigma^{-1}\\mu_0 - \\mu_1^\\top\\Sigma^{-1}\\mu_1) + \\log\\frac{\\phi}{1-\\phi}$$因此：\n$$p(y=1|x) = \\frac{1}{1+e^{-\\theta^\\top x - \\theta_0}} = \\frac{1}{1+e^{-\\tilde{\\theta}^\\top \\tilde{x}}}$$这正是Logistic回归的形式（其中 $\\tilde{x}$ 包含截距项）。\n第十题：Kernel Method分析 题目： Kernel method中，若Kernel function $K(x,z) = (x^\\top z + c)^2$，推导对应的feature mapping $\\phi$，并讨论对于 $n$ 个样本一轮SGD，使用Kernel method和在feature map上的计算效率优化比。\n提示：\n基于feature map的参数更新方法为：$\\theta := \\theta + \\alpha\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top\\phi(x^{(i)}))\\phi(x^{(i)})$ Kernel method的参数更新方法为：$\\theta := \\theta + \\alpha(\\tilde{y} - K\\theta)$，其中 $K_j = K(x^{(i)}, x^{(j)})$ 解：\n推导feature mapping：\n对于 $x,z \\in \\mathbb{R}^d$，展开核函数：\n$$\\begin{aligned} K(x,z) \u0026= (x^\\top z + c)^2 \\\\ \u0026= (x_1z_1 + x_2z_2 + \\cdots + x_dz_d + c)^2 \\\\ \u0026= \\sum_{i=1}^{d}x_i^2z_i^2 + \\sum_{i \\neq j}2x_ix_jz_iz_j + 2c\\sum_{i=1}^{d}x_iz_i + c^2 \\end{aligned}$$因此，feature mapping为：\n$$\\phi(x) = (x_1^2, x_2^2, \\ldots, x_d^2, \\sqrt{2}x_1x_2, \\sqrt{2}x_1x_3, \\ldots, \\sqrt{2}x_{d-1}x_d, \\sqrt{2c}x_1, \\ldots, \\sqrt{2c}x_d, c)$$维度为：$d + \\binom{d}{2} + d + 1 = d + \\frac{d(d-1)}{2} + d + 1 = \\frac{d(d+3)}{2} + 1 = O(d^2)$\n计算效率比较：\nFeature map方法： 计算 $\\phi(x^{(i)})$：$O(d^2)$ 每个样本 内积 $\\theta^\\top\\phi(x^{(i)})$：$O(d^2)$ 更新 $\\theta$：$O(d^2)$ 总计：$O(nd^2)$ 每轮SGD Kernel method： 计算核矩阵 $K$：$O(n^2d)$（一次性预计算） 更新参数：$O(n^2)$（矩阵向量乘法） 总计：$O(n^2d + n^2) = O(n^2d)$ 每轮 效率比：\n$$\\frac{\\text{Feature map}}{\\text{Kernel method}} = \\frac{O(nd^2)}{O(n^2d)} = \\frac{d}{n}$$ 当 $n \\ll d$ 时（样本少，特征多），Kernel method更高效 当 $n \\gg d$ 时（样本多，特征少），Feature map方法更高效 第十一题：超平面的函数间隔和几何间隔 题目： 对超平面 $w^\\top x + b = 0$，样本 $x^{(i)}$ 到的函数间隔 $\\hat{\\gamma}^{(i)}$ 与几何间隔 $\\gamma^{(i)}$ 满足何关系？直接给出答案即可。\n解：\n函数间隔定义为：\n$$\\hat{\\gamma}^{(i)} = y^{(i)}(w^\\top x^{(i)} + b)$$几何间隔定义为：\n$\\gamma^{(i)} = \\frac{y^{(i)}(w^\\top x^{(i)} + b)}{|w|} = \\frac{\\hat{\\gamma}^{(i)}}{|w|}$\n关系：\n$\\gamma^{(i)} = \\frac{\\hat{\\gamma}^{(i)}}{|w|}$\n几何间隔是函数间隔除以权重向量的范数，表示点到超平面的真实距离。\n第十二题：SVM的Lagrange函数和对偶形式 题目： 已知SVM的优化目标为：\n$$ \\min_{w,b} \\quad \\frac{1}{2}\\|w\\|^2 \\qquad (1) $$$$ \\text{s.t.} \\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1, \\quad i=1,\\ldots,n $$请构造其Lagrange函数 $\\mathcal{L}(w,b,\\alpha)$。\n已知 $\\mathcal{L}(w,b,\\alpha)$ 满足Slater条件，因此强对偶成立，问题(1)最终可转化为 $\\max_{\\alpha;\\alpha_i\\geq 0}\\min_w \\mathcal{L}(w,b,\\alpha)$，证明该对偶形式问题可进一步转化为：\n$$ \\max_\\alpha W(\\alpha) = \\max_\\alpha \\left(\\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle\\right) \\qquad (2) $$约束条件：\n$$ \\alpha_i \\geq 0, \\quad i=1,\\ldots,n $$$$ \\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0 $$解：\n步骤1：构造Lagrange函数\n$\\mathcal{L}(w,b,\\alpha) = \\frac{1}{2}|w|^2 - \\sum_{i=1}^{n}\\alpha_i[y^{(i)}(w^\\top x^{(i)} + b) - 1]$\n其中 $\\alpha_i \\geq 0$ 为Lagrange乘子。\n步骤2：固定 $\\alpha$，对 $w$ 求导\n$\\frac{\\partial \\mathcal{L}}{\\partial w} = w - \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)} = 0$\n因此：\n$w = \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}$\n步骤3：固定 $\\alpha$，对 $b$ 求导\n$\\frac{\\partial \\mathcal{L}}{\\partial b} = -\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$\n因此：\n$\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$\n步骤4：代入Lagrange函数\n将 $w = \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}$ 代入 $\\mathcal{L}$：\n$\\begin{aligned} \\mathcal{L}(w,b,\\alpha) \u0026= \\frac{1}{2}w^\\top w - \\sum_{i=1}^{n}\\alpha_i y^{(i)} w^\\top x^{(i)} - b\\sum_{i=1}^{n}\\alpha_i y^{(i)} + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\frac{1}{2}\\left(\\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}\\right)^\\top\\left(\\sum_{j=1}^{n}\\alpha_j y^{(j)} x^{(j)}\\right) - \\sum_{i=1}^{n}\\alpha_i y^{(i)} \\left(\\sum_{j=1}^{n}\\alpha_j y^{(j)} x^{(j)}\\right)^\\top x^{(i)} + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle - \\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle \\end{aligned}$\n其中使用了 $\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$，所以 $b$ 项消失。\n因此对偶问题为：\n$\\max_\\alpha W(\\alpha) = \\max_\\alpha \\left(\\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle\\right)$\n约束条件为：\n$\\begin{aligned} \\alpha_i \u0026\\geq 0, \\quad i=1,\\ldots,n \\\\ \\sum_{i=1}^{n}\\alpha_i y^{(i)} \u0026= 0 \\end{aligned}$\n第十三题：线性不可分的SVM与L1正则 题目： 对线性不可分的训练集，SVM对应带L1正则的优化目标是什么？已知对线性可分情况的优化为：\n$$ \\min_{w,b} \\quad \\frac{1}{2}\\|w\\|^2 \\qquad (1) $$ $$ \\text{s.t.} \\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1, \\quad i=1,\\ldots,n $$解：\n对于线性不可分的情况，引入松弛变量 $\\xi_i \\geq 0$，允许某些样本违反间隔约束。\n带L1正则的软间隔SVM优化目标为：\n$\\begin{aligned} \\min_{w,b,\\xi} \u0026\\quad \\frac{1}{2}|w|^2 + C\\sum_{i=1}^{n}\\xi_i \\\\ \\text{s.t.} \u0026\\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1 - \\xi_i, \\quad i=1,\\ldots,n \\\\ \u0026\\quad \\xi_i \\geq 0, \\quad i=1,\\ldots,n \\end{aligned}$\n其中：\n$\\xi_i$ 是松弛变量，表示样本 $i$ 违反间隔的程度 $C \u003e 0$ 是惩罚参数，控制间隔最大化与违反程度之间的权衡 $C\\sum_{i=1}^{n}\\xi_i$ 是L1正则项（对松弛变量的惩罚） 这个目标函数平衡了两个目标：\n最大化间隔（通过最小化 $|w|^2$） 最小化分类错误（通过最小化 $\\sum\\xi_i$） 第十四题：SVM最优化问题分析 题目： 已知SVM的最终优化目标为：\n$W(\\alpha) = \\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle$\n假设此时正在优化 $\\alpha_1$ 与 $\\alpha_2$，并有 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$。请推导此时 $\\alpha_2$ 应当更新的值。\n解：\n简化目标函数：\n在固定其他 $\\alpha_i$ ($i \\geq 3$) 的情况下，目标函数关于 $\\alpha_1, \\alpha_2$ 可写为：\n$W(\\alpha_1, \\alpha_2) = \\alpha_1 + \\alpha_2 + W_0 - \\frac{1}{2}[K_{11}\\alpha_1^2 + K_{22}\\alpha_2^2 + 2K_{12}\\alpha_1\\alpha_2y^{(1)}y^{(2)}] + \\text{线性项}$\n其中 $K_{ij} = \\langle x^{(i)}, x^{(j)}\\rangle$，$W_0$ 是常数项。\n利用约束 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$：\n这个约束来自 $\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$，可以改写为：\n$\\alpha_1 y^{(1)} + \\alpha_2 y^{(2)} = -\\sum_{i=3}^{n}\\alpha_i y^{(i)} = \\zeta \\quad \\text{（常数）}$\n将 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$ 代入目标函数，得到关于 $\\alpha_2$ 的单变量优化问题。\n对 $\\alpha_2$ 求导并令其为0，经过复杂推导（涉及预测误差），得到 $\\alpha_2$ 的无约束最优解：\n$\\alpha_2^{\\text{new, unc}} = \\alpha_2^{\\text{old}} + \\frac{y^{(2)}(E_1 - E_2)}{\\eta}$\n其中：\n$E_i = f(x^{(i)}) - y^{(i)}$ 是预测误差 $\\eta = K_{11} + K_{22} - 2K_{12} = \\|x^{(1)} - x^{(2)}\\|^2$（特征空间距离） 考虑约束 $0 \\leq \\alpha_2 \\leq C$：\n根据约束 $\\alpha_1 y^{(1)} + \\alpha_2 y^{(2)} = \\zeta$：\n若 $y^{(1)} \\neq y^{(2)}$： $L = \\max(0, \\alpha_2^{\\text{old}} - \\alpha_1^{\\text{old}}), \\quad H = \\min(C, C + \\alpha_2^{\\text{old}} - \\alpha_1^{\\text{old}})$ 若 $y^{(1)} = y^{(2)}$： $L = \\max(0, \\alpha_1^{\\text{old}} + \\alpha_2^{\\text{old}} - C), \\quad H = \\min(C, \\alpha_1^{\\text{old}} + \\alpha_2^{\\text{old}})$ 最终更新公式：\n$\\alpha_2^{\\text{new}} = \\begin{cases} H \u0026 \\text{if } \\alpha_2^{\\text{new, unc}} \u003e H \\\\ \\alpha_2^{\\text{new, unc}} \u0026 \\text{if } L \\leq \\alpha_2^{\\text{new, unc}} \\leq H \\\\ L \u0026 \\text{if } \\alpha_2^{\\text{new, unc}} \u003c L \\end{cases}$\n然后通过约束更新 $\\alpha_1$：\n$\\alpha_1^{\\text{new}} = \\alpha_1^{\\text{old}} + y^{(1)}y^{(2)}(\\alpha_2^{\\text{old}} - \\alpha_2^{\\text{new}})$\n第十五题：信息增益比计算 题目： 计算给定数据集中四个特征的信息增益比。可保留log项，统一底数为2。\n解：\n首先计算数据集的熵。类别分布：否=6，是=9，总计15。\n$H(D) = -\\frac{6}{15}\\log_2\\frac{6}{15} - \\frac{9}{15}\\log_2\\frac{9}{15} = -0.4\\log_2(0.4) - 0.6\\log_2(0.6) = 0.971$\n特征1：年龄 青年(5个)：否=3，是=2，$H = 0.971$ 中年(5个)：否=1，是=4，$H = 0.722$ 老年(5个)：否=2，是=3，$H = 0.971$ 条件熵：\n$H(D|\\text{年龄}) = \\frac{5}{15}(0.971) + \\frac{5}{15}(0.722) + \\frac{5}{15}(0.971) = 0.888$\n信息增益：\n$\\text{Gain}(\\text{年龄}) = 0.971 - 0.888 = 0.083$\n特征熵（分裂信息）：\n$H_A(\\text{年龄}) = -3 \\times \\frac{5}{15}\\log_2\\frac{5}{15} = \\log_2 3 = 1.585$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{年龄}) = \\frac{0.083}{1.585} = 0.052 $$特征2：有工作 否(8个)：否=4，是=4，$H = 1.0$ 是(7个)：否=2，是=5，$H = 0.863$ 条件熵：$H(D|\\text{有工作}) = 0.936$\n信息增益：$\\text{Gain}(\\text{有工作}) = 0.035$\n特征熵：$H_A(\\text{有工作}) = 0.997$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{有工作}) = 0.035 $$特征3：有自己的房子 否(9个)：否=3，是=6，$H = 0.918$ 是(6个)：否=3，是=3，$H = 1.0$ 条件熵：$H(D|\\text{有房}) = 0.951$\n信息增益：$\\text{Gain}(\\text{有房}) = 0.020$\n特征熵：$H_A(\\text{有房}) = 0.971$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{有房}) = 0.021 $$特征4：信贷情况 一般(5个)：否=4，是=1，$H = 0.722$ 好(6个)：否=2，是=4，$H = 0.918$ 非常好(4个)：否=0，是=4，$H = 0$ 条件熵：$H(D|\\text{信贷}) = 0.608$\n信息增益：$\\text{Gain}(\\text{信贷}) = 0.363$\n特征熵：$H_A(\\text{信贷}) = 1.557$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{信贷}) = 0.233 $$总结（信息增益比排序） 信贷情况：0.233 ⭐（最佳分裂特征） 年龄：0.052 有工作：0.035 有自己的房子：0.021 应选择\u0026quot;信贷情况\u0026quot;作为根节点的分裂特征。\n第十六题：XGBoost损失函数二阶泰勒展开 题目： 已知XGBoost优化第t棵树时的损失函数为：\n$\\mathcal{L}^{(t)} = \\sum_{i=1}^{n}l(y_i, \\hat{y}*i^{(t-1)} + f_t(x_i)) + \\gamma T + \\frac{1}{2}\\lambda\\sum*{j=1}^{T}w_j^2$\n请推导 $l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i))$ 在 $l(y_i, \\hat{y}_i^{(t-1)})$ 处对于 $f_t(x_i)$ 的二阶泰勒展开。其中，一阶和二阶导数可使用：\n$g_i = \\frac{\\partial l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i}\\Big|*{\\hat{y}_i^{(t-1)}}, \\quad h_i = \\frac{\\partial^2 l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i^2}\\Big|*{\\hat{y}_i^{(t-1)}}$\n在此基础上，推导叶子节点 $j$ 对应的 $w_j^*$ 满足：\n$w_j^* = -\\frac{\\sum_{i \\in \\mathcal{I}*j}g_i}{\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda}$\n其中，$\\mathcal{I}_j = \\{i \\mid q(x_i) = j\\}$ 表示属于叶子节点 $j$ 的样本集合。\n解：\n二阶泰勒展开 在 $\\hat{y}_i^{(t-1)}$ 处对 $l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i))$ 关于 $f_t(x_i)$ 进行二阶泰勒展开：\n$\\begin{aligned} l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i)) \u0026\\approx l(y_i, \\hat{y}_i^{(t-1)}) + \\frac{\\partial l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i}\\Big|*{\\hat{y}_i^{(t-1)}} \\cdot f_t(x_i) \\\\ \u0026\\quad + \\frac{1}{2}\\frac{\\partial^2 l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i^2}\\Big|*{\\hat{y}_i^{(t-1)}} \\cdot f_t(x_i)^2 \\\\ \u0026= l(y_i, \\hat{y}_i^{(t-1)}) + g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2 \\end{aligned}$\n因此损失函数变为：\n$\\mathcal{L}^{(t)} \\approx \\sum_{i=1}^{n}[l(y_i, \\hat{y}*i^{(t-1)}) + g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2] + \\gamma T + \\frac{1}{2}\\lambda\\sum*{j=1}^{T}w_j^2$\n去掉常数项 $\\sum_{i=1}^{n}l(y_i, \\hat{y}_i^{(t-1)})$：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{i=1}^{n}[g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2] + \\gamma T + \\frac{1}{2}\\lambda\\sum_{j=1}^{T}w_j^2$\n推导叶子权重 $w_j^*$ 对于树模型，$f_t(x_i) = w_{q(x_i)}$，其中 $q(x_i)$ 表示样本 $i$ 落在的叶子节点。\n将样本按叶子节点分组：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{j=1}^{T}\\left[\\left(\\sum_{i \\in \\mathcal{I}*j}g_i\\right)w_j + \\frac{1}{2}\\left(\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda\\right)w_j^2\\right] + \\gamma T$\n记 $G_j = \\sum_{i \\in \\mathcal{I}*j}g_i$，$H_j = \\sum*{i \\in \\mathcal{I}_j}h_i$，则：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{j=1}^{T}\\left[G_j w_j + \\frac{1}{2}(H_j + \\lambda)w_j^2\\right] + \\gamma T$\n对 $w_j$ 求导并令其为0：\n$\\frac{\\partial \\tilde{\\mathcal{L}}^{(t)}}{\\partial w_j} = G_j + (H_j + \\lambda)w_j = 0$\n解得：\n$w_j^* = -\\frac{G_j}{H_j + \\lambda} = -\\frac{\\sum_{i \\in \\mathcal{I}*j}g_i}{\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda}$\n这就是叶子节点的最优权重。将其代入损失函数，得到：\n$\\tilde{\\mathcal{L}}^{(t)} = -\\frac{1}{2}\\sum_{j=1}^{T}\\frac{G_j^2}{H_j + \\lambda} + \\gamma T$\n这个公式用于评估树结构的质量，指导分裂决策。\n","permalink":"http://localhost:1313/posts/ml-exercise-set/","summary":"胡老师上的机器学习课程习题集解答汇总","title":"机器学习习题集"},{"content":"前言 四川麻将，又称成都麻将或血战麻将，是中国最流行的麻将玩法之一。与传统麻将相比，四川麻将节奏快、变化多，充满了刺激性和趣味性。本文将带你从零开始，系统学习四川麻将的规则和技巧。\n一、基础规则入门 1.1 牌面组成 四川麻将使用108张牌，包括：\n万子：一万到九万，各4张（36张） 条子：一条到九条，各4张（36张） 筒子：一筒到九筒，各4张（36张） 注意：四川麻将没有东南西北中发白这些字牌和花牌。\n1.2 基本概念 刻子：三张相同的牌（如：三张五万） 顺子：三张连续的同花色牌（如：三四五条） 对子：两张相同的牌（如：两张八筒） 杠：四张相同的牌\n1.3 胡牌基本型 标准胡牌牌型：3n+2 结构（n个刻子或顺子 + 1个对子）\n例如：\n一一一 + 二三四 + 五六七 + 八八八 + 九九（4组3张+1对） 1.4 游戏流程 定庄：掷骰子决定庄家 配牌：每人抓13张牌，庄家多抓一张（14张） 出牌：庄家先出一张牌，其他玩家依次摸牌、出牌 胡牌：谁先凑齐胡牌牌型谁获胜 血战到底：已胡牌的玩家退出，剩余玩家继续游戏，直到3人胡牌或流局 二、四川麻将特色规则 2.1 缺一门 四川麻将的核心规则：必须缺一门才能胡牌\n也就是说，你的手牌中只能有两种花色（万、条、筒三选二）。\n例如：\n✅ 可以胡：万子+条子（缺筒） ✅ 可以胡：万子+筒子（缺条） ❌ 不能胡：万子+条子+筒子（三门齐全） 2.2 杠牌规则 明杠：\n碰牌后，再摸到第四张，可以杠牌 别人打出的牌，自己有三张，可以直接杠 暗杠：\n自己摸到四张相同的牌，可以暗杠 杠牌后：\n摸一张牌 多算一番（底分×2） 杠后可以继续杠或胡牌 2.3 血战到底 这是四川麻将最大的特色：\n第一个人胡牌后不结束游戏 剩余三人继续打，直到有第二、第三个人胡牌 最后没胡的人要赔给所有胡牌的人 第一个胡牌的人可以继续胡（查叫） 2.4 查叫 游戏结束时，如果有人没胡牌：\n如果他已听牌（只差一张就能胡），他只赔给胡牌的人 如果他未听牌（没有听牌），他要加倍赔偿 三、番型与计分 3.1 基础番型 番型 番数 说明 平胡 1番 基础胡牌 自摸 1番 自己摸牌胡 根（杠） 1番 每杠一次+1番 对对胡 2番 全是刻子+对子，没有顺子 清一色 4番 全部是一种花色 龙七对 4番 七个对子 天胡 封顶 庄家起手就胡 地胡 封顶 闲家第一轮胡 3.2 计分方式 基础公式：底分 × 2^(番数)\n例如：\n底分1元，平胡（1番）= 1×2¹ = 2元 底分1元，清一色（4番）= 1×2⁴ = 16元 底分1元，清一色+对对胡（6番）= 1×2⁶ = 64元 封顶：很多地方设置封顶番数（如10番），防止输赢过大\n四、进阶技巧 4.1 定缺策略 游戏开始后，要快速决定缺哪一门：\n判断依据：\n数量最少的门：哪门牌少就缺哪门 孤张多的门：有很多不连续的孤张，这门不好组合 对子情况：如果某门有对子，考虑留下，可能组成刻子 例子：\n手牌：一万 三万 五万 六万 | 二条 七条 | 一筒 二筒 三筒 四筒 八筒 九筒 分析：万子4张分散，条子2张，筒子6张且有顺子潜力 建议：缺条子 4.2 听牌技巧 多面听优于单钓：\n单钓：只有一种牌能胡（如：等一张五万） 两面听：能胡两种牌（如：三四条，等二条或五条） 多面听：能胡多种牌（如：卡张、边张、对子等组合） 例子：\n手牌：一万 二万 | 三万 四万 | 五万 六万 | 七万 八万 | 九万 拆牌选择： - 打九万：听二万和五万（两面） - 打一万：听三万和六万和九万（多面） 建议打一万，听牌面更多 4.3 防守策略 观察舍牌：\n对手打出的牌反映他要什么、不要什么 如果对手大量打某一门，可能在做清一色 如果对手突然不打某种牌，可能在攒那个牌 生张和熟张：\n生张：桌面上没出现过的牌，危险度较高 熟张：已经有人打过的牌，相对安全 听牌信号：\n出牌犹豫 打牌速度突然变化 开始打生张或中张 4.4 做大牌策略 什么时候做大牌：\n起手牌型好（比如某门很多，可以做清一色） 当前领先或持平，可以冒险 对手没有明显听牌迹象 做大牌风险：\n听牌较慢，容易被别人截胡 如果未听牌查叫，要加倍赔偿 建议新手以稳为主，先保证听牌 4.5 心理战术 诱敌出牌：\n故意打出中张，引诱对手出你需要的牌 注意节奏，不要过于明显 藏牌意图：\n不要急于碰牌或杠牌，暴露自己的牌型 暗刻比明刻更有迷惑性 施压策略：\n快速出牌，给对手压力 适当沉默，让对手摸不清你的意图 五、常见错误与避免 5.1 新手常犯错误 忘记缺门：手牌三门齐全还以为能胡 盲目做大牌：不顾牌型强行做清一色，最后未听牌 不会算番：不知道自己多少番，糊里糊涂胡牌 乱碰乱杠：过早暴露牌型，让对手防范 不看舍牌：只顾自己手牌，不观察对手 5.2 进阶常犯错误 过度防守：太在意对手，错失自己的听牌机会 贪大求全：总想胡大牌，反而听牌慢 不会放弃：明知牌型不好还死撑，最后查叫 心态失衡：连续点炮后急躁，决策失误 六、实战案例分析 案例1：定缺选择 起手牌：\n二万 四万 六万 八万 九万 一条 二条 三条 五筒 六筒 七筒 八筒 分析：\n万子：5张但分散，不易组合 条子：3张成顺，很好 筒子：4张有两个顺子潜力 决策：缺万子，保留条筒两门\n案例2：听牌选择 当前牌型：\n二万 三万 四万 | 五万 六万 七万 | 一条 二条 三条 | 五筒 六筒 | 八筒 八筒 选择1：打五筒或六筒，听七筒（单钓） 选择2：打八筒，听四筒或七筒（两面）\n决策：选择2更优，两面听更容易胡牌\n案例3：要不要做清一色 当前牌型（已缺条）：\n一万 二万 三万 四万 五万 六万 | 二筒 五筒 七筒 | 八筒 八筒 分析：\n距离清一色还差3张筒子替换万子 如果做清一色，需要拆掉现有的顺子 当前可以快速听牌（1-2轮） 决策：不做清一色，保证快速听牌，除非后续摸牌特别好\n七、练习建议 7.1 新手阶段 熟悉规则：先玩小局，熟悉缺门、血战等规则 记住番型：至少记住基础番型和分数 多观察：看别人怎么打，学习经验 求稳为主：不要急于做大牌，先学会稳定胡牌 7.2 进阶阶段 提高速度：加快判断和决策速度 学习算牌：记住哪些牌出过，推测剩余牌 心理博弈：学会观察对手，做出针对性策略 复盘总结：每局结束后思考得失 7.3 推荐练习方式 线上平台：在手机或电脑上玩四川麻将游戏，方便练习 观战学习：看高手直播或录像，学习思路 实战练习：找朋友线下对局，积累实战经验 理论学习：阅读麻将书籍或教程，系统提升 八、总结 四川麻将规则简单但策略丰富，从新手到高手需要：\n扎实的基本功：熟练掌握规则和番型 灵活的战术：根据牌型和局势调整策略 敏锐的观察力：读懂对手意图，做出正确判断 稳定的心态：胜不骄败不馁，理性决策 记住：麻将三分靠运气，七分靠技术。多练习、多思考，你一定能成为四川麻将高手！\n祝你好运，胡牌多多！🀄\n","permalink":"http://localhost:1313/posts/sichuan-mahjong-guide/","summary":"四川麻将完全攻略：从基础规则到高阶技巧，涵盖缺一门、血战到底、番型计分、定缺策略、听牌技巧、防守要点和实战案例分析。无论你是零基础| 新手还是想提升的进阶玩家，这篇指南都能帮你系统掌握四川麻将的精髓，快速从入门到精通。","title":"四川麻将指南"},{"content":"Windows PowerShell 常用指令 文件和目录操作 列出目录内容\nGet-ChildItem / ls - 列出当前目录内容 ls -Force - 显示隐藏文件 ls -Recurse - 递归列出所有子目录 ls | Sort-Object Length -Descending - 按文件大小排序 切换目录\nSet-Location \u0026lt;路径\u0026gt; / cd - 切换目录 cd ~ - 返回用户主目录 cd .. - 返回上级目录 cd - - 返回上一个目录 创建文件和目录\nNew-Item -ItemType Directory \u0026lt;名称\u0026gt; / mkdir - 创建目录 New-Item -ItemType File \u0026lt;名称\u0026gt; / ni - 创建文件 复制、移动和删除\nCopy-Item \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; 复制文件\nMove-Item \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; / mv - 移动/重命名文件\nRemove-Item \u0026lt;路径\u0026gt; 删除文件\n查看文件\nGet-Content \u0026lt;文件\u0026gt; / cat - 查看文件内容 Get-Content \u0026lt;文件\u0026gt; -Tail 10 - 查看最后 10 行 Get-Content \u0026lt;文件\u0026gt; -Wait - 实时查看文件更新（类似 tail -f） Test-Path \u0026lt;路径\u0026gt; - 检查路径是否存在 以默认方式打开文件或目录\nstart filename打开当前目录下的指定文件 code filename使用vscode打开 code .使用vscode打开当前目录 文本处理和搜索 Select-String \u0026lt;模式\u0026gt; \u0026lt;文件\u0026gt; - 在文件中搜索文本（类似 grep） Select-String \u0026quot;error\u0026quot; *.log - 在所有 log 文件中搜索 ls -Recurse | Select-String \u0026quot;TODO\u0026quot; - 递归搜索 Out-File \u0026lt;文件\u0026gt; - 输出重定向到文件 Tee-Object \u0026lt;文件\u0026gt; - 同时输出到控制台和文件 系统信息和管理 进程管理\nGet-Process / ps - 查看进程列表 Get-Process | Sort-Object CPU -Descending | Select-Object -First 5 - CPU 占用最高的 5 个进程 Stop-Process -Name \u0026lt;进程名\u0026gt; - 结束进程 服务管理\nGet-Service - 查看服务列表 Get-Service | Where-Object {$_.Status -eq \u0026quot;Running\u0026quot;} - 只显示运行中的服务 Start-Service \u0026lt;服务名\u0026gt; - 启动服务 Stop-Service \u0026lt;服务名\u0026gt; - 停止服务 系统信息\nGet-ComputerInfo - 查看计算机信息 Get-NetIPAddress - 查看网络配置 Get-Disk - 查看磁盘信息 Get-Volume - 查看卷信息 systeminfo - 显示详细系统信息 环境变量 $env:PATH - 查看 PATH 环境变量 $env:变量名 = \u0026quot;值\u0026quot; - 设置临时环境变量 [Environment]::SetEnvironmentVariable(\u0026quot;变量名\u0026quot;, \u0026quot;值\u0026quot;, \u0026quot;User\u0026quot;) - 永久设置 网络操作 Test-Connection \u0026lt;主机\u0026gt; / ping - 测试网络连接 Invoke-WebRequest \u0026lt;URL\u0026gt; / curl - 发送 HTTP 请求 Invoke-WebRequest -Uri \u0026lt;URL\u0026gt; -OutFile \u0026lt;文件\u0026gt; - 下载文件 Get-NetTCPConnection - 查看 TCP 连接 ipconfig - 查看 IP 配置 ipconfig /flushdns - 刷新 DNS 缓存 实用命令 Clear-Host / cls - 清屏 Get-History / history - 查看命令历史 Get-Help \u0026lt;命令\u0026gt; - 获取帮助 Get-Help \u0026lt;命令\u0026gt; -Examples - 查看使用示例 Get-Command - 列出所有可用命令 Get-Command *process* - 搜索包含 process 的命令 Get-Alias - 查看所有别名 Measure-Object - 统计对象 Start-Process \u0026lt;程序\u0026gt; - 启动程序 Get-Location / pwd - 显示当前路径 Linux Terminal 常用指令 文件和目录操作 列出目录\nls - 列出目录内容 ls -l - 长格式显示（详细信息） ls -a - 显示隐藏文件 ls -lh - 人性化显示文件大小 ls -lt - 按修改时间排序 ls -lS - 按文件大小排序 ls -R - 递归列出所有子目录 切换目录\ncd \u0026lt;路径\u0026gt; - 切换目录 cd / cd ~ - 返回主目录 cd .. - 返回上级目录 cd - - 返回上一个目录 pwd - 显示当前完整路径 创建\nmkdir \u0026lt;目录名\u0026gt; - 创建目录 mkdir -p a/b/c - 递归创建多级目录 touch \u0026lt;文件名\u0026gt; - 创建空文件或更新时间戳 复制、移动和删除\ncp \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 复制文件 cp -r \u0026lt;源目录\u0026gt; \u0026lt;目标\u0026gt; - 递归复制目录 cp -i \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 交互式复制（覆盖前询问） mv \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 移动/重命名文件 rm \u0026lt;文件\u0026gt; - 删除文件 rm -r \u0026lt;目录\u0026gt; - 递归删除目录 rm -f \u0026lt;文件\u0026gt; - 强制删除 rm -rf \u0026lt;目录\u0026gt; - 强制递归删除（危险！） rm -i \u0026lt;文件\u0026gt; - 交互式删除（推荐） 链接\nln -s \u0026lt;源\u0026gt; \u0026lt;链接名\u0026gt; - 创建符号链接 readlink -f \u0026lt;链接\u0026gt; - 查看链接目标 文件查看和编辑 查看文件\ncat \u0026lt;文件\u0026gt; - 显示文件内容 cat -n \u0026lt;文件\u0026gt; - 显示行号 less \u0026lt;文件\u0026gt; - 分页查看（可前后翻页） more \u0026lt;文件\u0026gt; - 分页查看（只能向前） head \u0026lt;文件\u0026gt; - 查看文件开头 head -n 20 \u0026lt;文件\u0026gt; - 查看前 20 行 tail \u0026lt;文件\u0026gt; - 查看文件末尾 tail -n 20 \u0026lt;文件\u0026gt; - 查看最后 20 行 tail -f \u0026lt;文件\u0026gt; - 实时查看文件更新 tail -f \u0026lt;文件\u0026gt; | grep \u0026quot;error\u0026quot; - 实时过滤查看 编辑文件\nnano \u0026lt;文件\u0026gt; - 简单文本编辑器 vim \u0026lt;文件\u0026gt; / vi \u0026lt;文件\u0026gt; - 强大的文本编辑器 统计文件\nwc \u0026lt;文件\u0026gt; - 统计文件 wc -l \u0026lt;文件\u0026gt; - 统计行数 wc -w \u0026lt;文件\u0026gt; - 统计单词数 wc -c \u0026lt;文件\u0026gt; - 统计字节数 文件搜索和查找 find 命令\nfind \u0026lt;路径\u0026gt; -name \u0026lt;名称\u0026gt; - 按名称查找 find . -name \u0026quot;*.txt\u0026quot; - 查找所有 txt 文件 find . -type f -name \u0026quot;*.log\u0026quot; - 查找文件（不含目录） find . -type d -name \u0026quot;node_modules\u0026quot; - 查找目录 find . -mtime -7 - 查找 7 天内修改的文件 find . -size +100M - 查找大于 100MB 的文件 find . -name \u0026quot;*.tmp\u0026quot; -delete - 查找并删除 grep 命令\ngrep \u0026lt;模式\u0026gt; \u0026lt;文件\u0026gt; - 搜索文本 grep -r \u0026quot;TODO\u0026quot; . - 递归搜索当前目录 grep -i \u0026quot;error\u0026quot; log.txt - 忽略大小写 grep -n \u0026quot;function\u0026quot; code.js - 显示行号 grep -v \u0026quot;debug\u0026quot; log.txt - 反向匹配（不包含） grep -E \u0026quot;error|warning\u0026quot; log.txt - 使用正则表达式 grep -c \u0026quot;error\u0026quot; log.txt - 统计匹配行数 其他查找工具\nlocate \u0026lt;文件名\u0026gt; - 快速查找文件 updatedb - 更新 locate 数据库 which \u0026lt;命令\u0026gt; - 查找命令位置 whereis \u0026lt;程序\u0026gt; - 查找程序位置 文件权限 chmod \u0026lt;权限\u0026gt; \u0026lt;文件\u0026gt; - 修改文件权限 chmod 755 script.sh - 数字方式（rwxr-xr-x） chmod +x script.sh - 添加执行权限 chmod -R 644 directory/ - 递归修改 chown \u0026lt;用户\u0026gt;:\u0026lt;组\u0026gt; \u0026lt;文件\u0026gt; - 修改所有者 chgrp \u0026lt;组\u0026gt; \u0026lt;文件\u0026gt; - 修改所属组 umask - 查看或设置默认权限掩码 进程管理 查看进程\nps - 查看进程 ps aux - 查看所有进程详细信息 ps -ef - 另一种格式 ps aux | grep \u0026lt;进程名\u0026gt; - 搜索特定进程 top - 实时查看系统资源（按 q 退出） htop - 增强版 top 管理进程\nkill \u0026lt;PID\u0026gt; - 结束进程 kill -9 \u0026lt;PID\u0026gt; - 强制结束 killall \u0026lt;进程名\u0026gt; - 按名称结束进程 pkill \u0026lt;进程名\u0026gt; - 按模式匹配结束 bg - 将任务放到后台 fg - 将后台任务调到前台 jobs - 查看后台任务 nohup \u0026lt;命令\u0026gt; \u0026amp; - 后台运行，不受终端关闭影响 磁盘和存储 df -h - 查看磁盘使用情况 du -sh \u0026lt;目录\u0026gt; - 查看目录大小 du -h --max-depth=1 - 查看各子目录大小 du -sh * | sort -h - 按大小排序 free -h - 查看内存使用 lsblk - 列出块设备 mount - 挂载文件系统 umount - 卸载文件系统 系统信息 uname -a - 完整系统信息 uname -r - 内核版本 hostname - 主机名 whoami - 当前用户 id - 用户 ID 和组 ID uptime - 系统运行时间和负载 date - 系统时间 cal - 日历 lsb_release -a - Linux 发行版信息（Ubuntu/Debian） cat /etc/os-release - 系统版本信息 网络操作 连接测试\nping \u0026lt;地址\u0026gt; - 测试网络连接 ping -c 4 google.com - 发送 4 个包后停止 traceroute \u0026lt;地址\u0026gt; - 追踪路由路径 文件传输\ncurl \u0026lt;URL\u0026gt; - 发送 HTTP 请求 curl -O \u0026lt;URL\u0026gt; - 下载文件（保持原文件名） curl -o \u0026lt;文件名\u0026gt; \u0026lt;URL\u0026gt; - 下载并重命名 curl -I \u0026lt;URL\u0026gt; - 只获取 HTTP 头 curl -X POST -d \u0026quot;data\u0026quot; \u0026lt;URL\u0026gt; - 发送 POST 请求 wget \u0026lt;URL\u0026gt; - 下载文件 wget -c \u0026lt;URL\u0026gt; - 断点续传 远程连接\nssh \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt; - SSH 连接 ssh -p \u0026lt;端口\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt; - 指定端口 scp \u0026lt;源\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt;:\u0026lt;目标\u0026gt; - 安全复制文件 scp -r \u0026lt;目录\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt;:\u0026lt;目标\u0026gt; - 复制目录 网络信息\nnetstat -tuln - 查看网络端口（传统） ss -tuln - 查看网络端口（现代） ip addr / ifconfig - 查看网络接口 nslookup \u0026lt;域名\u0026gt; - DNS 查询 dig \u0026lt;域名\u0026gt; - DNS 详细查询 压缩和解压 tar 格式\ntar -czf \u0026lt;文件.tar.gz\u0026gt; \u0026lt;目录\u0026gt; - 压缩为 tar.gz tar -xzf \u0026lt;文件.tar.gz\u0026gt; - 解压 tar.gz tar -xzf \u0026lt;文件.tar.gz\u0026gt; -C \u0026lt;目标目录\u0026gt; - 解压到指定目录 tar -tvf \u0026lt;文件.tar.gz\u0026gt; - 查看压缩包内容 zip 格式\nzip -r \u0026lt;文件.zip\u0026gt; \u0026lt;目录\u0026gt; - 创建 zip 压缩包 unzip \u0026lt;文件.zip\u0026gt; - 解压 zip unzip \u0026lt;文件.zip\u0026gt; -d \u0026lt;目标目录\u0026gt; - 解压到指定目录 gzip 格式\ngzip \u0026lt;文件\u0026gt; - 压缩为 .gz gunzip \u0026lt;文件.gz\u0026gt; - 解压 .gz 文本处理工具 sed（流编辑器）\nsed 's/old/new/g' file.txt - 替换文本 sed -i 's/old/new/g' file.txt - 直接修改文件 awk（文本处理）\nawk '{print $1}' file.txt - 打印第一列 awk -F',' '{print $2}' file.csv - 指定分隔符 排序和去重\nsort \u0026lt;文件\u0026gt; - 排序 sort -r \u0026lt;文件\u0026gt; - 反向排序 sort -n \u0026lt;文件\u0026gt; - 按数字排序 uniq \u0026lt;文件\u0026gt; - 去除重复行 sort file.txt | uniq - 配合使用 uniq -c \u0026lt;文件\u0026gt; - 统计重复次数 其他工具\ncut -d',' -f1,3 file.csv - 按分隔符提取列 tr 'a-z' 'A-Z' \u0026lt; file.txt - 字符转换 系统管理 用户管理\nsudo \u0026lt;命令\u0026gt; - 以管理员权限执行 su - 切换用户 su - - 切换到 root passwd - 修改密码 useradd \u0026lt;用户名\u0026gt; - 创建用户 userdel \u0026lt;用户名\u0026gt; - 删除用户 usermod -aG \u0026lt;组\u0026gt; \u0026lt;用户\u0026gt; - 添加用户到组 服务管理（systemd）\nsystemctl start \u0026lt;服务\u0026gt; - 启动服务 systemctl stop \u0026lt;服务\u0026gt; - 停止服务 systemctl restart \u0026lt;服务\u0026gt; - 重启服务 systemctl status \u0026lt;服务\u0026gt; - 查看状态 systemctl enable \u0026lt;服务\u0026gt; - 设置开机启动 journalctl -u \u0026lt;服务\u0026gt; - 查看服务日志 实用快捷键 Ctrl + C - 终止当前命令 Ctrl + Z - 暂停当前命令 Ctrl + D - 退出终端 Ctrl + L - 清屏 Ctrl + A - 光标移到行首 Ctrl + E - 光标移到行尾 Ctrl + U - 删除光标前的内容 Ctrl + K - 删除光标后的内容 Ctrl + R - 搜索命令历史 Tab - 自动补全 !! - 执行上一条命令 !$ - 上一条命令的最后一个参数 其他实用命令 clear - 清屏 history - 查看命令历史 history | grep \u0026lt;关键词\u0026gt; - 搜索历史命令 echo \u0026lt;文本\u0026gt; - 输出文本 echo \u0026quot;text\u0026quot; \u0026gt; file.txt - 覆盖写入 echo \u0026quot;text\u0026quot; \u0026gt;\u0026gt; file.txt - 追加写入 alias \u0026lt;别名\u0026gt;='\u0026lt;命令\u0026gt;' - 创建别名 watch \u0026lt;命令\u0026gt; - 定期执行命令 watch -n 2 df -h - 每 2 秒更新 xargs - 将标准输入转换为命令参数 tee \u0026lt;文件\u0026gt; - 同时输出到文件和标准输出 Git 常用指令 初始化和配置 初始化仓库\ngit init - 初始化新仓库 git clone \u0026lt;URL\u0026gt; - 克隆远程仓库 git clone \u0026lt;URL\u0026gt; \u0026lt;目录名\u0026gt; - 克隆到指定目录 git clone --depth 1 \u0026lt;URL\u0026gt; - 浅克隆（只克隆最新提交） git clone -b \u0026lt;分支名\u0026gt; \u0026lt;URL\u0026gt; - 克隆指定分支 配置 Git\ngit config --global user.name \u0026quot;\u0026lt;名字\u0026gt;\u0026quot; - 设置用户名 git config --global user.email \u0026quot;\u0026lt;邮箱\u0026gt;\u0026quot; - 设置邮箱 git config --list - 查看所有配置 git config --global core.editor \u0026quot;vim\u0026quot; - 设置编辑器 git config --global alias.st status - 设置别名 基本操作 查看状态\ngit status - 查看工作区状态 git status -s - 简短格式 添加和提交\ngit add \u0026lt;文件\u0026gt; - 添加文件到暂存区 git add . - 添加所有修改 git add -A - 添加所有变化（包括删除） git add -p - 交互式添加 git commit -m \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 提交 git commit -am \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 添加并提交已跟踪文件 git commit --amend - 修改最后一次提交 git commit --amend --no-edit - 修改提交但不改消息 推送和拉取\ngit push - 推送到远程 git push origin \u0026lt;分支名\u0026gt; - 推送指定分支 git push -u origin \u0026lt;分支名\u0026gt; - 推送并设置上游 git push --force / git push -f - 强制推送（危险！） git push --tags - 推送标签 git pull - 拉取并合并 git pull --rebase - 使用 rebase 方式拉取 git fetch - 获取但不合并 git fetch --all - 获取所有远程分支 git fetch --prune - 获取并清理已删除的远程分支 分支操作 查看分支\ngit branch - 查看本地分支 git branch -a - 查看所有分支（包括远程） git branch -r - 只查看远程分支 git branch -v - 查看分支及最后一次提交 创建和切换分支\ngit branch \u0026lt;分支名\u0026gt; - 创建分支 git checkout \u0026lt;分支名\u0026gt; - 切换分支 git checkout -b \u0026lt;分支名\u0026gt; - 创建并切换 git checkout -b \u0026lt;分支名\u0026gt; origin/\u0026lt;分支名\u0026gt; - 从远程分支创建 git switch \u0026lt;分支名\u0026gt; - 切换分支（新语法） git switch -c \u0026lt;分支名\u0026gt; - 创建并切换（新语法） 合并和删除分支\ngit merge \u0026lt;分支名\u0026gt; - 合并分支 git merge --no-ff \u0026lt;分支名\u0026gt; - 非快进合并 git merge --squash \u0026lt;分支名\u0026gt; - 压缩合并 git branch -d \u0026lt;分支名\u0026gt; - 删除已合并分支 git branch -D \u0026lt;分支名\u0026gt; - 强制删除分支 git branch -m \u0026lt;旧名\u0026gt; \u0026lt;新名\u0026gt; - 重命名分支 git push origin --delete \u0026lt;分支名\u0026gt; - 删除远程分支 查看历史 日志查看\ngit log - 查看提交历史 git log --oneline - 每个提交一行 git log --graph - 图形化显示 git log --oneline --graph --all - 图形化显示所有分支 git log -p - 显示详细差异 git log --author=\u0026quot;\u0026lt;作者\u0026gt;\u0026quot; - 按作者筛选 git log --since=\u0026quot;2 weeks ago\u0026quot; - 按时间筛选 git log --grep=\u0026quot;\u0026lt;关键词\u0026gt;\u0026quot; - 搜索提交消息 git log \u0026lt;文件\u0026gt; - 查看文件历史 git log --stat - 显示文件统计 差异比较\ngit diff - 查看未暂存的更改 git diff --staged / git diff --cached - 查看已暂存的更改 git diff \u0026lt;分支1\u0026gt; \u0026lt;分支2\u0026gt; - 比较分支 git diff \u0026lt;提交1\u0026gt; \u0026lt;提交2\u0026gt; - 比较提交 git diff HEAD - 比较工作区和最新提交 其他查看命令\ngit show \u0026lt;提交\u0026gt; - 查看提交详情 git show HEAD - 查看最新提交 git blame \u0026lt;文件\u0026gt; - 查看每行的修改者 git shortlog - 按作者分组显示 撤销和回退 撤销修改\ngit restore \u0026lt;文件\u0026gt; - 撤销工作区修改（新语法） git restore --staged \u0026lt;文件\u0026gt; - 取消暂存（新语法） git checkout -- \u0026lt;文件\u0026gt; - 撤销修改（旧语法） 重置提交\ngit reset \u0026lt;文件\u0026gt; - 取消暂存 git reset HEAD~ - 撤销最后一次提交，保留更改 git reset --soft HEAD~ - 撤销提交，更改在暂存区 git reset --hard HEAD~ - 撤销提交并丢弃更改（危险！） git reset --hard \u0026lt;提交\u0026gt; - 重置到指定提交 回退操作\ngit revert \u0026lt;提交\u0026gt; - 创建新提交来撤销 git revert HEAD - 撤销最新提交 git clean -fd - 删除未跟踪的文件 git clean -n - 预览将要删除的文件 暂存操作（Stash） git stash - 暂存当前更改 git stash save \u0026quot;描述\u0026quot; - 暂存并添加描述 git stash list - 查看暂存列表 git stash pop - 恢复并删除最新暂存 git stash apply - 恢复但不删除暂存 git stash apply stash@{0} - 恢复指定暂存 git stash drop - 删除最新暂存 git stash drop stash@{0} - 删除指定暂存 git stash clear - 清空所有暂存 git stash show - 查看暂存内容 远程仓库 查看远程\ngit remote - 查看远程仓库 git remote -v - 查看详细信息 管理远程\ngit remote add \u0026lt;名称\u0026gt; \u0026lt;URL\u0026gt; - 添加远程仓库 git remote add origin \u0026lt;URL\u0026gt; - 添加 origin git remote remove \u0026lt;名称\u0026gt; - 删除远程仓库 git remote rename \u0026lt;旧名\u0026gt; \u0026lt;新名\u0026gt; - 重命名 git remote set-url \u0026lt;名称\u0026gt; \u0026lt;新URL\u0026gt; - 修改 URL git remote show \u0026lt;名称\u0026gt; - 查看详细信息 git remote prune origin - 清理已删除的远程分支引用 标签操作 git tag - 查看所有标签 git tag \u0026lt;标签名\u0026gt; - 创建轻量标签 git tag -a \u0026lt;标签名\u0026gt; -m \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 创建带注释的标签 git tag -d \u0026lt;标签名\u0026gt; - 删除本地标签 git push origin \u0026lt;标签名\u0026gt; - 推送标签 git push origin --tags - 推送所有标签 git push origin :refs/tags/\u0026lt;标签名\u0026gt; - 删除远程标签 高级操作 变基（Rebase）\ngit rebase \u0026lt;分支\u0026gt; - 变基到指定分支 git rebase -i HEAD~3 - 交互式变基最近 3 个提交 git rebase --continue - 解决冲突后继续 git rebase --abort - 取消变基 其他高级命令\ngit cherry-pick \u0026lt;提交\u0026gt; - 将指定提交应用到当前分支 git reflog - 查看引用日志（恢复丢失的提交） git bisect start - 开始二分查找问题提交 git submodule add \u0026lt;URL\u0026gt; - 添加子模块 git submodule update --init - 初始化并更新子模块 .gitignore 配置 New-Item -ItemType File .gitignore创建 .gitignore 文件来忽略不需要跟踪的文件：\n# 忽略日志文件 *.log # 忽略 node_modules 目录 node_modules/ # 忽略环境变量文件 .env .env.local # 忽略构建输出 dist/ build/ # 忽略操作系统文件 .DS_Store Thumbs.db # 忽略 IDE 配置 .vscode/ .idea/ GitHub CLI 常用指令 认证 gh auth login - 登录 GitHub 账号 gh auth status - 查看认证状态 gh auth logout - 登出 gh auth refresh - 刷新令牌 gh config set editor vim - 设置编辑器 仓库操作 创建和克隆\ngh repo create - 创建仓库 gh repo create \u0026lt;名称\u0026gt; - 创建指定名称的仓库 gh repo create --public - 创建公开仓库 gh repo create --private - 创建私有仓库 gh repo create --clone - 创建并克隆 gh repo clone \u0026lt;仓库\u0026gt; - 克隆仓库 gh repo clone owner/repo - 克隆指定仓库 查看和管理\ngh repo view - 查看仓库信息 gh repo view --web - 在浏览器中打开 gh repo list - 列出仓库 gh repo list \u0026lt;用户名\u0026gt; - 列出指定用户的仓库 gh repo list --limit 50 - 限制显示数量 gh repo fork - Fork 仓库 gh repo fork --clone - Fork 并克隆 gh repo delete \u0026lt;仓库\u0026gt; - 删除仓库 gh repo rename \u0026lt;新名称\u0026gt; - 重命名仓库 or gh repo rename owner/repo 新名字 gh repo sync - 同步 fork Pull Request 创建 PR\ngh pr create - 创建 PR gh pr create --title \u0026quot;标题\u0026quot; --body \u0026quot;描述\u0026quot; - 指定标题和描述 gh pr create --web - 在浏览器中创建 gh pr create --draft - 创建草稿 PR 查看 PR\ngh pr list - 列出 PR gh pr list --state open - 只显示开放的 gh pr list --author \u0026lt;用户名\u0026gt; - 按作者筛选 gh pr list --label \u0026lt;标签\u0026gt; - 按标签筛选 gh pr view \u0026lt;编号\u0026gt; - 查看详情 gh pr view \u0026lt;编号\u0026gt; --web - 在浏览器中查看 gh pr view \u0026lt;编号\u0026gt; --comments - 查看评论 操作 PR\ngh pr checkout \u0026lt;编号\u0026gt; - 检出 PR 分支 gh pr diff \u0026lt;编号\u0026gt; - 查看差异 gh pr merge \u0026lt;编号\u0026gt; - 合并 PR gh pr merge \u0026lt;编号\u0026gt; --squash - 压缩合并 gh pr merge \u0026lt;编号\u0026gt; --rebase - 变基合并 gh pr close \u0026lt;编号\u0026gt; - 关闭 PR gh pr reopen \u0026lt;编号\u0026gt; - 重新打开 gh pr ready \u0026lt;编号\u0026gt; - 标记为准备好 审查 PR\ngh pr review \u0026lt;编号\u0026gt; - 审查 PR gh pr review \u0026lt;编号\u0026gt; --approve - 批准 gh pr review \u0026lt;编号\u0026gt; --request-changes - 请求更改 gh pr review \u0026lt;编号\u0026gt; --comment - 添加评论 gh pr checks \u0026lt;编号\u0026gt; - 查看 CI/CD 状态 Issue 创建 Issue\ngh issue create - 创建 Issue gh issue create --title \u0026quot;标题\u0026quot; --body \u0026quot;描述\u0026quot; - 指定内容 gh issue create --web - 在浏览器中创建 gh issue create --label \u0026quot;bug,help wanted\u0026quot; - 添加标签 查看 Issue\ngh issue list - 列出 Issues gh issue list --state open - 只显示开放的 gh issue list --assignee \u0026lt;用户名\u0026gt; - 按指派人筛选 gh issue list --label \u0026lt;标签\u0026gt; - 按标签筛选 gh issue list --author \u0026lt;用户名\u0026gt; - 按作者筛选 gh issue view \u0026lt;编号\u0026gt; - 查看详情 gh issue view \u0026lt;编号\u0026gt; --web - 在浏览器中查看 操作 Issue\ngh issue close \u0026lt;编号\u0026gt; - 关闭 Issue gh issue close \u0026lt;编号\u0026gt; --comment \u0026quot;已修复\u0026quot; - 关闭并评论 gh issue reopen \u0026lt;编号\u0026gt; - 重新打开 gh issue edit \u0026lt;编号\u0026gt; - 编辑 Issue gh issue edit \u0026lt;编号\u0026gt; --add-label \u0026quot;bug\u0026quot; - 添加标签 gh issue comment \u0026lt;编号\u0026gt; - 添加评论 gh issue status - 查看状态 Gist gh gist create \u0026lt;文件\u0026gt; - 创建 Gist gh gist create --public \u0026lt;文件\u0026gt; - 创建公开 Gist gh gist create --desc \u0026quot;描述\u0026quot; \u0026lt;文件\u0026gt; - 添加描述 gh gist list - 列出 Gists gh gist view \u0026lt;ID\u0026gt; - 查看 Gist gh gist view \u0026lt;ID\u0026gt; --web - 在浏览器中查看 gh gist edit \u0026lt;ID\u0026gt; - 编辑 Gist gh gist delete \u0026lt;ID\u0026gt; - 删除 Gist gh gist clone \u0026lt;ID\u0026gt; - 克隆到本地 Release 创建和查看\ngh release create \u0026lt;标签\u0026gt; - 创建 Release gh release create v1.0.0 --title \u0026quot;版本 1.0.0\u0026quot; --notes \u0026quot;说明\u0026quot; - 指定内容 gh release create v1.0.0 *.zip - 附加文件 gh release create v1.0.0 --draft - 创建草稿 gh release list - 列出所有 Releases gh release view \u0026lt;标签\u0026gt; - 查看详情 gh release view \u0026lt;标签\u0026gt; --web - 在浏览器中查看 下载和管理\ngh release download \u0026lt;标签\u0026gt; - 下载资源 gh release download \u0026lt;标签\u0026gt; --pattern \u0026quot;*.zip\u0026quot; - 下载匹配文件 gh release delete \u0026lt;标签\u0026gt; - 删除 Release gh release upload \u0026lt;标签\u0026gt; \u0026lt;文件\u0026gt; - 上传文件 GitHub Actions 工作流管理\ngh workflow list - 列出工作流 gh workflow view \u0026lt;工作流\u0026gt; - 查看详情 gh workflow view \u0026lt;工作流\u0026gt; --web - 在浏览器中查看 gh workflow run \u0026lt;工作流\u0026gt; - 触发工作流 gh workflow run \u0026lt;工作流\u0026gt; --ref \u0026lt;分支\u0026gt; - 在指定分支运行 运行管理\ngh run list - 列出运行记录 gh run list --workflow \u0026lt;工作流名\u0026gt; - 按工作流筛选 gh run view \u0026lt;运行ID\u0026gt; - 查看详情 gh run view \u0026lt;运行ID\u0026gt; --log - 查看日志 gh run watch \u0026lt;运行ID\u0026gt; - 实时查看状态 gh run rerun \u0026lt;运行ID\u0026gt; - 重新运行 gh run cancel \u0026lt;运行ID\u0026gt; - 取消运行 其他功能 浏览和搜索\ngh browse - 在浏览器中打开仓库 gh browse \u0026lt;文件\u0026gt; - 打开指定文件 gh browse --settings - 打开设置 gh search repos \u0026lt;关键词\u0026gt; - 搜索仓库 gh search repos --stars \u0026quot;\u0026gt;1000\u0026quot; - 按星标搜索 gh search repos --language python - 按语言搜索 gh search issues \u0026lt;关键词\u0026gt; - 搜索 Issues gh search prs \u0026lt;关键词\u0026gt; - 搜索 PRs API 和扩展\ngh api \u0026lt;端点\u0026gt; - 调用 GitHub API gh api user - 获取用户信息 gh alias set \u0026lt;别名\u0026gt; \u0026lt;命令\u0026gt; - 创建别名 gh extension install \u0026lt;扩展\u0026gt; - 安装扩展 gh extension list - 列出扩展 标签和项目\ngh label list - 列出标签 gh label create \u0026lt;名称\u0026gt; - 创建标签 gh project list - 列出项目 gh project view \u0026lt;编号\u0026gt; - 查看项目 ","permalink":"http://localhost:1313/posts/command-reference/","summary":"详细的命令行指令参考手册，包含 Windows PowerShell、Linux Terminal、Git 和 GitHub CLI 的常用命令及实用技巧","title":"常用命令行指令参考"},{"content":"一、数据库操作 1.1 创建和删除数据库 -- 创建数据库 CREATE DATABASE database_name; CREATE DATABASE IF NOT EXISTS database_name CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; -- 删除数据库 DROP DATABASE database_name; DROP DATABASE IF EXISTS database_name; -- 查看所有数据库 SHOW DATABASES; -- 选择数据库 USE database_name; -- 查看当前数据库 SELECT DATABASE(); 二、数据表操作 2.1 创建表 -- 基础创建表 CREATE TABLE users ( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(50) NOT NULL UNIQUE, email VARCHAR(100), age INT DEFAULT 0, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ); -- 创建表时指定引擎和字符集 CREATE TABLE products ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(100) NOT NULL, price DECIMAL(10, 2), stock INT DEFAULT 0 ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; -- 从查询结果创建表 CREATE TABLE users_backup AS SELECT * FROM users; 2.2 修改表结构 -- 添加列 ALTER TABLE users ADD COLUMN phone VARCHAR(20); ALTER TABLE users ADD COLUMN address TEXT AFTER email; -- 修改列 ALTER TABLE users MODIFY COLUMN age TINYINT; ALTER TABLE users CHANGE COLUMN username user_name VARCHAR(60); -- 删除列 ALTER TABLE users DROP COLUMN phone; -- 重命名表 RENAME TABLE users TO members; ALTER TABLE members RENAME TO users; -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键 ALTER TABLE users DROP PRIMARY KEY; -- 添加索引 ALTER TABLE users ADD INDEX idx_username (username); ALTER TABLE users ADD UNIQUE INDEX idx_email (email); -- 删除索引 ALTER TABLE users DROP INDEX idx_username; 2.3 查看表信息 -- 查看所有表 SHOW TABLES; -- 查看表结构 DESC users; DESCRIBE users; SHOW COLUMNS FROM users; -- 查看创建表的语句 SHOW CREATE TABLE users; -- 查看表状态 SHOW TABLE STATUS LIKE \u0026#39;users\u0026#39;; 2.4 删除和清空表 -- 删除表 DROP TABLE users; DROP TABLE IF EXISTS users; -- 清空表数据（保留结构） TRUNCATE TABLE users; DELETE FROM users; -- 与 TRUNCATE 的区别是可以回滚 三、数据操作（CRUD） 3.1 插入数据（INSERT） -- 插入单条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;, 25); -- 插入多条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;李四\u0026#39;, \u0026#39;lisi@example.com\u0026#39;, 28), (\u0026#39;王五\u0026#39;, \u0026#39;wangwu@example.com\u0026#39;, 30); -- 插入所有列（可省略列名） INSERT INTO users VALUES (NULL, \u0026#39;赵六\u0026#39;, \u0026#39;zhaoliu@example.com\u0026#39;, 22, NOW(), NOW()); -- 插入或更新（存在则更新） INSERT INTO users (id, username, email) VALUES (1, \u0026#39;张三\u0026#39;, \u0026#39;new@example.com\u0026#39;) ON DUPLICATE KEY UPDATE email = \u0026#39;new@example.com\u0026#39;; -- 忽略重复插入错误 INSERT IGNORE INTO users (username, email) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;); -- 从其他表插入数据 INSERT INTO users_backup SELECT * FROM users WHERE age \u0026gt; 25; 3.2 查询数据（SELECT） 基础查询 -- 查询所有列 SELECT * FROM users; -- 查询指定列 SELECT username, email FROM users; -- 使用别名 SELECT username AS name, email AS mail FROM users; -- 去重查询 SELECT DISTINCT age FROM users; -- 限制结果数量 SELECT * FROM users LIMIT 10; SELECT * FROM users LIMIT 10, 20; -- 跳过前10条，取20条 SELECT * FROM users LIMIT 20 OFFSET 10; -- 同上 WHERE 条件查询 -- 基本条件 SELECT * FROM users WHERE age \u0026gt; 25; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users WHERE email IS NULL; SELECT * FROM users WHERE email IS NOT NULL; -- 多条件组合 SELECT * FROM users WHERE age \u0026gt; 20 AND age \u0026lt; 30; SELECT * FROM users WHERE age BETWEEN 20 AND 30; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39; OR username = \u0026#39;李四\u0026#39;; SELECT * FROM users WHERE username IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;); SELECT * FROM users WHERE username NOT IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;); -- 模糊查询 SELECT * FROM users WHERE username LIKE \u0026#39;张%\u0026#39;; -- 以\u0026#34;张\u0026#34;开头 SELECT * FROM users WHERE username LIKE \u0026#39;%三\u0026#39;; -- 以\u0026#34;三\u0026#34;结尾 SELECT * FROM users WHERE username LIKE \u0026#39;%张%\u0026#39;; -- 包含\u0026#34;张\u0026#34; SELECT * FROM users WHERE username LIKE \u0026#39;张_\u0026#39;; -- 张+一个字符 SELECT * FROM users WHERE username NOT LIKE \u0026#39;张%\u0026#39;; 排序和分组 -- 排序 SELECT * FROM users ORDER BY age ASC; -- 升序（默认） SELECT * FROM users ORDER BY age DESC; -- 降序 SELECT * FROM users ORDER BY age DESC, username ASC; -- 多列排序 -- 分组 SELECT age, COUNT(*) as count FROM users GROUP BY age; SELECT age, AVG(age) as avg_age FROM users GROUP BY age; -- HAVING 过滤分组结果 SELECT age, COUNT(*) as count FROM users GROUP BY age HAVING count \u0026gt; 5; 聚合函数 -- 计数 SELECT COUNT(*) FROM users; SELECT COUNT(DISTINCT age) FROM users; -- 求和、平均、最大、最小 SELECT SUM(age) FROM users; SELECT AVG(age) FROM users; SELECT MAX(age) FROM users; SELECT MIN(age) FROM users; -- 多个聚合函数 SELECT COUNT(*) as total, AVG(age) as avg_age, MAX(age) as max_age FROM users; 连接查询（JOIN） -- 内连接（INNER JOIN） SELECT users.username, orders.order_no FROM users INNER JOIN orders ON users.id = orders.user_id; -- 左连接（LEFT JOIN） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id; -- 右连接（RIGHT JOIN） SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 全连接（FULL JOIN，MySQL不直接支持，需要用UNION） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id UNION SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 自连接 SELECT a.username, b.username as friend FROM users a INNER JOIN users b ON a.friend_id = b.id; -- 多表连接 SELECT u.username, o.order_no, p.product_name FROM users u INNER JOIN orders o ON u.id = o.user_id INNER JOIN order_items oi ON o.id = oi.order_id INNER JOIN products p ON oi.product_id = p.id; 子查询 -- WHERE 子查询 SELECT * FROM users WHERE id IN (SELECT user_id FROM orders WHERE amount \u0026gt; 1000); -- FROM 子查询 SELECT avg_age FROM (SELECT AVG(age) as avg_age FROM users GROUP BY city) as subquery; -- EXISTS 子查询 SELECT * FROM users WHERE EXISTS (SELECT 1 FROM orders WHERE orders.user_id = users.id); -- 标量子查询 SELECT username, (SELECT COUNT(*) FROM orders WHERE user_id = users.id) as order_count FROM users; 联合查询（UNION） -- UNION（去重） SELECT username FROM users WHERE age \u0026gt; 30 UNION SELECT username FROM admins WHERE age \u0026gt; 30; -- UNION ALL（不去重，性能更好） SELECT username FROM users WHERE age \u0026gt; 30 UNION ALL SELECT username FROM admins WHERE age \u0026gt; 30; 3.3 更新数据（UPDATE） -- 更新单列 UPDATE users SET age = 26 WHERE username = \u0026#39;张三\u0026#39;; -- 更新多列 UPDATE users SET age = 26, email = \u0026#39;new@example.com\u0026#39; WHERE username = \u0026#39;张三\u0026#39;; -- 批量更新 UPDATE users SET age = age + 1 WHERE age \u0026lt; 30; -- 使用表达式更新 UPDATE users SET updated_at = NOW() WHERE id = 1; -- 基于其他表更新 UPDATE users u INNER JOIN orders o ON u.id = o.user_id SET u.total_orders = u.total_orders + 1 WHERE o.created_at \u0026gt; \u0026#39;2024-01-01\u0026#39;; -- 条件更新（CASE） UPDATE users SET level = CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END; 3.4 删除数据（DELETE） -- 删除指定数据 DELETE FROM users WHERE id = 1; -- 批量删除 DELETE FROM users WHERE age \u0026lt; 18; -- 删除所有数据 DELETE FROM users; -- 基于其他表删除 DELETE u FROM users u INNER JOIN orders o ON u.id = o.user_id WHERE o.status = \u0026#39;cancelled\u0026#39;; 四、索引管理 4.1 创建索引 -- 普通索引 CREATE INDEX idx_username ON users(username); -- 唯一索引 CREATE UNIQUE INDEX idx_email ON users(email); -- 复合索引 CREATE INDEX idx_name_age ON users(username, age); -- 全文索引 CREATE FULLTEXT INDEX idx_content ON articles(content); -- 在创建表时添加索引 CREATE TABLE users ( id INT PRIMARY KEY, username VARCHAR(50), email VARCHAR(100), INDEX idx_username (username), UNIQUE INDEX idx_email (email) ); 4.2 查看和删除索引 -- 查看索引 SHOW INDEX FROM users; -- 删除索引 DROP INDEX idx_username ON users; ALTER TABLE users DROP INDEX idx_username; 五、约束管理 5.1 主键约束 -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键（需要先删除 AUTO_INCREMENT 属性） ALTER TABLE users MODIFY id INT; ALTER TABLE users DROP PRIMARY KEY; 5.2 外键约束 -- 添加外键 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id); -- 添加外键时设置级联操作 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE; -- 删除外键 ALTER TABLE orders DROP FOREIGN KEY fk_user_id; 5.3 其他约束 -- 唯一约束 ALTER TABLE users ADD UNIQUE (email); -- 非空约束 ALTER TABLE users MODIFY username VARCHAR(50) NOT NULL; -- 检查约束（MySQL 8.0.16+） ALTER TABLE users ADD CONSTRAINT chk_age CHECK (age \u0026gt;= 0 AND age \u0026lt;= 150); -- 默认值约束 ALTER TABLE users ALTER COLUMN status SET DEFAULT \u0026#39;active\u0026#39;; 六、视图 -- 创建视图 CREATE VIEW active_users AS SELECT id, username, email FROM users WHERE status = \u0026#39;active\u0026#39;; -- 创建或替换视图 CREATE OR REPLACE VIEW active_users AS SELECT id, username, email, age FROM users WHERE status = \u0026#39;active\u0026#39;; -- 查询视图 SELECT * FROM active_users; -- 查看视图定义 SHOW CREATE VIEW active_users; -- 删除视图 DROP VIEW active_users; DROP VIEW IF EXISTS active_users; 七、事务处理 -- 开启事务 START TRANSACTION; -- 或 BEGIN; -- 提交事务 COMMIT; -- 回滚事务 ROLLBACK; -- 设置保存点 SAVEPOINT sp1; ROLLBACK TO sp1; -- 完整示例 START TRANSACTION; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; COMMIT; -- 设置自动提交 SET autocommit = 0; -- 关闭自动提交 SET autocommit = 1; -- 开启自动提交 八、存储过程和函数 8.1 存储过程 -- 创建存储过程 DELIMITER // CREATE PROCEDURE GetUserById(IN userId INT) BEGIN SELECT * FROM users WHERE id = userId; END // DELIMITER ; -- 调用存储过程 CALL GetUserById(1); -- 带输出参数的存储过程 DELIMITER // CREATE PROCEDURE GetUserCount(OUT total INT) BEGIN SELECT COUNT(*) INTO total FROM users; END // DELIMITER ; CALL GetUserCount(@count); SELECT @count; -- 删除存储过程 DROP PROCEDURE IF EXISTS GetUserById; -- 查看存储过程 SHOW PROCEDURE STATUS; SHOW CREATE PROCEDURE GetUserById; 8.2 函数 -- 创建函数 DELIMITER // CREATE FUNCTION GetUserAge(userId INT) RETURNS INT BEGIN DECLARE userAge INT; SELECT age INTO userAge FROM users WHERE id = userId; RETURN userAge; END // DELIMITER ; -- 使用函数 SELECT GetUserAge(1); -- 删除函数 DROP FUNCTION IF EXISTS GetUserAge; 九、触发器 -- 创建 BEFORE INSERT 触发器 DELIMITER // CREATE TRIGGER before_user_insert BEFORE INSERT ON users FOR EACH ROW BEGIN SET NEW.created_at = NOW(); END // DELIMITER ; -- 创建 AFTER UPDATE 触发器 DELIMITER // CREATE TRIGGER after_user_update AFTER UPDATE ON users FOR EACH ROW BEGIN INSERT INTO user_logs (user_id, action, created_at) VALUES (OLD.id, \u0026#39;update\u0026#39;, NOW()); END // DELIMITER ; -- 查看触发器 SHOW TRIGGERS; -- 删除触发器 DROP TRIGGER IF EXISTS before_user_insert; 十、用户和权限管理 -- 创建用户 CREATE USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; CREATE USER \u0026#39;username\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; -- 允许任何主机 -- 授予权限 GRANT ALL PRIVILEGES ON database_name.* TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; GRANT SELECT, INSERT, UPDATE ON database_name.table_name TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 刷新权限 FLUSH PRIVILEGES; -- 查看用户权限 SHOW GRANTS FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 撤销权限 REVOKE INSERT, UPDATE ON database_name.* FROM \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 修改密码 ALTER USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;new_password\u0026#39;; SET PASSWORD FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; = PASSWORD(\u0026#39;new_password\u0026#39;); -- 删除用户 DROP USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; 十一、备份和恢复 -- 使用 mysqldump 备份（在命令行执行） mysqldump -u username -p database_name \u0026gt; backup.sql mysqldump -u username -p database_name table_name \u0026gt; table_backup.sql mysqldump -u username -p --all-databases \u0026gt; all_databases.sql -- 恢复数据库（在命令行执行） mysql -u username -p database_name \u0026lt; backup.sql -- 导出为 CSV SELECT * FROM users INTO OUTFILE \u0026#39;/tmp/users.csv\u0026#39; FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; -- 从 CSV 导入 LOAD DATA INFILE \u0026#39;/tmp/users.csv\u0026#39; INTO TABLE users FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; 十二、性能优化相关 12.1 EXPLAIN 分析查询 -- 分析查询执行计划 EXPLAIN SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; -- 详细分析 EXPLAIN EXTENDED SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SHOW WARNINGS; -- JSON 格式 EXPLAIN FORMAT=JSON SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; 12.2 查询优化 -- 使用索引提示 SELECT * FROM users USE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users FORCE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users IGNORE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; -- 优化 COUNT SELECT COUNT(1) FROM users; -- 比 COUNT(*) 快一点 -- 分页优化（避免大 OFFSET） SELECT * FROM users WHERE id \u0026gt; 10000 ORDER BY id LIMIT 20; 12.3 查看状态和变量 -- 查看数据库状态 SHOW STATUS; SHOW STATUS LIKE \u0026#39;Threads%\u0026#39;; -- 查看系统变量 SHOW VARIABLES; SHOW VARIABLES LIKE \u0026#39;max_connections\u0026#39;; -- 查看进程列表 SHOW PROCESSLIST; SHOW FULL PROCESSLIST; -- 杀死进程 KILL process_id; 十三、常用字符串和日期函数 13.1 字符串函数 -- 字符串连接 SELECT CONCAT(\u0026#39;Hello\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;World\u0026#39;); SELECT CONCAT_WS(\u0026#39;-\u0026#39;, \u0026#39;2024\u0026#39;, \u0026#39;12\u0026#39;, \u0026#39;10\u0026#39;); -- 字符串长度 SELECT LENGTH(\u0026#39;Hello\u0026#39;), CHAR_LENGTH(\u0026#39;你好\u0026#39;); -- 大小写转换 SELECT UPPER(\u0026#39;hello\u0026#39;), LOWER(\u0026#39;HELLO\u0026#39;); -- 截取字符串 SELECT SUBSTRING(\u0026#39;Hello World\u0026#39;, 1, 5); SELECT LEFT(\u0026#39;Hello World\u0026#39;, 5), RIGHT(\u0026#39;Hello World\u0026#39;, 5); -- 替换和删除 SELECT REPLACE(\u0026#39;Hello World\u0026#39;, \u0026#39;World\u0026#39;, \u0026#39;MySQL\u0026#39;); SELECT TRIM(\u0026#39; Hello \u0026#39;), LTRIM(\u0026#39; Hello\u0026#39;), RTRIM(\u0026#39;Hello \u0026#39;); -- 查找位置 SELECT POSITION(\u0026#39;World\u0026#39; IN \u0026#39;Hello World\u0026#39;); SELECT LOCATE(\u0026#39;World\u0026#39;, \u0026#39;Hello World\u0026#39;); 13.2 日期时间函数 -- 获取当前时间 SELECT NOW(), CURDATE(), CURTIME(); SELECT CURRENT_TIMESTAMP(), CURRENT_DATE(), CURRENT_TIME(); -- 日期格式化 SELECT DATE_FORMAT(NOW(), \u0026#39;%Y-%m-%d %H:%i:%s\u0026#39;); SELECT DATE_FORMAT(NOW(), \u0026#39;%Y年%m月%d日\u0026#39;); -- 日期计算 SELECT date_add(\u0026#39;2023-01-01\u0026#39;, interval 1 day) 输出 \u0026#39;2023-01-02\u0026#39; SELECT date_sub(\u0026#39;2023-01-01\u0026#39;, interval 1 day) 输出 \u0026#39;2022-12-31\u0026#39; SELECT datediff(\u0026#39;2023-02-01\u0026#39;, \u0026#39;2023-01-01\u0026#39;) 输出31 -- 提取日期部分 SELECT YEAR(NOW()), MONTH(NOW()), DAY(NOW()); SELECT HOUR(NOW()), MINUTE(NOW()), SECOND(NOW()); -- 时间戳转换 SELECT UNIX_TIMESTAMP(NOW()); SELECT FROM_UNIXTIME(1702195200); 13.3 数学和其他函数 -- 数学函数 SELECT ROUND(3.14159, 2), CEIL(3.2), FLOOR(3.8); SELECT ABS(-5), MOD(10, 3), POWER(2, 3); SELECT RAND(), RAND()*100; -- 条件函数 SELECT IF(age \u0026gt; 18, \u0026#39;成年\u0026#39;, \u0026#39;未成年\u0026#39;) FROM users; SELECT IFNULL(email, \u0026#39;无邮箱\u0026#39;) FROM users; SELECT COALESCE(NULL, NULL, \u0026#39;default\u0026#39;, \u0026#39;value\u0026#39;); -- CASE 表达式 SELECT username, CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END as age_group FROM users; 十四、JSON 操作（MySQL 5.7+） -- 创建 JSON 列 CREATE TABLE products ( id INT PRIMARY KEY, name VARCHAR(100), attributes JSON ); -- 插入 JSON 数据 INSERT INTO products VALUES (1, \u0026#39;iPhone\u0026#39;, \u0026#39;{\u0026#34;color\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;storage\u0026#34;: \u0026#34;128GB\u0026#34;}\u0026#39;); -- 查询 JSON 数据 SELECT JSON_EXTRACT(attributes, \u0026#39;$.color\u0026#39;) as color FROM products; SELECT attributes-\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; SELECT attributes-\u0026gt;\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; -- 去除引号 -- 修改 JSON 数据 UPDATE products SET attributes = JSON_SET(attributes, \u0026#39;$.color\u0026#39;, \u0026#39;white\u0026#39;) WHERE id = 1; UPDATE products SET attributes = JSON_INSERT(attributes, \u0026#39;$.price\u0026#39;, 999) WHERE id = 1; UPDATE products SET attributes = JSON_REMOVE(attributes, \u0026#39;$.storage\u0026#39;) WHERE id = 1; -- JSON 数组操作 SELECT JSON_ARRAY(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;); SELECT JSON_CONTAINS(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;, \u0026#39;\u0026#34;a\u0026#34;\u0026#39;); SELECT JSON_LENGTH(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;); 十五、窗口函数（MySQL 8.0+） -- ROW_NUMBER：行号 SELECT username, age, ROW_NUMBER() OVER (ORDER BY age DESC) as row_num FROM users; -- RANK：排名（有并列，跳号） SELECT username, score, RANK() OVER (ORDER BY score DESC) as rank FROM students; -- DENSE_RANK：密集排名（有并列，不跳号） SELECT username, score, DENSE_RANK() OVER (ORDER BY score DESC) as rank FROM students; -- 分组窗口 SELECT department, username, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank FROM employees; -- 累计求和 SELECT username, amount, SUM(amount) OVER (ORDER BY created_at) as running_total FROM transactions; -- LAG 和 LEAD：访问上下行 SELECT username, salary, LAG(salary, 1) OVER (ORDER BY id) as prev_salary, LEAD(salary, 1) OVER (ORDER BY id) as next_salary FROM employees; 十六、常见问题和技巧 16.1 查找重复数据 -- 查找重复的用户名 SELECT username, COUNT(*) as count FROM users GROUP BY username HAVING count \u0026gt; 1; -- 删除重复数据（保留ID最小的） DELETE u1 FROM users u1 INNER JOIN users u2 WHERE u1.id \u0026gt; u2.id AND u1.username = u2.username; 16.2 随机获取数据 -- 随机获取一条数据 SELECT * FROM users ORDER BY RAND() LIMIT 1; -- 更高效的随机（大表适用） SELECT * FROM users WHERE id \u0026gt;= (SELECT FLOOR(MAX(id) * RAND()) FROM users) LIMIT 1; 16.3 行转列 -- 使用 CASE WHEN SELECT name, SUM(CASE WHEN subject = \u0026#39;语文\u0026#39; THEN score ELSE 0 END) as chinese, SUM(CASE WHEN subject = \u0026#39;数学\u0026#39; THEN score ELSE 0 END) as math FROM scores GROUP BY name; 16.4 列转行 -- 使用 UNION ALL SELECT name, \u0026#39;语文\u0026#39; as subject, chinese as score FROM scores UNION ALL SELECT name, \u0026#39;数学\u0026#39; as subject, math as score FROM scores; 十七、常用管理命令 -- 查看 MySQL 版本 SELECT VERSION(); -- 查看当前用户 SELECT USER(), CURRENT_USER(); -- 查看数据库大小 SELECT table_schema AS \u0026#39;Database\u0026#39;, ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables GROUP BY table_schema; -- 查看表大小 SELECT table_name AS \u0026#39;Table\u0026#39;, ROUND(((data_length + index_length) / 1024 / 1024), 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables WHERE table_schema = \u0026#39;database_name\u0026#39; ORDER BY (data_length + index_length) DESC; -- 修复表 REPAIR TABLE users; -- 优化表 OPTIMIZE TABLE users; -- 分析表 ANALYZE TABLE users; -- 检查表 CHECK TABLE users; 总结 这份笔记涵盖了 MySQL 从基础到进阶的大部分常用操作，当然也适合在刷题中补充，包括：\n数据库和表的管理 完整的 CRUD 操作 索引和约束 视图、事务、存储过程 用户权限管理 性能优化技巧 常用函数和 JSON、窗口函数！ ","permalink":"http://localhost:1313/posts/mysql-cheatsheet/","summary":"MySQL 常用语句全面速查手册，涵盖从基础 CRUD 到高级特性（索引、事务、存储过程、窗口函数等）的所有常用操作，适合快速查阅和刷题使用","title":"MySQL 语句速查笔记"},{"content":"论文基本信息 标题: Linking Souls to Humans: Blockchain Accounts with Credible Anonymity for Web 3.0 Decentralized Identity 作者: Taotao Wang, Zibin Lin, Shengli Zhang, Long Shi, Qing Yang, Boris Düdder 会议: WWW \u0026lsquo;25 (ACM Web Conference 2025) 时间: 2025年4月28日-5月2日，悉尼 机构: 深圳大学、南京理工大学、哥本哈根大学 研究背景 数字身份的三个发展阶段 数字身份系统经历了三个演进阶段，分别对应互联网的三个时代：\n阶段 身份类型 对应时代 特点 问题 1 中心化身份 Web 1.0 用户创建，应用提供商管理 多账户管理复杂，数据泄露风险 2 联盟身份 Web 2.0 少数大型提供商管理，可跨应用使用 数据霸权，用户数据集中在少数巨头手中 3 去中心化身份 Web 3.0 用户自主创建和管理（自主权身份） 完全匿名导致无法追溯真实社交关系 Web 3.0的核心价值 Web 3.0的革命性转变在于：\n用户拥有数据主权 数据不被应用提供商占有 需要去中心化身份系统支撑 当前区块链账户系统的问题 区块链账户系统是Web 3.0去中心化身份的理想原型，但存在以下问题：\n完全匿名的缺陷： 用户可以无需认证创建多个账户 无法准确记录真实用户之间的社交关系和互动 用户与区块链身份之间的映射关系模糊 Soulbound Token的局限性： Vitalik Buterin提出的\u0026quot;灵魂\u0026quot;（Soul）概念和\u0026quot;灵魂绑定代币\u0026quot;（Soulbound Token） 用户仍可创建多个\u0026quot;灵魂\u0026quot;账户来抹除、转移或隐藏关系 无法真实反映人类社会中的真实关系 研究方案：zkBID 核心目标 zkBID（Zero-Knowledge Blockchain-account-based Web 3.0 decentralized IDentity）旨在实现：\n一对一映射：将灵魂（区块链账户）与人类（用户）建立一对一关联 去中心化：无需第三方中心化机构参与 隐私保护：隐藏身份与账户之间的绑定关系（即匿名） 可信性：每个账户在区块链上的信用与对应的真实用户一对一映射 关键技术 zkBID采用三大核心技术：\n零知识证明（zkSNARK） 可链接环签名（Linkable Ring Signature） 区块链智能合约（Smart Contracts） 技术预备知识 1. 可验证凭证（Verifiable Credentials, VC） 由W3C提出的去中心化标识符（DID）体系中的关键组件。\n三个主要角色：\n颁发者（Issuer）：签发凭证 持有者（Holder）：拥有凭证 验证者（Verifier）：验证凭证 VC的数据结构（JSON对象）：\n{ \u0026#34;metadata\u0026#34;: \u0026#34;包含颁发者DID、颁发日期、声明类型\u0026#34;, \u0026#34;claims\u0026#34;: \u0026#34;关于持有者的断言，包括持有者DID\u0026#34;, \u0026#34;proofs\u0026#34;: \u0026#34;颁发者的数字签名\u0026#34; } 2. 人格凭证（Personhood Credentials, PHC） 定义：证明用户是真人而非AI的数字凭证\n运作流程：\n注册流程 用户向PHC颁发者证明自己是真人 → 颁发者签发PHC\n使用流程 第三方服务可要求用户出示PHC作为授权过程的一部分\n验证方法（颁发者确保用户是真人的三种主要方式）：\n现有身份文件 基于政府签发的身份证件 利用现有可信来源 生物识别信息 测量持久且唯一的人体特征（掌纹、虹膜、指纹） 确保是真人且限制每人只注册一次 信任网络（Web of Trust） 通过社交图谱分析区分真人和机器 检测用户是否曾获得过凭证 在zkBID中的应用：\nPHC以VC形式作为每个人类用户的身份凭证 3. zkSNARK算法 全称：Zero-knowledge Succinct Non-interactive Argument of Knowledge\n优势：\n简洁性（Succinct）：证明大小仅几个字节，验证时间短 非交互性（Non-interactive）：证明者和验证者无需同步通信 工作原理：\n使用算术电路表示，包含基本运算：加、减、乘、除\nF-算术电路：\n输入：$x \\in \\mathbb{F}^n$ 辅助输入（见证）：$w \\in \\mathbb{F}^h$ 输出：$C(x, w) \\in \\mathbb{F}^l$ 三个算法组件：\n密钥生成（KEYGEN）\n(PK, VK) ← KEYGEN(1^λ, C) 输入：安全参数λ和电路C 输出：证明密钥PK和验证密钥VK 证明生成（PROVE）\nπ ← PROVE(PK, x, W) 输入：PK、公开输入x、私密见证W 输出：证明π 证明验证（VERIFY）\n1/0 ← VERIFY(VK, x, π) 输入：VK、公开输入x、证明π 输出：接受（1）或拒绝（0） zkBID采用的算法：Groth16\n原因：验证速度快，证明紧凑 适用于大规模应用和大型区块链网络 4. 可链接环签名（Linkable Ring Signature） 基本环签名：\n验证者可以确认签名由预定义集合中的某个成员创建 但无法确定具体是哪个成员 可链接环签名的额外特性：\n允许验证者确定两个签名是否由同一签名者生成 四个算法组件：\n密钥生成（GEN）\n(pk, sk) ← GEN(1^k) 签名生成（SIG）\nσ ← SIG(1^k, 1^n, m, L, sk) 输入：安全参数k、环大小n、消息m、公钥环L、私钥sk 输出：签名σ 签名验证（VER）\n1/0 ← VER(1^k, 1^n, m, L, σ) 可链接性检查（LINK）\n1/0 ← LINK(1^k, 1^n, m1, m2, σ1, σ2, L1, L2) 判断两个签名是否由同一签名者生成 关键属性：\n签名者模糊性（Signer Ambiguity）： 攻击者正确猜测真实签名者的概率不超过 1/(n-t) 其中n是环大小，t是攻击者拥有的私钥数量 可链接性（Linkability）： 同一签名者（相同私钥）签名的两条消息可被验证为关联 zkBID采用的算法：MLSAGS（Multilayered Linkable Spontaneous Anonymous Group Signature）\n原因：实现可链接性的技术复杂度较低，适合在智能合约上实现 密钥图像（Key Image）机制：\ny₀ ← sk * Hₚ(pk) y₀对于给定的(sk, pk)对是唯一的 所有由同一签名者产生的签名都带有相同的密钥图像 即使环中的公钥改变，签名仍可链接 zkBID系统设计 整体架构 映射关系图 真实用户 → PHC（人格凭证）→ PHC哈希 → 种子公钥 → 灵魂账户 关系说明：\n实线：可见的一对一关系 虚线：不可见但可验证的关系 箭头：单向计算关系 核心设计理念 隐私保护： PHC的具体内容不上链，只存储零知识证明 灵魂账户与种子公钥的关联不可见 可信匿名： 账户是匿名的（无法追踪到真实身份） 账户是可信的（确实与真实用户一对一绑定） 完全去中心化： 所有数据由用户生成 通过区块链上的智能合约验证 IVAC流程（Identity Verification and Account Certification） zkBID通过三个子流程生成具有可信匿名性的灵魂账户：\n[用户] → [注册信息生成] → [用户身份验证] → [灵魂账户认证] → [灵魂账户] ↓ ↓ ↓ 零知识证明 智能合约验证 可链接环签名 详细设计 阶段1：注册信息生成 目标：生成隐私保护的注册信息，不泄露PHC的具体内容\nPHC格式设计 zkBID中的PHC采用VC格式，包含三个关键字段：\n{ \u0026#34;credentialSubject\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_holder\u0026#34; // 持有者公钥 }, \u0026#34;proof\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_issuer\u0026#34;, // 颁发者公钥 \u0026#34;signature\u0026#34;: \u0026#34;sig_issuer\u0026#34; // 颁发者签名 } } 零知识证明生成流程 Protocol 1: PHC的ZK证明生成\n输入： - hash_PHC：PHC的哈希值 - sig_holder：持有者的签名 - pk_issuer：颁发者的公钥 - PHC：完整的PHC数据 设置： (PK, VK) ← zkSNARK.KEYGEN(1^λ, C) 生成证明： 1. 公开输入 x ← (hash_PHC, sig_holder, pk_issuer) 2. 私密见证 W ← PHC 3. π ← zkSNARK.PROVE(PK, x, W) 输出：π（零知识证明） 算术电路验证逻辑 graph TD A[私密输入: PHC] --\u0026gt; B[计算PHC的哈希] C[公开输入: hash_PHC] --\u0026gt; B B --\u0026gt; D{哈希值是否相等?} A --\u0026gt; E[提取pk_holder] F[公开输入: sig_holder] --\u0026gt; G[验证sig_holder] E --\u0026gt; G G --\u0026gt; H{签名是否有效?} A --\u0026gt; I[提取sig_issuer] J[公开输入: pk_issuer] --\u0026gt; K[验证sig_issuer] I --\u0026gt; K K --\u0026gt; L{签名是否有效?} D --\u0026gt; M[AND] H --\u0026gt; M L --\u0026gt; M M --\u0026gt; N{输出TRUE/FALSE} 验证步骤：\n验证哈希正确性： 计算PHC的哈希 检查是否等于公开输入中的hash_PHC 确保hash_PHC确实从PHC计算得出 验证所有权： 从PHC中提取持有者公钥pk_holder 用pk_holder验证sig_holder 证明用户拥有PHC 验证PHC有效性： 从PHC中提取颁发者签名sig_issuer 用pk_issuer验证sig_issuer 证明PHC由可信颁发者签发 输出：\n如果所有检查通过：输出TRUE和证明π π证明的声明：\u0026ldquo;PHC哈希正确，持有者拥有PHC，PHC由颁发者签发\u0026rdquo; 关键：不泄露PHC的具体内容 阶段2：用户身份验证 目标：\n验证用户的真人身份（通过验证ZK证明） 防止重复注册（检查PHC哈希未被使用） 智能合约流程 Protocol 2: 用户身份验证智能合约\n输入： - π：零知识证明 - hash_PHC：PHC哈希 - sig_holder：持有者签名 - pk_seed：种子公钥 执行步骤： 1. pk_issuer ← GetIssuerPK() // 获取预定义的颁发者公钥 2. validation ← zkSNARK.VERIFY(VK, hash_PHC, pk_issuer, π) 3. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 4. stored ← Traverse(hash_PHC) // 检查是否已注册 5. if stored ≠ 0: return \u0026#34;已经注册\u0026#34; 6. Store(hash_PHC, pk_seed) // 存储为键值对 7. return \u0026#34;认证成功\u0026#34; 用户操作步骤 生成种子密钥对：\n(pk_seed, sk_seed) ← MLSAGS.GEN(1^k) 构造交易：\n数据字段包含：π, hash_PHC, sig_holder, pk_issuer, pk_seed 发送到身份验证合约地址 合约验证：\n验证颁发者公钥匹配 验证零知识证明 检查PHC哈希未被使用 链上记录：\n存储键值对：(hash_PHC, pk_seed) hash_PHC用于防止重复注册 pk_seed作为用户在下一阶段创建灵魂账户的凭证 安全保证：\nPHC的具体内容不上链 仍能验证PHC的所有权和有效性 防止同一PHC多次注册 阶段3：灵魂账户认证 目标：认证灵魂账户与合法种子公钥的一对一关联\n整体流程 生成灵魂账户（普通以太坊账户） 建立关联（使用可链接环签名） 链上验证（智能合约验证签名） 可链接环签名的生成和验证 graph LR A[用户端] --\u0026gt; B[签名生成] B --\u0026gt; C[智能合约] C --\u0026gt; D[签名验证] E[输入] --\u0026gt; B E --\u0026gt; |选择的L-1个种子公钥| B E --\u0026gt; |用户的种子公钥pk_seed| B E --\u0026gt; |用户的种子私钥sk_seed| B E --\u0026gt; |灵魂账户地址addr_soul| B E --\u0026gt; |密钥图像y₀| B B --\u0026gt; |签名σ| C F[公钥环L] --\u0026gt; C G[addr_soul] --\u0026gt; C D --\u0026gt; H{验证结果} H --\u0026gt; |True| I[认证成功] H --\u0026gt; |False| J[认证失败] 详细步骤 步骤1：生成灵魂账户\n(addr_soul, pk_soul, sk_soul) = 生成以太坊账户 步骤2：构造公钥环\n从已注册的种子公钥中选择L-1个 加上用户自己的pk_seed 形成大小为L的公钥环 步骤3：计算密钥图像\ny₀ ← sk_seed * Hₚ(pk_seed) y₀对于给定的(sk_seed, pk_seed)是唯一的 用于防止重复注册 步骤4：生成可链接环签名\nσ ← MLSAGS.SIG(1^k, 1^n, addr_soul, L, sk_seed) 消息m = addr_soul（要签名的是灵魂账户地址） 签名格式：σ = (y₀, \u0026hellip;) y₀作为签名的一部分 步骤5：智能合约验证\nProtocol 3: 灵魂账户认证智能合约\n输入： - σ：可链接环签名 - L：公钥环 - addr_soul：灵魂账户地址 执行步骤： 1. validation ← LRS.VER(1^k, 1^n, addr_soul, L, σ) 2. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 3. stored ← Traverse(σ.y₀) // 检查密钥图像是否已使用 4. if stored ≠ 0: return \u0026#34;已经认证\u0026#34; 5. Store(σ.y₀, addr_soul) // 存储密钥图像和灵魂账户 6. return \u0026#34;认证成功\u0026#34; 隐私保护机制 关键特性：\n签名者模糊性： 签名可以被验证为有效 但无法确定环L中哪个公钥是真正的签名者 攻击者猜对的概率：1/(n-t)，其中n是环大小，t是攻击者拥有的私钥数 一对一保证： 密钥图像y₀唯一对应一个种子密钥对 同一种子密钥对只能生成一个有效签名 确保一个PHC只能关联一个灵魂账户 可验证的匿名性： 任何人都可以验证灵魂账户与某个合法种子公钥关联 但无法确定具体是哪个种子公钥 实现\u0026quot;可信匿名\u0026quot; 链上数据 存储内容：\n(σ.y₀, addr_soul) 键值对 可见信息：\n所有种子公钥（从阶段2） 所有灵魂账户地址 所有密钥图像 不可见关联：\n哪个种子公钥对应哪个灵魂账户 哪个PHC哈希对应哪个灵魂账户 哪个真实用户对应哪个灵魂账户 安全性分析 安全前提条件 计算对手受限：攻击者为多项式时间的计算对手 验证者诚实：智能合约不会接受虚假验证请求 PHC唯一性：每个用户只能从颁发者获得一个PHC 安全目标 zkBID需要满足三个核心安全属性：\n安全属性 定义 目标 身份唯一性 防止重复注册 一个用户不能注册多个灵魂账户 不可伪造性 防止身份伪造 攻击者不能冒充诚实用户认证灵魂账户 匿名性 保护身份隐私 攻击者无法检测用户身份(PHC)与灵魂账户的关联 威胁模型与防御 1. 女巫攻击（Sybil Attack） 攻击场景： 攻击者已拥有一个灵魂账户，试图获取新的灵魂账户\n攻击方法：\n方法A：使用相同PHC关联新的种子公钥 → 用新种子公钥认证新灵魂账户\n方法B：直接使用已用过的种子公钥认证新灵魂账户\n防御分析：\n方法A的防御：\n在用户身份验证合约中： 1. 合约检查hash_PHC是否已存储 2. 由于哈希函数的抗碰撞性，每个PHC只能生成一个唯一哈希 3. zkSNARK的可靠性保证：攻击者通过伪造哈希成功的概率可忽略不计 4. 因此无法用同一PHC注册两个种子账户 方法B的防御：\n在灵魂账户认证合约中： 1. 合约检查密钥图像y₀是否已使用 2. 由于可链接环签名的可链接性，同一种子私钥无法构造两个不同y₀的有效签名 3. 因此无法用同一种子密钥对认证两个灵魂账户 结论：无法使用相同PHC或种子公钥注册两个灵魂账户\n2. 链接攻击（Linkage Attack） 攻击场景： 攻击者试图通过破解环签名的真实签名者，建立用户身份（PHC哈希）与灵魂账户的链接\n攻击方法： 分析链上存储的环签名，推断哪个种子公钥是真正的签名者\n防御分析：\n基于可链接环签名的签名者模糊性： - 假设环大小为n - 攻击者拥有t个私钥 - 攻击者正确识别真实签名者的概率 = 1/(n-t) 示例： - 环大小 n = 100 - 攻击者拥有 t = 10 个私钥 - 成功概率 = 1/90 ≈ 1.1% 结论：攻击者无法有效建立身份与账户的链接 环大小的影响：\n环越大 → 匿名性越强 但签名生成和验证成本增加 需要在匿名性和效率之间权衡 3. 伪造攻击（Forgery Attack） 攻击场景： 攻击者试图冒充诚实用户获取灵魂账户\n攻击方法：\n方法A：伪造holder签名生成有效zkSNARK证明\n攻击者获得诚实用户的PHC ↓ 伪造sig_holder ↓ 生成通过验证的zkSNARK证明 ↓ 注册种子公钥 ↓ 认证灵魂账户 方法B：伪造种子账户的环签名\n已注册的种子公钥公开可见 ↓ 伪造某个诚实用户的环签名sig_seed ↓ 认证新的灵魂账户 防御分析：\n方法A的防御：\n依赖两个密码学保证： 1. EdDSA算法的不可伪造性 → 攻击者无法伪造任何诚实用户的sig_holder 2. zkSNARK的可靠性 → 没有有效签名，无法创建有效的zkSNARK证明 结论：攻击者无法通过伪造签名获得种子公钥 方法B的防御：\n依赖可链接环签名的不可伪造性： - 攻击者无法伪造任何已注册种子账户的有效签名 - 即使种子公钥公开可见 结论：攻击者无法冒充诚实用户认证灵魂账户 总结：zkBID协议能够抵御伪造攻击\n安全性总结表 攻击类型 攻击目标 依赖的安全属性 防御结果 女巫攻击-方法A 重复注册PHC 哈希抗碰撞性 + zkSNARK可靠性 ✅ 安全 女巫攻击-方法B 重复使用种子密钥 可链接环签名的可链接性 ✅ 安全 链接攻击 破坏匿名性 可链接环签名的签名者模糊性 ✅ 安全 伪造攻击-方法A 伪造身份验证 EdDSA不可伪造性 + zkSNARK可靠性 ✅ 安全 伪造攻击-方法B 伪造账户认证 可链接环签名不可伪造性 ✅ 安全 实验评估 实验环境 测试网络配置 区块链测试网络：\n平台：阿里云 节点数：6个以太坊全节点 共识协议：工作量证明（PoW） 客户端：Go-Ethereum 网络拓扑：全连接（每个节点有独立IP） 用户节点：\n1个用户节点连接到1个以太坊节点 运行用户端功能 硬件配置（所有节点）：\n操作系统：Ubuntu 20.04 CPU：Intel(R) Core(TM) i7-10700 @ 2.90GHz 内存：48GB RAM 实现技术栈 智能合约：\n语言：Solidity 部署：以太坊测试网络 zkSNARK：\n算法：Groth16 平台：Circom 2 功能：Setup和证明生成 可链接环签名：\n算法：MLSAGS 用户端实现：Python（密钥生成、签名算法） 合约实现：Solidity（签名验证） 性能评估指标 指标 说明 重要性 ZK证明生成时间 Groth16证明算法的执行时间 影响用户体验 ZK证明大小 证明所占字节数 影响链上存储 ZK证明验证成本 智能合约验证所需Gas 影响使用成本 算术电路大小 R1CS约束数量 影响系统复杂度 MLSAGS签名生成时间 环签名生成的执行时间 影响用户体验 MLSAGS签名验证成本 智能合约验证所需Gas 影响使用成本 实验结果 1. Groth16性能测试 测试方案：\n使用单个算术电路验证多个PHC批次 测试不同批次大小下的性能表现 图表 6(a)：电路大小和证明大小 PHC批次大小 R1CS约束数量 ZK证明大小 1 ~19,000 192 Bytes 2 ~38,000 192 Bytes 4 ~76,000 192 Bytes 8 ~152,000 192 Bytes 16 ~304,000 192 Bytes 32 ~608,000 192 Bytes 64 ~1,216,000 192 Bytes 128 ~2,432,000 192 Bytes 关键发现：\n✨ 证明大小恒定：无论批次大小如何，证明始终为192字节 这是Groth16的核心优势：简洁性（Succinctness） 电路大小随批次线性增长 图表 6(b)：证明生成时间和验证成本 证明生成时间：\nPHC批次大小 生成时间 (ms) 增长趋势 1 ~2,000 基准 2 ~4,000 2x 4 ~8,000 4x 8 ~16,000 8x 16 ~32,000 16x 32 ~64,000 32x 证明验证成本（Gas）：\nPHC批次大小 验证Gas消耗 单个PHC平均Gas 1 215.7K 215.7K 2 247.2K 123.6K 4 310.2K 77.6K 8 436.2K 54.5K 16 688.2K 43.0K 32 1,040.0K 32.5K 关键发现：\n📈 线性增长：生成时间和验证成本都与批次大小呈线性关系\n💰\n批处理优势\n：批次大小为32时，单个PHC的Gas消耗仅为32.5K\n相比单独验证（215.7K），节省约85% 效率提升约7倍 ⚠️ 部署限制：批次大小≥64时，验证合约因以太坊合约大小限制无法部署\n最佳实践建议：\n推荐批次大小：16-32个PHC - 在合约大小限制内 - 获得显著的Gas优化 - 用户体验可接受 2. MLSAGS性能测试 测试方案：\n测试不同环大小L下的签名生成和验证性能 环大小影响匿名性和性能的权衡 图表 6(c)：MLSAGS性能指标 签名生成时间：\n环大小 L 生成时间 (ms) 增量时间 1 ~40 - 2 ~80 +40ms 4 ~160 +40ms 8 ~320 +40ms 16 ~640 +40ms 32 ~1,280 +40ms 64 ~2,560 +40ms 128 ~5,120 +40ms 签名验证成本（Gas）：\n环大小 L 验证Gas消耗 增量Gas 1 ~57K - 2 ~114K +57K 4 ~228K +57K 8 ~456K +57K 16 ~912K +57K 32 ~1,824K +57K 64 ~3,648K +57K 128 ~7,296K +57K 关键发现：\n📏\n完美线性关系\n：\n每增加1个公钥，生成时间增加约40ms 每增加1个公钥，验证Gas增加约57K ⚖️\n匿名性vs效率权衡\n：\n环越大 → 匿名性越强（攻击者猜中概率 = 1/L） 环越大 → 成本越高（时间和Gas） 匿名性分析：\n环大小 L 攻击者成功率 匿名性等级 Gas成本 10 10% 较弱 570K 50 2% 中等 2,850K 100 1% 强 5,700K 1000 0.1% 非常强 57,000K 实际应用建议：\n小规模应用（\u0026lt; 1000用户）： 环大小：10-20 匿名性：10%-5%攻击成功率 Gas成本：570K-1,140K（可接受） 中等规模应用（1000-10000用户）： 环大小：50-100 匿名性：2%-1%攻击成功率 Gas成本：2,850K-5,700K（需要优化） 大规模应用（\u0026gt; 10000用户）： 环大小：100+ 匿名性：\u0026lt; 1%攻击成功率 Gas成本：\u0026gt; 5,700K（需要Layer 2或批处理） 性能优化建议 1. 对于zkSNARK部分 批处理策略：\n低频场景（个人注册）： - 批次大小：1-4 - 适用：个人用户单次注册 - 优点：即时处理 - 缺点：Gas成本较高（215K-310K） 高频场景（批量注册）： - 批次大小：16-32 - 适用：组织批量入职、大规模注册活动 - 优点：Gas效率提升7倍 - 缺点：需要等待批次凑齐 2. 对于MLSAGS部分 环大小配置：\n# 根据用户总数动态调整 def calculate_ring_size(total_users, target_anonymity=0.01): \u0026#34;\u0026#34;\u0026#34; total_users: 系统总用户数 target_anonymity: 目标攻击成功率（如0.01 = 1%） \u0026#34;\u0026#34;\u0026#34; # 环大小不超过总用户数 ring_size = min(int(1 / target_anonymity), total_users) # 考虑Gas成本限制（假设单笔交易Gas上限为8M） max_affordable_ring = 8_000_000 / 57_000 # ≈ 140 return min(ring_size, max_affordable_ring) # 示例 calculate_ring_size(1000, 0.01) # 返回 100 calculate_ring_size(10000, 0.01) # 返回 100（受成本限制） calculate_ring_size(50, 0.01) # 返回 50（受用户数限制） 分层匿名策略：\nVIP用户/高价值账户： - 使用较大环（100+） - 提供更强匿名性 - 愿意支付更高Gas 普通用户： - 使用中等环（20-50） - 平衡匿名性和成本 - 实际应用最常见 测试/低价值账户： - 使用小环（10-20） - 基本匿名性 - 成本最低 实验结论 zkSNARK的优势： ✅ 证明大小恒定（192字节）：不受批次影响 ✅ 批处理优化显著：32个PHC可节省85% Gas ✅ 验证快速：链上验证成本可接受 MLSAGS的特性： ✅ 性能可预测：完美线性关系 ⚠️ 需要权衡：匿名性与成本呈正比 ✅ 灵活配置：可根据场景调整环大小 系统可行性： ✅ 在实际以太坊网络上完全可行 ✅ 通过参数优化可适应不同规模 ✅ 性能瓶颈明确且可优化 相关工作对比 现有方案分析 论文对比了8个相关的区块链身份方案：\n方案 年份 主要技术 应用场景 TradeMap [12] 2019 ZKP 符合FINMA的匿名KYC平台 Pauwels et al. [14] 2022 zkSNARK DeFi协议的KYC系统 Aydar et al. [3] 2019 Blockchain 数字身份验证框架 Singh et al. [18] 2020 Credential Protocol 保护个人属性的身份系统 Abraham et al. [1] 2020 SSI Model 支持凭证撤销的自主身份 ZEBRA [15] 2022 zkSNARK 链上匿名凭证验证 Zhang et al. [26] 2024 ZKP 能源交易身份认证 Kim et al. [10] 2023 SBT + DID 元宇宙的KYC系统 设计目标对比 方案 DG1 技术灵活性 DG2 身份匿名性 DG3 身份可信性 DG4 隐私存储 TradeMap [12] ✅ ❌ ❌ ❌ Pauwels [14] ✅ ❌ ✅ ✅ Aydar [3] ❌ ✅ ❌ ❌ Singh [18] ❌ ✅ ✅ ✅ Abraham [1] ✅ ✅ ❌ ❌ ZEBRA [15] ❌ ✅ ❌ ❌ Zhang [26] ✅ ❌ ✅ ❌ Kim [10] ❌ ✅ ❌ ❌ zkBID ✅ ✅ ✅ ✅ 设计目标说明：\nDG1 - 技术灵活性：不局限于特定的ZKP算法或区块链平台 DG2 - 身份匿名性：无法从链上活动推断用户真实身份 DG3 - 身份可信性：每个身份可信地连接到真实世界用户 DG4 - 隐私存储：身份文档保密存储，不公开可见 zkBID的独特优势 1. 唯一全面满足所有设计目标 其他方案的局限： ├─ TradeMap: 只关注合规性，缺乏匿名性和可信映射 ├─ Pauwels: DeFi场景，但身份匿名性不足 ├─ Aydar/Singh: 技术灵活性差，绑定特定实现 ├─ Abraham/ZEBRA: 缺乏与真实用户的可信绑定 ├─ Zhang: 特定场景（能源交易），匿名性不足 └─ Kim: 元宇宙场景，技术灵活性和可信性不足 zkBID的创新： ✅ 同时实现匿名性和可信性（看似矛盾的目标） ✅ 完全去中心化（无需可信第三方） ✅ 技术灵活（可替换ZKP算法和环签名方案） ✅ 隐私保护（身份信息不上链） 2. 技术组合的创新性 现有方案的技术使用：\n大多只使用zkSNARK进行凭证验证 少数使用环签名，但未实现身份-账户绑定 没有方案同时使用zkSNARK + 可链接环签名 zkBID的技术创新：\nzkSNARK（阶段1-2）： 目的：验证PHC有效性 优势：不泄露PHC内容 创新：批处理优化 可链接环签名（阶段3）： 目的：建立身份-账户映射 优势：保持匿名性的同时确保一对一 创新：使用密钥图像防止重复绑定 组合效果： = 可验证的身份 + 不可追踪的账户绑定 = 可信匿名（Credible Anonymity） 3. 实际应用价值 传统KYC系统的问题：\n中心化KYC： ❌ 隐私泄露风险 ❌ 数据被服务商控制 ❌ 跨平台不互通 区块链匿名账户： ❌ 无法防止女巫攻击 ❌ 信誉系统难以建立 ❌ 监管合规困难 zkBID的解决方案：\n对用户： ✅ 保护隐私（身份信息不泄露） ✅ 自主控制（无需信任中心化机构） ✅ 一次认证，多处使用 对平台： ✅ 防止女巫攻击（一人一账户） ✅ 建立信誉系统（账户可信） ✅ 满足监管要求（有认证机制） 对监管： ✅ 可验证的身份（PHC由可信机构签发） ✅ 可追责性（必要时可追踪） ✅ 隐私保护合规 应用场景 1. 去中心化社交网络 问题：\nTwitter/X上的机器人和假账户泛滥 难以区分真人和AI生成的内容 水军和虚假舆论操纵 zkBID解决方案：\n用户注册： 1. 用政府ID获取PHC 2. 通过zkBID认证获得灵魂账户 3. 使用灵魂账户在社交网络发布内容 效果： ✅ 每个账户对应一个真人 ✅ 保持用户匿名性 ✅ 机器人和假账户显著减少 ✅ 信誉系统可以建立在灵魂账户上 2. DAO治理 问题：\n一人多账户操纵投票 女巫攻击破坏治理公平性 难以验证投票者资格 zkBID解决方案：\n治理流程： 1. DAO成员通过zkBID认证 2. 每个灵魂账户 = 一个真实成员 3. 投票时保持匿名 4. 防止多重投票 效果： ✅ 一人一票（真正的民主） ✅ 投票匿名（防止胁迫和贿赂） ✅ 可验证（确保只有成员投票） ✅ 信誉加权（可基于历史贡献） 3. DeFi空投和激励 问题：\n空投被羊毛党多账户瓜分 难以识别真实用户 激励机制被滥用 zkBID解决方案：\n空投流程： 1. 要求使用zkBID认证的灵魂账户 2. 每个灵魂账户只能领取一次 3. 基于链上行为的信誉评分 效果： ✅ 公平分配（每人一份） ✅ 防止女巫攻击 ✅ 识别真实活跃用户 ✅ 建立长期激励机制 4. Web3游戏和元宇宙 问题：\n工作室多开刷金币 游戏经济被破坏 难以建立公平竞技环境 zkBID解决方案：\n游戏应用： 1. 玩家使用灵魂账户登录 2. 游戏内资产绑定到灵魂账户 3. 排行榜和竞技只认可灵魂账户 效果： ✅ 一人一号（公平竞争） ✅ 资产真实归属 ✅ 游戏经济稳定 ✅ 社交关系可信 5. 去中心化信用系统 问题：\n传统信用系统中心化 跨平台信用不互通 隐私泄露风险 zkBID解决方案：\n信用体系： 1. 灵魂账户作为信用载体 2. 链上行为建立信用历史 3. 跨DApp信用互认 4. 保护用户隐私 效果： ✅ 去中心化信用（不被单一机构控制） ✅ 可移植性（跨平台使用） ✅ 隐私保护（匿名但可信） ✅ 防止信用欺诈（一人一信用档案） 局限性与未来工作 当前局限性 1. 性能限制 Gas成本：\n当前状态： - 单次PHC验证：215.7K Gas - 环大小100的签名验证：5,700K Gas - 在以太坊主网上成本较高 影响： ❌ 大规模应用成本高 ❌ 限制了环大小（影响匿名性） 可能的解决方案：\nLayer 2方案（如Optimism、Arbitrum） 侧链部署 批处理优化 2. PHC依赖 当前状态：\n依赖可信的PHC颁发机构： - 政府机构 - 大型科技公司 - 其他可信第三方 问题： ❌ PHC系统尚未广泛部署 ❌ 不同颁发者的互操作性 ❌ 颁发者可能成为中心化风险点 3. 隐私权衡 匿名性级别：\n环大小的限制： - 小环（\u0026lt;20）：匿名性较弱 - 大环（100+）：成本高昂 - 实际应用中需要权衡 4. 撤销机制 当前缺失：\n无法撤销已认证的灵魂账户： ❌ 如果PHC被吊销怎么办？ ❌ 如果用户想注销怎么办？ ❌ 如果发现欺诈怎么办？ 需要设计： - 灵活的撤销机制 - 保持匿名性的撤销 - 防止滥用撤销权 未来研究方向 1. 性能优化 方向A：递归证明：\n使用递归zkSNARK： - 将多个证明聚合成一个 - 减少链上验证成本 - 提高批处理效率 预期效果： - Gas成本降低50%+ - 支持更大批次 方向B：量子抗性：\n替换为抗量子密码算法： - 格基密码学 - 哈希基签名 - 为后量子时代做准备 2. PHC生态系统 多颁发者互操作：\n标准化PHC格式： - 统一的VC模板 - 跨颁发者互认 - 去中心化颁发者网络 目标： - 减少单点故障 - 提高可用性 - 增强去中心化 去中心化PHC颁发：\n探索无需中心化颁发者的方案： - 基于生物识别的去中心化验证 - 社交图谱验证 - 组合多种验证方式 3. 隐私增强 方向A：动态环：\n允许用户动态选择环大小： - 根据交易重要性调整 - 重要交易用大环 - 普通交易用小环 效果： - 灵活性提高 - 成本优化 方向B：分层匿名：\n不同隐私级别的灵魂账户： - 公开级：最小匿名性，低成本 - 标准级：中等匿名性，中等成本 - 隐私级：高匿名性，高成本 4. 跨链支持 多链部署：\n扩展到其他区块链： - Polkadot/Cosmos生态 - 高性能链（Solana、Aptos） - 专用隐私链（Zcash、Monero概念） 跨链身份： - 一个PHC，多链认证 - 统一的身份层 5. 撤销和恢复机制 优雅的撤销：\n设计保护隐私的撤销： - 使用累加器（Accumulator） - 撤销列表不泄露身份 - 高效的撤销验证 恢复机制： - PHC过期后的更新流程 - 密钥丢失的恢复方案 - 保持连续性的信誉迁移 6. 合规和监管 可选的透明性：\n为监管场景设计： - 选择性披露机制 - 紧急情况下的去匿名化 - 法院命令的执行 平衡： - 保护普通用户隐私 - 满足反洗钱（AML）要求 - 支持合法调查 关键takeaways 技术创新 可信匿名的突破： 首次在区块链上实现\u0026quot;可信\u0026quot;+\u0026ldquo;匿名\u0026quot;的结合 通过零知识证明保护隐私 通过可链接环签名确保一对一映射 完全去中心化： 无需可信第三方参与验证 所有逻辑在智能合约中执行 用户完全控制自己的身份 实用性验证： 在真实以太坊测试网络上实现 性能指标明确可测 成本可接受且可优化 理论贡献 身份模型创新：\n传统模型：身份 → 账户（可见映射） zkBID模型：身份 → [ZK层] → 种子 → [环签名层] → 账户 创新点： - 两层隐私保护 - 可验证但不可追踪 - 数学上可证明的安全性 密码学组合：\nzkSNARK + 可链接环签名的首次组合应用 各取所长，弥补对方不足 为未来类似系统提供范式 实践意义 Web3基础设施： 为Web3提供关键的身份层 解决匿名性与可信性的矛盾 使去中心化应用更实用 防止AI冒充： 在AI时代区分人类和机器 PHC作为\u0026quot;数字人格证\u0026rdquo; 保护在线空间的人类性 新经济模式： 支持基于信誉的去中心化经济 公平的激励分配机制 可持续的社区治理 结论 zkBID是一个创新的Web 3.0去中心化身份方案，成功解决了区块链账户系统中匿名性与可信性的矛盾。\n核心成就 ✅ 技术突破：\n零知识证明保护身份隐私 可链接环签名确保一对一映射 完全去中心化的验证机制 ✅ 安全保证：\n抵御女巫攻击 抵御链接攻击 抵御伪造攻击 ✅ 实用验证：\n以太坊测试网络成功部署 性能指标满足实际应用需求 成本可通过参数优化控制 未来展望 zkBID为Web3去中心化身份提供了一个可行的解决方案，但仍有改进空间：\n继续优化性能和成本 推动PHC生态系统发展 探索跨链和多链支持 完善撤销和恢复机制 平衡隐私保护 ","permalink":"http://localhost:1313/posts/linking-souls-to-humans/","summary":"zkBID通过零知识证明和可链接环签名技术，首次实现了区块链账户的\u0026quot;可信匿名\u0026quot;：每个账户与真实用户一对一绑定（可信），但外界无法追踪具体对应关系（匿名）。系统采用三阶段IVAC流程，将人格凭证(PHC)通过零知识证明验证后绑定到种子公钥，再用环签名将种子公钥关联到灵魂账户。实验显示批处理可将验证成本降低85%，环大小灵活可调以平衡匿名性与效率。该方案为Web3提供了关键身份基础设施，可有效防止女巫攻击，支持去中心化社交、DAO治理、DeFi空投等场景。","title":"zkBID: 区块链账户与Web 3.0去中心化身份"},{"content":"📚 Part 1: Java 集合使用手册 0.String - 不可变字符串 // 初始化 String s = \u0026#34;hello\u0026#34;; String s2 = new String(\u0026#34;world\u0026#34;); String s3 = String.valueOf(123); // 数字转字符串 // 基本属性 int len = s.length(); // 长度 boolean empty = s.isEmpty(); // 是否为空 char ch = s.charAt(0); // 获取字符 // 查找 int index = s.indexOf(\u0026#34;ll\u0026#34;); // 查找子串位置 int lastIndex = s.lastIndexOf(\u0026#34;l\u0026#34;); // 最后出现位置 boolean contains = s.contains(\u0026#34;el\u0026#34;); // 是否包含 // 截取 String sub = s.substring(1, 4); // [1, 4) 截取 String sub2 = s.substring(2); // 从索引2到结尾 // 替换 String replaced = s.replace(\u0026#34;l\u0026#34;, \u0026#34;L\u0026#34;); // 替换所有 String replaced2 = s.replaceFirst(\u0026#34;l\u0026#34;, \u0026#34;L\u0026#34;); // 替换第一个 String replaced3 = s.replaceAll(\u0026#34;[aeiou]\u0026#34;, \u0026#34;*\u0026#34;); // 正则替换 // 分割 String[] parts = \u0026#34;a,b,c\u0026#34;.split(\u0026#34;,\u0026#34;); // 按分隔符分割 String[] parts2 = \u0026#34;a b c\u0026#34;.split(\u0026#34;\\\\s+\u0026#34;); // 按空格分割 // 拼接 String joined = String.join(\u0026#34;,\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); // \u0026#34;a,b,c\u0026#34; String concat = s.concat(\u0026#34; world\u0026#34;); // 拼接 // 大小写 String upper = s.toUpperCase(); String lower = s.toUpperCase().toLowerCase(); // 去空格 String trimmed = \u0026#34; hello \u0026#34;.trim(); // 去两端空格 String stripped = \u0026#34; hello \u0026#34;.strip(); // Java 11+ // 比较 boolean equals = s.equals(\u0026#34;hello\u0026#34;); boolean equalsIgnoreCase = s.equalsIgnoreCase(\u0026#34;HELLO\u0026#34;); int compare = s.compareTo(\u0026#34;world\u0026#34;); // 字典序比较 // 判断 boolean startsWith = s.startsWith(\u0026#34;he\u0026#34;); boolean endsWith = s.endsWith(\u0026#34;lo\u0026#34;); // 转换 char[] chars = s.toCharArray(); // 转字符数组 byte[] bytes = s.getBytes(); // 转字节数组 StringBuilder - 可变字符串 使用场景：单线程环境下需要频繁修改字符串\n// 初始化 StringBuilder sb = new StringBuilder(); StringBuilder sb2 = new StringBuilder(\u0026#34;hello\u0026#34;); StringBuilder sb3 = new StringBuilder(100); // 指定初始容量 // 添加（拼接） sb.append(\u0026#34;hello\u0026#34;); // 尾部添加 sb.append(123); // 添加数字 sb.append(\u0026#39;!\u0026#39;); // 添加字符 sb.insert(0, \u0026#34;start \u0026#34;); // 指定位置插入 // 删除 sb.delete(0, 5); // 删除 [0, 5) sb.deleteCharAt(0); // 删除指定位置 sb.setLength(0); // 清空（重置长度为0） // 修改 sb.replace(0, 5, \u0026#34;world\u0026#34;); // 替换 [0, 5) sb.setCharAt(0, \u0026#39;H\u0026#39;); // 修改指定位置字符 // 反转 sb.reverse(); // 查询 int len = sb.length(); char ch = sb.charAt(0); String sub = sb.substring(0, 5); // 转换为 String String result = sb.toString(); // 常见应用：循环拼接字符串 StringBuilder result = new StringBuilder(); for (int i = 0; i \u0026lt; 1000; i++) { result.append(i).append(\u0026#34;,\u0026#34;); } // 比用 String + 拼接快得多！ StringBuffer - 可变字符串 使用场景：多线程环境下需要频繁修改字符串\n// API 与 StringBuilder 完全相同 StringBuffer sb = new StringBuffer(); sb.append(\u0026#34;hello\u0026#34;); sb.append(\u0026#34; world\u0026#34;); String result = sb.toString(); // 区别：StringBuffer 的方法都是 synchronized 的 // 多线程安全，但性能比 StringBuilder 差 常用字符串操作技巧 // 1. 字符串转数字 int num = Integer.parseInt(\u0026#34;123\u0026#34;); long l = Long.parseLong(\u0026#34;123\u0026#34;); double d = Double.parseDouble(\u0026#34;3.14\u0026#34;); // 2. 数字转字符串 String s1 = String.valueOf(123); String s2 = Integer.toString(123); String s3 = \u0026#34;\u0026#34; + 123; // 不推荐 // 3. 字符串数组拼接 String[] arr = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; String joined = String.join(\u0026#34;,\u0026#34;, arr); // \u0026#34;a,b,c\u0026#34; // 4. 重复字符串（Java 11+） String repeated = \u0026#34;ab\u0026#34;.repeat(3); // \u0026#34;ababab\u0026#34; // 5. 判断空字符串 if (s != null \u0026amp;\u0026amp; !s.isEmpty()) { } if (s != null \u0026amp;\u0026amp; !s.isBlank()) { } // Java 11+，忽略空白字符 // 6. 字符串格式化 String formatted = String.format(\u0026#34;Hello %s, you are %d years old\u0026#34;, \u0026#34;Alice\u0026#34;, 25); 1. List - 列表 ArrayList - 动态数组 // 初始化 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); List\u0026lt;Integer\u0026gt; list3 = new ArrayList\u0026lt;\u0026gt;(100); // 指定初始容量 // 增 list.add(1); // 尾部添加 list.add(0, 10); // 指定位置添加 list.addAll(Arrays.asList(2,3,4)); // 批量添加 // 删 list.remove(0); // 删除指定索引 list.remove(Integer.valueOf(1)); // 删除指定元素 list.clear(); // 清空 // 改 list.set(0, 100); // 修改指定位置 // 查 int val = list.get(0); // 获取元素 int size = list.size(); // 获取大小 boolean empty = list.isEmpty(); // 是否为空 boolean contains = list.contains(1); // 是否包含 int index = list.indexOf(1); // 查找索引 // 遍历 for (int num : list) { System.out.println(num); } // 或使用迭代器 Iterator\u0026lt;Integer\u0026gt; it = list.iterator(); while (it.hasNext()) { System.out.println(it.next()); } LinkedList - 双向链表 LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 头部操作 list.addFirst(1); list.removeFirst(); int first = list.getFirst(); // 尾部操作 list.addLast(2); list.removeLast(); int last = list.getLast(); // 作为队列使用 list.offer(3); // 入队 int head = list.poll(); // 出队 // 作为栈使用 list.push(4); // 入栈 int top = list.pop(); // 出栈 2. Set - 集合 HashSet - 无序不重复 // 初始化 Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); // 增 set.add(1); set.addAll(Arrays.asList(2, 3, 4)); // 删 set.remove(1); set.clear(); // 查 boolean contains = set.contains(1); int size = set.size(); boolean empty = set.isEmpty(); // 遍历 for (int num : set) { System.out.println(num); } TreeSet - 有序集合（红黑树） TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 基本操作同 HashSet set.add(3); set.add(1); set.add(2); System.out.println(set); // [1, 2, 3] 自动排序 // 特有方法 int first = set.first(); // 最小元素 int last = set.last(); // 最大元素 int lower = set.lower(2); // 小于 2 的最大元素 int higher = set.higher(2); // 大于 2 的最小元素 int floor = set.floor(2); // ≤ 2 的最大元素 int ceiling = set.ceiling(2); // ≥ 2 的最小元素 // 子集操作 SortedSet\u0026lt;Integer\u0026gt; subset = set.subSet(1, 3); // [1, 3) SortedSet\u0026lt;Integer\u0026gt; headSet = set.headSet(2); // \u0026lt; 2 SortedSet\u0026lt;Integer\u0026gt; tailSet = set.tailSet(2); // \u0026gt;= 2 LinkedHashSet - 保持插入顺序 Set\u0026lt;Integer\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); set.add(3); set.add(1); set.add(2); System.out.println(set); // [3, 1, 2] 保持插入顺序 3. Map - 映射 HashMap - 键值对 // 初始化 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 增/改 map.put(\u0026#34;apple\u0026#34;, 1); map.put(\u0026#34;banana\u0026#34;, 2); map.putIfAbsent(\u0026#34;apple\u0026#34;, 10); // 键不存在时才添加 // 删 map.remove(\u0026#34;apple\u0026#34;); map.clear(); // 查 int val = map.get(\u0026#34;apple\u0026#34;); int valOrDefault = map.getOrDefault(\u0026#34;orange\u0026#34;, 0); boolean hasKey = map.containsKey(\u0026#34;apple\u0026#34;); boolean hasValue = map.containsValue(1); int size = map.size(); // 遍历键值对 for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { String key = entry.getKey(); int value = entry.getValue(); } // 遍历键 for (String key : map.keySet()) { System.out.println(key); } // 遍历值 for (int value : map.values()) { System.out.println(value); } // Java 8+ 新方法 map.computeIfAbsent(\u0026#34;cherry\u0026#34;, k -\u0026gt; 3); map.merge(\u0026#34;apple\u0026#34;, 1, Integer::sum); // 累加 TreeMap - 有序映射（红黑树） TreeMap\u0026lt;Integer, String\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); map.put(3, \u0026#34;c\u0026#34;); map.put(1, \u0026#34;a\u0026#34;); map.put(2, \u0026#34;b\u0026#34;); // 基本操作同 HashMap // 特有方法 int firstKey = map.firstKey(); int lastKey = map.lastKey(); Map.Entry\u0026lt;Integer, String\u0026gt; firstEntry = map.firstEntry(); Map.Entry\u0026lt;Integer, String\u0026gt; lastEntry = map.lastEntry(); int lowerKey = map.lowerKey(2); // \u0026lt; 2 的最大键 int higherKey = map.higherKey(2); // \u0026gt; 2 的最小键 int floorKey = map.floorKey(2); // \u0026lt;= 2 的最大键 int ceilingKey = map.ceilingKey(2); // \u0026gt;= 2 的最小键 LinkedHashMap - 保持插入顺序 Map\u0026lt;String, Integer\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;c\u0026#34;, 3); map.put(\u0026#34;a\u0026#34;, 1); map.put(\u0026#34;b\u0026#34;, 2); // 遍历时保持插入顺序: c, a, b 4. Queue - 队列 普通队列 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 入队 queue.offer(1); queue.add(2); // 队列满时抛异常 // 出队 int head = queue.poll(); // 空时返回 null int head2 = queue.remove(); // 空时抛异常 // 查看队首 int peek = queue.peek(); // 空时返回 null int peek2 = queue.element(); // 空时抛异常 PriorityQueue - 优先队列（堆） // 小根堆（默认） PriorityQueue\u0026lt;Integer\u0026gt; minHeap = new PriorityQueue\u0026lt;\u0026gt;(); // 大根堆 PriorityQueue\u0026lt;Integer\u0026gt; maxHeap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); // 自定义对象 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); minHeap.offer(3); minHeap.offer(1); minHeap.offer(2); while (!minHeap.isEmpty()) { System.out.println(minHeap.poll()); // 1, 2, 3 } Deque - 双端队列 Deque\u0026lt;Integer\u0026gt; deque = new ArrayDeque\u0026lt;\u0026gt;(); // 头部操作 deque.offerFirst(1); deque.pollFirst(); deque.peekFirst(); // 尾部操作 deque.offerLast(2); deque.pollLast(); deque.peekLast(); // 作为栈使用 deque.push(3); int top = deque.pop(); 5. Stack - 栈 Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(1); // 入栈 int top = stack.pop(); // 出栈 int peek = stack.peek(); // 查看栈顶 boolean empty = stack.isEmpty(); int size = stack.size(); // 推荐使用 Deque 代替 Stack Deque\u0026lt;Integer\u0026gt; stack2 = new ArrayDeque\u0026lt;\u0026gt;(); 🧮 Part 2: 算法模板 1. 树的遍历 二叉树定义 class TreeNode { int val; // 节点值 TreeNode left; // 左子节点 TreeNode right; // 右子节点 TreeNode(int val) { this.val = val; } } DFS - 深度优先遍历 前序遍历（根-左-右） // 递归版本 - 最简洁直观 void preorder(TreeNode root) { if (root == null) return; // 递归终止条件：空节点 System.out.println(root.val); // 1. 先访问根节点 preorder(root.left); // 2. 再遍历左子树 preorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 使用栈模拟递归 List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); // 根节点入栈 while (!stack.isEmpty()) { TreeNode node = stack.pop(); // 弹出栈顶节点 res.add(node.val); // 访问该节点 // 关键：先压右子节点，再压左子节点 // 这样出栈时左子节点先出（栈是后进先出） if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); } return res; } 中序遍历（左-根-右） // 递归版本 void inorder(TreeNode root) { if (root == null) return; // 递归终止条件 inorder(root.left); // 1. 先遍历左子树 System.out.println(root.val); // 2. 再访问根节点 inorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 一直向左走到底 List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode curr = root; while (curr != null || !stack.isEmpty()) { // 第一步：一直向左走到底，沿途节点入栈 while (curr != null) { stack.push(curr); curr = curr.left; } // 第二步：弹出栈顶（当前最左节点），访问它 curr = stack.pop(); res.add(curr.val); // 第三步：转向右子树 curr = curr.right; } return res; } 后序遍历（左-右-根） // 递归版本 void postorder(TreeNode root) { if (root == null) return; // 递归终止条件 postorder(root.left); // 1. 先遍历左子树 postorder(root.right); // 2. 再遍历右子树 System.out.println(root.val); // 3. 最后访问根节点 } // 迭代版本 - 巧妙方法：前序遍历变形 + 反转 // 思路：前序是\u0026#34;根左右\u0026#34;，改成\u0026#34;根右左\u0026#34;，反转后得到\u0026#34;左右根\u0026#34; List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); res.add(node.val); // 添加到结果（根右左顺序） // 注意：这里先左后右，出栈时就是先右后左 if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); } Collections.reverse(res); // 反转得到左右根 return res; } BFS - 层序遍历 // 按层遍历二叉树，每层的节点放在一个列表中 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); // 根节点入队 while (!queue.isEmpty()) { int size = queue.size(); // 当前层的节点数（重要！） List\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); // 遍历当前层的所有节点 for (int i = 0; i \u0026lt; size; i++) { TreeNode node = queue.poll(); // 出队 level.add(node.val); // 记录节点值 // 将下一层的节点入队 if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } res.add(level); // 保存当前层结果 } return res; } 线段树（Segment Tree） /** * 线段树：用于高效处理区间查询和单点修改 * 时间复杂度：构建 O(n)，查询 O(log n)，更新 O(log n) */ class SegmentTree { private int[] tree; // 线段树数组 private int n; // 原数组大小 public SegmentTree(int[] nums) { n = nums.length; tree = new int[4 * n]; // 线段树最多需要 4n 空间 build(nums, 0, 0, n - 1); } // 构建线段树：递归构建 // node: 当前节点在 tree 中的索引 // start, end: 当前节点代表的区间 [start, end] private void build(int[] nums, int node, int start, int end) { if (start == end) { // 叶子节点：直接存储原数组的值 tree[node] = nums[start]; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; // 左子节点索引 int rightNode = 2 * node + 2; // 右子节点索引 // 递归构建左右子树 build(nums, leftNode, start, mid); build(nums, rightNode, mid + 1, end); // 当前节点的值 = 左子树 + 右子树（区间和） tree[node] = tree[leftNode] + tree[rightNode]; } // 区间查询：查询区间 [l, r] 的和 public int query(int l, int r) { return query(0, 0, n - 1, l, r); } private int query(int node, int start, int end, int l, int r) { // 情况1：当前区间与查询区间完全不相交 if (l \u0026gt; end || r \u0026lt; start) return 0; // 情况2：当前区间完全包含在查询区间内 if (l \u0026lt;= start \u0026amp;\u0026amp; end \u0026lt;= r) return tree[node]; // 情况3：部分相交，需要递归查询左右子树 int mid = start + (end - start) / 2; int leftSum = query(2 * node + 1, start, mid, l, r); int rightSum = query(2 * node + 2, mid + 1, end, l, r); return leftSum + rightSum; } // 单点更新：将 index 位置的值更新为 val public void update(int index, int val) { update(0, 0, n - 1, index, val); } private void update(int node, int start, int end, int index, int val) { if (start == end) { // 找到叶子节点，更新值 tree[node] = val; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; int rightNode = 2 * node + 2; // 判断 index 在左子树还是右子树 if (index \u0026lt;= mid) { update(leftNode, start, mid, index, val); } else { update(rightNode, mid + 1, end, index, val); } // 更新完子树后，更新当前节点 tree[node] = tree[leftNode] + tree[rightNode]; } } 2. 图算法 图的表示 // 方式1：邻接表（适合稀疏图） Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; graph = new HashMap\u0026lt;\u0026gt;(); // 或使用 ArrayList List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); // 方式2：邻接矩阵（适合密集图） int[][] graph = new int[n][n]; // graph[i][j] 表示 i 到 j 的边权 DFS - 图的深度优先遍历 // 递归实现 DFS void dfs(int node, Set\u0026lt;Integer\u0026gt; visited, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { visited.add(node); // 标记当前节点已访问 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { // 如果邻居未访问 dfs(neighbor, visited, graph); // 递归访问邻居 } } } // 使用示例 Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); dfs(0, visited, graph); // 从节点 0 开始 DFS BFS - 图的广度优先遍历 // 使用队列实现 BFS void bfs(int start, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(start); // 起始节点入队 visited.add(start); // 标记已访问 while (!queue.isEmpty()) { int node = queue.poll(); // 出队 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { queue.offer(neighbor); // 邻居入队 visited.add(neighbor); // 标记已访问 } } } } 拓扑排序（Kahn 算法） /** * 拓扑排序：将有向无环图(DAG)转换为线性序列 * 应用：课程安排、任务调度等 * 核心思想：不断移除入度为0的节点 */ List\u0026lt;Integer\u0026gt; topologicalSort(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] inDegree = new int[n]; // 记录每个节点的入度 for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } // 构建图并计算入度 for (int[] edge : edges) { graph.get(edge[0]).add(edge[1]); // edge[0] -\u0026gt; edge[1] inDegree[edge[1]]++; // edge[1] 的入度+1 } // 将所有入度为0的节点入队 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (inDegree[i] == 0) { queue.offer(i); } } List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); while (!queue.isEmpty()) { int node = queue.poll(); res.add(node); // 将节点加入结果 // 删除该节点的所有出边 for (int neighbor : graph.get(node)) { inDegree[neighbor]--; // 邻居的入度-1 if (inDegree[neighbor] == 0) { // 入度变为0，入队 queue.offer(neighbor); } } } // 如果所有节点都被访问，说明无环，返回结果；否则返回空 return res.size() == n ? res : new ArrayList\u0026lt;\u0026gt;(); } Dijkstra 最短路径算法 /** * Dijkstra算法：单源最短路径（不能有负权边） * 时间复杂度：O(E log V)，E是边数，V是顶点数 * 核心思想：贪心，每次选择距离最小的未访问节点 */ int[] dijkstra(int n, int[][] edges, int start) { // 构建邻接表: {neighbor, weight} List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // edge = [from, to, weight] graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); } // dist[i] 表示从 start 到 i 的最短距离 int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 优先队列: {distance, node}，按距离从小到大排序 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); pq.offer(new int[]{0, start}); while (!pq.isEmpty()) { int[] curr = pq.poll(); int d = curr[0], node = curr[1]; // 如果当前距离大于已知最短距离，跳过 if (d \u0026gt; dist[node]) continue; // 遍历所有邻居，尝试松弛操作 for (int[] neighbor : graph.get(node)) { int next = neighbor[0], weight = neighbor[1]; int newDist = d + weight; // 如果找到更短的路径，更新距离 if (newDist \u0026lt; dist[next]) { dist[next] = newDist; pq.offer(new int[]{newDist, next}); } } } return dist; } Bellman-Ford 算法（可处理负权边） /** * Bellman-Ford算法：单源最短路径，可处理负权边 * 时间复杂度：O(V * E) * 可以检测负环 */ int[] bellmanFord(int n, int[][] edges, int start) { int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 松弛操作：最多进行 n-1 次 // 原理：最短路径最多包含 n-1 条边 for (int i = 0; i \u0026lt; n - 1; i++) { for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; // 松弛操作：如果经过 u 到 v 更短，则更新 if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { dist[v] = dist[u] + w; } } } // 第 n 次松弛：如果还能更新，说明存在负环 for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { return null; // 存在负环 } } return dist; } Floyd-Warshall 全源最短路径 /** * Floyd-Warshall算法：计算所有点对之间的最短路径 * 时间复杂度：O(V³) * 核心思想：动态规划，逐步加入中间节点 */ int[][] floydWarshall(int n, int[][] edges) { int[][] dist = new int[n][n]; // 初始化距离矩阵 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(dist[i], Integer.MAX_VALUE / 2); // 除以2防止溢出 dist[i][i] = 0; // 自己到自己距离为0 } // 填入边的权重 for (int[] edge : edges) { dist[edge[0]][edge[1]] = edge[2]; } // 动态规划：k 是中间节点 // dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) for (int k = 0; k \u0026lt; n; k++) { // 枚举中间节点 for (int i = 0; i \u0026lt; n; i++) { // 枚举起点 for (int j = 0; j \u0026lt; n; j++) { // 枚举终点 // 如果经过 k 中转更短，则更新 dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]); } } } return dist; } Prim 最小生成树 /** * Prim算法：构建最小生成树 * 时间复杂度：O(E log V) * 核心思想：从一个节点开始，逐步扩展，每次选最小边 */ int prim(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // 无向图：添加双向边 graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); graph.get(edge[1]).add(new int[]{edge[0], edge[2]}); } boolean[] visited = new boolean[n]; // 优先队列：{node, weight}，按权重从小到大 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[1] - b[1]); pq.offer(new int[]{0, 0}); // 从节点0开始，权重0 int totalWeight = 0; // 最小生成树的总权重 int edgeCount = 0; // 已添加的边数 while (!pq.isEmpty() \u0026amp;\u0026amp; edgeCount \u0026lt; n) { int[] curr = pq.poll(); int node = curr[0], weight = curr[1]; if (visited[node]) continue; // 已访问，跳过 visited[node] = true; totalWeight += weight; // 加入最小生成树 edgeCount++; // 将邻居节点的边加入优先队列 for (int[] neighbor : graph.get(node)) { if (!visited[neighbor[0]]) { pq.offer(neighbor); } } } // 如果所有节点都连通，返回总权重；否则返回-1 return edgeCount == n ? totalWeight : -1; } Kruskal 最小生成树（并查集） /** * 并查集：用于判断连通性和合并集合 */ class UnionFind { int[] parent; // parent[i] 表示 i 的父节点 int[] rank; // rank[i] 表示以 i 为根的树的高度 public UnionFind(int n) { parent = new int[n]; rank = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; // 初始时每个节点的父节点是自己 } } // 查找：找到 x 所在集合的代表元素（路径压缩） public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); // 路径压缩：直接连到根节点 } return parent[x]; } // 合并：将 x 和 y 所在的集合合并（按秩合并） public boolean union(int x, int y) { int rootX = find(x), rootY = find(y); if (rootX == rootY) return false; // 已经在同一集合 // 按秩合并：将矮树挂到高树上 if (rank[rootX] \u0026lt; rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] \u0026gt; rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; // 高度相同，随便挂，高度+1 } return true; } } /** * Kruskal算法：构建最小生成树 * 时间复杂度：O(E log E) * 核心思想：按边权从小到大排序，用并查集避免成环 */ int kruskal(int n, int[][] edges) { // 按边权从小到大排序 Arrays.sort(edges, (a, b) -\u0026gt; a[2] - b[2]); UnionFind uf = new UnionFind(n); int totalWeight = 0; int edgeCount = 0; for (int[] edge : edges) { // 如果两个节点不在同一集合，添加这条边 if (uf.union(edge[0], edge[1])) { totalWeight += edge[2]; edgeCount++; if (edgeCount == n - 1) break; // 最小生成树有 n-1 条边 } } return edgeCount == n - 1 ? totalWeight : -1; } 3. 回溯算法 组合问题 /** * 组合问题：从 n 个数中选 k 个数的所有组合 * 例如：n=4, k=2 -\u0026gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), 1, n, k); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int start, int n, int k) { // 递归终止条件：已选择 k 个数 if (path.size() == k) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 注意：要复制一份 return; } // 从 start 开始枚举，避免重复 for (int i = start; i \u0026lt;= n; i++) { path.add(i); // 做选择 backtrack(res, path, i + 1, n, k); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } 全排列 /** * 全排列问题：给定数组，返回所有可能的排列 * 例如：[1,2,3] -\u0026gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, new boolean[nums.length]); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, boolean[] used) { // 递归终止条件：所有数字都已使用 if (path.size() == nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } // 枚举所有数字 for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) continue; // 已使用过，跳过 path.add(nums[i]); // 做选择 used[i] = true; // 标记已使用 backtrack(res, path, nums, used); // 递归 used[i] = false; // 撤销标记（回溯） path.remove(path.size() - 1); // 撤销选择（回溯） } } 子集问题 /** * 子集问题：返回数组的所有子集（幂集） * 例如：[1,2,3] -\u0026gt; [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, int start) { // 每个状态都是一个子集 res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 枚举后续元素 for (int i = start; i \u0026lt; nums.length; i++) { path.add(nums[i]); // 做选择 backtrack(res, path, nums, i + 1); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } N 皇后问题 /** * N皇后问题：在 n×n 的棋盘上放置 n 个皇后，使它们互不攻击 * 规则：任意两个皇后不能在同一行、同一列、同一对角线 */ List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); char[][] board = new char[n][n]; // 初始化棋盘：\u0026#39;.\u0026#39; 表示空位 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(board[i], \u0026#39;.\u0026#39;); } backtrack(res, board, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res, char[][] board, int row) { // 递归终止条件：所有行都放置完成 if (row == board.length) { res.add(construct(board)); // 将棋盘转换为字符串列表 return; } // 尝试在当前行的每一列放置皇后 for (int col = 0; col \u0026lt; board.length; col++) { if (!isValid(board, row, col)) continue; // 不合法，跳过 board[row][col] = \u0026#39;Q\u0026#39;; // 放置皇后 backtrack(res, board, row + 1); // 递归下一行 board[row][col] = \u0026#39;.\u0026#39;; // 撤销放置（回溯） } } // 检查在 (row, col) 位置放置皇后是否合法 boolean isValid(char[][] board, int row, int col) { int n = board.length; // 检查列：同一列不能有其他皇后 for (int i = 0; i \u0026lt; row; i++) { if (board[i][col] == \u0026#39;Q\u0026#39;) return false; } // 检查左上对角线 for (int i = row - 1, j = col - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } // 检查右上对角线 for (int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } return true; } // 将棋盘转换为字符串列表 List\u0026lt;String\u0026gt; construct(char[][] board) { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for (char[] row : board) { res.add(new String(row)); } return res; } 4. 动态规划 0-1 背包问题 /** * 0-1背包：每个物品只能选一次 * weights[i]: 第i个物品的重量 * values[i]: 第i个物品的价值 * capacity: 背包容量 * 返回：最大价值 */ int knapsack(int[] weights, int[] values, int capacity) { int n = weights.length; // dp[i][w] 表示前 i 个物品，背包容量为 w 时的最大价值 int[][] dp = new int[n + 1][capacity + 1]; for (int i = 1; i \u0026lt;= n; i++) { for (int w = 0; w \u0026lt;= capacity; w++) { // 如果当前物品的重量 \u0026lt;= 背包容量 if (weights[i - 1] \u0026lt;= w) { // 选择：max(不拿, 拿) dp[i][w] = Math.max( dp[i - 1][w], // 不拿第i个物品 dp[i - 1][w - weights[i - 1]] + values[i - 1] // 拿第i个物品 ); } else { // 放不下，只能不拿 dp[i][w] = dp[i - 1][w]; } } } return dp[n][capacity]; } /** * 0-1背包 - 空间优化版本 * 时间复杂度：O(n * capacity) * 空间复杂度：O(capacity) */ int knapsackOptimized(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：必须从后往前遍历，避免重复使用同一物品 for (int w = capacity; w \u0026gt;= weights[i]; w--) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 完全背包问题 /** * 完全背包：每个物品可以选无限次 * 与0-1背包的区别：内层循环从前往后遍历 */ int completeKnapsack(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：从前往后遍历，允许重复使用物品 for (int w = weights[i]; w \u0026lt;= capacity; w++) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 最长公共子序列（LCS） /** * 最长公共子序列：找两个字符串的最长公共子序列长度 * 子序列：不要求连续 * 例如：\u0026#34;abcde\u0026#34; 和 \u0026#34;ace\u0026#34; 的LCS是 \u0026#34;ace\u0026#34;，长度为3 */ int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); // dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的LCS长度 int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (text1.charAt(i - 1) == text2.charAt(j - 1)) { // 字符相同：LCS长度+1 dp[i][j] = dp[i - 1][j - 1] + 1; } else { // 字符不同：取两种情况的最大值 dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; } 最长递增子序列（LIS） /** * 最长递增子序列 - O(n²) 动态规划解法 * dp[i] 表示以 nums[i] 结尾的最长递增子序列长度 */ int lengthOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; Arrays.fill(dp, 1); // 初始每个元素自己构成长度为1的子序列 int maxLen = 1; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { // 如果 nums[i] 可以接在 nums[j] 后面 if (nums[i] \u0026gt; nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } maxLen = Math.max(maxLen, dp[i]); } return maxLen; } /** * 最长递增子序列 - O(n log n) 二分解法 * tails[i] 表示长度为 i+1 的递增子序列的最小尾部元素 */ int lengthOfLISBinary(int[] nums) { List\u0026lt;Integer\u0026gt; tails = new ArrayList\u0026lt;\u0026gt;(); for (int num : nums) { // 二分查找：找到第一个 \u0026gt;= num 的位置 int left = 0, right = tails.size(); while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (tails.get(mid) \u0026lt; num) { left = mid + 1; } else { right = mid; } } // 如果 num 比所有元素都大，追加到末尾 if (left == tails.size()) { tails.add(num); } else { // 否则替换找到的位置 tails.set(left, num); } } return tails.size(); } 编辑距离 /** * 编辑距离：将 word1 转换为 word2 的最少操作次数 * 操作：插入、删除、替换 * 例如：\u0026#34;horse\u0026#34; -\u0026gt; \u0026#34;ros\u0026#34; 需要3步（删除h、删除r、替换s） */ int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); // dp[i][j] 表示 word1[0..i-1] 转换为 word2[0..j-1] 的最少操作数 int[][] dp = new int[m + 1][n + 1]; // 边界条件：一个字符串为空 for (int i = 0; i \u0026lt;= m; i++) dp[i][0] = i; // word1 -\u0026gt; 空串：删除i个字符 for (int j = 0; j \u0026lt;= n; j++) dp[0][j] = j; // 空串 -\u0026gt; word2：插入j个字符 for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { // 字符相同：不需要操作 dp[i][j] = dp[i - 1][j - 1]; } else { // 字符不同：三种操作取最小 dp[i][j] = Math.min( Math.min( dp[i - 1][j], // 删除 word1[i-1] dp[i][j - 1] // 插入 word2[j-1] ), dp[i - 1][j - 1] // 替换 word1[i-1] 为 word2[j-1] ) + 1; } } } return dp[m][n]; } 股票买卖问题 只能买卖一次\n/** * 买卖股票的最佳时机 I：只能买卖一次 * 贪心思想：记录最低价格，计算每天卖出的最大利润 */ int maxProfit(int[] prices) { int minPrice = Integer.MAX_VALUE; // 记录目前为止的最低价格 int maxProfit = 0; // 记录最大利润 for (int price : prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; } 可以买卖多次\n/** * 买卖股票的最佳时机 II：可以买卖多次 * 贪心思想：只要今天价格比昨天高，就在昨天买今天卖 */ int maxProfitMultiple(int[] prices) { int profit = 0; for (int i = 1; i \u0026lt; prices.length; i++) { // 如果今天价格更高，累加差价 if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } 最多买卖 k 次\n/** * 买卖股票的最佳时机 III/IV：最多买卖 k 次 * dp[i][j] 表示第 i 次交易后，第 j 天的最大利润 */ int maxProfitK(int k, int[] prices) { if (prices.length == 0) return 0; int n = prices.length; // 如果 k \u0026gt;= n/2，相当于无限次交易 if (k \u0026gt;= n / 2) { int profit = 0; for (int i = 1; i \u0026lt; n; i++) { if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } int[][] dp = new int[k + 1][n]; for (int i = 1; i \u0026lt;= k; i++) { int maxDiff = -prices[0]; // 第 i-1 次交易后买入的最大收益 for (int j = 1; j \u0026lt; n; j++) { // 不操作 vs 卖出 dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff); // 更新买入的最大收益 maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]); } } return dp[k][n - 1]; } 打家劫舍 /** * 打家劫舍 I：线性排列的房屋 * 不能抢相邻的房屋 * dp[i] = max(dp[i-1], dp[i-2] + nums[i]) */ int rob(int[] nums) { if (nums.length == 0) return 0; if (nums.length == 1) return nums[0]; int prev2 = 0, prev1 = 0; // prev2: dp[i-2], prev1: dp[i-1] for (int num : nums) { int temp = prev1; // 不抢 vs 抢 prev1 = Math.max(prev1, prev2 + num); prev2 = temp; } return prev1; } /** * 打家劫舍 II：环形排列的房屋 * 第一个和最后一个房屋相邻 * 思路：分两种情况，取最大值 * 1. 抢第一个房屋，不抢最后一个 * 2. 不抢第一个房屋，抢最后一个 */ int robCircular(int[] nums) { if (nums.length == 1) return nums[0]; return Math.max( robRange(nums, 0, nums.length - 2), robRange(nums, 1, nums.length - 1) ); } int robRange(int[] nums, int start, int end) { int prev2 = 0, prev1 = 0; for (int i = start; i \u0026lt;= end; i++) { int temp = prev1; prev1 = Math.max(prev1, prev2 + nums[i]); prev2 = temp; } return prev1; } 分割等和子集 /** * 分割等和子集：判断是否能将数组分成两个和相等的子集 * 本质：0-1背包问题，目标是找到和为 sum/2 的子集 */ boolean canPartition(int[] nums) { int sum = 0; for (int num : nums) sum += num; if (sum % 2 != 0) return false; // 和为奇数，不可能分割 int target = sum / 2; // dp[j] 表示能否凑出和为 j boolean[] dp = new boolean[target + 1]; dp[0] = true; // 和为0总是可以（不选任何数） for (int num : nums) { // 从后往前遍历，避免重复使用 for (int j = target; j \u0026gt;= num; j--) { dp[j] = dp[j] || dp[j - num]; // 不选 num 或 选 num } } return dp[target]; } 零钱兑换 /** * 零钱兑换 I：最少硬币数 * dp[i] 表示凑出金额 i 所需的最少硬币数 */ int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); // 初始化为不可能的大值 dp[0] = 0; // 凑出0元需要0个硬币 for (int i = 1; i \u0026lt;= amount; i++) { for (int coin : coins) { if (i \u0026gt;= coin) { // 选择使用当前硬币 dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } } return dp[amount] \u0026gt; amount ? -1 : dp[amount]; } /** * 零钱兑换 II：组成方案数 * dp[i] 表示凑出金额 i 的方案数 */ int change(int amount, int[] coins) { int[] dp = new int[amount + 1]; dp[0] = 1; // 凑出0元有1种方案（不选） // 外层遍历硬币，内层遍历金额（避免重复计数） for (int coin : coins) { for (int i = coin; i \u0026lt;= amount; i++) { dp[i] += dp[i - coin]; } } return dp[amount]; } 5. 双指针 对撞指针 // 两数之和（有序数组） int[] twoSum(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[left] + nums[right]; if (sum == target) { return new int[]{left, right}; } else if (sum \u0026lt; target) { left++; } else { right--; } } return new int[]{-1, -1}; } // 三数之和 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length - 2; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { res.add(Arrays.asList(nums[i], nums[left], nums[right])); while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; left++; right--; } else if (sum \u0026lt; 0) { left++; } else { right--; } } } return res; } 快慢指针 // 链表中点 ListNode findMiddle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } // 环形链表 boolean hasCycle(ListNode head) { if (head == null) return false; ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) return true; } return false; } // 找环的入口 ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { slow = head; while (slow != fast) { slow = slow.next; fast = fast.next; } return slow; } } return null; } 6. 单调栈 // 下一个更大元素 int[] nextGreaterElement(int[] nums) { int n = nums.length; int[] res = new int[n]; Arrays.fill(res, -1); Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; nums[stack.peek()] \u0026lt; nums[i]) { int idx = stack.pop(); res[idx] = nums[i]; } stack.push(i); } return res; } // 每日温度 int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] res = new int[n]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[stack.peek()] \u0026lt; temperatures[i]) { int idx = stack.pop(); res[idx] = i - idx; } stack.push(i); } return res; } // 柱状图中最大的矩形 int largestRectangleArea(int[] heights) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(-1); int maxArea = 0; for (int i = 0; i \u0026lt; heights.length; i++) { while (stack.peek() != -1 \u0026amp;\u0026amp; heights[stack.peek()] \u0026gt;= heights[i]) { int h = heights[stack.pop()]; int w = i - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } stack.push(i); } while (stack.peek() != -1) { int h = heights[stack.pop()]; int w = heights.length - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } return maxArea; } 7. 前缀和 // 一维前缀和 class PrefixSum { private int[] preSum; public PrefixSum(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 0; i \u0026lt; nums.length; i++) { preSum[i + 1] = preSum[i] + nums[i]; } } // 查询区间 [left, right] 的和 public int query(int left, int right) { return preSum[right + 1] - preSum[left]; } } // 二维前缀和 class MatrixPrefixSum { private int[][] preSum; public MatrixPrefixSum(int[][] matrix) { int m = matrix.length, n = matrix[0].length; preSum = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } // 查询子矩阵 [row1, col1] 到 [row2, col2] 的和 public int query(int row1, int col1, int row2, int col2) { return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]; } } 📌 总结 这份文档涵盖了：\nJava 集合框架：List、Set、Map、Queue、Stack 的完整使用方法 树算法：DFS、BFS、线段树 图算法：遍历、最短路径、最小生成树 经典算法：回溯、动态规划、二分查找、滑动窗口、双指针、单调栈、前缀和 建议配合 LeetCode 刷题使用，遇到问题时可以快速查阅对应的模板代码。\n持续更新中\u0026hellip; 🚀\n","permalink":"http://localhost:1313/posts/algorithm-with-java/","summary":"详细介绍java集合的使用,以及在刷算法题中需要使用到的一些板子","title":"算法刷题必备：Java集合与算法模板"},{"content":"一、Hugo 常用指令 1.1 创建新站点 # 创建一个新的 Hugo 站点 hugo new site mysite # 进入站点目录 cd mysite 1.2 创建新文章 # 在 content/posts 目录下创建新文章 hugo new posts/my-first-post.md # 在 content 目录下创建文章 hugo new about.md # 创建在特定子目录 hugo new blog/2024/new-post.md 1.3 本地预览 # 启动本地开发服务器（默认 http://localhost:1313） hugo server # 启动并显示草稿文章 hugo server -D # 启动并显示草稿、未来日期和过期的文章 hugo server -DEF # 指定端口 hugo server --port 8080 # 实时重载并打开浏览器 hugo server -D --navigateToChanged 1.4 主题管理 # 添加主题（使用 Git submodule） git submodule add https://github.com/username/theme-name.git themes/theme-name # 更新主题 git submodule update --remote --merge # 删除主题 git submodule deinit -f themes/theme-name rm -rf .git/modules/themes/theme-name git rm -f themes/theme-name 1.5 其他常用指令 # 查看 Hugo 版本 hugo version # 查看帮助 hugo help # 查看配置信息 hugo config # 列出所有内容 hugo list all # 列出草稿 hugo list drafts 二、Markdown Front Matter 配置 2.1 完整配置示例 --- # 基本信息 title: \u0026#34;我的第一篇文章\u0026#34; date: 2025-12-06T15:04:05+08:00 lastmod: 2025-12-07T10:00:00+08:00 draft: false # 作者信息 author: \u0026#34;Minjie\u0026#34; authorLink: \u0026#34;https://github.com/Minjie2003\u0026#34; # 分类和标签 categories: [\u0026#34;技术\u0026#34;] tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;, \u0026#34;博客\u0026#34;] series: [\u0026#34;Hugo教程\u0026#34;] # 摘要和描述 summary: \u0026#34;这是一篇关于 Hugo 和 Markdown 的完整指南\u0026#34; description: \u0026#34;详细介绍 Hugo 的使用方法和 Markdown 配置\u0026#34; # 特色图片 image: \u0026#34;/images/featured.jpg\u0026#34; cover: image: \u0026#34;/images/cover.jpg\u0026#34; alt: \u0026#34;封面图片描述\u0026#34; caption: \u0026#34;图片说明文字\u0026#34; # SEO 相关 keywords: [\u0026#34;Hugo\u0026#34;, \u0026#34;静态博客\u0026#34;, \u0026#34;Markdown\u0026#34;] slug: \u0026#34;hugo-markdown-guide\u0026#34; url: \u0026#34;/posts/hugo-guide/\u0026#34; # 显示控制 toc: true # 显示目录 comments: true # 允许评论 showToc: true # 显示目录 TocOpen: false # 默认展开目录 hidemeta: false # 隐藏元信息 disableShare: false # 禁用分享按钮 hideSummary: false # 隐藏摘要 ShowReadingTime: true # 显示阅读时间 ShowBreadCrumbs: true # 显示面包屑导航 ShowPostNavLinks: true # 显示文章导航链接 # 权重（用于排序） weight: 1 # 外部链接 externalLink: \u0026#34;https://example.com\u0026#34; # 是否在首页显示 showhome: true --- 2.2 常用字段说明 字段 说明 示例 title 文章标题 \u0026quot;我的文章\u0026quot; date 发布日期 2025-12-06 或 2025-12-06T15:04:05+08:00 draft 是否为草稿 true / false tags 标签（数组） [\u0026quot;Hugo\u0026quot;, \u0026quot;博客\u0026quot;] categories 分类（数组） [\u0026quot;技术\u0026quot;, \u0026quot;教程\u0026quot;] summary 文章摘要 \u0026quot;这是摘要\u0026quot; description SEO 描述 \u0026quot;页面描述\u0026quot; slug URL 友好名称 \u0026quot;my-post\u0026quot; url 自定义完整 URL \u0026quot;/posts/my-post/\u0026quot; weight 排序权重 1 (数字越小越靠前) toc 是否显示目录 true / false 三、Hugo Shortcodes（短代码） 3.1 内置 Shortcodes # 显示图片 {{\u0026lt; figure src=\u0026#34;/images/photo.jpg\u0026#34; title=\u0026#34;图片标题\u0026#34; \u0026gt;}} # 高亮文本 {{\u0026lt; highlight python \u0026gt;}} def hello(): print(\u0026#34;Hello!\u0026#34;) {{\u0026lt; /highlight \u0026gt;}} # YouTube 视频 {{\u0026lt; youtube VIDEO_ID \u0026gt;}} # X (Twitter) 推文（新版） {{\u0026lt; x user=\u0026#34;USERNAME\u0026#34; id=\u0026#34;TWEET_ID\u0026#34; \u0026gt;}} # GitHub Gist（已废弃，建议直接嵌入代码） # 可以使用 highlight 或直接用代码块替代 # 参数传递（需要在 Front Matter 中定义参数） {{\u0026lt; param \u0026#34;description\u0026#34; \u0026gt;}} 3.2 自定义 Shortcode 示例 在 layouts/shortcodes/note.html 创建：\n\u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; 使用时：\n{{\u0026lt; note \u0026gt;}} 这是一个提示框 {{\u0026lt; /note \u0026gt;}} 四、Markdown 基本语法 4.1 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 4.2 文本样式 **粗体文字** *斜体文字* ***粗斜体*** ~~删除线~~ `行内代码` 4.3 列表 # 无序列表 - 项目 1 - 项目 2 - 子项目 2.1 - 子项目 2.2 # 有序列表 1. 第一项 2. 第二项 1. 子项 2.1 2. 子项 2.2 4.4 链接和图片 # 链接 [链接文字](https://example.com) [带标题的链接](https://example.com \u0026#34;鼠标悬停显示\u0026#34;) # 图片 ![图片描述](/images/photo.jpg) ![图片](https://example.com/image.jpg \u0026#34;图片标题\u0026#34;) 4.5 引用 \u0026gt; 这是一段引用文字 \u0026gt; 可以多行 \u0026gt;\u0026gt; 嵌套引用 4.6 代码块 ```python def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) ``` ```javascript console.log(\u0026#34;Hello, World!\u0026#34;); ``` 4.7 表格 | 列1 | 列2 | 列3 | |-----|-----|-----| | 数据1 | 数据2 | 数据3 | | 数据4 | 数据5 | 数据6 | # 对齐方式 | 左对齐 | 居中 | 右对齐 | |:-------|:----:|-------:| | 内容 | 内容 | 内容 | 4.8 分隔线 --- *** ___ 4.9 任务列表 - [x] 已完成的任务 - [ ] 未完成的任务 - [ ] 另一个任务 五、实用技巧 5.1 文章模板 在 archetypes/default.md 创建默认模板：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true tags: [] categories: [] summary: \u0026#34;\u0026#34; --- ## 简介 内容开始... 5.2 多语言配置 在 Front Matter 中：\n--- title: \u0026#34;English Title\u0026#34; title.zh: \u0026#34;中文标题\u0026#34; --- 5.3 自定义 URL 结构 在 hugo.toml 中：\n[permalinks] posts = \u0026#34;/:year/:month/:slug/\u0026#34; 5.4 草稿快速发布 # 将草稿改为发布状态 sed -i \u0026#39;s/draft: true/draft: false/\u0026#39; content/posts/my-post.md ","permalink":"http://localhost:1313/posts/hugo-readme/","summary":"详细介绍 Hugo 常用指令、Markdown Front Matter 配置、基本语法和实用技巧的完整指南","title":"Hugo 常用指令与 Markdown 配置指南"},{"content":"👋 嗨，我是 Minjie 很高兴你能来到这里！这是我在互联网上的一个小角落，用来记录代码、想法和生活的点滴。\n🧑‍💻 关于我 我是一名在读研究生，研究方向包括区块链，web3.0，数据库管理等。当然，目前更加专注于 Java 后端开发。相比起\u0026quot;全栈工程师\u0026quot;这样的标签，我更喜欢把自己定义为一个对计算机技术充满好奇心的探索者。\n📖 这个博客写什么 这里主要记录我在技术道路上的成长轨迹，你可能会看到：\n技术笔记 - Java 后端开发的实践经验、框架使用心得、踩过的坑和解决方案\n项目复盘 - 从需求分析到上线部署，记录项目中的思考和收获\n学习记录 - 新技术的探索、算法题的思路、计算机基础知识的整理\n随笔杂谈 - 偶尔也会写写读书笔记、游戏感想，或者对技术趋势的一些思考\n我希望这里不仅是我个人的知识库,也能给同样在技术路上摸索的你带来一些启发或共鸣。\n🎯 技术栈 \u0026amp; 兴趣方向 后端开发：Java、Spring Boot、MyBatis、MySQL、Redis - 这是我的主战场\n折腾爱好：除了后端，我还喜欢写点爬虫玩玩，做些自动化小工具来解决日常遇到的重复性工作。总觉得能用代码解决的事情，就不该浪费时间手动操作。有时候为了实现一个自动化脚本，花的时间可能比手动做还多，但那种\u0026quot;一劳永逸\u0026quot;的快感真的很上头。\n探索中：对各种能提高效率的技术和工具都充满兴趣，正在不断拓展技术边界\u0026hellip;\n🎮 代码之外 游戏时光：Steam 上收藏了不少游戏，也会玩玩王者、原神这些。\n音乐陪伴：写代码的时候总要听点什么。古典音乐能让思路更清晰，ACG 音乐带来满满的回忆，偶尔也会跟着流行音乐哼哼唱唱。喜欢洗澡的时候k歌······当然，也是个半吊子吉他选手\n运动爱好：除了敲键盘，也喜欢出去动一动。篮球、羽毛球、乒乓球都有涉猎，虽然都不算精通，但也能过上两招。过去打篮球多一点，现在更想尝试羽毛球。\n历史爱好者：对历史有种莫名的着迷，喜欢看历史书籍、纪录片。主要包括近现代欧洲历史，唐史，春秋战国。\n💬 来聊聊？ 如果你也对后端开发感兴趣，或者想交流技术、分享项目经验，甚至只是想推荐个好玩的游戏或好听的歌，都欢迎联系我：\n📧 邮箱：zhongnagisa01@gmail.com 🐙 GitHub：Minjie2003 \u0026ldquo;流水不争先，争的是滔滔不绝\u0026rdquo;\n感谢你的访问，希望我们能在这里有更多交流！✨\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于我"},{"content":"论文基本信息 标题: Enhancing trust and privacy in distributed networks: a comprehensive survey on blockchain-based federated learning\n作者: Ji Liu, Chunlu Chen, Yu Li, Lin Sun, Yulun Song, Jingbo Zhou, Bo Jing, Dejing Dou\n发表: Knowledge and Information Systems (2024) 66:4377–4403\n机构: 恒生电子、九州大学、百度、联通数科、波士顿咨询\n一、研究背景 1.1 区块链技术概述 论文首先介绍了区块链的基本概念和特性：\n核心特性：\n去中心化架构：将验证系统从中心化转变为去中心化，通过多个用户的共识来促进验证过程 不可篡改性：通过哈希函数将数据块链接成链，任何篡改尝试都会破坏哈希链，导致不匹配 加密安全：使用哈希函数、数字签名和加密技术保护数据完整性和安全性 透明性：区块链上记录的每笔交易对所有网络参与者透明可见 智能合约：自动执行的协议，按预定义规则执行交易，无需中介 区块链类型：\n类型 访问方式 典型代表 常用共识 无许可链 匿名访问，任何人可加入 Bitcoin, Ethereum PoW, PoS 有许可链 需要注册，限制访问 Hyperledger Fabric Kafka, Raft, PBFT 分布式系统特性：\n去中心化：控制和决策分布在各个节点 共识机制：确保所有节点对系统状态达成一致 容错性：通过冗余、复制和错误处理机制实现 可扩展性：通过增加节点水平扩展 1.2 联邦学习基础 FL基本流程：\n中央服务器初始化模型参数并分发给所有客户端 客户端使用本地数据训练模型 客户端上传训练后的模型参数到中央服务器 中央服务器聚合参数，更新全局模型 重复以上步骤直到模型收敛 FL分类：\n按网络拓扑：\n中心化FL 去中心化FL 按数据可用性：\n跨孤岛FL (Cross-silo) 跨设备FL (Cross-device) 按数据分区：\n横向FL：特征空间相同，样本不同 纵向FL：样本相同，特征空间不同 联邦迁移学习：样本和特征都不同 常见优化算法：FedAvg, FedProx, SCAFFOLD, FedPD, FedBN\n1.3 FL面临的主要挑战 论文总结了FL的三大核心挑战：\n挑战1：数据异构性 三种异构：\n特征异构：参与设备拥有不同的特征集，使模型聚合和对齐变得困难 数据分布异构：由于用户群体、地理位置、数据收集实践的差异，导致数据分布不同，可能引入偏见 数据格式异构：来自不同来源或平台的数据可能具有不同的格式、表示或结构 解决技术：\n模型架构调整和特征工程 元学习和域适应 多格式设计的模型 挑战2：隐私与安全 主要威胁：\n数据泄露：共享模型可能包含训练数据的敏感信息 成员推理攻击：对手试图确定特定数据点是否属于训练数据集 模型投毒攻击：对手注入恶意数据或操纵本地更新以毒化共享模型 防御技术：\n差分隐私(DP)：向数据或模型更新添加噪声以模糊个体贡献 同态加密(HE)：允许对加密数据进行计算 安全多方计算(SMPC)：多方在不暴露私有数据的情况下联合计算 可信执行环境(TEE)：如TrustFL方案 挑战3：可追溯性与问责性 可追溯性需求：\n模型审计：通过记录元数据（模型架构、超参数、数据源）跟踪和审计FL中训练的模型 数据溯源：追踪训练数据的来源和历史，确保真实性并评估潜在偏见 问责性需求：\n参与者问责：参与者应遵守商定的协议、隐私措施和安全实践 安全与信任维护：实施适当的安全措施，保护数据机密性，防止未授权访问或恶意活动 面临的困难：\nFL的去中心化结构使协调和建立共识变得复杂 在保护隐私的同时确保可追溯性需要平衡 数据分散在不同参与者之间，追踪数据来源和血统面临挑战 1.4 整合区块链与FL的必要性 论文论述了结合区块链和FL的三大核心价值：\n价值1：激励机制 传统FL中，许多客户端由于经济理性不愿分享有价值的数据 区块链原生的加密货币或代币系统可建立激励机制 通过奖励数据贡献者、模型验证者和其他参与者，激励积极参与、数据共享和模型改进 价值2：增强数据隐私与安全 解决中心化风险：传统FL严重依赖单一中央服务器，如果服务器恶意行为，整个系统可能崩溃 防御客户端攻击：现有设计容易受到恶意客户端的攻击，可能上传有毒模型攻击FL网络 区块链优势： 去中心化和不可变的特性提供安全透明的数据共享和存储框架 加密方法显著增强数据隐私和安全 参与者可以验证共享模型的完整性和真实性，而不暴露敏感信息 价值3：信任与透明 区块链固有的透明性和可审计性可以解决FL中的信任问题 使参与者能够追踪数据、模型和计算的历史和来源 透明性在参与者之间培养信任，因为他们可以验证FL过程的公平性和可靠性 二、BCFL系统架构 2.1 整体架构概览 论文提出从底向上的五层架构（加上贯穿的区块链共识层）：\n┌─────────────────────────────────────────────┐ │ 应用层 (Application Layer) │ │ 医疗 | 车联网 | 边缘计算 | 能源 | 资源分配 │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 区块链共识层 (Blockchain Consensus) │ │ PoW | PoS | DPoS | PBFT | PoQ | PoF | Raft │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 算法层 (Algorithm Layer) │ │ 聚合算法 | 安全算法 | 优化算法 | 激励算法 │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 通信层 (Communication Layer) │ │ 加密技术 | 网络协议 | 同步机制 | P2P框架 │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 网络层 (Network Layer) │ │ 中心化 | 多中心化 | 去中心化 (P2P) │ └─────────────────────────────────────────────┘ ↕ ┌─────────────────────────────────────────────┐ │ 基础设施层 (Infrastructure Layer) │ │ L1/L2架构 | 存储资源 | 计算资源(CPU/GPU/TPU)│ └─────────────────────────────────────────────┘ 2.2 架构分类：三种耦合方式 论文根据操作动态将BCFL系统分为三种架构：\n完全耦合 (Fully Coupled) 定义：客户端同时作为训练节点和区块链节点\n特点：\n提供去中心化 要求高设备性能 适用场景：参与者设备能力强的环境\n灵活耦合 (Flexibly Coupled) 定义：分离区块链和FL操作以减轻网络通信负担\n实现方式：\n委员会选择：选择部分节点参与共识 智能合约：通过智能合约实现分离 特点：平衡了去中心化和效率\n松散耦合 (Loosely Coupled) 定义：优先考虑声誉来衡量参与者可靠性\n关注点：\n主要关注模型更新验证 在账本上进行声誉管理 特点：轻量级，适合大规模异构设备\n三、六层架构详解 3.1 基础设施层 L1与L2架构 L1层架构：\nFL直接集成到区块链 提供去中心化的P2P框架 对等方自由加入 由共识机制支持系统可靠性 L2层架构：\nFL构建在区块链节点之上 强调分层数据处理和模型训练 存储方案 去中心化存储：\n采用去中心化存储模型 通过高级加密方法确保隐私： 安全多方计算(SMPC) 同态加密 优势：\n促进安全、私密的数据共享和模型聚合 区块链的可审计性提高透明度和信任 计算资源 本地计算：\n本地满足计算需求 利用CPU、GPU、TPU 异构性处理：\n通过轻量级架构处理设备异构性 模型压缩技术 联邦蒸馏(Federated Distillation) 优化性能和资源分配 3.2 网络层 论文将区块链网络结构分为三类：\n中心化网络 特点：\n所有通信和交易通过中央节点路由 常见于有许可区块链系统 优势：\n简化效率 由于单一控制点，共识更快 劣势：\n显著的安全风险 中央节点成为攻击的主要目标 可能损害整个网络的完整性和隐私 多中心化网络（联邦区块链） 特点：\n引入多个中央节点而非单一节点 通常用于平衡多个组织或方之间的控制 优势：\n增强协作 维持一定程度的中心化治理 改善安全性，减少单点故障风险 劣势：\n仍可能面临可扩展性限制 中心化控制问题 去中心化网络 特点：\n以无许可区块链为代表（如Bitcoin、Ethereum） 在广泛的节点阵列中分布数据验证和交易处理 P2P网络结构 无单点控制或故障 每个节点以平等地位运行 优势：\n最高级别的安全性和数据完整性 显著增强对审查、篡改和攻击的抵抗力 劣势：\n可能在可扩展性方面面临挑战 由于决策过程的分布式性质，共识速度可能较慢 论文总结：网络设置的选择深刻影响BCFL系统的性能和安全性\n3.3 通信层 核心任务 通信层在BCFL系统中扮演关键角色，负责：\n编排参与者之间的数据传输和消息交换 促进协作学习过程 高效、安全地传输模型更新、聚合结果和协调指令 关键技术 加密技术：\n在传输前加密数据 防止未授权访问 确保维护数据隐私 网络协议：\n采用可靠高效的网络协议管理消息传递 确保数据包可靠有序地到达目的地 即使在网络中断或拥塞情况下 同步机制：\n在BCFL系统的分布式特性下，同步机制至关重要 协调参与者之间的通信 确保及时共享模型更新 管理数据传输的异步性质 对齐来自不同参与者的更新 去中心化通信框架：\n采用去中心化框架（如P2P网络或区块链） 促进参与者之间的直接通信 消除中心化中介的需要 增强系统的韧性和去中心化 减少潜在瓶颈和故障点 案例 - BLADE-FL：\n论文提到的完全去中心化框架 将训练和挖矿的责任都分配给全节点 增强去中心化和系统韧性 面临的挑战 延迟和有限带宽：\n通过数据压缩技术解决 最小化数据传输的大小 提高交换速度 优化策略：\n自适应网络路由 拥塞控制算法 优化数据流 减少延迟 提高通信效率 批处理和缓存：\n降低数据传输的频率和数量 减轻网络约束的影响 3.4 算法层 论文将算法层分为四个关键方面：\n1. 聚合算法 经典算法：\nFedAvg：\n参与者上传本地模型权重到区块链网络 通过智能合约计算权重平均值获得全局模型 进阶算法：\nFedProx：处理异构性 SCAFFOLD：减少方差 FedPD：原对偶优化 FedBN：批归一化层处理 异步FL系统：\n解决中心化模型带来的安全挑战 实现隐私、容错和可靠的数据共享 基于有许可区块链的FL异步聚合协议 通过将学习模型集成到区块链并执行二阶聚合计算 有效缓解同步FL算法的问题 2. 安全算法 论文详细介绍了三种核心隐私保护技术：\n安全多方计算(SMPC)：\n定义：保护数据隐私的计算模型，允许多方在不披露私有数据的情况下进行计算\n特点：\n各方持有部分私有数据 可以对加密数据执行计算以维护隐私 各方通过协议进行通信和交互 共同计算最终结果而无需直接暴露私有数据 技术组成：\n同态加密 秘密共享(Secret Sharing) 零知识证明(Zero-Knowledge Proof) 安全多方计算协议 同态加密(HE)：\n定义：满足密文同态运算性质的加密算法\n核心特性：\n数据经过同态加密后 对密文执行特定计算 密文计算结果经相应同态解密后 等价于对明文数据直接执行相同计算 实现数据的\u0026quot;可计算但不可见\u0026quot;状态 优势：\n可以在密文上进行计算而无需密钥 减少通信成本 平衡各方的计算成本 差分隐私(DP)：\n定义：通过添加扰动噪声保护底层用户隐私信息的技术\n原理：\n确保即使攻击者掌握除一条信息外的所有其他信息 仍无法推断该条信息 方法：\n向结果添加符合特定分布的噪声 随机化查询结果 挑战：需要解决数据可用性问题（由于需要在查询结果中加入随机性，可能导致数据可用性下降）\n3. 优化算法 目标：\n优化FL性能 减少训练轮次 降低通信开销 提高模型准确性 常用方法：\n梯度压缩：减少通信开销 梯度剪枝：减少通信开销 异步更新：减少训练轮次 本地更新：减少训练轮次 4. 激励算法 论文强调：虽然FL在保护数据隐私的同时实现协作学习展现了巨大优势，但仍面临如何激励人们通过贡献计算能力和数据加入FL的开放挑战。\n基于声誉的FL：\n核心思想：通过设计安全机制衡量参与者的可靠性\n代表性工作：\n区块链声誉系统\n增加贡献正确有用模型参数的客户端的声誉值 降低上传恶意参数的客户端的声誉值 影响后续训练轮次的客户端选择 RepBFL框架\n结合区块链和FL应用于车联网(IoV) 利用区块链确保共享数据保护 选择高声誉节点进行FL 评估IoV中车辆的可靠性 基于模型质量参数的评估\n使用模型质量参数进行声誉评估 区块链衡量工作者可靠性并维护声誉值 CFFL协作公平框架\n引入基于经验个体模型性能的声誉机制 调节参与者奖励以保持通信轮次间的公平性 多权重主观逻辑模型\n将声誉作为量化移动设备可靠性和可信度的指标 采用多权重主观逻辑模型进行声誉计算 联盟区块链技术以去中心化方式保护声誉存储 基于支付的FL：\nFedCoin\n采用Shapley值(SVs)进行可行的基于SV的利润分配 公平反映对全局FL模型的贡献 区块链共识实体部署Shapley权益证明协议(PoSap) 用于计算SVs和创建新区块 公共区块链上的FL协议\n解决监控工作者行为和保证协议遵守的挑战 将竞争嵌入BCFL 仅奖励贡献有价值的工作者 自然抑制偏离协议的行为 移动群体FL系统\n通过根据个人贡献提供奖励来激励移动设备训练准确模型 Stackelberg博弈建模服务器和设备间的交互 比较基于规模和基于准确性的两种奖励策略 跨孤岛横向FL的贡献评估\n解决透明评估不同数据所有者贡献的挑战 使用可调精度量化数据所有者基于SV的贡献 保护隐私 DeepChain：\n特点：\n客户端联合参与训练深度学习模型的协作框架 保证数据机密性和计算可验证性 为参与者提供激励 激励机制：\n围绕超时检查和货币惩罚编排 促进参与者之间的公平性 在参与者未能满足截止日期或不准确执行函数的情况下采取惩罚措施 施加货币惩罚，没收不诚实参与者的预存资金 在诚实参与者之间重新分配 机制设计综述：\n论文引用的综述工作：\n基于关键技术对现有激励机制进行分类 包括：Stackelberg博弈、拍卖、合约理论、Shapley值、强化学习、区块链 Refiner系统：\n部署在Ethereum公共区块链平台 运行激励机制，根据训练数据量和本地更新性能奖励参与者 处理大规模协作中的恶意参与者 部署随机选择的验证者委员会 验证者惩罚不道德参与者，拒绝奖励并从全局模型中消除腐败更新 3.5 区块链共识层 论文强调：在FL系统实现的背景下，共识涉及参与者同步模型并集体做出决策所采用的协议。共识算法确保所有参与者对模型更新的有效性达成一致，并防止恶意行为者篡改系统。\n共识机制的重要性 共识机制的作用：\n在极短时间内完成交易验证和确认 通过特殊节点的投票完成 如果利益不同的节点能对交易达成共识，则可以认为整个网络也能达成共识 主要共识机制 1. Proof of Work (PoW)\n特点：\nBitcoin使用PoW工作量证明机制 Ethereum曾使用PoW和PoS混合共识机制 相当于解决一个随时间变难的数学难题 挑战：\n计算消耗大量能源 可能间接影响碳排放和环境 应用案例：\nBCFL系统：引入分布式哈希表用于高效区块生成，采用PoW共识机制确保全局模型一致性 LearningChain：去中心化联邦系统，利用基于PoW共识的拜占庭容错聚合算法（l-nearest aggregation），通过竞争选择领导者，使用l-nearest算法聚合梯度 Swarm Learning (SL)：去中心化机器学习方法，结合边缘计算和基于区块链的P2P网络，数据和参数保留在边缘，消除中央协调者的需求 2. Proof of Stake (PoS)\n特点：\n被视为PoW的环保替代方案 验证者基于持有和愿意\u0026quot;质押\u0026quot;作为抵押品的加密货币数量被选择创建新区块 3. Delegated Proof of Stake (DPoS)\n特点：\n利益相关者选举一定数量的代表来验证交易和创建区块 设计为比传统PoS更民主和高效 4. Proof of Training Quality (PoQ)\n背景：现有共识机制（如PoW）消耗大量计算和通信资源，或对数据共享的额外贡献有限\n解决方案：\n论文提到提出了结合FL与差分隐私的共识机制PoQ 将数据模型训练与共识过程集成 用模型参数准确性的认证替代PoW中寻找随机数的无意义计算工作 5. Byzantine Fault Tolerance (BFT)\n目标：抵御\u0026quot;拜占庭\u0026quot;故障（组件可能失败且对组件是否失败的信息不完善）\n变体：\nPBFT (Practical Byzantine Fault Tolerance)：用于Hyperledger Fabric FBA (Federated Byzantine Agreement)：用于Stellar 6. Proof of Federation (PoF)\nBiscotti系统：\n将PoF与一致性哈希和可验证随机函数(VRF)结合 为对等节点选择关键角色，协助协调模型更新的隐私和安全 通过Multi-Krum防御防止对等点毒化模型 采用差分化私有噪声提供隐私 利用Shamir秘密共享进行安全聚合 挑战：当所有节点参与共识时，计算负载过大\n7. RAFT\n特点：\n在一组节点中选举领导者 领导者负责提出和验证区块 专注于简单性和容错性 设计为比其他共识算法更易理解和实现 应用：一些有许可区块链网络\n8. Proof of Federated Training (PoFT)\n特点：\n实现跨多个区块链网络的可验证模型训练的框架 解决PoW中的功耗/资源浪费问题 解决区块链中的数据隐私问题 扩展 - PoFL：\n联邦学习证明 应用于车辆网络 车辆通过遵守区块链网络内的FL共识证明竞争成为矿工 IPFS和PoFL用于确保连接自动驾驶车辆的去中心化联邦学习安全 9. 委员会共识\nBFLC框架：\n基于区块链的委员会共识FL框架 利用区块链进行全局模型存储和本地模型更新交换 消除中心化服务器需求 引入创新的委员会共识机制减少计算负载并缓解恶意攻击 论文总结：\n所有这些共识算法都有其优势和劣势 适合不同的用例 选择正确的共识机制对区块链网络的安全性、可扩展性和效率至关重要 共识算法的选择受期望的去中心化程度、安全性、可扩展性以及区块链网络的特定需求等因素影响 3.6 应用层 论文探讨了FL在不同领域的应用，这些领域可以提供基于该技术的服务。\n车联网 (Internet of Vehicles) 应用背景：\n车辆日益成为数据生成源 GPS位置、速度、道路状况等数据可以为更好的交通管理、路线规划和事故预防做出贡献 但这些数据也是敏感的 BCFL的价值：\n能够聚合来自多辆车辆的数据来训练模型，而无需共享原始数据 区块链还可以用于维护网络中车辆交互和交易的防篡改记录 相关研究：论文引用了多篇关于BCFL在车联网应用的研究工作\n资源分配 应用价值：\n在大型分布式系统中，有效的资源分配对于最大化效率至关重要 通过在区块链网络之上应用FL，可以根据从网络使用模式中学习的知识动态分配资源 将区块链与FL集成不仅加强隐私和可靠性，还为高效的资源分配和利用提供平台 边缘计算 应用潜力：\nBCFL在边缘计算应用方面具有巨大潜力 为数据共享、资源协作和共享、模型更新和升级以及抗干扰和容错提供安全机制 实现方式：\n通过利用边缘设备的计算资源和数据 使智能应用能够高效安全地执行推理和决策任务 解决的挑战：\n数据隐私 资源约束 边缘计算中常见的不稳定环境 应用现状：\n已在移动电话场景中进行了广泛研究和应用 预计将为更多边缘计算场景的发展和扩展提供解决方案 医疗健康 应用价值：\n患者数据敏感但对检测疾病和改善治疗极有价值 BCFL允许医疗机构协作并从大量患者数据中学习，而不损害患者隐私 区块链优势：\n可以提供数据和计算的可追溯性 增加对学习模型的信任 相关应用：\n疾病检测 治疗改进 电子健康记录系统的安全性、隐私和互操作性 能源 应用场景：\n智能电网：\n优化电网运营 促进微电网间的P2P能源交易和共享 工业物联网(IIoT)：\n解决无线网络中与信用数据共享相关的安全和隐私问题 可再生能源：\n应用于风能涡轮机的叶片结冰检测 风能是快速增长的可再生能源部门 四、关键框架案例 论文介绍了多个具有代表性的BCFL框架：\nBML-ES 基于区块链的工业物联网(IIoT)边缘服务机器学习框架 利用智能合约实现聚合策略 采用SM2公钥密码系统保护隐私并提高模型准确性 TrustFed 将区块链集成到跨设备FL系统中 防止模型投毒 确保公平训练 维护参与者声誉 使用智能合约管理声誉并排除恶意行为者 确保可靠的训练环境 基于状态通道的信任监督机制 使用区块链和FL为分布式数据共享创建可信环境 采用状态通道为FL任务建立安全沙箱 确保整个过程的完整性和监督 Proof of Federated Training (PoFT) 实现跨区块链网络可验证模型训练的框架 增强协作训练过程中的透明度和信任 去中心化模型训练和梯度聚合 提出基于区块链的安全模型训练架构 引入旨在提高模型准确性、隐私和性能的梯度聚合方法 Blockchain-in-the-loop FL 将传统FL与Hyperledger Fabric合并 结合游戏化以增强参与度和效率 Swarm Learning 去中心化机器学习方法 结合边缘计算和基于区块链的P2P网络 数据和参数保留在边缘 消除中央协调者的需求 发表在Nature上，应用于COVID-19等疾病的去中心化临床机器学习 五、挑战与未来研究方向 论文在结尾部分识别了BCFL面临的主要挑战并提出未来研究方向：\n5.1 数据安全与隐私保护 挑战：\n在FL与区块链结合的环境中，确保数据安全和隐私成为首要关注点 在网络环境中有效管理敏感信息（如医疗记录或个人身份）是一项挑战 需要深入探索在不暴露其真实内容的情况下处理此类数据的密码技术 研究方向：\n未来研究应深入研究针对这个集成系统定制的新密码解决方案 5.2 模型效率与性能优化 挑战：\n分布式数据和模型的高效计算是FL的基本要求 该领域的核心挑战涉及： 设计降低计算复杂度的算法 最小化通信开销 提高模型训练和推理的效率 研究方向：\n未来研究工作应集中于微调分布式优化方法 整合先进的压缩策略以减轻通信负担 探索硬件增强以提高计算效率 调查混合模型，合并中心化和去中心化训练方法，也具有相当大的前景 5.3 可扩展性 问题描述：\n随着区块链和FL融合以创建安全、私密的数据管理框架 可扩展性成为一个关键瓶颈 特别是当系统规模扩大和需求增加时 解决方案： 论文提出的前瞻性方法：\n链下计算 (Off-chain Calculations)：卸载密集任务，减少主区块链负载 侧链 (Sidechains)：单独管理交易以减少拥塞 Layer-2技术： 状态通道(State Channels) Plasma 在现有区块链之上促进快速交易，同时保持安全性 目标：\n这些方法利用区块链和FL的核心原则 旨在培育可扩展、安全和去中心化的学习生态系统 六、论文贡献总结 论文明确指出其核心贡献：\n分类法提出\n从三个方面呈现BCFL的分类： 去中心化架构 分离网络 基于声誉的架构 通用架构总结\n总结了BCFL系统的通用架构 提供了基于区块链的FL架构的全面视角 包括六个关键层： 基础设施层 网络层 通信层 算法层 区块链共识层 应用层 应用分析\n分析了BCFL在以下领域的应用： 医疗健康 物联网 其他隐私敏感领域 未来方向识别\n识别了BCFL的未来研究方向 综合视角\n本研究旨在提供BCFL系统的全面视角 为BCFL系统领域的未来研究提供基础 七、个人理解 说明：以下是我基于论文内容的理解和思考，并非论文原文\n论文的核心价值 这篇综述的主要价值在于：\n系统性整合：将分散的BCFL研究整合到统一框架中 架构清晰：六层架构为理解BCFL系统提供了清晰的分析框架 全面覆盖：从底层基础设施到上层应用都有涉及 论文的特点 优势：\n文献综述全面，引用了大量相关工作 分类清晰，便于理解不同方法的特点 对各种技术（共识机制、激励机制、隐私保护）都有介绍 可能的不足：\n对各种方案的性能对比分析较少 部分技术介绍较为概念化，实现细节不足 缺少对不同方案适用场景的明确指导 对未来研究的启示 BCFL是一个跨学科领域，需要区块链、机器学习、密码学等多方面知识 不同应用场景可能需要不同的架构选择（完全耦合 vs 灵活耦合 vs 松散耦合） 隐私保护、效率、去中心化程度之间的权衡是核心问题 实际应用还需要考虑工程实现、成本、监管合规等问题 引用 @article{liu2024enhancing, title={Enhancing trust and privacy in distributed networks: a comprehensive survey on blockchain-based federated learning}, author={Liu, Ji and Chen, Chunlu and Li, Yu and Sun, Lin and Song, Yulun and Zhou, Jingbo and Jing, Bo and Dou, Dejing}, journal={Knowledge and Information Systems}, volume={66}, pages={4377--4403}, year={2024}, publisher={Springer} } ","permalink":"http://localhost:1313/posts/blockchain-federated-learning-survey/","summary":"本文系统性地综述了区块链联邦学习（BCFL）技术，从架构分类、基础设施层、网络层、通信层、算法层到共识机制进行了深入分析，并探讨了其在医疗、物联网车辆、边缘计算等领域的应用，为构建安全、隐私保护的分布式学习系统提供了理论框架","title":"区块链联邦学习综述：增强分布式网络中的信任与隐私"},{"content":"第一题：线性回归梯度下降 题目： 对线性模型 $h_\\theta(x) = \\theta^\\top x$，给定训练集 $\\{(x^{(i)}, y^{(i)})\\}$，推导其向量形式的最小二乘损失梯度下降更新公式为：\n$$\\theta := \\theta + \\alpha \\sum_{i=1}^{n} (y^{(i)} - h_\\theta(x^{(i)})) x^{(i)}$$解：\n最小二乘损失函数为：\n$$J(\\theta) = \\frac{1}{2}\\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)})^2 = \\frac{1}{2}\\sum_{i=1}^{n}(\\theta^\\top x^{(i)} - y^{(i)})^2$$对 $\\theta$ 求梯度：\n$$\\begin{aligned} \\nabla_\\theta J(\\theta) \u0026= \\sum_{i=1}^{n}(\\theta^\\top x^{(i)} - y^{(i)}) \\cdot x^{(i)} \\\\ \u0026= \\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} \\end{aligned}$$梯度下降更新规则为 $\\theta := \\theta - \\alpha \\nabla_\\theta J(\\theta)$，因此：\n$$\\theta := \\theta - \\alpha \\sum_{i=1}^{n}(h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} = \\theta + \\alpha \\sum_{i=1}^{n}(y^{(i)} - h_\\theta(x^{(i)})) x^{(i)}$$ 第二题：交叉熵损失梯度 题目： Cross Entropy Loss 定义如下：\n$$l_{ce}((t_1,\\ldots,t_k),y) = -\\log\\left(\\frac{\\exp(t_y)}{\\sum_j \\exp(t_j)}\\right)$$令向量 $t = (t_1,t_2,\\ldots,t_k)$，推导 CEL 对任意 $t_i$ 求导为：\n$$\\frac{\\partial l_{ce}(t,y)}{\\partial t_i} = \\phi_i - \\mathbb{1}\\{y=i\\}$$解：\n记 $\\phi_i = \\frac{\\exp(t_i)}{\\sum_j \\exp(t_j)}$ 为 softmax 函数。\n首先简化损失函数：\n$$l_{ce}(t,y) = -\\log(\\phi_y) = -t_y + \\log\\left(\\sum_j \\exp(t_j)\\right)$$对 $t_i$ 求导：\n$$\\begin{aligned} \\frac{\\partial l_{ce}(t,y)}{\\partial t_i} \u0026= -\\frac{\\partial t_y}{\\partial t_i} + \\frac{\\partial}{\\partial t_i}\\log\\left(\\sum_j \\exp(t_j)\\right) \\\\ \u0026= -\\mathbb{1}\\{y=i\\} + \\frac{\\exp(t_i)}{\\sum_j \\exp(t_j)} \\\\ \u0026= \\phi_i - \\mathbb{1}\\{y=i\\} \\end{aligned}$$其中 $\\mathbb{1}\\{y=i\\}$ 是指示函数，当 $y=i$ 时为1，否则为0。\n第三题：高斯假设下的最大似然估计 题目： 证明在高斯差异假定下，对线性模型 $h_\\theta(x) = \\theta^\\top x$，最大化参数似然 $L(\\theta)$ 等价于最小化二乘损失 $\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2$。\n解：\n假设误差 $\\epsilon^{(i)} = y^{(i)} - \\theta^\\top x^{(i)}$ 服从独立同分布的高斯分布 $\\mathcal{N}(0, \\sigma^2)$，即：\n$$p(\\epsilon^{(i)}) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(\\epsilon^{(i)})^2}{2\\sigma^2}\\right)$$因此：\n$$p(y^{(i)} | x^{(i)}; \\theta) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right)$$似然函数为：\n$$\\begin{aligned} L(\\theta) \u0026= \\prod_{i=1}^{n} p(y^{(i)} | x^{(i)}; \\theta) \\\\ \u0026= \\prod_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right) \\end{aligned}$$对数似然为：\n$$\\begin{aligned} \\log L(\\theta) \u0026= \\sum_{i=1}^{n}\\left[\\log\\frac{1}{\\sqrt{2\\pi}\\sigma} - \\frac{(y^{(i)} - \\theta^\\top x^{(i)})^2}{2\\sigma^2}\\right] \\\\ \u0026= n\\log\\frac{1}{\\sqrt{2\\pi}\\sigma} - \\frac{1}{2\\sigma^2}\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2 \\end{aligned}$$最大化 $\\log L(\\theta)$ 等价于最小化 $\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top x^{(i)})^2$。\n第四题：Logistic回归的NLL损失 题目： 对Logistic回归模型 $h_\\theta(x) = g(\\theta^\\top x) = \\frac{1}{1+e^{-\\theta^\\top x}}$，推导其在单样本 $(x,y)$ 下的NLL（negative log likelihood）损失，以及损失对特定参数 $\\theta_j$ 的导数为 $(h_\\theta(x) - y)x_j$。\n提示：Logistic回归预测概率的统一形式为 $P(y|x;\\theta) = (h_\\theta(x))^y(1-h_\\theta(x))^{1-y}$\n解：\n根据提示，Logistic回归的概率模型为：\n$$P(y|x;\\theta) = (h_\\theta(x))^y(1-h_\\theta(x))^{1-y}$$其中 $y \\in \\{0,1\\}$，$h_\\theta(x) = g(\\theta^\\top x) = \\frac{1}{1+e^{-\\theta^\\top x}}$。\n对数似然为：\n$$\\log P(y|x;\\theta) = y\\log(h_\\theta(x)) + (1-y)\\log(1-h_\\theta(x))$$NLL损失为：\n$$\\text{NLL}(x,y;\\theta) = -\\log P(y|x;\\theta) = -y\\log(h_\\theta(x)) - (1-y)\\log(1-h_\\theta(x))$$对 $\\theta_j$ 求导。首先注意到：\n$$\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j} = h_\\theta(x)(1-h_\\theta(x)) \\cdot x_j$$这是因为 $g'(z) = g(z)(1-g(z))$。\n因此：\n$$\\begin{aligned} \\frac{\\partial \\text{NLL}}{\\partial \\theta_j} \u0026= -y\\frac{1}{h_\\theta(x)}\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j} - (1-y)\\frac{1}{1-h_\\theta(x)}\\left(-\\frac{\\partial h_\\theta(x)}{\\partial \\theta_j}\\right) \\\\ \u0026= -y\\frac{1}{h_\\theta(x)} \\cdot h_\\theta(x)(1-h_\\theta(x))x_j + (1-y)\\frac{1}{1-h_\\theta(x)} \\cdot h_\\theta(x)(1-h_\\theta(x))x_j \\\\ \u0026= -y(1-h_\\theta(x))x_j + (1-y)h_\\theta(x)x_j \\\\ \u0026= (h_\\theta(x) - y)x_j \\end{aligned}$$ 第五题：Poisson分布的指数族形式 题目： 已知指数分布族定义如下：$p(y;\\eta) = b(y)\\exp(\\eta^\\top y - a(\\eta))$。推导Poisson分布的指数分布族形式，并构建Poisson分布对应的广义线性模型。其中，Poisson分布 $\\text{Pois}(\\lambda)$ 的概率密度函数如下：\n$$P(X=k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}$$解：\n将Poisson分布改写为指数族形式：\n$$\\begin{aligned} P(X=k) \u0026= \\frac{\\lambda^k e^{-\\lambda}}{k!} \\\\ \u0026= \\frac{1}{k!}\\exp(k\\log\\lambda - \\lambda) \\\\ \u0026= \\frac{1}{k!}\\exp(\\eta \\cdot k - e^\\eta) \\end{aligned}$$其中 $\\eta = \\log\\lambda$（自然参数），因此 $\\lambda = e^\\eta$。\n对应指数族形式：\n$b(y) = \\frac{1}{y!}$ $\\eta = \\log\\lambda$ $a(\\eta) = e^\\eta = \\lambda$ $y$ 的充分统计量就是 $y$ 本身 构建广义线性模型：\n假设 $y|x;\\theta \\sim \\text{Pois}(\\lambda)$ 自然参数 $\\eta = \\theta^\\top x$ 因为 $\\lambda = e^\\eta$，所以 $\\lambda = e^{\\theta^\\top x}$ 响应函数（期望）为：$h_\\theta(x) = \\mathbb{E}[y|x;\\theta] = \\lambda = e^{\\theta^\\top x}$ 这就是Poisson回归模型。\n第六题：Shapley值计算 题目： 计算以下3人团队的Shapley值 $\\phi_1$、$\\phi_2$、$\\phi_3$。\n给定：\n$C_{123} = 10000$，$C_0 = 0$ $C_{12} = 7500$，$C_{13} = 7500$，$C_{23} = 5000$ $C_1 = 5000$，$C_2 = 5000$，$C_3 = 0$ 解：\nShapley值的公式为：\n$$\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(|N|-|S|-1)!}{|N|!}[C(S \\cup \\{i\\}) - C(S)]$$对于3人团队，$|N| = 3$，计算每个玩家的边际贡献：\n玩家1的Shapley值：\n$$\\begin{aligned} \\phi_1 \u0026= \\frac{0!2!}{3!}[C_1 - C_0] + \\frac{1!1!}{3!}[C_{12} - C_2] + \\frac{1!1!}{3!}[C_{13} - C_3] + \\frac{2!0!}{3!}[C_{123} - C_{23}] \\\\ \u0026= \\frac{1}{3}[5000 - 0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[7500 - 0] + \\frac{1}{3}[10000 - 5000] \\\\ \u0026= \\frac{5000}{3} + \\frac{2500}{6} + \\frac{7500}{6} + \\frac{5000}{3} \\\\ \u0026= \\frac{10000}{3} + \\frac{10000}{6} = \\frac{20000 + 10000}{6} = 5000 \\end{aligned}$$玩家2的Shapley值：\n$$\\begin{aligned} \\phi_2 \u0026= \\frac{0!2!}{3!}[C_2 - C_0] + \\frac{1!1!}{3!}[C_{12} - C_1] + \\frac{1!1!}{3!}[C_{23} - C_3] + \\frac{2!0!}{3!}[C_{123} - C_{13}] \\\\ \u0026= \\frac{1}{3}[5000 - 0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[5000 - 0] + \\frac{1}{3}[10000 - 7500] \\\\ \u0026= \\frac{5000}{3} + \\frac{2500}{6} + \\frac{5000}{6} + \\frac{2500}{3} \\\\ \u0026= \\frac{15000 + 2500 + 5000 + 5000}{6} = \\frac{27500}{6} \\approx 4583.33 \\end{aligned}$$玩家3的Shapley值：\n由对称性或直接计算：\n$$\\phi_3 = 10000 - \\phi_1 - \\phi_2 = 10000 - 5000 - 4583.33 = 416.67$$或直接计算：\n$$\\begin{aligned} \\phi_3 \u0026= \\frac{1}{3}[0] + \\frac{1}{6}[7500 - 5000] + \\frac{1}{6}[5000 - 5000] + \\frac{1}{3}[10000 - 7500] \\\\ \u0026= 0 + \\frac{2500}{6} + 0 + \\frac{2500}{3} = \\frac{5000}{6} \\approx 416.67 \\end{aligned}$$答案： $\\phi_1 = 5000$，$\\phi_2 \\approx 4583.33$，$\\phi_3 \\approx 416.67$\n第七题：协方差矩阵性质 题目： 基于协方差矩阵定义 $\\Sigma = \\text{Cov}(X)$ 证明：\n$\\Sigma$ 为对称矩阵； $\\Sigma$ 半正定，记 $\\Sigma \\geq 0$，即对任意向量 $z \\in \\mathbb{R}^d$ 有 $z^\\top \\Sigma z \\geq 0$。 解：\n设 $X \\in \\mathbb{R}^d$ 为随机向量，$\\mu = \\mathbb{E}[X]$，则：\n$$\\Sigma = \\text{Cov}(X) = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top]$$(1) 证明 $\\Sigma$ 为对称矩阵：\n$$\\Sigma^\\top = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top]^\\top = \\mathbb{E}[((X-\\mu)(X-\\mu)^\\top)^\\top] = \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top] = \\Sigma$$因此 $\\Sigma$ 是对称矩阵。\n(2) 证明 $\\Sigma$ 半正定：\n对任意 $z \\in \\mathbb{R}^d$：\n$$\\begin{aligned} z^\\top \\Sigma z \u0026= z^\\top \\mathbb{E}[(X-\\mu)(X-\\mu)^\\top] z \\\\ \u0026= \\mathbb{E}[z^\\top(X-\\mu)(X-\\mu)^\\top z] \\\\ \u0026= \\mathbb{E}[(z^\\top(X-\\mu))^2] \\\\ \u0026\\geq 0 \\end{aligned}$$最后一步是因为期望中的项是平方项，必然非负。因此 $\\Sigma$ 半正定。\n第八题：高斯判别分析的MLE 题目： 对高斯判别分析，已知各变量概率分布为：\n$$\\begin{aligned} p(y) \u0026= \\phi^y(1-\\phi)^{1-y} \\\\ p(x|y=0) \u0026= \\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}\\exp\\left(-\\frac{1}{2}(x-\\mu_0)^\\top\\Sigma^{-1}(x-\\mu_0)\\right) \\\\ p(x|y=1) \u0026= \\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}\\exp\\left(-\\frac{1}{2}(x-\\mu_1)^\\top\\Sigma^{-1}(x-\\mu_1)\\right) \\end{aligned}$$证明在极大似然估计下，参数 $\\phi$、$\\mu_0$、$\\mu_1$ 的形式为：\n$$\\begin{aligned} \\phi \u0026= \\frac{1}{n}\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\} \\\\ \\mu_0 \u0026= \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}} \\\\ \\mu_1 \u0026= \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}} \\end{aligned}$$解：\n对数似然函数为：\n$$\\log L = \\sum_{i=1}^{n}\\left[\\log p(y^{(i)}) + \\log p(x^{(i)}|y^{(i)})\\right]$$估计 $\\phi$：\n$$\\log L_\\phi = \\sum_{i=1}^{n}\\log p(y^{(i)}) = \\sum_{i=1}^{n}[y^{(i)}\\log\\phi + (1-y^{(i)})\\log(1-\\phi)]$$令 $\\frac{\\partial \\log L_\\phi}{\\partial \\phi} = 0$：\n$$\\sum_{i=1}^{n}\\left[\\frac{y^{(i)}}{\\phi} - \\frac{1-y^{(i)}}{1-\\phi}\\right] = 0$$解得：\n$$\\phi = \\frac{1}{n}\\sum_{i=1}^{n}y^{(i)} = \\frac{1}{n}\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=1\\}$$估计 $\\mu_0$：\n只考虑 $y=0$ 的样本：\n$$\\log L_{\\mu_0} = \\sum_{i:y^{(i)}=0}\\left[-\\frac{1}{2}(x^{(i)}-\\mu_0)^\\top\\Sigma^{-1}(x^{(i)}-\\mu_0) + \\text{const}\\right]$$令 $\\frac{\\partial \\log L_{\\mu_0}}{\\partial \\mu_0} = 0$：\n$$\\sum_{i:y^{(i)}=0}\\Sigma^{-1}(x^{(i)}-\\mu_0) = 0$$解得：\n$$\\mu_0 = \\frac{\\sum_{i:y^{(i)}=0}x^{(i)}}{\\sum_{i:y^{(i)}=0}1} = \\frac{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}x^{(i)}}{\\sum_{i=1}^{n}\\mathbb{1}\\{y^{(i)}=0\\}}$$同理可得 $\\mu_1$ 的估计。\n第九题：GDA可转化为Logistic回归 题目： 证明GDA可转化为Logistic回归。提示：\n$p(y=1|x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=1)p(y=1) + p(x|y=0)p(y=0)}$ 可记 $r(x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)}$ 给出 $p(x|y=0)$, $p(x|y=1)$, $p(y=1)$ 的表达式 解：\n根据贝叶斯定理：\n$$p(y=1|x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=1)p(y=1) + p(x|y=0)p(y=0)} = \\frac{1}{1 + \\frac{p(x|y=0)p(y=0)}{p(x|y=1)p(y=1)}} = \\frac{1}{1 + \\frac{1}{r(x)}}$$其中：\n$$r(x) = \\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)}$$计算 $\\log r(x)$：\n$$\\begin{aligned} \\log r(x) \u0026= \\log p(x|y=1) + \\log p(y=1) - \\log p(x|y=0) - \\log p(y=0) \\\\ \u0026= -\\frac{1}{2}(x-\\mu_1)^\\top\\Sigma^{-1}(x-\\mu_1) + \\frac{1}{2}(x-\\mu_0)^\\top\\Sigma^{-1}(x-\\mu_0) + \\log\\frac{\\phi}{1-\\phi} \\end{aligned}$$展开：\n$$\\begin{aligned} \\log r(x) \u0026= -\\frac{1}{2}x^\\top\\Sigma^{-1}x + x^\\top\\Sigma^{-1}\\mu_1 - \\frac{1}{2}\\mu_1^\\top\\Sigma^{-1}\\mu_1 \\\\ \u0026\\quad + \\frac{1}{2}x^\\top\\Sigma^{-1}x - x^\\top\\Sigma^{-1}\\mu_0 + \\frac{1}{2}\\mu_0^\\top\\Sigma^{-1}\\mu_0 + \\log\\frac{\\phi}{1-\\phi} \\\\ \u0026= x^\\top\\Sigma^{-1}(\\mu_1 - \\mu_0) + \\frac{1}{2}(\\mu_0^\\top\\Sigma^{-1}\\mu_0 - \\mu_1^\\top\\Sigma^{-1}\\mu_1) + \\log\\frac{\\phi}{1-\\phi} \\\\ \u0026= \\theta^\\top x + \\theta_0 \\end{aligned}$$其中：\n$$\\theta = \\Sigma^{-1}(\\mu_1 - \\mu_0), \\quad \\theta_0 = \\frac{1}{2}(\\mu_0^\\top\\Sigma^{-1}\\mu_0 - \\mu_1^\\top\\Sigma^{-1}\\mu_1) + \\log\\frac{\\phi}{1-\\phi}$$因此：\n$$p(y=1|x) = \\frac{1}{1+e^{-\\theta^\\top x - \\theta_0}} = \\frac{1}{1+e^{-\\tilde{\\theta}^\\top \\tilde{x}}}$$这正是Logistic回归的形式（其中 $\\tilde{x}$ 包含截距项）。\n第十题：Kernel Method分析 题目： Kernel method中，若Kernel function $K(x,z) = (x^\\top z + c)^2$，推导对应的feature mapping $\\phi$，并讨论对于 $n$ 个样本一轮SGD，使用Kernel method和在feature map上的计算效率优化比。\n提示：\n基于feature map的参数更新方法为：$\\theta := \\theta + \\alpha\\sum_{i=1}^{n}(y^{(i)} - \\theta^\\top\\phi(x^{(i)}))\\phi(x^{(i)})$ Kernel method的参数更新方法为：$\\theta := \\theta + \\alpha(\\tilde{y} - K\\theta)$，其中 $K_j = K(x^{(i)}, x^{(j)})$ 解：\n推导feature mapping：\n对于 $x,z \\in \\mathbb{R}^d$，展开核函数：\n$$\\begin{aligned} K(x,z) \u0026= (x^\\top z + c)^2 \\\\ \u0026= (x_1z_1 + x_2z_2 + \\cdots + x_dz_d + c)^2 \\\\ \u0026= \\sum_{i=1}^{d}x_i^2z_i^2 + \\sum_{i \\neq j}2x_ix_jz_iz_j + 2c\\sum_{i=1}^{d}x_iz_i + c^2 \\end{aligned}$$因此，feature mapping为：\n$$\\phi(x) = (x_1^2, x_2^2, \\ldots, x_d^2, \\sqrt{2}x_1x_2, \\sqrt{2}x_1x_3, \\ldots, \\sqrt{2}x_{d-1}x_d, \\sqrt{2c}x_1, \\ldots, \\sqrt{2c}x_d, c)$$维度为：$d + \\binom{d}{2} + d + 1 = d + \\frac{d(d-1)}{2} + d + 1 = \\frac{d(d+3)}{2} + 1 = O(d^2)$\n计算效率比较：\nFeature map方法： 计算 $\\phi(x^{(i)})$：$O(d^2)$ 每个样本 内积 $\\theta^\\top\\phi(x^{(i)})$：$O(d^2)$ 更新 $\\theta$：$O(d^2)$ 总计：$O(nd^2)$ 每轮SGD Kernel method： 计算核矩阵 $K$：$O(n^2d)$（一次性预计算） 更新参数：$O(n^2)$（矩阵向量乘法） 总计：$O(n^2d + n^2) = O(n^2d)$ 每轮 效率比：\n$$\\frac{\\text{Feature map}}{\\text{Kernel method}} = \\frac{O(nd^2)}{O(n^2d)} = \\frac{d}{n}$$ 当 $n \\ll d$ 时（样本少，特征多），Kernel method更高效 当 $n \\gg d$ 时（样本多，特征少），Feature map方法更高效 第十一题：超平面的函数间隔和几何间隔 题目： 对超平面 $w^\\top x + b = 0$，样本 $x^{(i)}$ 到的函数间隔 $\\hat{\\gamma}^{(i)}$ 与几何间隔 $\\gamma^{(i)}$ 满足何关系？直接给出答案即可。\n解：\n函数间隔定义为：\n$$\\hat{\\gamma}^{(i)} = y^{(i)}(w^\\top x^{(i)} + b)$$几何间隔定义为：\n$\\gamma^{(i)} = \\frac{y^{(i)}(w^\\top x^{(i)} + b)}{|w|} = \\frac{\\hat{\\gamma}^{(i)}}{|w|}$\n关系：\n$\\gamma^{(i)} = \\frac{\\hat{\\gamma}^{(i)}}{|w|}$\n几何间隔是函数间隔除以权重向量的范数，表示点到超平面的真实距离。\n第十二题：SVM的Lagrange函数和对偶形式 题目： 已知SVM的优化目标为：\n$$ \\min_{w,b} \\quad \\frac{1}{2}\\|w\\|^2 \\qquad (1) $$$$ \\text{s.t.} \\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1, \\quad i=1,\\ldots,n $$请构造其Lagrange函数 $\\mathcal{L}(w,b,\\alpha)$。\n已知 $\\mathcal{L}(w,b,\\alpha)$ 满足Slater条件，因此强对偶成立，问题(1)最终可转化为 $\\max_{\\alpha;\\alpha_i\\geq 0}\\min_w \\mathcal{L}(w,b,\\alpha)$，证明该对偶形式问题可进一步转化为：\n$$ \\max_\\alpha W(\\alpha) = \\max_\\alpha \\left(\\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle\\right) \\qquad (2) $$约束条件：\n$$ \\alpha_i \\geq 0, \\quad i=1,\\ldots,n $$$$ \\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0 $$解：\n步骤1：构造Lagrange函数\n$\\mathcal{L}(w,b,\\alpha) = \\frac{1}{2}|w|^2 - \\sum_{i=1}^{n}\\alpha_i[y^{(i)}(w^\\top x^{(i)} + b) - 1]$\n其中 $\\alpha_i \\geq 0$ 为Lagrange乘子。\n步骤2：固定 $\\alpha$，对 $w$ 求导\n$\\frac{\\partial \\mathcal{L}}{\\partial w} = w - \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)} = 0$\n因此：\n$w = \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}$\n步骤3：固定 $\\alpha$，对 $b$ 求导\n$\\frac{\\partial \\mathcal{L}}{\\partial b} = -\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$\n因此：\n$\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$\n步骤4：代入Lagrange函数\n将 $w = \\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}$ 代入 $\\mathcal{L}$：\n$\\begin{aligned} \\mathcal{L}(w,b,\\alpha) \u0026= \\frac{1}{2}w^\\top w - \\sum_{i=1}^{n}\\alpha_i y^{(i)} w^\\top x^{(i)} - b\\sum_{i=1}^{n}\\alpha_i y^{(i)} + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\frac{1}{2}\\left(\\sum_{i=1}^{n}\\alpha_i y^{(i)} x^{(i)}\\right)^\\top\\left(\\sum_{j=1}^{n}\\alpha_j y^{(j)} x^{(j)}\\right) - \\sum_{i=1}^{n}\\alpha_i y^{(i)} \\left(\\sum_{j=1}^{n}\\alpha_j y^{(j)} x^{(j)}\\right)^\\top x^{(i)} + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle - \\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle + \\sum_{i=1}^{n}\\alpha_i \\\\ \u0026= \\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i\\alpha_j y^{(i)}y^{(j)}\\langle x^{(i)}, x^{(j)}\\rangle \\end{aligned}$\n其中使用了 $\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$，所以 $b$ 项消失。\n因此对偶问题为：\n$\\max_\\alpha W(\\alpha) = \\max_\\alpha \\left(\\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle\\right)$\n约束条件为：\n$\\begin{aligned} \\alpha_i \u0026\\geq 0, \\quad i=1,\\ldots,n \\\\ \\sum_{i=1}^{n}\\alpha_i y^{(i)} \u0026= 0 \\end{aligned}$\n第十三题：线性不可分的SVM与L1正则 题目： 对线性不可分的训练集，SVM对应带L1正则的优化目标是什么？已知对线性可分情况的优化为：\n$$ \\min_{w,b} \\quad \\frac{1}{2}\\|w\\|^2 \\qquad (1) $$ $$ \\text{s.t.} \\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1, \\quad i=1,\\ldots,n $$解：\n对于线性不可分的情况，引入松弛变量 $\\xi_i \\geq 0$，允许某些样本违反间隔约束。\n带L1正则的软间隔SVM优化目标为：\n$\\begin{aligned} \\min_{w,b,\\xi} \u0026\\quad \\frac{1}{2}|w|^2 + C\\sum_{i=1}^{n}\\xi_i \\\\ \\text{s.t.} \u0026\\quad y^{(i)}(w^\\top x^{(i)} + b) \\geq 1 - \\xi_i, \\quad i=1,\\ldots,n \\\\ \u0026\\quad \\xi_i \\geq 0, \\quad i=1,\\ldots,n \\end{aligned}$\n其中：\n$\\xi_i$ 是松弛变量，表示样本 $i$ 违反间隔的程度 $C \u003e 0$ 是惩罚参数，控制间隔最大化与违反程度之间的权衡 $C\\sum_{i=1}^{n}\\xi_i$ 是L1正则项（对松弛变量的惩罚） 这个目标函数平衡了两个目标：\n最大化间隔（通过最小化 $|w|^2$） 最小化分类错误（通过最小化 $\\sum\\xi_i$） 第十四题：SVM最优化问题分析 题目： 已知SVM的最终优化目标为：\n$W(\\alpha) = \\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^{n}y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle$\n假设此时正在优化 $\\alpha_1$ 与 $\\alpha_2$，并有 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$。请推导此时 $\\alpha_2$ 应当更新的值。\n解：\n简化目标函数：\n在固定其他 $\\alpha_i$ ($i \\geq 3$) 的情况下，目标函数关于 $\\alpha_1, \\alpha_2$ 可写为：\n$W(\\alpha_1, \\alpha_2) = \\alpha_1 + \\alpha_2 + W_0 - \\frac{1}{2}[K_{11}\\alpha_1^2 + K_{22}\\alpha_2^2 + 2K_{12}\\alpha_1\\alpha_2y^{(1)}y^{(2)}] + \\text{线性项}$\n其中 $K_{ij} = \\langle x^{(i)}, x^{(j)}\\rangle$，$W_0$ 是常数项。\n利用约束 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$：\n这个约束来自 $\\sum_{i=1}^{n}\\alpha_i y^{(i)} = 0$，可以改写为：\n$\\alpha_1 y^{(1)} + \\alpha_2 y^{(2)} = -\\sum_{i=3}^{n}\\alpha_i y^{(i)} = \\zeta \\quad \\text{（常数）}$\n将 $\\alpha_1 = (\\zeta - \\alpha_2y^{(2)})y^{(1)}$ 代入目标函数，得到关于 $\\alpha_2$ 的单变量优化问题。\n对 $\\alpha_2$ 求导并令其为0，经过复杂推导（涉及预测误差），得到 $\\alpha_2$ 的无约束最优解：\n$\\alpha_2^{\\text{new, unc}} = \\alpha_2^{\\text{old}} + \\frac{y^{(2)}(E_1 - E_2)}{\\eta}$\n其中：\n$E_i = f(x^{(i)}) - y^{(i)}$ 是预测误差 $\\eta = K_{11} + K_{22} - 2K_{12} = \\|x^{(1)} - x^{(2)}\\|^2$（特征空间距离） 考虑约束 $0 \\leq \\alpha_2 \\leq C$：\n根据约束 $\\alpha_1 y^{(1)} + \\alpha_2 y^{(2)} = \\zeta$：\n若 $y^{(1)} \\neq y^{(2)}$： $L = \\max(0, \\alpha_2^{\\text{old}} - \\alpha_1^{\\text{old}}), \\quad H = \\min(C, C + \\alpha_2^{\\text{old}} - \\alpha_1^{\\text{old}})$ 若 $y^{(1)} = y^{(2)}$： $L = \\max(0, \\alpha_1^{\\text{old}} + \\alpha_2^{\\text{old}} - C), \\quad H = \\min(C, \\alpha_1^{\\text{old}} + \\alpha_2^{\\text{old}})$ 最终更新公式：\n$\\alpha_2^{\\text{new}} = \\begin{cases} H \u0026 \\text{if } \\alpha_2^{\\text{new, unc}} \u003e H \\\\ \\alpha_2^{\\text{new, unc}} \u0026 \\text{if } L \\leq \\alpha_2^{\\text{new, unc}} \\leq H \\\\ L \u0026 \\text{if } \\alpha_2^{\\text{new, unc}} \u003c L \\end{cases}$\n然后通过约束更新 $\\alpha_1$：\n$\\alpha_1^{\\text{new}} = \\alpha_1^{\\text{old}} + y^{(1)}y^{(2)}(\\alpha_2^{\\text{old}} - \\alpha_2^{\\text{new}})$\n第十五题：信息增益比计算 题目： 计算给定数据集中四个特征的信息增益比。可保留log项，统一底数为2。\n解：\n首先计算数据集的熵。类别分布：否=6，是=9，总计15。\n$H(D) = -\\frac{6}{15}\\log_2\\frac{6}{15} - \\frac{9}{15}\\log_2\\frac{9}{15} = -0.4\\log_2(0.4) - 0.6\\log_2(0.6) = 0.971$\n特征1：年龄 青年(5个)：否=3，是=2，$H = 0.971$ 中年(5个)：否=1，是=4，$H = 0.722$ 老年(5个)：否=2，是=3，$H = 0.971$ 条件熵：\n$H(D|\\text{年龄}) = \\frac{5}{15}(0.971) + \\frac{5}{15}(0.722) + \\frac{5}{15}(0.971) = 0.888$\n信息增益：\n$\\text{Gain}(\\text{年龄}) = 0.971 - 0.888 = 0.083$\n特征熵（分裂信息）：\n$H_A(\\text{年龄}) = -3 \\times \\frac{5}{15}\\log_2\\frac{5}{15} = \\log_2 3 = 1.585$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{年龄}) = \\frac{0.083}{1.585} = 0.052 $$特征2：有工作 否(8个)：否=4，是=4，$H = 1.0$ 是(7个)：否=2，是=5，$H = 0.863$ 条件熵：$H(D|\\text{有工作}) = 0.936$\n信息增益：$\\text{Gain}(\\text{有工作}) = 0.035$\n特征熵：$H_A(\\text{有工作}) = 0.997$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{有工作}) = 0.035 $$特征3：有自己的房子 否(9个)：否=3，是=6，$H = 0.918$ 是(6个)：否=3，是=3，$H = 1.0$ 条件熵：$H(D|\\text{有房}) = 0.951$\n信息增益：$\\text{Gain}(\\text{有房}) = 0.020$\n特征熵：$H_A(\\text{有房}) = 0.971$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{有房}) = 0.021 $$特征4：信贷情况 一般(5个)：否=4，是=1，$H = 0.722$ 好(6个)：否=2，是=4，$H = 0.918$ 非常好(4个)：否=0，是=4，$H = 0$ 条件熵：$H(D|\\text{信贷}) = 0.608$\n信息增益：$\\text{Gain}(\\text{信贷}) = 0.363$\n特征熵：$H_A(\\text{信贷}) = 1.557$\n信息增益比：\n$$ \\text{Gain\\_ratio}(\\text{信贷}) = 0.233 $$总结（信息增益比排序） 信贷情况：0.233 ⭐（最佳分裂特征） 年龄：0.052 有工作：0.035 有自己的房子：0.021 应选择\u0026quot;信贷情况\u0026quot;作为根节点的分裂特征。\n第十六题：XGBoost损失函数二阶泰勒展开 题目： 已知XGBoost优化第t棵树时的损失函数为：\n$\\mathcal{L}^{(t)} = \\sum_{i=1}^{n}l(y_i, \\hat{y}*i^{(t-1)} + f_t(x_i)) + \\gamma T + \\frac{1}{2}\\lambda\\sum*{j=1}^{T}w_j^2$\n请推导 $l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i))$ 在 $l(y_i, \\hat{y}_i^{(t-1)})$ 处对于 $f_t(x_i)$ 的二阶泰勒展开。其中，一阶和二阶导数可使用：\n$g_i = \\frac{\\partial l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i}\\Big|*{\\hat{y}_i^{(t-1)}}, \\quad h_i = \\frac{\\partial^2 l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i^2}\\Big|*{\\hat{y}_i^{(t-1)}}$\n在此基础上，推导叶子节点 $j$ 对应的 $w_j^*$ 满足：\n$w_j^* = -\\frac{\\sum_{i \\in \\mathcal{I}*j}g_i}{\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda}$\n其中，$\\mathcal{I}_j = \\{i \\mid q(x_i) = j\\}$ 表示属于叶子节点 $j$ 的样本集合。\n解：\n二阶泰勒展开 在 $\\hat{y}_i^{(t-1)}$ 处对 $l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i))$ 关于 $f_t(x_i)$ 进行二阶泰勒展开：\n$\\begin{aligned} l(y_i, \\hat{y}_i^{(t-1)} + f_t(x_i)) \u0026\\approx l(y_i, \\hat{y}_i^{(t-1)}) + \\frac{\\partial l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i}\\Big|*{\\hat{y}_i^{(t-1)}} \\cdot f_t(x_i) \\\\ \u0026\\quad + \\frac{1}{2}\\frac{\\partial^2 l(y_i, \\hat{y}_i)}{\\partial \\hat{y}*i^2}\\Big|*{\\hat{y}_i^{(t-1)}} \\cdot f_t(x_i)^2 \\\\ \u0026= l(y_i, \\hat{y}_i^{(t-1)}) + g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2 \\end{aligned}$\n因此损失函数变为：\n$\\mathcal{L}^{(t)} \\approx \\sum_{i=1}^{n}[l(y_i, \\hat{y}*i^{(t-1)}) + g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2] + \\gamma T + \\frac{1}{2}\\lambda\\sum*{j=1}^{T}w_j^2$\n去掉常数项 $\\sum_{i=1}^{n}l(y_i, \\hat{y}_i^{(t-1)})$：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{i=1}^{n}[g_i f_t(x_i) + \\frac{1}{2}h_i f_t(x_i)^2] + \\gamma T + \\frac{1}{2}\\lambda\\sum_{j=1}^{T}w_j^2$\n推导叶子权重 $w_j^*$ 对于树模型，$f_t(x_i) = w_{q(x_i)}$，其中 $q(x_i)$ 表示样本 $i$ 落在的叶子节点。\n将样本按叶子节点分组：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{j=1}^{T}\\left[\\left(\\sum_{i \\in \\mathcal{I}*j}g_i\\right)w_j + \\frac{1}{2}\\left(\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda\\right)w_j^2\\right] + \\gamma T$\n记 $G_j = \\sum_{i \\in \\mathcal{I}*j}g_i$，$H_j = \\sum*{i \\in \\mathcal{I}_j}h_i$，则：\n$\\tilde{\\mathcal{L}}^{(t)} = \\sum_{j=1}^{T}\\left[G_j w_j + \\frac{1}{2}(H_j + \\lambda)w_j^2\\right] + \\gamma T$\n对 $w_j$ 求导并令其为0：\n$\\frac{\\partial \\tilde{\\mathcal{L}}^{(t)}}{\\partial w_j} = G_j + (H_j + \\lambda)w_j = 0$\n解得：\n$w_j^* = -\\frac{G_j}{H_j + \\lambda} = -\\frac{\\sum_{i \\in \\mathcal{I}*j}g_i}{\\sum*{i \\in \\mathcal{I}_j}h_i + \\lambda}$\n这就是叶子节点的最优权重。将其代入损失函数，得到：\n$\\tilde{\\mathcal{L}}^{(t)} = -\\frac{1}{2}\\sum_{j=1}^{T}\\frac{G_j^2}{H_j + \\lambda} + \\gamma T$\n这个公式用于评估树结构的质量，指导分裂决策。\n","permalink":"http://localhost:1313/posts/ml-exercise-set/","summary":"胡老师上的机器学习课程习题集解答汇总","title":"机器学习习题集"},{"content":"前言 四川麻将，又称成都麻将或血战麻将，是中国最流行的麻将玩法之一。与传统麻将相比，四川麻将节奏快、变化多，充满了刺激性和趣味性。本文将带你从零开始，系统学习四川麻将的规则和技巧。\n一、基础规则入门 1.1 牌面组成 四川麻将使用108张牌，包括：\n万子：一万到九万，各4张（36张） 条子：一条到九条，各4张（36张） 筒子：一筒到九筒，各4张（36张） 注意：四川麻将没有东南西北中发白这些字牌和花牌。\n1.2 基本概念 刻子：三张相同的牌（如：三张五万） 顺子：三张连续的同花色牌（如：三四五条） 对子：两张相同的牌（如：两张八筒） 杠：四张相同的牌\n1.3 胡牌基本型 标准胡牌牌型：3n+2 结构（n个刻子或顺子 + 1个对子）\n例如：\n一一一 + 二三四 + 五六七 + 八八八 + 九九（4组3张+1对） 1.4 游戏流程 定庄：掷骰子决定庄家 配牌：每人抓13张牌，庄家多抓一张（14张） 出牌：庄家先出一张牌，其他玩家依次摸牌、出牌 胡牌：谁先凑齐胡牌牌型谁获胜 血战到底：已胡牌的玩家退出，剩余玩家继续游戏，直到3人胡牌或流局 二、四川麻将特色规则 2.1 缺一门 四川麻将的核心规则：必须缺一门才能胡牌\n也就是说，你的手牌中只能有两种花色（万、条、筒三选二）。\n例如：\n✅ 可以胡：万子+条子（缺筒） ✅ 可以胡：万子+筒子（缺条） ❌ 不能胡：万子+条子+筒子（三门齐全） 2.2 杠牌规则 明杠：\n碰牌后，再摸到第四张，可以杠牌 别人打出的牌，自己有三张，可以直接杠 暗杠：\n自己摸到四张相同的牌，可以暗杠 杠牌后：\n摸一张牌 多算一番（底分×2） 杠后可以继续杠或胡牌 2.3 血战到底 这是四川麻将最大的特色：\n第一个人胡牌后不结束游戏 剩余三人继续打，直到有第二、第三个人胡牌 最后没胡的人要赔给所有胡牌的人 第一个胡牌的人可以继续胡（查叫） 2.4 查叫 游戏结束时，如果有人没胡牌：\n如果他已听牌（只差一张就能胡），他只赔给胡牌的人 如果他未听牌（没有听牌），他要加倍赔偿 三、番型与计分 3.1 基础番型 番型 番数 说明 平胡 1番 基础胡牌 自摸 1番 自己摸牌胡 根（杠） 1番 每杠一次+1番 对对胡 2番 全是刻子+对子，没有顺子 清一色 4番 全部是一种花色 龙七对 4番 七个对子 天胡 封顶 庄家起手就胡 地胡 封顶 闲家第一轮胡 3.2 计分方式 基础公式：底分 × 2^(番数)\n例如：\n底分1元，平胡（1番）= 1×2¹ = 2元 底分1元，清一色（4番）= 1×2⁴ = 16元 底分1元，清一色+对对胡（6番）= 1×2⁶ = 64元 封顶：很多地方设置封顶番数（如10番），防止输赢过大\n四、进阶技巧 4.1 定缺策略 游戏开始后，要快速决定缺哪一门：\n判断依据：\n数量最少的门：哪门牌少就缺哪门 孤张多的门：有很多不连续的孤张，这门不好组合 对子情况：如果某门有对子，考虑留下，可能组成刻子 例子：\n手牌：一万 三万 五万 六万 | 二条 七条 | 一筒 二筒 三筒 四筒 八筒 九筒 分析：万子4张分散，条子2张，筒子6张且有顺子潜力 建议：缺条子 4.2 听牌技巧 多面听优于单钓：\n单钓：只有一种牌能胡（如：等一张五万） 两面听：能胡两种牌（如：三四条，等二条或五条） 多面听：能胡多种牌（如：卡张、边张、对子等组合） 例子：\n手牌：一万 二万 | 三万 四万 | 五万 六万 | 七万 八万 | 九万 拆牌选择： - 打九万：听二万和五万（两面） - 打一万：听三万和六万和九万（多面） 建议打一万，听牌面更多 4.3 防守策略 观察舍牌：\n对手打出的牌反映他要什么、不要什么 如果对手大量打某一门，可能在做清一色 如果对手突然不打某种牌，可能在攒那个牌 生张和熟张：\n生张：桌面上没出现过的牌，危险度较高 熟张：已经有人打过的牌，相对安全 听牌信号：\n出牌犹豫 打牌速度突然变化 开始打生张或中张 4.4 做大牌策略 什么时候做大牌：\n起手牌型好（比如某门很多，可以做清一色） 当前领先或持平，可以冒险 对手没有明显听牌迹象 做大牌风险：\n听牌较慢，容易被别人截胡 如果未听牌查叫，要加倍赔偿 建议新手以稳为主，先保证听牌 4.5 心理战术 诱敌出牌：\n故意打出中张，引诱对手出你需要的牌 注意节奏，不要过于明显 藏牌意图：\n不要急于碰牌或杠牌，暴露自己的牌型 暗刻比明刻更有迷惑性 施压策略：\n快速出牌，给对手压力 适当沉默，让对手摸不清你的意图 五、常见错误与避免 5.1 新手常犯错误 忘记缺门：手牌三门齐全还以为能胡 盲目做大牌：不顾牌型强行做清一色，最后未听牌 不会算番：不知道自己多少番，糊里糊涂胡牌 乱碰乱杠：过早暴露牌型，让对手防范 不看舍牌：只顾自己手牌，不观察对手 5.2 进阶常犯错误 过度防守：太在意对手，错失自己的听牌机会 贪大求全：总想胡大牌，反而听牌慢 不会放弃：明知牌型不好还死撑，最后查叫 心态失衡：连续点炮后急躁，决策失误 六、实战案例分析 案例1：定缺选择 起手牌：\n二万 四万 六万 八万 九万 一条 二条 三条 五筒 六筒 七筒 八筒 分析：\n万子：5张但分散，不易组合 条子：3张成顺，很好 筒子：4张有两个顺子潜力 决策：缺万子，保留条筒两门\n案例2：听牌选择 当前牌型：\n二万 三万 四万 | 五万 六万 七万 | 一条 二条 三条 | 五筒 六筒 | 八筒 八筒 选择1：打五筒或六筒，听七筒（单钓） 选择2：打八筒，听四筒或七筒（两面）\n决策：选择2更优，两面听更容易胡牌\n案例3：要不要做清一色 当前牌型（已缺条）：\n一万 二万 三万 四万 五万 六万 | 二筒 五筒 七筒 | 八筒 八筒 分析：\n距离清一色还差3张筒子替换万子 如果做清一色，需要拆掉现有的顺子 当前可以快速听牌（1-2轮） 决策：不做清一色，保证快速听牌，除非后续摸牌特别好\n七、练习建议 7.1 新手阶段 熟悉规则：先玩小局，熟悉缺门、血战等规则 记住番型：至少记住基础番型和分数 多观察：看别人怎么打，学习经验 求稳为主：不要急于做大牌，先学会稳定胡牌 7.2 进阶阶段 提高速度：加快判断和决策速度 学习算牌：记住哪些牌出过，推测剩余牌 心理博弈：学会观察对手，做出针对性策略 复盘总结：每局结束后思考得失 7.3 推荐练习方式 线上平台：在手机或电脑上玩四川麻将游戏，方便练习 观战学习：看高手直播或录像，学习思路 实战练习：找朋友线下对局，积累实战经验 理论学习：阅读麻将书籍或教程，系统提升 八、总结 四川麻将规则简单但策略丰富，从新手到高手需要：\n扎实的基本功：熟练掌握规则和番型 灵活的战术：根据牌型和局势调整策略 敏锐的观察力：读懂对手意图，做出正确判断 稳定的心态：胜不骄败不馁，理性决策 记住：麻将三分靠运气，七分靠技术。多练习、多思考，你一定能成为四川麻将高手！\n祝你好运，胡牌多多！🀄\n","permalink":"http://localhost:1313/posts/sichuan-mahjong-guide/","summary":"四川麻将完全攻略：从基础规则到高阶技巧，涵盖缺一门、血战到底、番型计分、定缺策略、听牌技巧、防守要点和实战案例分析。无论你是零基础| 新手还是想提升的进阶玩家，这篇指南都能帮你系统掌握四川麻将的精髓，快速从入门到精通。","title":"四川麻将指南"},{"content":"Windows PowerShell 常用指令 文件和目录操作 列出目录内容\nGet-ChildItem / ls - 列出当前目录内容 ls -Force - 显示隐藏文件 ls -Recurse - 递归列出所有子目录 ls | Sort-Object Length -Descending - 按文件大小排序 切换目录\nSet-Location \u0026lt;路径\u0026gt; / cd - 切换目录 cd ~ - 返回用户主目录 cd .. - 返回上级目录 cd - - 返回上一个目录 创建文件和目录\nNew-Item -ItemType Directory \u0026lt;名称\u0026gt; / mkdir - 创建目录 New-Item -ItemType File \u0026lt;名称\u0026gt; / ni - 创建文件 复制、移动和删除\nCopy-Item \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; 复制文件\nMove-Item \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; / mv - 移动/重命名文件\nRemove-Item \u0026lt;路径\u0026gt; 删除文件\n查看文件\nGet-Content \u0026lt;文件\u0026gt; / cat - 查看文件内容 Get-Content \u0026lt;文件\u0026gt; -Tail 10 - 查看最后 10 行 Get-Content \u0026lt;文件\u0026gt; -Wait - 实时查看文件更新（类似 tail -f） Test-Path \u0026lt;路径\u0026gt; - 检查路径是否存在 以默认方式打开文件或目录\nstart filename打开当前目录下的指定文件 code filename使用vscode打开 code .使用vscode打开当前目录 文本处理和搜索 Select-String \u0026lt;模式\u0026gt; \u0026lt;文件\u0026gt; - 在文件中搜索文本（类似 grep） Select-String \u0026quot;error\u0026quot; *.log - 在所有 log 文件中搜索 ls -Recurse | Select-String \u0026quot;TODO\u0026quot; - 递归搜索 Out-File \u0026lt;文件\u0026gt; - 输出重定向到文件 Tee-Object \u0026lt;文件\u0026gt; - 同时输出到控制台和文件 系统信息和管理 进程管理\nGet-Process / ps - 查看进程列表 Get-Process | Sort-Object CPU -Descending | Select-Object -First 5 - CPU 占用最高的 5 个进程 Stop-Process -Name \u0026lt;进程名\u0026gt; - 结束进程 服务管理\nGet-Service - 查看服务列表 Get-Service | Where-Object {$_.Status -eq \u0026quot;Running\u0026quot;} - 只显示运行中的服务 Start-Service \u0026lt;服务名\u0026gt; - 启动服务 Stop-Service \u0026lt;服务名\u0026gt; - 停止服务 系统信息\nGet-ComputerInfo - 查看计算机信息 Get-NetIPAddress - 查看网络配置 Get-Disk - 查看磁盘信息 Get-Volume - 查看卷信息 systeminfo - 显示详细系统信息 环境变量 $env:PATH - 查看 PATH 环境变量 $env:变量名 = \u0026quot;值\u0026quot; - 设置临时环境变量 [Environment]::SetEnvironmentVariable(\u0026quot;变量名\u0026quot;, \u0026quot;值\u0026quot;, \u0026quot;User\u0026quot;) - 永久设置 网络操作 Test-Connection \u0026lt;主机\u0026gt; / ping - 测试网络连接 Invoke-WebRequest \u0026lt;URL\u0026gt; / curl - 发送 HTTP 请求 Invoke-WebRequest -Uri \u0026lt;URL\u0026gt; -OutFile \u0026lt;文件\u0026gt; - 下载文件 Get-NetTCPConnection - 查看 TCP 连接 ipconfig - 查看 IP 配置 ipconfig /flushdns - 刷新 DNS 缓存 实用命令 Clear-Host / cls - 清屏 Get-History / history - 查看命令历史 Get-Help \u0026lt;命令\u0026gt; - 获取帮助 Get-Help \u0026lt;命令\u0026gt; -Examples - 查看使用示例 Get-Command - 列出所有可用命令 Get-Command *process* - 搜索包含 process 的命令 Get-Alias - 查看所有别名 Measure-Object - 统计对象 Start-Process \u0026lt;程序\u0026gt; - 启动程序 Get-Location / pwd - 显示当前路径 Linux Terminal 常用指令 文件和目录操作 列出目录\nls - 列出目录内容 ls -l - 长格式显示（详细信息） ls -a - 显示隐藏文件 ls -lh - 人性化显示文件大小 ls -lt - 按修改时间排序 ls -lS - 按文件大小排序 ls -R - 递归列出所有子目录 切换目录\ncd \u0026lt;路径\u0026gt; - 切换目录 cd / cd ~ - 返回主目录 cd .. - 返回上级目录 cd - - 返回上一个目录 pwd - 显示当前完整路径 创建\nmkdir \u0026lt;目录名\u0026gt; - 创建目录 mkdir -p a/b/c - 递归创建多级目录 touch \u0026lt;文件名\u0026gt; - 创建空文件或更新时间戳 复制、移动和删除\ncp \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 复制文件 cp -r \u0026lt;源目录\u0026gt; \u0026lt;目标\u0026gt; - 递归复制目录 cp -i \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 交互式复制（覆盖前询问） mv \u0026lt;源\u0026gt; \u0026lt;目标\u0026gt; - 移动/重命名文件 rm \u0026lt;文件\u0026gt; - 删除文件 rm -r \u0026lt;目录\u0026gt; - 递归删除目录 rm -f \u0026lt;文件\u0026gt; - 强制删除 rm -rf \u0026lt;目录\u0026gt; - 强制递归删除（危险！） rm -i \u0026lt;文件\u0026gt; - 交互式删除（推荐） 链接\nln -s \u0026lt;源\u0026gt; \u0026lt;链接名\u0026gt; - 创建符号链接 readlink -f \u0026lt;链接\u0026gt; - 查看链接目标 文件查看和编辑 查看文件\ncat \u0026lt;文件\u0026gt; - 显示文件内容 cat -n \u0026lt;文件\u0026gt; - 显示行号 less \u0026lt;文件\u0026gt; - 分页查看（可前后翻页） more \u0026lt;文件\u0026gt; - 分页查看（只能向前） head \u0026lt;文件\u0026gt; - 查看文件开头 head -n 20 \u0026lt;文件\u0026gt; - 查看前 20 行 tail \u0026lt;文件\u0026gt; - 查看文件末尾 tail -n 20 \u0026lt;文件\u0026gt; - 查看最后 20 行 tail -f \u0026lt;文件\u0026gt; - 实时查看文件更新 tail -f \u0026lt;文件\u0026gt; | grep \u0026quot;error\u0026quot; - 实时过滤查看 编辑文件\nnano \u0026lt;文件\u0026gt; - 简单文本编辑器 vim \u0026lt;文件\u0026gt; / vi \u0026lt;文件\u0026gt; - 强大的文本编辑器 统计文件\nwc \u0026lt;文件\u0026gt; - 统计文件 wc -l \u0026lt;文件\u0026gt; - 统计行数 wc -w \u0026lt;文件\u0026gt; - 统计单词数 wc -c \u0026lt;文件\u0026gt; - 统计字节数 文件搜索和查找 find 命令\nfind \u0026lt;路径\u0026gt; -name \u0026lt;名称\u0026gt; - 按名称查找 find . -name \u0026quot;*.txt\u0026quot; - 查找所有 txt 文件 find . -type f -name \u0026quot;*.log\u0026quot; - 查找文件（不含目录） find . -type d -name \u0026quot;node_modules\u0026quot; - 查找目录 find . -mtime -7 - 查找 7 天内修改的文件 find . -size +100M - 查找大于 100MB 的文件 find . -name \u0026quot;*.tmp\u0026quot; -delete - 查找并删除 grep 命令\ngrep \u0026lt;模式\u0026gt; \u0026lt;文件\u0026gt; - 搜索文本 grep -r \u0026quot;TODO\u0026quot; . - 递归搜索当前目录 grep -i \u0026quot;error\u0026quot; log.txt - 忽略大小写 grep -n \u0026quot;function\u0026quot; code.js - 显示行号 grep -v \u0026quot;debug\u0026quot; log.txt - 反向匹配（不包含） grep -E \u0026quot;error|warning\u0026quot; log.txt - 使用正则表达式 grep -c \u0026quot;error\u0026quot; log.txt - 统计匹配行数 其他查找工具\nlocate \u0026lt;文件名\u0026gt; - 快速查找文件 updatedb - 更新 locate 数据库 which \u0026lt;命令\u0026gt; - 查找命令位置 whereis \u0026lt;程序\u0026gt; - 查找程序位置 文件权限 chmod \u0026lt;权限\u0026gt; \u0026lt;文件\u0026gt; - 修改文件权限 chmod 755 script.sh - 数字方式（rwxr-xr-x） chmod +x script.sh - 添加执行权限 chmod -R 644 directory/ - 递归修改 chown \u0026lt;用户\u0026gt;:\u0026lt;组\u0026gt; \u0026lt;文件\u0026gt; - 修改所有者 chgrp \u0026lt;组\u0026gt; \u0026lt;文件\u0026gt; - 修改所属组 umask - 查看或设置默认权限掩码 进程管理 查看进程\nps - 查看进程 ps aux - 查看所有进程详细信息 ps -ef - 另一种格式 ps aux | grep \u0026lt;进程名\u0026gt; - 搜索特定进程 top - 实时查看系统资源（按 q 退出） htop - 增强版 top 管理进程\nkill \u0026lt;PID\u0026gt; - 结束进程 kill -9 \u0026lt;PID\u0026gt; - 强制结束 killall \u0026lt;进程名\u0026gt; - 按名称结束进程 pkill \u0026lt;进程名\u0026gt; - 按模式匹配结束 bg - 将任务放到后台 fg - 将后台任务调到前台 jobs - 查看后台任务 nohup \u0026lt;命令\u0026gt; \u0026amp; - 后台运行，不受终端关闭影响 磁盘和存储 df -h - 查看磁盘使用情况 du -sh \u0026lt;目录\u0026gt; - 查看目录大小 du -h --max-depth=1 - 查看各子目录大小 du -sh * | sort -h - 按大小排序 free -h - 查看内存使用 lsblk - 列出块设备 mount - 挂载文件系统 umount - 卸载文件系统 系统信息 uname -a - 完整系统信息 uname -r - 内核版本 hostname - 主机名 whoami - 当前用户 id - 用户 ID 和组 ID uptime - 系统运行时间和负载 date - 系统时间 cal - 日历 lsb_release -a - Linux 发行版信息（Ubuntu/Debian） cat /etc/os-release - 系统版本信息 网络操作 连接测试\nping \u0026lt;地址\u0026gt; - 测试网络连接 ping -c 4 google.com - 发送 4 个包后停止 traceroute \u0026lt;地址\u0026gt; - 追踪路由路径 文件传输\ncurl \u0026lt;URL\u0026gt; - 发送 HTTP 请求 curl -O \u0026lt;URL\u0026gt; - 下载文件（保持原文件名） curl -o \u0026lt;文件名\u0026gt; \u0026lt;URL\u0026gt; - 下载并重命名 curl -I \u0026lt;URL\u0026gt; - 只获取 HTTP 头 curl -X POST -d \u0026quot;data\u0026quot; \u0026lt;URL\u0026gt; - 发送 POST 请求 wget \u0026lt;URL\u0026gt; - 下载文件 wget -c \u0026lt;URL\u0026gt; - 断点续传 远程连接\nssh \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt; - SSH 连接 ssh -p \u0026lt;端口\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt; - 指定端口 scp \u0026lt;源\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt;:\u0026lt;目标\u0026gt; - 安全复制文件 scp -r \u0026lt;目录\u0026gt; \u0026lt;用户\u0026gt;@\u0026lt;主机\u0026gt;:\u0026lt;目标\u0026gt; - 复制目录 网络信息\nnetstat -tuln - 查看网络端口（传统） ss -tuln - 查看网络端口（现代） ip addr / ifconfig - 查看网络接口 nslookup \u0026lt;域名\u0026gt; - DNS 查询 dig \u0026lt;域名\u0026gt; - DNS 详细查询 压缩和解压 tar 格式\ntar -czf \u0026lt;文件.tar.gz\u0026gt; \u0026lt;目录\u0026gt; - 压缩为 tar.gz tar -xzf \u0026lt;文件.tar.gz\u0026gt; - 解压 tar.gz tar -xzf \u0026lt;文件.tar.gz\u0026gt; -C \u0026lt;目标目录\u0026gt; - 解压到指定目录 tar -tvf \u0026lt;文件.tar.gz\u0026gt; - 查看压缩包内容 zip 格式\nzip -r \u0026lt;文件.zip\u0026gt; \u0026lt;目录\u0026gt; - 创建 zip 压缩包 unzip \u0026lt;文件.zip\u0026gt; - 解压 zip unzip \u0026lt;文件.zip\u0026gt; -d \u0026lt;目标目录\u0026gt; - 解压到指定目录 gzip 格式\ngzip \u0026lt;文件\u0026gt; - 压缩为 .gz gunzip \u0026lt;文件.gz\u0026gt; - 解压 .gz 文本处理工具 sed（流编辑器）\nsed 's/old/new/g' file.txt - 替换文本 sed -i 's/old/new/g' file.txt - 直接修改文件 awk（文本处理）\nawk '{print $1}' file.txt - 打印第一列 awk -F',' '{print $2}' file.csv - 指定分隔符 排序和去重\nsort \u0026lt;文件\u0026gt; - 排序 sort -r \u0026lt;文件\u0026gt; - 反向排序 sort -n \u0026lt;文件\u0026gt; - 按数字排序 uniq \u0026lt;文件\u0026gt; - 去除重复行 sort file.txt | uniq - 配合使用 uniq -c \u0026lt;文件\u0026gt; - 统计重复次数 其他工具\ncut -d',' -f1,3 file.csv - 按分隔符提取列 tr 'a-z' 'A-Z' \u0026lt; file.txt - 字符转换 系统管理 用户管理\nsudo \u0026lt;命令\u0026gt; - 以管理员权限执行 su - 切换用户 su - - 切换到 root passwd - 修改密码 useradd \u0026lt;用户名\u0026gt; - 创建用户 userdel \u0026lt;用户名\u0026gt; - 删除用户 usermod -aG \u0026lt;组\u0026gt; \u0026lt;用户\u0026gt; - 添加用户到组 服务管理（systemd）\nsystemctl start \u0026lt;服务\u0026gt; - 启动服务 systemctl stop \u0026lt;服务\u0026gt; - 停止服务 systemctl restart \u0026lt;服务\u0026gt; - 重启服务 systemctl status \u0026lt;服务\u0026gt; - 查看状态 systemctl enable \u0026lt;服务\u0026gt; - 设置开机启动 journalctl -u \u0026lt;服务\u0026gt; - 查看服务日志 实用快捷键 Ctrl + C - 终止当前命令 Ctrl + Z - 暂停当前命令 Ctrl + D - 退出终端 Ctrl + L - 清屏 Ctrl + A - 光标移到行首 Ctrl + E - 光标移到行尾 Ctrl + U - 删除光标前的内容 Ctrl + K - 删除光标后的内容 Ctrl + R - 搜索命令历史 Tab - 自动补全 !! - 执行上一条命令 !$ - 上一条命令的最后一个参数 其他实用命令 clear - 清屏 history - 查看命令历史 history | grep \u0026lt;关键词\u0026gt; - 搜索历史命令 echo \u0026lt;文本\u0026gt; - 输出文本 echo \u0026quot;text\u0026quot; \u0026gt; file.txt - 覆盖写入 echo \u0026quot;text\u0026quot; \u0026gt;\u0026gt; file.txt - 追加写入 alias \u0026lt;别名\u0026gt;='\u0026lt;命令\u0026gt;' - 创建别名 watch \u0026lt;命令\u0026gt; - 定期执行命令 watch -n 2 df -h - 每 2 秒更新 xargs - 将标准输入转换为命令参数 tee \u0026lt;文件\u0026gt; - 同时输出到文件和标准输出 Git 常用指令 初始化和配置 初始化仓库\ngit init - 初始化新仓库 git clone \u0026lt;URL\u0026gt; - 克隆远程仓库 git clone \u0026lt;URL\u0026gt; \u0026lt;目录名\u0026gt; - 克隆到指定目录 git clone --depth 1 \u0026lt;URL\u0026gt; - 浅克隆（只克隆最新提交） git clone -b \u0026lt;分支名\u0026gt; \u0026lt;URL\u0026gt; - 克隆指定分支 配置 Git\ngit config --global user.name \u0026quot;\u0026lt;名字\u0026gt;\u0026quot; - 设置用户名 git config --global user.email \u0026quot;\u0026lt;邮箱\u0026gt;\u0026quot; - 设置邮箱 git config --list - 查看所有配置 git config --global core.editor \u0026quot;vim\u0026quot; - 设置编辑器 git config --global alias.st status - 设置别名 基本操作 查看状态\ngit status - 查看工作区状态 git status -s - 简短格式 添加和提交\ngit add \u0026lt;文件\u0026gt; - 添加文件到暂存区 git add . - 添加所有修改 git add -A - 添加所有变化（包括删除） git add -p - 交互式添加 git commit -m \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 提交 git commit -am \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 添加并提交已跟踪文件 git commit --amend - 修改最后一次提交 git commit --amend --no-edit - 修改提交但不改消息 推送和拉取\ngit push - 推送到远程 git push origin \u0026lt;分支名\u0026gt; - 推送指定分支 git push -u origin \u0026lt;分支名\u0026gt; - 推送并设置上游 git push --force / git push -f - 强制推送（危险！） git push --tags - 推送标签 git pull - 拉取并合并 git pull --rebase - 使用 rebase 方式拉取 git fetch - 获取但不合并 git fetch --all - 获取所有远程分支 git fetch --prune - 获取并清理已删除的远程分支 分支操作 查看分支\ngit branch - 查看本地分支 git branch -a - 查看所有分支（包括远程） git branch -r - 只查看远程分支 git branch -v - 查看分支及最后一次提交 创建和切换分支\ngit branch \u0026lt;分支名\u0026gt; - 创建分支 git checkout \u0026lt;分支名\u0026gt; - 切换分支 git checkout -b \u0026lt;分支名\u0026gt; - 创建并切换 git checkout -b \u0026lt;分支名\u0026gt; origin/\u0026lt;分支名\u0026gt; - 从远程分支创建 git switch \u0026lt;分支名\u0026gt; - 切换分支（新语法） git switch -c \u0026lt;分支名\u0026gt; - 创建并切换（新语法） 合并和删除分支\ngit merge \u0026lt;分支名\u0026gt; - 合并分支 git merge --no-ff \u0026lt;分支名\u0026gt; - 非快进合并 git merge --squash \u0026lt;分支名\u0026gt; - 压缩合并 git branch -d \u0026lt;分支名\u0026gt; - 删除已合并分支 git branch -D \u0026lt;分支名\u0026gt; - 强制删除分支 git branch -m \u0026lt;旧名\u0026gt; \u0026lt;新名\u0026gt; - 重命名分支 git push origin --delete \u0026lt;分支名\u0026gt; - 删除远程分支 查看历史 日志查看\ngit log - 查看提交历史 git log --oneline - 每个提交一行 git log --graph - 图形化显示 git log --oneline --graph --all - 图形化显示所有分支 git log -p - 显示详细差异 git log --author=\u0026quot;\u0026lt;作者\u0026gt;\u0026quot; - 按作者筛选 git log --since=\u0026quot;2 weeks ago\u0026quot; - 按时间筛选 git log --grep=\u0026quot;\u0026lt;关键词\u0026gt;\u0026quot; - 搜索提交消息 git log \u0026lt;文件\u0026gt; - 查看文件历史 git log --stat - 显示文件统计 差异比较\ngit diff - 查看未暂存的更改 git diff --staged / git diff --cached - 查看已暂存的更改 git diff \u0026lt;分支1\u0026gt; \u0026lt;分支2\u0026gt; - 比较分支 git diff \u0026lt;提交1\u0026gt; \u0026lt;提交2\u0026gt; - 比较提交 git diff HEAD - 比较工作区和最新提交 其他查看命令\ngit show \u0026lt;提交\u0026gt; - 查看提交详情 git show HEAD - 查看最新提交 git blame \u0026lt;文件\u0026gt; - 查看每行的修改者 git shortlog - 按作者分组显示 撤销和回退 撤销修改\ngit restore \u0026lt;文件\u0026gt; - 撤销工作区修改（新语法） git restore --staged \u0026lt;文件\u0026gt; - 取消暂存（新语法） git checkout -- \u0026lt;文件\u0026gt; - 撤销修改（旧语法） 重置提交\ngit reset \u0026lt;文件\u0026gt; - 取消暂存 git reset HEAD~ - 撤销最后一次提交，保留更改 git reset --soft HEAD~ - 撤销提交，更改在暂存区 git reset --hard HEAD~ - 撤销提交并丢弃更改（危险！） git reset --hard \u0026lt;提交\u0026gt; - 重置到指定提交 回退操作\ngit revert \u0026lt;提交\u0026gt; - 创建新提交来撤销 git revert HEAD - 撤销最新提交 git clean -fd - 删除未跟踪的文件 git clean -n - 预览将要删除的文件 暂存操作（Stash） git stash - 暂存当前更改 git stash save \u0026quot;描述\u0026quot; - 暂存并添加描述 git stash list - 查看暂存列表 git stash pop - 恢复并删除最新暂存 git stash apply - 恢复但不删除暂存 git stash apply stash@{0} - 恢复指定暂存 git stash drop - 删除最新暂存 git stash drop stash@{0} - 删除指定暂存 git stash clear - 清空所有暂存 git stash show - 查看暂存内容 远程仓库 查看远程\ngit remote - 查看远程仓库 git remote -v - 查看详细信息 管理远程\ngit remote add \u0026lt;名称\u0026gt; \u0026lt;URL\u0026gt; - 添加远程仓库 git remote add origin \u0026lt;URL\u0026gt; - 添加 origin git remote remove \u0026lt;名称\u0026gt; - 删除远程仓库 git remote rename \u0026lt;旧名\u0026gt; \u0026lt;新名\u0026gt; - 重命名 git remote set-url \u0026lt;名称\u0026gt; \u0026lt;新URL\u0026gt; - 修改 URL git remote show \u0026lt;名称\u0026gt; - 查看详细信息 git remote prune origin - 清理已删除的远程分支引用 标签操作 git tag - 查看所有标签 git tag \u0026lt;标签名\u0026gt; - 创建轻量标签 git tag -a \u0026lt;标签名\u0026gt; -m \u0026quot;\u0026lt;消息\u0026gt;\u0026quot; - 创建带注释的标签 git tag -d \u0026lt;标签名\u0026gt; - 删除本地标签 git push origin \u0026lt;标签名\u0026gt; - 推送标签 git push origin --tags - 推送所有标签 git push origin :refs/tags/\u0026lt;标签名\u0026gt; - 删除远程标签 高级操作 变基（Rebase）\ngit rebase \u0026lt;分支\u0026gt; - 变基到指定分支 git rebase -i HEAD~3 - 交互式变基最近 3 个提交 git rebase --continue - 解决冲突后继续 git rebase --abort - 取消变基 其他高级命令\ngit cherry-pick \u0026lt;提交\u0026gt; - 将指定提交应用到当前分支 git reflog - 查看引用日志（恢复丢失的提交） git bisect start - 开始二分查找问题提交 git submodule add \u0026lt;URL\u0026gt; - 添加子模块 git submodule update --init - 初始化并更新子模块 .gitignore 配置 New-Item -ItemType File .gitignore创建 .gitignore 文件来忽略不需要跟踪的文件：\n# 忽略日志文件 *.log # 忽略 node_modules 目录 node_modules/ # 忽略环境变量文件 .env .env.local # 忽略构建输出 dist/ build/ # 忽略操作系统文件 .DS_Store Thumbs.db # 忽略 IDE 配置 .vscode/ .idea/ GitHub CLI 常用指令 认证 gh auth login - 登录 GitHub 账号 gh auth status - 查看认证状态 gh auth logout - 登出 gh auth refresh - 刷新令牌 gh config set editor vim - 设置编辑器 仓库操作 创建和克隆\ngh repo create - 创建仓库 gh repo create \u0026lt;名称\u0026gt; - 创建指定名称的仓库 gh repo create --public - 创建公开仓库 gh repo create --private - 创建私有仓库 gh repo create --clone - 创建并克隆 gh repo clone \u0026lt;仓库\u0026gt; - 克隆仓库 gh repo clone owner/repo - 克隆指定仓库 查看和管理\ngh repo view - 查看仓库信息 gh repo view --web - 在浏览器中打开 gh repo list - 列出仓库 gh repo list \u0026lt;用户名\u0026gt; - 列出指定用户的仓库 gh repo list --limit 50 - 限制显示数量 gh repo fork - Fork 仓库 gh repo fork --clone - Fork 并克隆 gh repo delete \u0026lt;仓库\u0026gt; - 删除仓库 gh repo rename \u0026lt;新名称\u0026gt; - 重命名仓库 or gh repo rename owner/repo 新名字 gh repo sync - 同步 fork Pull Request 创建 PR\ngh pr create - 创建 PR gh pr create --title \u0026quot;标题\u0026quot; --body \u0026quot;描述\u0026quot; - 指定标题和描述 gh pr create --web - 在浏览器中创建 gh pr create --draft - 创建草稿 PR 查看 PR\ngh pr list - 列出 PR gh pr list --state open - 只显示开放的 gh pr list --author \u0026lt;用户名\u0026gt; - 按作者筛选 gh pr list --label \u0026lt;标签\u0026gt; - 按标签筛选 gh pr view \u0026lt;编号\u0026gt; - 查看详情 gh pr view \u0026lt;编号\u0026gt; --web - 在浏览器中查看 gh pr view \u0026lt;编号\u0026gt; --comments - 查看评论 操作 PR\ngh pr checkout \u0026lt;编号\u0026gt; - 检出 PR 分支 gh pr diff \u0026lt;编号\u0026gt; - 查看差异 gh pr merge \u0026lt;编号\u0026gt; - 合并 PR gh pr merge \u0026lt;编号\u0026gt; --squash - 压缩合并 gh pr merge \u0026lt;编号\u0026gt; --rebase - 变基合并 gh pr close \u0026lt;编号\u0026gt; - 关闭 PR gh pr reopen \u0026lt;编号\u0026gt; - 重新打开 gh pr ready \u0026lt;编号\u0026gt; - 标记为准备好 审查 PR\ngh pr review \u0026lt;编号\u0026gt; - 审查 PR gh pr review \u0026lt;编号\u0026gt; --approve - 批准 gh pr review \u0026lt;编号\u0026gt; --request-changes - 请求更改 gh pr review \u0026lt;编号\u0026gt; --comment - 添加评论 gh pr checks \u0026lt;编号\u0026gt; - 查看 CI/CD 状态 Issue 创建 Issue\ngh issue create - 创建 Issue gh issue create --title \u0026quot;标题\u0026quot; --body \u0026quot;描述\u0026quot; - 指定内容 gh issue create --web - 在浏览器中创建 gh issue create --label \u0026quot;bug,help wanted\u0026quot; - 添加标签 查看 Issue\ngh issue list - 列出 Issues gh issue list --state open - 只显示开放的 gh issue list --assignee \u0026lt;用户名\u0026gt; - 按指派人筛选 gh issue list --label \u0026lt;标签\u0026gt; - 按标签筛选 gh issue list --author \u0026lt;用户名\u0026gt; - 按作者筛选 gh issue view \u0026lt;编号\u0026gt; - 查看详情 gh issue view \u0026lt;编号\u0026gt; --web - 在浏览器中查看 操作 Issue\ngh issue close \u0026lt;编号\u0026gt; - 关闭 Issue gh issue close \u0026lt;编号\u0026gt; --comment \u0026quot;已修复\u0026quot; - 关闭并评论 gh issue reopen \u0026lt;编号\u0026gt; - 重新打开 gh issue edit \u0026lt;编号\u0026gt; - 编辑 Issue gh issue edit \u0026lt;编号\u0026gt; --add-label \u0026quot;bug\u0026quot; - 添加标签 gh issue comment \u0026lt;编号\u0026gt; - 添加评论 gh issue status - 查看状态 Gist gh gist create \u0026lt;文件\u0026gt; - 创建 Gist gh gist create --public \u0026lt;文件\u0026gt; - 创建公开 Gist gh gist create --desc \u0026quot;描述\u0026quot; \u0026lt;文件\u0026gt; - 添加描述 gh gist list - 列出 Gists gh gist view \u0026lt;ID\u0026gt; - 查看 Gist gh gist view \u0026lt;ID\u0026gt; --web - 在浏览器中查看 gh gist edit \u0026lt;ID\u0026gt; - 编辑 Gist gh gist delete \u0026lt;ID\u0026gt; - 删除 Gist gh gist clone \u0026lt;ID\u0026gt; - 克隆到本地 Release 创建和查看\ngh release create \u0026lt;标签\u0026gt; - 创建 Release gh release create v1.0.0 --title \u0026quot;版本 1.0.0\u0026quot; --notes \u0026quot;说明\u0026quot; - 指定内容 gh release create v1.0.0 *.zip - 附加文件 gh release create v1.0.0 --draft - 创建草稿 gh release list - 列出所有 Releases gh release view \u0026lt;标签\u0026gt; - 查看详情 gh release view \u0026lt;标签\u0026gt; --web - 在浏览器中查看 下载和管理\ngh release download \u0026lt;标签\u0026gt; - 下载资源 gh release download \u0026lt;标签\u0026gt; --pattern \u0026quot;*.zip\u0026quot; - 下载匹配文件 gh release delete \u0026lt;标签\u0026gt; - 删除 Release gh release upload \u0026lt;标签\u0026gt; \u0026lt;文件\u0026gt; - 上传文件 GitHub Actions 工作流管理\ngh workflow list - 列出工作流 gh workflow view \u0026lt;工作流\u0026gt; - 查看详情 gh workflow view \u0026lt;工作流\u0026gt; --web - 在浏览器中查看 gh workflow run \u0026lt;工作流\u0026gt; - 触发工作流 gh workflow run \u0026lt;工作流\u0026gt; --ref \u0026lt;分支\u0026gt; - 在指定分支运行 运行管理\ngh run list - 列出运行记录 gh run list --workflow \u0026lt;工作流名\u0026gt; - 按工作流筛选 gh run view \u0026lt;运行ID\u0026gt; - 查看详情 gh run view \u0026lt;运行ID\u0026gt; --log - 查看日志 gh run watch \u0026lt;运行ID\u0026gt; - 实时查看状态 gh run rerun \u0026lt;运行ID\u0026gt; - 重新运行 gh run cancel \u0026lt;运行ID\u0026gt; - 取消运行 其他功能 浏览和搜索\ngh browse - 在浏览器中打开仓库 gh browse \u0026lt;文件\u0026gt; - 打开指定文件 gh browse --settings - 打开设置 gh search repos \u0026lt;关键词\u0026gt; - 搜索仓库 gh search repos --stars \u0026quot;\u0026gt;1000\u0026quot; - 按星标搜索 gh search repos --language python - 按语言搜索 gh search issues \u0026lt;关键词\u0026gt; - 搜索 Issues gh search prs \u0026lt;关键词\u0026gt; - 搜索 PRs API 和扩展\ngh api \u0026lt;端点\u0026gt; - 调用 GitHub API gh api user - 获取用户信息 gh alias set \u0026lt;别名\u0026gt; \u0026lt;命令\u0026gt; - 创建别名 gh extension install \u0026lt;扩展\u0026gt; - 安装扩展 gh extension list - 列出扩展 标签和项目\ngh label list - 列出标签 gh label create \u0026lt;名称\u0026gt; - 创建标签 gh project list - 列出项目 gh project view \u0026lt;编号\u0026gt; - 查看项目 ","permalink":"http://localhost:1313/posts/command-reference/","summary":"详细的命令行指令参考手册，包含 Windows PowerShell、Linux Terminal、Git 和 GitHub CLI 的常用命令及实用技巧","title":"常用命令行指令参考"},{"content":"一、数据库操作 1.1 创建和删除数据库 -- 创建数据库 CREATE DATABASE database_name; CREATE DATABASE IF NOT EXISTS database_name CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; -- 删除数据库 DROP DATABASE database_name; DROP DATABASE IF EXISTS database_name; -- 查看所有数据库 SHOW DATABASES; -- 选择数据库 USE database_name; -- 查看当前数据库 SELECT DATABASE(); 二、数据表操作 2.1 创建表 -- 基础创建表 CREATE TABLE users ( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(50) NOT NULL UNIQUE, email VARCHAR(100), age INT DEFAULT 0, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ); -- 创建表时指定引擎和字符集 CREATE TABLE products ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(100) NOT NULL, price DECIMAL(10, 2), stock INT DEFAULT 0 ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; -- 从查询结果创建表 CREATE TABLE users_backup AS SELECT * FROM users; 2.2 修改表结构 -- 添加列 ALTER TABLE users ADD COLUMN phone VARCHAR(20); ALTER TABLE users ADD COLUMN address TEXT AFTER email; -- 修改列 ALTER TABLE users MODIFY COLUMN age TINYINT; ALTER TABLE users CHANGE COLUMN username user_name VARCHAR(60); -- 删除列 ALTER TABLE users DROP COLUMN phone; -- 重命名表 RENAME TABLE users TO members; ALTER TABLE members RENAME TO users; -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键 ALTER TABLE users DROP PRIMARY KEY; -- 添加索引 ALTER TABLE users ADD INDEX idx_username (username); ALTER TABLE users ADD UNIQUE INDEX idx_email (email); -- 删除索引 ALTER TABLE users DROP INDEX idx_username; 2.3 查看表信息 -- 查看所有表 SHOW TABLES; -- 查看表结构 DESC users; DESCRIBE users; SHOW COLUMNS FROM users; -- 查看创建表的语句 SHOW CREATE TABLE users; -- 查看表状态 SHOW TABLE STATUS LIKE \u0026#39;users\u0026#39;; 2.4 删除和清空表 -- 删除表 DROP TABLE users; DROP TABLE IF EXISTS users; -- 清空表数据（保留结构） TRUNCATE TABLE users; DELETE FROM users; -- 与 TRUNCATE 的区别是可以回滚 三、数据操作（CRUD） 3.1 插入数据（INSERT） -- 插入单条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;, 25); -- 插入多条数据 INSERT INTO users (username, email, age) VALUES (\u0026#39;李四\u0026#39;, \u0026#39;lisi@example.com\u0026#39;, 28), (\u0026#39;王五\u0026#39;, \u0026#39;wangwu@example.com\u0026#39;, 30); -- 插入所有列（可省略列名） INSERT INTO users VALUES (NULL, \u0026#39;赵六\u0026#39;, \u0026#39;zhaoliu@example.com\u0026#39;, 22, NOW(), NOW()); -- 插入或更新（存在则更新） INSERT INTO users (id, username, email) VALUES (1, \u0026#39;张三\u0026#39;, \u0026#39;new@example.com\u0026#39;) ON DUPLICATE KEY UPDATE email = \u0026#39;new@example.com\u0026#39;; -- 忽略重复插入错误 INSERT IGNORE INTO users (username, email) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;); -- 从其他表插入数据 INSERT INTO users_backup SELECT * FROM users WHERE age \u0026gt; 25; 3.2 查询数据（SELECT） 基础查询 -- 查询所有列 SELECT * FROM users; -- 查询指定列 SELECT username, email FROM users; -- 使用别名 SELECT username AS name, email AS mail FROM users; -- 去重查询 SELECT DISTINCT age FROM users; -- 限制结果数量 SELECT * FROM users LIMIT 10; SELECT * FROM users LIMIT 10, 20; -- 跳过前10条，取20条 SELECT * FROM users LIMIT 20 OFFSET 10; -- 同上 WHERE 条件查询 -- 基本条件 SELECT * FROM users WHERE age \u0026gt; 25; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users WHERE email IS NULL; SELECT * FROM users WHERE email IS NOT NULL; -- 多条件组合 SELECT * FROM users WHERE age \u0026gt; 20 AND age \u0026lt; 30; SELECT * FROM users WHERE age BETWEEN 20 AND 30; SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39; OR username = \u0026#39;李四\u0026#39;; SELECT * FROM users WHERE username IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;); SELECT * FROM users WHERE username NOT IN (\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;); -- 模糊查询 SELECT * FROM users WHERE username LIKE \u0026#39;张%\u0026#39;; -- 以\u0026#34;张\u0026#34;开头 SELECT * FROM users WHERE username LIKE \u0026#39;%三\u0026#39;; -- 以\u0026#34;三\u0026#34;结尾 SELECT * FROM users WHERE username LIKE \u0026#39;%张%\u0026#39;; -- 包含\u0026#34;张\u0026#34; SELECT * FROM users WHERE username LIKE \u0026#39;张_\u0026#39;; -- 张+一个字符 SELECT * FROM users WHERE username NOT LIKE \u0026#39;张%\u0026#39;; 排序和分组 -- 排序 SELECT * FROM users ORDER BY age ASC; -- 升序（默认） SELECT * FROM users ORDER BY age DESC; -- 降序 SELECT * FROM users ORDER BY age DESC, username ASC; -- 多列排序 -- 分组 SELECT age, COUNT(*) as count FROM users GROUP BY age; SELECT age, AVG(age) as avg_age FROM users GROUP BY age; -- HAVING 过滤分组结果 SELECT age, COUNT(*) as count FROM users GROUP BY age HAVING count \u0026gt; 5; 聚合函数 -- 计数 SELECT COUNT(*) FROM users; SELECT COUNT(DISTINCT age) FROM users; -- 求和、平均、最大、最小 SELECT SUM(age) FROM users; SELECT AVG(age) FROM users; SELECT MAX(age) FROM users; SELECT MIN(age) FROM users; -- 多个聚合函数 SELECT COUNT(*) as total, AVG(age) as avg_age, MAX(age) as max_age FROM users; 连接查询（JOIN） -- 内连接（INNER JOIN） SELECT users.username, orders.order_no FROM users INNER JOIN orders ON users.id = orders.user_id; -- 左连接（LEFT JOIN） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id; -- 右连接（RIGHT JOIN） SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 全连接（FULL JOIN，MySQL不直接支持，需要用UNION） SELECT users.username, orders.order_no FROM users LEFT JOIN orders ON users.id = orders.user_id UNION SELECT users.username, orders.order_no FROM users RIGHT JOIN orders ON users.id = orders.user_id; -- 自连接 SELECT a.username, b.username as friend FROM users a INNER JOIN users b ON a.friend_id = b.id; -- 多表连接 SELECT u.username, o.order_no, p.product_name FROM users u INNER JOIN orders o ON u.id = o.user_id INNER JOIN order_items oi ON o.id = oi.order_id INNER JOIN products p ON oi.product_id = p.id; 子查询 -- WHERE 子查询 SELECT * FROM users WHERE id IN (SELECT user_id FROM orders WHERE amount \u0026gt; 1000); -- FROM 子查询 SELECT avg_age FROM (SELECT AVG(age) as avg_age FROM users GROUP BY city) as subquery; -- EXISTS 子查询 SELECT * FROM users WHERE EXISTS (SELECT 1 FROM orders WHERE orders.user_id = users.id); -- 标量子查询 SELECT username, (SELECT COUNT(*) FROM orders WHERE user_id = users.id) as order_count FROM users; 联合查询（UNION） -- UNION（去重） SELECT username FROM users WHERE age \u0026gt; 30 UNION SELECT username FROM admins WHERE age \u0026gt; 30; -- UNION ALL（不去重，性能更好） SELECT username FROM users WHERE age \u0026gt; 30 UNION ALL SELECT username FROM admins WHERE age \u0026gt; 30; 3.3 更新数据（UPDATE） -- 更新单列 UPDATE users SET age = 26 WHERE username = \u0026#39;张三\u0026#39;; -- 更新多列 UPDATE users SET age = 26, email = \u0026#39;new@example.com\u0026#39; WHERE username = \u0026#39;张三\u0026#39;; -- 批量更新 UPDATE users SET age = age + 1 WHERE age \u0026lt; 30; -- 使用表达式更新 UPDATE users SET updated_at = NOW() WHERE id = 1; -- 基于其他表更新 UPDATE users u INNER JOIN orders o ON u.id = o.user_id SET u.total_orders = u.total_orders + 1 WHERE o.created_at \u0026gt; \u0026#39;2024-01-01\u0026#39;; -- 条件更新（CASE） UPDATE users SET level = CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END; 3.4 删除数据（DELETE） -- 删除指定数据 DELETE FROM users WHERE id = 1; -- 批量删除 DELETE FROM users WHERE age \u0026lt; 18; -- 删除所有数据 DELETE FROM users; -- 基于其他表删除 DELETE u FROM users u INNER JOIN orders o ON u.id = o.user_id WHERE o.status = \u0026#39;cancelled\u0026#39;; 四、索引管理 4.1 创建索引 -- 普通索引 CREATE INDEX idx_username ON users(username); -- 唯一索引 CREATE UNIQUE INDEX idx_email ON users(email); -- 复合索引 CREATE INDEX idx_name_age ON users(username, age); -- 全文索引 CREATE FULLTEXT INDEX idx_content ON articles(content); -- 在创建表时添加索引 CREATE TABLE users ( id INT PRIMARY KEY, username VARCHAR(50), email VARCHAR(100), INDEX idx_username (username), UNIQUE INDEX idx_email (email) ); 4.2 查看和删除索引 -- 查看索引 SHOW INDEX FROM users; -- 删除索引 DROP INDEX idx_username ON users; ALTER TABLE users DROP INDEX idx_username; 五、约束管理 5.1 主键约束 -- 添加主键 ALTER TABLE users ADD PRIMARY KEY (id); -- 删除主键（需要先删除 AUTO_INCREMENT 属性） ALTER TABLE users MODIFY id INT; ALTER TABLE users DROP PRIMARY KEY; 5.2 外键约束 -- 添加外键 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id); -- 添加外键时设置级联操作 ALTER TABLE orders ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE; -- 删除外键 ALTER TABLE orders DROP FOREIGN KEY fk_user_id; 5.3 其他约束 -- 唯一约束 ALTER TABLE users ADD UNIQUE (email); -- 非空约束 ALTER TABLE users MODIFY username VARCHAR(50) NOT NULL; -- 检查约束（MySQL 8.0.16+） ALTER TABLE users ADD CONSTRAINT chk_age CHECK (age \u0026gt;= 0 AND age \u0026lt;= 150); -- 默认值约束 ALTER TABLE users ALTER COLUMN status SET DEFAULT \u0026#39;active\u0026#39;; 六、视图 -- 创建视图 CREATE VIEW active_users AS SELECT id, username, email FROM users WHERE status = \u0026#39;active\u0026#39;; -- 创建或替换视图 CREATE OR REPLACE VIEW active_users AS SELECT id, username, email, age FROM users WHERE status = \u0026#39;active\u0026#39;; -- 查询视图 SELECT * FROM active_users; -- 查看视图定义 SHOW CREATE VIEW active_users; -- 删除视图 DROP VIEW active_users; DROP VIEW IF EXISTS active_users; 七、事务处理 -- 开启事务 START TRANSACTION; -- 或 BEGIN; -- 提交事务 COMMIT; -- 回滚事务 ROLLBACK; -- 设置保存点 SAVEPOINT sp1; ROLLBACK TO sp1; -- 完整示例 START TRANSACTION; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; COMMIT; -- 设置自动提交 SET autocommit = 0; -- 关闭自动提交 SET autocommit = 1; -- 开启自动提交 八、存储过程和函数 8.1 存储过程 -- 创建存储过程 DELIMITER // CREATE PROCEDURE GetUserById(IN userId INT) BEGIN SELECT * FROM users WHERE id = userId; END // DELIMITER ; -- 调用存储过程 CALL GetUserById(1); -- 带输出参数的存储过程 DELIMITER // CREATE PROCEDURE GetUserCount(OUT total INT) BEGIN SELECT COUNT(*) INTO total FROM users; END // DELIMITER ; CALL GetUserCount(@count); SELECT @count; -- 删除存储过程 DROP PROCEDURE IF EXISTS GetUserById; -- 查看存储过程 SHOW PROCEDURE STATUS; SHOW CREATE PROCEDURE GetUserById; 8.2 函数 -- 创建函数 DELIMITER // CREATE FUNCTION GetUserAge(userId INT) RETURNS INT BEGIN DECLARE userAge INT; SELECT age INTO userAge FROM users WHERE id = userId; RETURN userAge; END // DELIMITER ; -- 使用函数 SELECT GetUserAge(1); -- 删除函数 DROP FUNCTION IF EXISTS GetUserAge; 九、触发器 -- 创建 BEFORE INSERT 触发器 DELIMITER // CREATE TRIGGER before_user_insert BEFORE INSERT ON users FOR EACH ROW BEGIN SET NEW.created_at = NOW(); END // DELIMITER ; -- 创建 AFTER UPDATE 触发器 DELIMITER // CREATE TRIGGER after_user_update AFTER UPDATE ON users FOR EACH ROW BEGIN INSERT INTO user_logs (user_id, action, created_at) VALUES (OLD.id, \u0026#39;update\u0026#39;, NOW()); END // DELIMITER ; -- 查看触发器 SHOW TRIGGERS; -- 删除触发器 DROP TRIGGER IF EXISTS before_user_insert; 十、用户和权限管理 -- 创建用户 CREATE USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; CREATE USER \u0026#39;username\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; -- 允许任何主机 -- 授予权限 GRANT ALL PRIVILEGES ON database_name.* TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; GRANT SELECT, INSERT, UPDATE ON database_name.table_name TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 刷新权限 FLUSH PRIVILEGES; -- 查看用户权限 SHOW GRANTS FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 撤销权限 REVOKE INSERT, UPDATE ON database_name.* FROM \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 修改密码 ALTER USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;new_password\u0026#39;; SET PASSWORD FOR \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; = PASSWORD(\u0026#39;new_password\u0026#39;); -- 删除用户 DROP USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; 十一、备份和恢复 -- 使用 mysqldump 备份（在命令行执行） mysqldump -u username -p database_name \u0026gt; backup.sql mysqldump -u username -p database_name table_name \u0026gt; table_backup.sql mysqldump -u username -p --all-databases \u0026gt; all_databases.sql -- 恢复数据库（在命令行执行） mysql -u username -p database_name \u0026lt; backup.sql -- 导出为 CSV SELECT * FROM users INTO OUTFILE \u0026#39;/tmp/users.csv\u0026#39; FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; -- 从 CSV 导入 LOAD DATA INFILE \u0026#39;/tmp/users.csv\u0026#39; INTO TABLE users FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39;; 十二、性能优化相关 12.1 EXPLAIN 分析查询 -- 分析查询执行计划 EXPLAIN SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; -- 详细分析 EXPLAIN EXTENDED SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; SHOW WARNINGS; -- JSON 格式 EXPLAIN FORMAT=JSON SELECT * FROM users WHERE username = \u0026#39;张三\u0026#39;; 12.2 查询优化 -- 使用索引提示 SELECT * FROM users USE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users FORCE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; SELECT * FROM users IGNORE INDEX (idx_username) WHERE username = \u0026#39;张三\u0026#39;; -- 优化 COUNT SELECT COUNT(1) FROM users; -- 比 COUNT(*) 快一点 -- 分页优化（避免大 OFFSET） SELECT * FROM users WHERE id \u0026gt; 10000 ORDER BY id LIMIT 20; 12.3 查看状态和变量 -- 查看数据库状态 SHOW STATUS; SHOW STATUS LIKE \u0026#39;Threads%\u0026#39;; -- 查看系统变量 SHOW VARIABLES; SHOW VARIABLES LIKE \u0026#39;max_connections\u0026#39;; -- 查看进程列表 SHOW PROCESSLIST; SHOW FULL PROCESSLIST; -- 杀死进程 KILL process_id; 十三、常用字符串和日期函数 13.1 字符串函数 -- 字符串连接 SELECT CONCAT(\u0026#39;Hello\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;World\u0026#39;); SELECT CONCAT_WS(\u0026#39;-\u0026#39;, \u0026#39;2024\u0026#39;, \u0026#39;12\u0026#39;, \u0026#39;10\u0026#39;); -- 字符串长度 SELECT LENGTH(\u0026#39;Hello\u0026#39;), CHAR_LENGTH(\u0026#39;你好\u0026#39;); -- 大小写转换 SELECT UPPER(\u0026#39;hello\u0026#39;), LOWER(\u0026#39;HELLO\u0026#39;); -- 截取字符串 SELECT SUBSTRING(\u0026#39;Hello World\u0026#39;, 1, 5); SELECT LEFT(\u0026#39;Hello World\u0026#39;, 5), RIGHT(\u0026#39;Hello World\u0026#39;, 5); -- 替换和删除 SELECT REPLACE(\u0026#39;Hello World\u0026#39;, \u0026#39;World\u0026#39;, \u0026#39;MySQL\u0026#39;); SELECT TRIM(\u0026#39; Hello \u0026#39;), LTRIM(\u0026#39; Hello\u0026#39;), RTRIM(\u0026#39;Hello \u0026#39;); -- 查找位置 SELECT POSITION(\u0026#39;World\u0026#39; IN \u0026#39;Hello World\u0026#39;); SELECT LOCATE(\u0026#39;World\u0026#39;, \u0026#39;Hello World\u0026#39;); 13.2 日期时间函数 -- 获取当前时间 SELECT NOW(), CURDATE(), CURTIME(); SELECT CURRENT_TIMESTAMP(), CURRENT_DATE(), CURRENT_TIME(); -- 日期格式化 SELECT DATE_FORMAT(NOW(), \u0026#39;%Y-%m-%d %H:%i:%s\u0026#39;); SELECT DATE_FORMAT(NOW(), \u0026#39;%Y年%m月%d日\u0026#39;); -- 日期计算 SELECT date_add(\u0026#39;2023-01-01\u0026#39;, interval 1 day) 输出 \u0026#39;2023-01-02\u0026#39; SELECT date_sub(\u0026#39;2023-01-01\u0026#39;, interval 1 day) 输出 \u0026#39;2022-12-31\u0026#39; SELECT datediff(\u0026#39;2023-02-01\u0026#39;, \u0026#39;2023-01-01\u0026#39;) 输出31 -- 提取日期部分 SELECT YEAR(NOW()), MONTH(NOW()), DAY(NOW()); SELECT HOUR(NOW()), MINUTE(NOW()), SECOND(NOW()); -- 时间戳转换 SELECT UNIX_TIMESTAMP(NOW()); SELECT FROM_UNIXTIME(1702195200); 13.3 数学和其他函数 -- 数学函数 SELECT ROUND(3.14159, 2), CEIL(3.2), FLOOR(3.8); SELECT ABS(-5), MOD(10, 3), POWER(2, 3); SELECT RAND(), RAND()*100; -- 条件函数 SELECT IF(age \u0026gt; 18, \u0026#39;成年\u0026#39;, \u0026#39;未成年\u0026#39;) FROM users; SELECT IFNULL(email, \u0026#39;无邮箱\u0026#39;) FROM users; SELECT COALESCE(NULL, NULL, \u0026#39;default\u0026#39;, \u0026#39;value\u0026#39;); -- CASE 表达式 SELECT username, CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; WHEN age \u0026lt; 60 THEN \u0026#39;成年\u0026#39; ELSE \u0026#39;老年\u0026#39; END as age_group FROM users; 十四、JSON 操作（MySQL 5.7+） -- 创建 JSON 列 CREATE TABLE products ( id INT PRIMARY KEY, name VARCHAR(100), attributes JSON ); -- 插入 JSON 数据 INSERT INTO products VALUES (1, \u0026#39;iPhone\u0026#39;, \u0026#39;{\u0026#34;color\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;storage\u0026#34;: \u0026#34;128GB\u0026#34;}\u0026#39;); -- 查询 JSON 数据 SELECT JSON_EXTRACT(attributes, \u0026#39;$.color\u0026#39;) as color FROM products; SELECT attributes-\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; SELECT attributes-\u0026gt;\u0026gt;\u0026#39;$.color\u0026#39; as color FROM products; -- 去除引号 -- 修改 JSON 数据 UPDATE products SET attributes = JSON_SET(attributes, \u0026#39;$.color\u0026#39;, \u0026#39;white\u0026#39;) WHERE id = 1; UPDATE products SET attributes = JSON_INSERT(attributes, \u0026#39;$.price\u0026#39;, 999) WHERE id = 1; UPDATE products SET attributes = JSON_REMOVE(attributes, \u0026#39;$.storage\u0026#39;) WHERE id = 1; -- JSON 数组操作 SELECT JSON_ARRAY(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;); SELECT JSON_CONTAINS(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;, \u0026#39;\u0026#34;a\u0026#34;\u0026#39;); SELECT JSON_LENGTH(\u0026#39;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026#39;); 十五、窗口函数（MySQL 8.0+） -- ROW_NUMBER：行号 SELECT username, age, ROW_NUMBER() OVER (ORDER BY age DESC) as row_num FROM users; -- RANK：排名（有并列，跳号） SELECT username, score, RANK() OVER (ORDER BY score DESC) as rank FROM students; -- DENSE_RANK：密集排名（有并列，不跳号） SELECT username, score, DENSE_RANK() OVER (ORDER BY score DESC) as rank FROM students; -- 分组窗口 SELECT department, username, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank FROM employees; -- 累计求和 SELECT username, amount, SUM(amount) OVER (ORDER BY created_at) as running_total FROM transactions; -- LAG 和 LEAD：访问上下行 SELECT username, salary, LAG(salary, 1) OVER (ORDER BY id) as prev_salary, LEAD(salary, 1) OVER (ORDER BY id) as next_salary FROM employees; 十六、常见问题和技巧 16.1 查找重复数据 -- 查找重复的用户名 SELECT username, COUNT(*) as count FROM users GROUP BY username HAVING count \u0026gt; 1; -- 删除重复数据（保留ID最小的） DELETE u1 FROM users u1 INNER JOIN users u2 WHERE u1.id \u0026gt; u2.id AND u1.username = u2.username; 16.2 随机获取数据 -- 随机获取一条数据 SELECT * FROM users ORDER BY RAND() LIMIT 1; -- 更高效的随机（大表适用） SELECT * FROM users WHERE id \u0026gt;= (SELECT FLOOR(MAX(id) * RAND()) FROM users) LIMIT 1; 16.3 行转列 -- 使用 CASE WHEN SELECT name, SUM(CASE WHEN subject = \u0026#39;语文\u0026#39; THEN score ELSE 0 END) as chinese, SUM(CASE WHEN subject = \u0026#39;数学\u0026#39; THEN score ELSE 0 END) as math FROM scores GROUP BY name; 16.4 列转行 -- 使用 UNION ALL SELECT name, \u0026#39;语文\u0026#39; as subject, chinese as score FROM scores UNION ALL SELECT name, \u0026#39;数学\u0026#39; as subject, math as score FROM scores; 十七、常用管理命令 -- 查看 MySQL 版本 SELECT VERSION(); -- 查看当前用户 SELECT USER(), CURRENT_USER(); -- 查看数据库大小 SELECT table_schema AS \u0026#39;Database\u0026#39;, ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables GROUP BY table_schema; -- 查看表大小 SELECT table_name AS \u0026#39;Table\u0026#39;, ROUND(((data_length + index_length) / 1024 / 1024), 2) AS \u0026#39;Size (MB)\u0026#39; FROM information_schema.tables WHERE table_schema = \u0026#39;database_name\u0026#39; ORDER BY (data_length + index_length) DESC; -- 修复表 REPAIR TABLE users; -- 优化表 OPTIMIZE TABLE users; -- 分析表 ANALYZE TABLE users; -- 检查表 CHECK TABLE users; 总结 这份笔记涵盖了 MySQL 从基础到进阶的大部分常用操作，当然也适合在刷题中补充，包括：\n数据库和表的管理 完整的 CRUD 操作 索引和约束 视图、事务、存储过程 用户权限管理 性能优化技巧 常用函数和 JSON、窗口函数！ ","permalink":"http://localhost:1313/posts/mysql-cheatsheet/","summary":"MySQL 常用语句全面速查手册，涵盖从基础 CRUD 到高级特性（索引、事务、存储过程、窗口函数等）的所有常用操作，适合快速查阅和刷题使用","title":"MySQL 语句速查笔记"},{"content":"论文基本信息 标题: Linking Souls to Humans: Blockchain Accounts with Credible Anonymity for Web 3.0 Decentralized Identity 作者: Taotao Wang, Zibin Lin, Shengli Zhang, Long Shi, Qing Yang, Boris Düdder 会议: WWW \u0026lsquo;25 (ACM Web Conference 2025) 时间: 2025年4月28日-5月2日，悉尼 机构: 深圳大学、南京理工大学、哥本哈根大学 研究背景 数字身份的三个发展阶段 数字身份系统经历了三个演进阶段，分别对应互联网的三个时代：\n阶段 身份类型 对应时代 特点 问题 1 中心化身份 Web 1.0 用户创建，应用提供商管理 多账户管理复杂，数据泄露风险 2 联盟身份 Web 2.0 少数大型提供商管理，可跨应用使用 数据霸权，用户数据集中在少数巨头手中 3 去中心化身份 Web 3.0 用户自主创建和管理（自主权身份） 完全匿名导致无法追溯真实社交关系 Web 3.0的核心价值 Web 3.0的革命性转变在于：\n用户拥有数据主权 数据不被应用提供商占有 需要去中心化身份系统支撑 当前区块链账户系统的问题 区块链账户系统是Web 3.0去中心化身份的理想原型，但存在以下问题：\n完全匿名的缺陷： 用户可以无需认证创建多个账户 无法准确记录真实用户之间的社交关系和互动 用户与区块链身份之间的映射关系模糊 Soulbound Token的局限性： Vitalik Buterin提出的\u0026quot;灵魂\u0026quot;（Soul）概念和\u0026quot;灵魂绑定代币\u0026quot;（Soulbound Token） 用户仍可创建多个\u0026quot;灵魂\u0026quot;账户来抹除、转移或隐藏关系 无法真实反映人类社会中的真实关系 研究方案：zkBID 核心目标 zkBID（Zero-Knowledge Blockchain-account-based Web 3.0 decentralized IDentity）旨在实现：\n一对一映射：将灵魂（区块链账户）与人类（用户）建立一对一关联 去中心化：无需第三方中心化机构参与 隐私保护：隐藏身份与账户之间的绑定关系（即匿名） 可信性：每个账户在区块链上的信用与对应的真实用户一对一映射 关键技术 zkBID采用三大核心技术：\n零知识证明（zkSNARK） 可链接环签名（Linkable Ring Signature） 区块链智能合约（Smart Contracts） 技术预备知识 1. 可验证凭证（Verifiable Credentials, VC） 由W3C提出的去中心化标识符（DID）体系中的关键组件。\n三个主要角色：\n颁发者（Issuer）：签发凭证 持有者（Holder）：拥有凭证 验证者（Verifier）：验证凭证 VC的数据结构（JSON对象）：\n{ \u0026#34;metadata\u0026#34;: \u0026#34;包含颁发者DID、颁发日期、声明类型\u0026#34;, \u0026#34;claims\u0026#34;: \u0026#34;关于持有者的断言，包括持有者DID\u0026#34;, \u0026#34;proofs\u0026#34;: \u0026#34;颁发者的数字签名\u0026#34; } 2. 人格凭证（Personhood Credentials, PHC） 定义：证明用户是真人而非AI的数字凭证\n运作流程：\n注册流程 用户向PHC颁发者证明自己是真人 → 颁发者签发PHC\n使用流程 第三方服务可要求用户出示PHC作为授权过程的一部分\n验证方法（颁发者确保用户是真人的三种主要方式）：\n现有身份文件 基于政府签发的身份证件 利用现有可信来源 生物识别信息 测量持久且唯一的人体特征（掌纹、虹膜、指纹） 确保是真人且限制每人只注册一次 信任网络（Web of Trust） 通过社交图谱分析区分真人和机器 检测用户是否曾获得过凭证 在zkBID中的应用：\nPHC以VC形式作为每个人类用户的身份凭证 3. zkSNARK算法 全称：Zero-knowledge Succinct Non-interactive Argument of Knowledge\n优势：\n简洁性（Succinct）：证明大小仅几个字节，验证时间短 非交互性（Non-interactive）：证明者和验证者无需同步通信 工作原理：\n使用算术电路表示，包含基本运算：加、减、乘、除\nF-算术电路：\n输入：$x \\in \\mathbb{F}^n$ 辅助输入（见证）：$w \\in \\mathbb{F}^h$ 输出：$C(x, w) \\in \\mathbb{F}^l$ 三个算法组件：\n密钥生成（KEYGEN）\n(PK, VK) ← KEYGEN(1^λ, C) 输入：安全参数λ和电路C 输出：证明密钥PK和验证密钥VK 证明生成（PROVE）\nπ ← PROVE(PK, x, W) 输入：PK、公开输入x、私密见证W 输出：证明π 证明验证（VERIFY）\n1/0 ← VERIFY(VK, x, π) 输入：VK、公开输入x、证明π 输出：接受（1）或拒绝（0） zkBID采用的算法：Groth16\n原因：验证速度快，证明紧凑 适用于大规模应用和大型区块链网络 4. 可链接环签名（Linkable Ring Signature） 基本环签名：\n验证者可以确认签名由预定义集合中的某个成员创建 但无法确定具体是哪个成员 可链接环签名的额外特性：\n允许验证者确定两个签名是否由同一签名者生成 四个算法组件：\n密钥生成（GEN）\n(pk, sk) ← GEN(1^k) 签名生成（SIG）\nσ ← SIG(1^k, 1^n, m, L, sk) 输入：安全参数k、环大小n、消息m、公钥环L、私钥sk 输出：签名σ 签名验证（VER）\n1/0 ← VER(1^k, 1^n, m, L, σ) 可链接性检查（LINK）\n1/0 ← LINK(1^k, 1^n, m1, m2, σ1, σ2, L1, L2) 判断两个签名是否由同一签名者生成 关键属性：\n签名者模糊性（Signer Ambiguity）： 攻击者正确猜测真实签名者的概率不超过 1/(n-t) 其中n是环大小，t是攻击者拥有的私钥数量 可链接性（Linkability）： 同一签名者（相同私钥）签名的两条消息可被验证为关联 zkBID采用的算法：MLSAGS（Multilayered Linkable Spontaneous Anonymous Group Signature）\n原因：实现可链接性的技术复杂度较低，适合在智能合约上实现 密钥图像（Key Image）机制：\ny₀ ← sk * Hₚ(pk) y₀对于给定的(sk, pk)对是唯一的 所有由同一签名者产生的签名都带有相同的密钥图像 即使环中的公钥改变，签名仍可链接 zkBID系统设计 整体架构 映射关系图 真实用户 → PHC（人格凭证）→ PHC哈希 → 种子公钥 → 灵魂账户 关系说明：\n实线：可见的一对一关系 虚线：不可见但可验证的关系 箭头：单向计算关系 核心设计理念 隐私保护： PHC的具体内容不上链，只存储零知识证明 灵魂账户与种子公钥的关联不可见 可信匿名： 账户是匿名的（无法追踪到真实身份） 账户是可信的（确实与真实用户一对一绑定） 完全去中心化： 所有数据由用户生成 通过区块链上的智能合约验证 IVAC流程（Identity Verification and Account Certification） zkBID通过三个子流程生成具有可信匿名性的灵魂账户：\n[用户] → [注册信息生成] → [用户身份验证] → [灵魂账户认证] → [灵魂账户] ↓ ↓ ↓ 零知识证明 智能合约验证 可链接环签名 详细设计 阶段1：注册信息生成 目标：生成隐私保护的注册信息，不泄露PHC的具体内容\nPHC格式设计 zkBID中的PHC采用VC格式，包含三个关键字段：\n{ \u0026#34;credentialSubject\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_holder\u0026#34; // 持有者公钥 }, \u0026#34;proof\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_issuer\u0026#34;, // 颁发者公钥 \u0026#34;signature\u0026#34;: \u0026#34;sig_issuer\u0026#34; // 颁发者签名 } } 零知识证明生成流程 Protocol 1: PHC的ZK证明生成\n输入： - hash_PHC：PHC的哈希值 - sig_holder：持有者的签名 - pk_issuer：颁发者的公钥 - PHC：完整的PHC数据 设置： (PK, VK) ← zkSNARK.KEYGEN(1^λ, C) 生成证明： 1. 公开输入 x ← (hash_PHC, sig_holder, pk_issuer) 2. 私密见证 W ← PHC 3. π ← zkSNARK.PROVE(PK, x, W) 输出：π（零知识证明） 算术电路验证逻辑 graph TD A[私密输入: PHC] --\u0026gt; B[计算PHC的哈希] C[公开输入: hash_PHC] --\u0026gt; B B --\u0026gt; D{哈希值是否相等?} A --\u0026gt; E[提取pk_holder] F[公开输入: sig_holder] --\u0026gt; G[验证sig_holder] E --\u0026gt; G G --\u0026gt; H{签名是否有效?} A --\u0026gt; I[提取sig_issuer] J[公开输入: pk_issuer] --\u0026gt; K[验证sig_issuer] I --\u0026gt; K K --\u0026gt; L{签名是否有效?} D --\u0026gt; M[AND] H --\u0026gt; M L --\u0026gt; M M --\u0026gt; N{输出TRUE/FALSE} 验证步骤：\n验证哈希正确性： 计算PHC的哈希 检查是否等于公开输入中的hash_PHC 确保hash_PHC确实从PHC计算得出 验证所有权： 从PHC中提取持有者公钥pk_holder 用pk_holder验证sig_holder 证明用户拥有PHC 验证PHC有效性： 从PHC中提取颁发者签名sig_issuer 用pk_issuer验证sig_issuer 证明PHC由可信颁发者签发 输出：\n如果所有检查通过：输出TRUE和证明π π证明的声明：\u0026ldquo;PHC哈希正确，持有者拥有PHC，PHC由颁发者签发\u0026rdquo; 关键：不泄露PHC的具体内容 阶段2：用户身份验证 目标：\n验证用户的真人身份（通过验证ZK证明） 防止重复注册（检查PHC哈希未被使用） 智能合约流程 Protocol 2: 用户身份验证智能合约\n输入： - π：零知识证明 - hash_PHC：PHC哈希 - sig_holder：持有者签名 - pk_seed：种子公钥 执行步骤： 1. pk_issuer ← GetIssuerPK() // 获取预定义的颁发者公钥 2. validation ← zkSNARK.VERIFY(VK, hash_PHC, pk_issuer, π) 3. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 4. stored ← Traverse(hash_PHC) // 检查是否已注册 5. if stored ≠ 0: return \u0026#34;已经注册\u0026#34; 6. Store(hash_PHC, pk_seed) // 存储为键值对 7. return \u0026#34;认证成功\u0026#34; 用户操作步骤 生成种子密钥对：\n(pk_seed, sk_seed) ← MLSAGS.GEN(1^k) 构造交易：\n数据字段包含：π, hash_PHC, sig_holder, pk_issuer, pk_seed 发送到身份验证合约地址 合约验证：\n验证颁发者公钥匹配 验证零知识证明 检查PHC哈希未被使用 链上记录：\n存储键值对：(hash_PHC, pk_seed) hash_PHC用于防止重复注册 pk_seed作为用户在下一阶段创建灵魂账户的凭证 安全保证：\nPHC的具体内容不上链 仍能验证PHC的所有权和有效性 防止同一PHC多次注册 阶段3：灵魂账户认证 目标：认证灵魂账户与合法种子公钥的一对一关联\n整体流程 生成灵魂账户（普通以太坊账户） 建立关联（使用可链接环签名） 链上验证（智能合约验证签名） 可链接环签名的生成和验证 graph LR A[用户端] --\u0026gt; B[签名生成] B --\u0026gt; C[智能合约] C --\u0026gt; D[签名验证] E[输入] --\u0026gt; B E --\u0026gt; |选择的L-1个种子公钥| B E --\u0026gt; |用户的种子公钥pk_seed| B E --\u0026gt; |用户的种子私钥sk_seed| B E --\u0026gt; |灵魂账户地址addr_soul| B E --\u0026gt; |密钥图像y₀| B B --\u0026gt; |签名σ| C F[公钥环L] --\u0026gt; C G[addr_soul] --\u0026gt; C D --\u0026gt; H{验证结果} H --\u0026gt; |True| I[认证成功] H --\u0026gt; |False| J[认证失败] 详细步骤 步骤1：生成灵魂账户\n(addr_soul, pk_soul, sk_soul) = 生成以太坊账户 步骤2：构造公钥环\n从已注册的种子公钥中选择L-1个 加上用户自己的pk_seed 形成大小为L的公钥环 步骤3：计算密钥图像\ny₀ ← sk_seed * Hₚ(pk_seed) y₀对于给定的(sk_seed, pk_seed)是唯一的 用于防止重复注册 步骤4：生成可链接环签名\nσ ← MLSAGS.SIG(1^k, 1^n, addr_soul, L, sk_seed) 消息m = addr_soul（要签名的是灵魂账户地址） 签名格式：σ = (y₀, \u0026hellip;) y₀作为签名的一部分 步骤5：智能合约验证\nProtocol 3: 灵魂账户认证智能合约\n输入： - σ：可链接环签名 - L：公钥环 - addr_soul：灵魂账户地址 执行步骤： 1. validation ← LRS.VER(1^k, 1^n, addr_soul, L, σ) 2. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 3. stored ← Traverse(σ.y₀) // 检查密钥图像是否已使用 4. if stored ≠ 0: return \u0026#34;已经认证\u0026#34; 5. Store(σ.y₀, addr_soul) // 存储密钥图像和灵魂账户 6. return \u0026#34;认证成功\u0026#34; 隐私保护机制 关键特性：\n签名者模糊性： 签名可以被验证为有效 但无法确定环L中哪个公钥是真正的签名者 攻击者猜对的概率：1/(n-t)，其中n是环大小，t是攻击者拥有的私钥数 一对一保证： 密钥图像y₀唯一对应一个种子密钥对 同一种子密钥对只能生成一个有效签名 确保一个PHC只能关联一个灵魂账户 可验证的匿名性： 任何人都可以验证灵魂账户与某个合法种子公钥关联 但无法确定具体是哪个种子公钥 实现\u0026quot;可信匿名\u0026quot; 链上数据 存储内容：\n(σ.y₀, addr_soul) 键值对 可见信息：\n所有种子公钥（从阶段2） 所有灵魂账户地址 所有密钥图像 不可见关联：\n哪个种子公钥对应哪个灵魂账户 哪个PHC哈希对应哪个灵魂账户 哪个真实用户对应哪个灵魂账户 安全性分析 安全前提条件 计算对手受限：攻击者为多项式时间的计算对手 验证者诚实：智能合约不会接受虚假验证请求 PHC唯一性：每个用户只能从颁发者获得一个PHC 安全目标 zkBID需要满足三个核心安全属性：\n安全属性 定义 目标 身份唯一性 防止重复注册 一个用户不能注册多个灵魂账户 不可伪造性 防止身份伪造 攻击者不能冒充诚实用户认证灵魂账户 匿名性 保护身份隐私 攻击者无法检测用户身份(PHC)与灵魂账户的关联 威胁模型与防御 1. 女巫攻击（Sybil Attack） 攻击场景： 攻击者已拥有一个灵魂账户，试图获取新的灵魂账户\n攻击方法：\n方法A：使用相同PHC关联新的种子公钥 → 用新种子公钥认证新灵魂账户\n方法B：直接使用已用过的种子公钥认证新灵魂账户\n防御分析：\n方法A的防御：\n在用户身份验证合约中： 1. 合约检查hash_PHC是否已存储 2. 由于哈希函数的抗碰撞性，每个PHC只能生成一个唯一哈希 3. zkSNARK的可靠性保证：攻击者通过伪造哈希成功的概率可忽略不计 4. 因此无法用同一PHC注册两个种子账户 方法B的防御：\n在灵魂账户认证合约中： 1. 合约检查密钥图像y₀是否已使用 2. 由于可链接环签名的可链接性，同一种子私钥无法构造两个不同y₀的有效签名 3. 因此无法用同一种子密钥对认证两个灵魂账户 结论：无法使用相同PHC或种子公钥注册两个灵魂账户\n2. 链接攻击（Linkage Attack） 攻击场景： 攻击者试图通过破解环签名的真实签名者，建立用户身份（PHC哈希）与灵魂账户的链接\n攻击方法： 分析链上存储的环签名，推断哪个种子公钥是真正的签名者\n防御分析：\n基于可链接环签名的签名者模糊性： - 假设环大小为n - 攻击者拥有t个私钥 - 攻击者正确识别真实签名者的概率 = 1/(n-t) 示例： - 环大小 n = 100 - 攻击者拥有 t = 10 个私钥 - 成功概率 = 1/90 ≈ 1.1% 结论：攻击者无法有效建立身份与账户的链接 环大小的影响：\n环越大 → 匿名性越强 但签名生成和验证成本增加 需要在匿名性和效率之间权衡 3. 伪造攻击（Forgery Attack） 攻击场景： 攻击者试图冒充诚实用户获取灵魂账户\n攻击方法：\n方法A：伪造holder签名生成有效zkSNARK证明\n攻击者获得诚实用户的PHC ↓ 伪造sig_holder ↓ 生成通过验证的zkSNARK证明 ↓ 注册种子公钥 ↓ 认证灵魂账户 方法B：伪造种子账户的环签名\n已注册的种子公钥公开可见 ↓ 伪造某个诚实用户的环签名sig_seed ↓ 认证新的灵魂账户 防御分析：\n方法A的防御：\n依赖两个密码学保证： 1. EdDSA算法的不可伪造性 → 攻击者无法伪造任何诚实用户的sig_holder 2. zkSNARK的可靠性 → 没有有效签名，无法创建有效的zkSNARK证明 结论：攻击者无法通过伪造签名获得种子公钥 方法B的防御：\n依赖可链接环签名的不可伪造性： - 攻击者无法伪造任何已注册种子账户的有效签名 - 即使种子公钥公开可见 结论：攻击者无法冒充诚实用户认证灵魂账户 总结：zkBID协议能够抵御伪造攻击\n安全性总结表 攻击类型 攻击目标 依赖的安全属性 防御结果 女巫攻击-方法A 重复注册PHC 哈希抗碰撞性 + zkSNARK可靠性 ✅ 安全 女巫攻击-方法B 重复使用种子密钥 可链接环签名的可链接性 ✅ 安全 链接攻击 破坏匿名性 可链接环签名的签名者模糊性 ✅ 安全 伪造攻击-方法A 伪造身份验证 EdDSA不可伪造性 + zkSNARK可靠性 ✅ 安全 伪造攻击-方法B 伪造账户认证 可链接环签名不可伪造性 ✅ 安全 实验评估 实验环境 测试网络配置 区块链测试网络：\n平台：阿里云 节点数：6个以太坊全节点 共识协议：工作量证明（PoW） 客户端：Go-Ethereum 网络拓扑：全连接（每个节点有独立IP） 用户节点：\n1个用户节点连接到1个以太坊节点 运行用户端功能 硬件配置（所有节点）：\n操作系统：Ubuntu 20.04 CPU：Intel(R) Core(TM) i7-10700 @ 2.90GHz 内存：48GB RAM 实现技术栈 智能合约：\n语言：Solidity 部署：以太坊测试网络 zkSNARK：\n算法：Groth16 平台：Circom 2 功能：Setup和证明生成 可链接环签名：\n算法：MLSAGS 用户端实现：Python（密钥生成、签名算法） 合约实现：Solidity（签名验证） 性能评估指标 指标 说明 重要性 ZK证明生成时间 Groth16证明算法的执行时间 影响用户体验 ZK证明大小 证明所占字节数 影响链上存储 ZK证明验证成本 智能合约验证所需Gas 影响使用成本 算术电路大小 R1CS约束数量 影响系统复杂度 MLSAGS签名生成时间 环签名生成的执行时间 影响用户体验 MLSAGS签名验证成本 智能合约验证所需Gas 影响使用成本 实验结果 1. Groth16性能测试 测试方案：\n使用单个算术电路验证多个PHC批次 测试不同批次大小下的性能表现 图表 6(a)：电路大小和证明大小 PHC批次大小 R1CS约束数量 ZK证明大小 1 ~19,000 192 Bytes 2 ~38,000 192 Bytes 4 ~76,000 192 Bytes 8 ~152,000 192 Bytes 16 ~304,000 192 Bytes 32 ~608,000 192 Bytes 64 ~1,216,000 192 Bytes 128 ~2,432,000 192 Bytes 关键发现：\n✨ 证明大小恒定：无论批次大小如何，证明始终为192字节 这是Groth16的核心优势：简洁性（Succinctness） 电路大小随批次线性增长 图表 6(b)：证明生成时间和验证成本 证明生成时间：\nPHC批次大小 生成时间 (ms) 增长趋势 1 ~2,000 基准 2 ~4,000 2x 4 ~8,000 4x 8 ~16,000 8x 16 ~32,000 16x 32 ~64,000 32x 证明验证成本（Gas）：\nPHC批次大小 验证Gas消耗 单个PHC平均Gas 1 215.7K 215.7K 2 247.2K 123.6K 4 310.2K 77.6K 8 436.2K 54.5K 16 688.2K 43.0K 32 1,040.0K 32.5K 关键发现：\n📈 线性增长：生成时间和验证成本都与批次大小呈线性关系\n💰\n批处理优势\n：批次大小为32时，单个PHC的Gas消耗仅为32.5K\n相比单独验证（215.7K），节省约85% 效率提升约7倍 ⚠️ 部署限制：批次大小≥64时，验证合约因以太坊合约大小限制无法部署\n最佳实践建议：\n推荐批次大小：16-32个PHC - 在合约大小限制内 - 获得显著的Gas优化 - 用户体验可接受 2. MLSAGS性能测试 测试方案：\n测试不同环大小L下的签名生成和验证性能 环大小影响匿名性和性能的权衡 图表 6(c)：MLSAGS性能指标 签名生成时间：\n环大小 L 生成时间 (ms) 增量时间 1 ~40 - 2 ~80 +40ms 4 ~160 +40ms 8 ~320 +40ms 16 ~640 +40ms 32 ~1,280 +40ms 64 ~2,560 +40ms 128 ~5,120 +40ms 签名验证成本（Gas）：\n环大小 L 验证Gas消耗 增量Gas 1 ~57K - 2 ~114K +57K 4 ~228K +57K 8 ~456K +57K 16 ~912K +57K 32 ~1,824K +57K 64 ~3,648K +57K 128 ~7,296K +57K 关键发现：\n📏\n完美线性关系\n：\n每增加1个公钥，生成时间增加约40ms 每增加1个公钥，验证Gas增加约57K ⚖️\n匿名性vs效率权衡\n：\n环越大 → 匿名性越强（攻击者猜中概率 = 1/L） 环越大 → 成本越高（时间和Gas） 匿名性分析：\n环大小 L 攻击者成功率 匿名性等级 Gas成本 10 10% 较弱 570K 50 2% 中等 2,850K 100 1% 强 5,700K 1000 0.1% 非常强 57,000K 实际应用建议：\n小规模应用（\u0026lt; 1000用户）： 环大小：10-20 匿名性：10%-5%攻击成功率 Gas成本：570K-1,140K（可接受） 中等规模应用（1000-10000用户）： 环大小：50-100 匿名性：2%-1%攻击成功率 Gas成本：2,850K-5,700K（需要优化） 大规模应用（\u0026gt; 10000用户）： 环大小：100+ 匿名性：\u0026lt; 1%攻击成功率 Gas成本：\u0026gt; 5,700K（需要Layer 2或批处理） 性能优化建议 1. 对于zkSNARK部分 批处理策略：\n低频场景（个人注册）： - 批次大小：1-4 - 适用：个人用户单次注册 - 优点：即时处理 - 缺点：Gas成本较高（215K-310K） 高频场景（批量注册）： - 批次大小：16-32 - 适用：组织批量入职、大规模注册活动 - 优点：Gas效率提升7倍 - 缺点：需要等待批次凑齐 2. 对于MLSAGS部分 环大小配置：\n# 根据用户总数动态调整 def calculate_ring_size(total_users, target_anonymity=0.01): \u0026#34;\u0026#34;\u0026#34; total_users: 系统总用户数 target_anonymity: 目标攻击成功率（如0.01 = 1%） \u0026#34;\u0026#34;\u0026#34; # 环大小不超过总用户数 ring_size = min(int(1 / target_anonymity), total_users) # 考虑Gas成本限制（假设单笔交易Gas上限为8M） max_affordable_ring = 8_000_000 / 57_000 # ≈ 140 return min(ring_size, max_affordable_ring) # 示例 calculate_ring_size(1000, 0.01) # 返回 100 calculate_ring_size(10000, 0.01) # 返回 100（受成本限制） calculate_ring_size(50, 0.01) # 返回 50（受用户数限制） 分层匿名策略：\nVIP用户/高价值账户： - 使用较大环（100+） - 提供更强匿名性 - 愿意支付更高Gas 普通用户： - 使用中等环（20-50） - 平衡匿名性和成本 - 实际应用最常见 测试/低价值账户： - 使用小环（10-20） - 基本匿名性 - 成本最低 实验结论 zkSNARK的优势： ✅ 证明大小恒定（192字节）：不受批次影响 ✅ 批处理优化显著：32个PHC可节省85% Gas ✅ 验证快速：链上验证成本可接受 MLSAGS的特性： ✅ 性能可预测：完美线性关系 ⚠️ 需要权衡：匿名性与成本呈正比 ✅ 灵活配置：可根据场景调整环大小 系统可行性： ✅ 在实际以太坊网络上完全可行 ✅ 通过参数优化可适应不同规模 ✅ 性能瓶颈明确且可优化 相关工作对比 现有方案分析 论文对比了8个相关的区块链身份方案：\n方案 年份 主要技术 应用场景 TradeMap [12] 2019 ZKP 符合FINMA的匿名KYC平台 Pauwels et al. [14] 2022 zkSNARK DeFi协议的KYC系统 Aydar et al. [3] 2019 Blockchain 数字身份验证框架 Singh et al. [18] 2020 Credential Protocol 保护个人属性的身份系统 Abraham et al. [1] 2020 SSI Model 支持凭证撤销的自主身份 ZEBRA [15] 2022 zkSNARK 链上匿名凭证验证 Zhang et al. [26] 2024 ZKP 能源交易身份认证 Kim et al. [10] 2023 SBT + DID 元宇宙的KYC系统 设计目标对比 方案 DG1 技术灵活性 DG2 身份匿名性 DG3 身份可信性 DG4 隐私存储 TradeMap [12] ✅ ❌ ❌ ❌ Pauwels [14] ✅ ❌ ✅ ✅ Aydar [3] ❌ ✅ ❌ ❌ Singh [18] ❌ ✅ ✅ ✅ Abraham [1] ✅ ✅ ❌ ❌ ZEBRA [15] ❌ ✅ ❌ ❌ Zhang [26] ✅ ❌ ✅ ❌ Kim [10] ❌ ✅ ❌ ❌ zkBID ✅ ✅ ✅ ✅ 设计目标说明：\nDG1 - 技术灵活性：不局限于特定的ZKP算法或区块链平台 DG2 - 身份匿名性：无法从链上活动推断用户真实身份 DG3 - 身份可信性：每个身份可信地连接到真实世界用户 DG4 - 隐私存储：身份文档保密存储，不公开可见 zkBID的独特优势 1. 唯一全面满足所有设计目标 其他方案的局限： ├─ TradeMap: 只关注合规性，缺乏匿名性和可信映射 ├─ Pauwels: DeFi场景，但身份匿名性不足 ├─ Aydar/Singh: 技术灵活性差，绑定特定实现 ├─ Abraham/ZEBRA: 缺乏与真实用户的可信绑定 ├─ Zhang: 特定场景（能源交易），匿名性不足 └─ Kim: 元宇宙场景，技术灵活性和可信性不足 zkBID的创新： ✅ 同时实现匿名性和可信性（看似矛盾的目标） ✅ 完全去中心化（无需可信第三方） ✅ 技术灵活（可替换ZKP算法和环签名方案） ✅ 隐私保护（身份信息不上链） 2. 技术组合的创新性 现有方案的技术使用：\n大多只使用zkSNARK进行凭证验证 少数使用环签名，但未实现身份-账户绑定 没有方案同时使用zkSNARK + 可链接环签名 zkBID的技术创新：\nzkSNARK（阶段1-2）： 目的：验证PHC有效性 优势：不泄露PHC内容 创新：批处理优化 可链接环签名（阶段3）： 目的：建立身份-账户映射 优势：保持匿名性的同时确保一对一 创新：使用密钥图像防止重复绑定 组合效果： = 可验证的身份 + 不可追踪的账户绑定 = 可信匿名（Credible Anonymity） 3. 实际应用价值 传统KYC系统的问题：\n中心化KYC： ❌ 隐私泄露风险 ❌ 数据被服务商控制 ❌ 跨平台不互通 区块链匿名账户： ❌ 无法防止女巫攻击 ❌ 信誉系统难以建立 ❌ 监管合规困难 zkBID的解决方案：\n对用户： ✅ 保护隐私（身份信息不泄露） ✅ 自主控制（无需信任中心化机构） ✅ 一次认证，多处使用 对平台： ✅ 防止女巫攻击（一人一账户） ✅ 建立信誉系统（账户可信） ✅ 满足监管要求（有认证机制） 对监管： ✅ 可验证的身份（PHC由可信机构签发） ✅ 可追责性（必要时可追踪） ✅ 隐私保护合规 应用场景 1. 去中心化社交网络 问题：\nTwitter/X上的机器人和假账户泛滥 难以区分真人和AI生成的内容 水军和虚假舆论操纵 zkBID解决方案：\n用户注册： 1. 用政府ID获取PHC 2. 通过zkBID认证获得灵魂账户 3. 使用灵魂账户在社交网络发布内容 效果： ✅ 每个账户对应一个真人 ✅ 保持用户匿名性 ✅ 机器人和假账户显著减少 ✅ 信誉系统可以建立在灵魂账户上 2. DAO治理 问题：\n一人多账户操纵投票 女巫攻击破坏治理公平性 难以验证投票者资格 zkBID解决方案：\n治理流程： 1. DAO成员通过zkBID认证 2. 每个灵魂账户 = 一个真实成员 3. 投票时保持匿名 4. 防止多重投票 效果： ✅ 一人一票（真正的民主） ✅ 投票匿名（防止胁迫和贿赂） ✅ 可验证（确保只有成员投票） ✅ 信誉加权（可基于历史贡献） 3. DeFi空投和激励 问题：\n空投被羊毛党多账户瓜分 难以识别真实用户 激励机制被滥用 zkBID解决方案：\n空投流程： 1. 要求使用zkBID认证的灵魂账户 2. 每个灵魂账户只能领取一次 3. 基于链上行为的信誉评分 效果： ✅ 公平分配（每人一份） ✅ 防止女巫攻击 ✅ 识别真实活跃用户 ✅ 建立长期激励机制 4. Web3游戏和元宇宙 问题：\n工作室多开刷金币 游戏经济被破坏 难以建立公平竞技环境 zkBID解决方案：\n游戏应用： 1. 玩家使用灵魂账户登录 2. 游戏内资产绑定到灵魂账户 3. 排行榜和竞技只认可灵魂账户 效果： ✅ 一人一号（公平竞争） ✅ 资产真实归属 ✅ 游戏经济稳定 ✅ 社交关系可信 5. 去中心化信用系统 问题：\n传统信用系统中心化 跨平台信用不互通 隐私泄露风险 zkBID解决方案：\n信用体系： 1. 灵魂账户作为信用载体 2. 链上行为建立信用历史 3. 跨DApp信用互认 4. 保护用户隐私 效果： ✅ 去中心化信用（不被单一机构控制） ✅ 可移植性（跨平台使用） ✅ 隐私保护（匿名但可信） ✅ 防止信用欺诈（一人一信用档案） 局限性与未来工作 当前局限性 1. 性能限制 Gas成本：\n当前状态： - 单次PHC验证：215.7K Gas - 环大小100的签名验证：5,700K Gas - 在以太坊主网上成本较高 影响： ❌ 大规模应用成本高 ❌ 限制了环大小（影响匿名性） 可能的解决方案：\nLayer 2方案（如Optimism、Arbitrum） 侧链部署 批处理优化 2. PHC依赖 当前状态：\n依赖可信的PHC颁发机构： - 政府机构 - 大型科技公司 - 其他可信第三方 问题： ❌ PHC系统尚未广泛部署 ❌ 不同颁发者的互操作性 ❌ 颁发者可能成为中心化风险点 3. 隐私权衡 匿名性级别：\n环大小的限制： - 小环（\u0026lt;20）：匿名性较弱 - 大环（100+）：成本高昂 - 实际应用中需要权衡 4. 撤销机制 当前缺失：\n无法撤销已认证的灵魂账户： ❌ 如果PHC被吊销怎么办？ ❌ 如果用户想注销怎么办？ ❌ 如果发现欺诈怎么办？ 需要设计： - 灵活的撤销机制 - 保持匿名性的撤销 - 防止滥用撤销权 未来研究方向 1. 性能优化 方向A：递归证明：\n使用递归zkSNARK： - 将多个证明聚合成一个 - 减少链上验证成本 - 提高批处理效率 预期效果： - Gas成本降低50%+ - 支持更大批次 方向B：量子抗性：\n替换为抗量子密码算法： - 格基密码学 - 哈希基签名 - 为后量子时代做准备 2. PHC生态系统 多颁发者互操作：\n标准化PHC格式： - 统一的VC模板 - 跨颁发者互认 - 去中心化颁发者网络 目标： - 减少单点故障 - 提高可用性 - 增强去中心化 去中心化PHC颁发：\n探索无需中心化颁发者的方案： - 基于生物识别的去中心化验证 - 社交图谱验证 - 组合多种验证方式 3. 隐私增强 方向A：动态环：\n允许用户动态选择环大小： - 根据交易重要性调整 - 重要交易用大环 - 普通交易用小环 效果： - 灵活性提高 - 成本优化 方向B：分层匿名：\n不同隐私级别的灵魂账户： - 公开级：最小匿名性，低成本 - 标准级：中等匿名性，中等成本 - 隐私级：高匿名性，高成本 4. 跨链支持 多链部署：\n扩展到其他区块链： - Polkadot/Cosmos生态 - 高性能链（Solana、Aptos） - 专用隐私链（Zcash、Monero概念） 跨链身份： - 一个PHC，多链认证 - 统一的身份层 5. 撤销和恢复机制 优雅的撤销：\n设计保护隐私的撤销： - 使用累加器（Accumulator） - 撤销列表不泄露身份 - 高效的撤销验证 恢复机制： - PHC过期后的更新流程 - 密钥丢失的恢复方案 - 保持连续性的信誉迁移 6. 合规和监管 可选的透明性：\n为监管场景设计： - 选择性披露机制 - 紧急情况下的去匿名化 - 法院命令的执行 平衡： - 保护普通用户隐私 - 满足反洗钱（AML）要求 - 支持合法调查 关键takeaways 技术创新 可信匿名的突破： 首次在区块链上实现\u0026quot;可信\u0026quot;+\u0026ldquo;匿名\u0026quot;的结合 通过零知识证明保护隐私 通过可链接环签名确保一对一映射 完全去中心化： 无需可信第三方参与验证 所有逻辑在智能合约中执行 用户完全控制自己的身份 实用性验证： 在真实以太坊测试网络上实现 性能指标明确可测 成本可接受且可优化 理论贡献 身份模型创新：\n传统模型：身份 → 账户（可见映射） zkBID模型：身份 → [ZK层] → 种子 → [环签名层] → 账户 创新点： - 两层隐私保护 - 可验证但不可追踪 - 数学上可证明的安全性 密码学组合：\nzkSNARK + 可链接环签名的首次组合应用 各取所长，弥补对方不足 为未来类似系统提供范式 实践意义 Web3基础设施： 为Web3提供关键的身份层 解决匿名性与可信性的矛盾 使去中心化应用更实用 防止AI冒充： 在AI时代区分人类和机器 PHC作为\u0026quot;数字人格证\u0026rdquo; 保护在线空间的人类性 新经济模式： 支持基于信誉的去中心化经济 公平的激励分配机制 可持续的社区治理 结论 zkBID是一个创新的Web 3.0去中心化身份方案，成功解决了区块链账户系统中匿名性与可信性的矛盾。\n核心成就 ✅ 技术突破：\n零知识证明保护身份隐私 可链接环签名确保一对一映射 完全去中心化的验证机制 ✅ 安全保证：\n抵御女巫攻击 抵御链接攻击 抵御伪造攻击 ✅ 实用验证：\n以太坊测试网络成功部署 性能指标满足实际应用需求 成本可通过参数优化控制 未来展望 zkBID为Web3去中心化身份提供了一个可行的解决方案，但仍有改进空间：\n继续优化性能和成本 推动PHC生态系统发展 探索跨链和多链支持 完善撤销和恢复机制 平衡隐私保护 ","permalink":"http://localhost:1313/posts/linking-souls-to-humans/","summary":"zkBID通过零知识证明和可链接环签名技术，首次实现了区块链账户的\u0026quot;可信匿名\u0026quot;：每个账户与真实用户一对一绑定（可信），但外界无法追踪具体对应关系（匿名）。系统采用三阶段IVAC流程，将人格凭证(PHC)通过零知识证明验证后绑定到种子公钥，再用环签名将种子公钥关联到灵魂账户。实验显示批处理可将验证成本降低85%，环大小灵活可调以平衡匿名性与效率。该方案为Web3提供了关键身份基础设施，可有效防止女巫攻击，支持去中心化社交、DAO治理、DeFi空投等场景。","title":"zkBID: 区块链账户与Web 3.0去中心化身份"},{"content":"📚 Part 1: Java 集合使用手册 0.String - 不可变字符串 // 初始化 String s = \u0026#34;hello\u0026#34;; String s2 = new String(\u0026#34;world\u0026#34;); String s3 = String.valueOf(123); // 数字转字符串 // 基本属性 int len = s.length(); // 长度 boolean empty = s.isEmpty(); // 是否为空 char ch = s.charAt(0); // 获取字符 // 查找 int index = s.indexOf(\u0026#34;ll\u0026#34;); // 查找子串位置 int lastIndex = s.lastIndexOf(\u0026#34;l\u0026#34;); // 最后出现位置 boolean contains = s.contains(\u0026#34;el\u0026#34;); // 是否包含 // 截取 String sub = s.substring(1, 4); // [1, 4) 截取 String sub2 = s.substring(2); // 从索引2到结尾 // 替换 String replaced = s.replace(\u0026#34;l\u0026#34;, \u0026#34;L\u0026#34;); // 替换所有 String replaced2 = s.replaceFirst(\u0026#34;l\u0026#34;, \u0026#34;L\u0026#34;); // 替换第一个 String replaced3 = s.replaceAll(\u0026#34;[aeiou]\u0026#34;, \u0026#34;*\u0026#34;); // 正则替换 // 分割 String[] parts = \u0026#34;a,b,c\u0026#34;.split(\u0026#34;,\u0026#34;); // 按分隔符分割 String[] parts2 = \u0026#34;a b c\u0026#34;.split(\u0026#34;\\\\s+\u0026#34;); // 按空格分割 // 拼接 String joined = String.join(\u0026#34;,\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); // \u0026#34;a,b,c\u0026#34; String concat = s.concat(\u0026#34; world\u0026#34;); // 拼接 // 大小写 String upper = s.toUpperCase(); String lower = s.toUpperCase().toLowerCase(); // 去空格 String trimmed = \u0026#34; hello \u0026#34;.trim(); // 去两端空格 String stripped = \u0026#34; hello \u0026#34;.strip(); // Java 11+ // 比较 boolean equals = s.equals(\u0026#34;hello\u0026#34;); boolean equalsIgnoreCase = s.equalsIgnoreCase(\u0026#34;HELLO\u0026#34;); int compare = s.compareTo(\u0026#34;world\u0026#34;); // 字典序比较 // 判断 boolean startsWith = s.startsWith(\u0026#34;he\u0026#34;); boolean endsWith = s.endsWith(\u0026#34;lo\u0026#34;); // 转换 char[] chars = s.toCharArray(); // 转字符数组 byte[] bytes = s.getBytes(); // 转字节数组 StringBuilder - 可变字符串 使用场景：单线程环境下需要频繁修改字符串\n// 初始化 StringBuilder sb = new StringBuilder(); StringBuilder sb2 = new StringBuilder(\u0026#34;hello\u0026#34;); StringBuilder sb3 = new StringBuilder(100); // 指定初始容量 // 添加（拼接） sb.append(\u0026#34;hello\u0026#34;); // 尾部添加 sb.append(123); // 添加数字 sb.append(\u0026#39;!\u0026#39;); // 添加字符 sb.insert(0, \u0026#34;start \u0026#34;); // 指定位置插入 // 删除 sb.delete(0, 5); // 删除 [0, 5) sb.deleteCharAt(0); // 删除指定位置 sb.setLength(0); // 清空（重置长度为0） // 修改 sb.replace(0, 5, \u0026#34;world\u0026#34;); // 替换 [0, 5) sb.setCharAt(0, \u0026#39;H\u0026#39;); // 修改指定位置字符 // 反转 sb.reverse(); // 查询 int len = sb.length(); char ch = sb.charAt(0); String sub = sb.substring(0, 5); // 转换为 String String result = sb.toString(); // 常见应用：循环拼接字符串 StringBuilder result = new StringBuilder(); for (int i = 0; i \u0026lt; 1000; i++) { result.append(i).append(\u0026#34;,\u0026#34;); } // 比用 String + 拼接快得多！ StringBuffer - 可变字符串 使用场景：多线程环境下需要频繁修改字符串\n// API 与 StringBuilder 完全相同 StringBuffer sb = new StringBuffer(); sb.append(\u0026#34;hello\u0026#34;); sb.append(\u0026#34; world\u0026#34;); String result = sb.toString(); // 区别：StringBuffer 的方法都是 synchronized 的 // 多线程安全，但性能比 StringBuilder 差 常用字符串操作技巧 // 1. 字符串转数字 int num = Integer.parseInt(\u0026#34;123\u0026#34;); long l = Long.parseLong(\u0026#34;123\u0026#34;); double d = Double.parseDouble(\u0026#34;3.14\u0026#34;); // 2. 数字转字符串 String s1 = String.valueOf(123); String s2 = Integer.toString(123); String s3 = \u0026#34;\u0026#34; + 123; // 不推荐 // 3. 字符串数组拼接 String[] arr = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; String joined = String.join(\u0026#34;,\u0026#34;, arr); // \u0026#34;a,b,c\u0026#34; // 4. 重复字符串（Java 11+） String repeated = \u0026#34;ab\u0026#34;.repeat(3); // \u0026#34;ababab\u0026#34; // 5. 判断空字符串 if (s != null \u0026amp;\u0026amp; !s.isEmpty()) { } if (s != null \u0026amp;\u0026amp; !s.isBlank()) { } // Java 11+，忽略空白字符 // 6. 字符串格式化 String formatted = String.format(\u0026#34;Hello %s, you are %d years old\u0026#34;, \u0026#34;Alice\u0026#34;, 25); 1. List - 列表 ArrayList - 动态数组 // 初始化 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); List\u0026lt;Integer\u0026gt; list3 = new ArrayList\u0026lt;\u0026gt;(100); // 指定初始容量 // 增 list.add(1); // 尾部添加 list.add(0, 10); // 指定位置添加 list.addAll(Arrays.asList(2,3,4)); // 批量添加 // 删 list.remove(0); // 删除指定索引 list.remove(Integer.valueOf(1)); // 删除指定元素 list.clear(); // 清空 // 改 list.set(0, 100); // 修改指定位置 // 查 int val = list.get(0); // 获取元素 int size = list.size(); // 获取大小 boolean empty = list.isEmpty(); // 是否为空 boolean contains = list.contains(1); // 是否包含 int index = list.indexOf(1); // 查找索引 // 遍历 for (int num : list) { System.out.println(num); } // 或使用迭代器 Iterator\u0026lt;Integer\u0026gt; it = list.iterator(); while (it.hasNext()) { System.out.println(it.next()); } LinkedList - 双向链表 LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 头部操作 list.addFirst(1); list.removeFirst(); int first = list.getFirst(); // 尾部操作 list.addLast(2); list.removeLast(); int last = list.getLast(); // 作为队列使用 list.offer(3); // 入队 int head = list.poll(); // 出队 // 作为栈使用 list.push(4); // 入栈 int top = list.pop(); // 出栈 2. Set - 集合 HashSet - 无序不重复 // 初始化 Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); // 增 set.add(1); set.addAll(Arrays.asList(2, 3, 4)); // 删 set.remove(1); set.clear(); // 查 boolean contains = set.contains(1); int size = set.size(); boolean empty = set.isEmpty(); // 遍历 for (int num : set) { System.out.println(num); } TreeSet - 有序集合（红黑树） TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 基本操作同 HashSet set.add(3); set.add(1); set.add(2); System.out.println(set); // [1, 2, 3] 自动排序 // 特有方法 int first = set.first(); // 最小元素 int last = set.last(); // 最大元素 int lower = set.lower(2); // 小于 2 的最大元素 int higher = set.higher(2); // 大于 2 的最小元素 int floor = set.floor(2); // ≤ 2 的最大元素 int ceiling = set.ceiling(2); // ≥ 2 的最小元素 // 子集操作 SortedSet\u0026lt;Integer\u0026gt; subset = set.subSet(1, 3); // [1, 3) SortedSet\u0026lt;Integer\u0026gt; headSet = set.headSet(2); // \u0026lt; 2 SortedSet\u0026lt;Integer\u0026gt; tailSet = set.tailSet(2); // \u0026gt;= 2 LinkedHashSet - 保持插入顺序 Set\u0026lt;Integer\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); set.add(3); set.add(1); set.add(2); System.out.println(set); // [3, 1, 2] 保持插入顺序 3. Map - 映射 HashMap - 键值对 // 初始化 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 增/改 map.put(\u0026#34;apple\u0026#34;, 1); map.put(\u0026#34;banana\u0026#34;, 2); map.putIfAbsent(\u0026#34;apple\u0026#34;, 10); // 键不存在时才添加 // 删 map.remove(\u0026#34;apple\u0026#34;); map.clear(); // 查 int val = map.get(\u0026#34;apple\u0026#34;); int valOrDefault = map.getOrDefault(\u0026#34;orange\u0026#34;, 0); boolean hasKey = map.containsKey(\u0026#34;apple\u0026#34;); boolean hasValue = map.containsValue(1); int size = map.size(); // 遍历键值对 for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { String key = entry.getKey(); int value = entry.getValue(); } // 遍历键 for (String key : map.keySet()) { System.out.println(key); } // 遍历值 for (int value : map.values()) { System.out.println(value); } // Java 8+ 新方法 map.computeIfAbsent(\u0026#34;cherry\u0026#34;, k -\u0026gt; 3); map.merge(\u0026#34;apple\u0026#34;, 1, Integer::sum); // 累加 TreeMap - 有序映射（红黑树） TreeMap\u0026lt;Integer, String\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); map.put(3, \u0026#34;c\u0026#34;); map.put(1, \u0026#34;a\u0026#34;); map.put(2, \u0026#34;b\u0026#34;); // 基本操作同 HashMap // 特有方法 int firstKey = map.firstKey(); int lastKey = map.lastKey(); Map.Entry\u0026lt;Integer, String\u0026gt; firstEntry = map.firstEntry(); Map.Entry\u0026lt;Integer, String\u0026gt; lastEntry = map.lastEntry(); int lowerKey = map.lowerKey(2); // \u0026lt; 2 的最大键 int higherKey = map.higherKey(2); // \u0026gt; 2 的最小键 int floorKey = map.floorKey(2); // \u0026lt;= 2 的最大键 int ceilingKey = map.ceilingKey(2); // \u0026gt;= 2 的最小键 LinkedHashMap - 保持插入顺序 Map\u0026lt;String, Integer\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;c\u0026#34;, 3); map.put(\u0026#34;a\u0026#34;, 1); map.put(\u0026#34;b\u0026#34;, 2); // 遍历时保持插入顺序: c, a, b 4. Queue - 队列 普通队列 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 入队 queue.offer(1); queue.add(2); // 队列满时抛异常 // 出队 int head = queue.poll(); // 空时返回 null int head2 = queue.remove(); // 空时抛异常 // 查看队首 int peek = queue.peek(); // 空时返回 null int peek2 = queue.element(); // 空时抛异常 PriorityQueue - 优先队列（堆） // 小根堆（默认） PriorityQueue\u0026lt;Integer\u0026gt; minHeap = new PriorityQueue\u0026lt;\u0026gt;(); // 大根堆 PriorityQueue\u0026lt;Integer\u0026gt; maxHeap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); // 自定义对象 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); minHeap.offer(3); minHeap.offer(1); minHeap.offer(2); while (!minHeap.isEmpty()) { System.out.println(minHeap.poll()); // 1, 2, 3 } Deque - 双端队列 Deque\u0026lt;Integer\u0026gt; deque = new ArrayDeque\u0026lt;\u0026gt;(); // 头部操作 deque.offerFirst(1); deque.pollFirst(); deque.peekFirst(); // 尾部操作 deque.offerLast(2); deque.pollLast(); deque.peekLast(); // 作为栈使用 deque.push(3); int top = deque.pop(); 5. Stack - 栈 Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(1); // 入栈 int top = stack.pop(); // 出栈 int peek = stack.peek(); // 查看栈顶 boolean empty = stack.isEmpty(); int size = stack.size(); // 推荐使用 Deque 代替 Stack Deque\u0026lt;Integer\u0026gt; stack2 = new ArrayDeque\u0026lt;\u0026gt;(); 🧮 Part 2: 算法模板 1. 树的遍历 二叉树定义 class TreeNode { int val; // 节点值 TreeNode left; // 左子节点 TreeNode right; // 右子节点 TreeNode(int val) { this.val = val; } } DFS - 深度优先遍历 前序遍历（根-左-右） // 递归版本 - 最简洁直观 void preorder(TreeNode root) { if (root == null) return; // 递归终止条件：空节点 System.out.println(root.val); // 1. 先访问根节点 preorder(root.left); // 2. 再遍历左子树 preorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 使用栈模拟递归 List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); // 根节点入栈 while (!stack.isEmpty()) { TreeNode node = stack.pop(); // 弹出栈顶节点 res.add(node.val); // 访问该节点 // 关键：先压右子节点，再压左子节点 // 这样出栈时左子节点先出（栈是后进先出） if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); } return res; } 中序遍历（左-根-右） // 递归版本 void inorder(TreeNode root) { if (root == null) return; // 递归终止条件 inorder(root.left); // 1. 先遍历左子树 System.out.println(root.val); // 2. 再访问根节点 inorder(root.right); // 3. 最后遍历右子树 } // 迭代版本 - 一直向左走到底 List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode curr = root; while (curr != null || !stack.isEmpty()) { // 第一步：一直向左走到底，沿途节点入栈 while (curr != null) { stack.push(curr); curr = curr.left; } // 第二步：弹出栈顶（当前最左节点），访问它 curr = stack.pop(); res.add(curr.val); // 第三步：转向右子树 curr = curr.right; } return res; } 后序遍历（左-右-根） // 递归版本 void postorder(TreeNode root) { if (root == null) return; // 递归终止条件 postorder(root.left); // 1. 先遍历左子树 postorder(root.right); // 2. 再遍历右子树 System.out.println(root.val); // 3. 最后访问根节点 } // 迭代版本 - 巧妙方法：前序遍历变形 + 反转 // 思路：前序是\u0026#34;根左右\u0026#34;，改成\u0026#34;根右左\u0026#34;，反转后得到\u0026#34;左右根\u0026#34; List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); res.add(node.val); // 添加到结果（根右左顺序） // 注意：这里先左后右，出栈时就是先右后左 if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); } Collections.reverse(res); // 反转得到左右根 return res; } BFS - 层序遍历 // 按层遍历二叉树，每层的节点放在一个列表中 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); // 根节点入队 while (!queue.isEmpty()) { int size = queue.size(); // 当前层的节点数（重要！） List\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); // 遍历当前层的所有节点 for (int i = 0; i \u0026lt; size; i++) { TreeNode node = queue.poll(); // 出队 level.add(node.val); // 记录节点值 // 将下一层的节点入队 if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } res.add(level); // 保存当前层结果 } return res; } 线段树（Segment Tree） /** * 线段树：用于高效处理区间查询和单点修改 * 时间复杂度：构建 O(n)，查询 O(log n)，更新 O(log n) */ class SegmentTree { private int[] tree; // 线段树数组 private int n; // 原数组大小 public SegmentTree(int[] nums) { n = nums.length; tree = new int[4 * n]; // 线段树最多需要 4n 空间 build(nums, 0, 0, n - 1); } // 构建线段树：递归构建 // node: 当前节点在 tree 中的索引 // start, end: 当前节点代表的区间 [start, end] private void build(int[] nums, int node, int start, int end) { if (start == end) { // 叶子节点：直接存储原数组的值 tree[node] = nums[start]; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; // 左子节点索引 int rightNode = 2 * node + 2; // 右子节点索引 // 递归构建左右子树 build(nums, leftNode, start, mid); build(nums, rightNode, mid + 1, end); // 当前节点的值 = 左子树 + 右子树（区间和） tree[node] = tree[leftNode] + tree[rightNode]; } // 区间查询：查询区间 [l, r] 的和 public int query(int l, int r) { return query(0, 0, n - 1, l, r); } private int query(int node, int start, int end, int l, int r) { // 情况1：当前区间与查询区间完全不相交 if (l \u0026gt; end || r \u0026lt; start) return 0; // 情况2：当前区间完全包含在查询区间内 if (l \u0026lt;= start \u0026amp;\u0026amp; end \u0026lt;= r) return tree[node]; // 情况3：部分相交，需要递归查询左右子树 int mid = start + (end - start) / 2; int leftSum = query(2 * node + 1, start, mid, l, r); int rightSum = query(2 * node + 2, mid + 1, end, l, r); return leftSum + rightSum; } // 单点更新：将 index 位置的值更新为 val public void update(int index, int val) { update(0, 0, n - 1, index, val); } private void update(int node, int start, int end, int index, int val) { if (start == end) { // 找到叶子节点，更新值 tree[node] = val; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; int rightNode = 2 * node + 2; // 判断 index 在左子树还是右子树 if (index \u0026lt;= mid) { update(leftNode, start, mid, index, val); } else { update(rightNode, mid + 1, end, index, val); } // 更新完子树后，更新当前节点 tree[node] = tree[leftNode] + tree[rightNode]; } } 2. 图算法 图的表示 // 方式1：邻接表（适合稀疏图） Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; graph = new HashMap\u0026lt;\u0026gt;(); // 或使用 ArrayList List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); // 方式2：邻接矩阵（适合密集图） int[][] graph = new int[n][n]; // graph[i][j] 表示 i 到 j 的边权 DFS - 图的深度优先遍历 // 递归实现 DFS void dfs(int node, Set\u0026lt;Integer\u0026gt; visited, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { visited.add(node); // 标记当前节点已访问 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { // 如果邻居未访问 dfs(neighbor, visited, graph); // 递归访问邻居 } } } // 使用示例 Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); dfs(0, visited, graph); // 从节点 0 开始 DFS BFS - 图的广度优先遍历 // 使用队列实现 BFS void bfs(int start, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(start); // 起始节点入队 visited.add(start); // 标记已访问 while (!queue.isEmpty()) { int node = queue.poll(); // 出队 System.out.println(node); // 处理当前节点 // 遍历所有邻居节点 for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { queue.offer(neighbor); // 邻居入队 visited.add(neighbor); // 标记已访问 } } } } 拓扑排序（Kahn 算法） /** * 拓扑排序：将有向无环图(DAG)转换为线性序列 * 应用：课程安排、任务调度等 * 核心思想：不断移除入度为0的节点 */ List\u0026lt;Integer\u0026gt; topologicalSort(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] inDegree = new int[n]; // 记录每个节点的入度 for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } // 构建图并计算入度 for (int[] edge : edges) { graph.get(edge[0]).add(edge[1]); // edge[0] -\u0026gt; edge[1] inDegree[edge[1]]++; // edge[1] 的入度+1 } // 将所有入度为0的节点入队 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (inDegree[i] == 0) { queue.offer(i); } } List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); while (!queue.isEmpty()) { int node = queue.poll(); res.add(node); // 将节点加入结果 // 删除该节点的所有出边 for (int neighbor : graph.get(node)) { inDegree[neighbor]--; // 邻居的入度-1 if (inDegree[neighbor] == 0) { // 入度变为0，入队 queue.offer(neighbor); } } } // 如果所有节点都被访问，说明无环，返回结果；否则返回空 return res.size() == n ? res : new ArrayList\u0026lt;\u0026gt;(); } Dijkstra 最短路径算法 /** * Dijkstra算法：单源最短路径（不能有负权边） * 时间复杂度：O(E log V)，E是边数，V是顶点数 * 核心思想：贪心，每次选择距离最小的未访问节点 */ int[] dijkstra(int n, int[][] edges, int start) { // 构建邻接表: {neighbor, weight} List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // edge = [from, to, weight] graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); } // dist[i] 表示从 start 到 i 的最短距离 int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 优先队列: {distance, node}，按距离从小到大排序 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); pq.offer(new int[]{0, start}); while (!pq.isEmpty()) { int[] curr = pq.poll(); int d = curr[0], node = curr[1]; // 如果当前距离大于已知最短距离，跳过 if (d \u0026gt; dist[node]) continue; // 遍历所有邻居，尝试松弛操作 for (int[] neighbor : graph.get(node)) { int next = neighbor[0], weight = neighbor[1]; int newDist = d + weight; // 如果找到更短的路径，更新距离 if (newDist \u0026lt; dist[next]) { dist[next] = newDist; pq.offer(new int[]{newDist, next}); } } } return dist; } Bellman-Ford 算法（可处理负权边） /** * Bellman-Ford算法：单源最短路径，可处理负权边 * 时间复杂度：O(V * E) * 可以检测负环 */ int[] bellmanFord(int n, int[][] edges, int start) { int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 松弛操作：最多进行 n-1 次 // 原理：最短路径最多包含 n-1 条边 for (int i = 0; i \u0026lt; n - 1; i++) { for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; // 松弛操作：如果经过 u 到 v 更短，则更新 if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { dist[v] = dist[u] + w; } } } // 第 n 次松弛：如果还能更新，说明存在负环 for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { return null; // 存在负环 } } return dist; } Floyd-Warshall 全源最短路径 /** * Floyd-Warshall算法：计算所有点对之间的最短路径 * 时间复杂度：O(V³) * 核心思想：动态规划，逐步加入中间节点 */ int[][] floydWarshall(int n, int[][] edges) { int[][] dist = new int[n][n]; // 初始化距离矩阵 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(dist[i], Integer.MAX_VALUE / 2); // 除以2防止溢出 dist[i][i] = 0; // 自己到自己距离为0 } // 填入边的权重 for (int[] edge : edges) { dist[edge[0]][edge[1]] = edge[2]; } // 动态规划：k 是中间节点 // dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) for (int k = 0; k \u0026lt; n; k++) { // 枚举中间节点 for (int i = 0; i \u0026lt; n; i++) { // 枚举起点 for (int j = 0; j \u0026lt; n; j++) { // 枚举终点 // 如果经过 k 中转更短，则更新 dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]); } } } return dist; } Prim 最小生成树 /** * Prim算法：构建最小生成树 * 时间复杂度：O(E log V) * 核心思想：从一个节点开始，逐步扩展，每次选最小边 */ int prim(int n, int[][] edges) { // 构建邻接表 List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { // 无向图：添加双向边 graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); graph.get(edge[1]).add(new int[]{edge[0], edge[2]}); } boolean[] visited = new boolean[n]; // 优先队列：{node, weight}，按权重从小到大 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[1] - b[1]); pq.offer(new int[]{0, 0}); // 从节点0开始，权重0 int totalWeight = 0; // 最小生成树的总权重 int edgeCount = 0; // 已添加的边数 while (!pq.isEmpty() \u0026amp;\u0026amp; edgeCount \u0026lt; n) { int[] curr = pq.poll(); int node = curr[0], weight = curr[1]; if (visited[node]) continue; // 已访问，跳过 visited[node] = true; totalWeight += weight; // 加入最小生成树 edgeCount++; // 将邻居节点的边加入优先队列 for (int[] neighbor : graph.get(node)) { if (!visited[neighbor[0]]) { pq.offer(neighbor); } } } // 如果所有节点都连通，返回总权重；否则返回-1 return edgeCount == n ? totalWeight : -1; } Kruskal 最小生成树（并查集） /** * 并查集：用于判断连通性和合并集合 */ class UnionFind { int[] parent; // parent[i] 表示 i 的父节点 int[] rank; // rank[i] 表示以 i 为根的树的高度 public UnionFind(int n) { parent = new int[n]; rank = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; // 初始时每个节点的父节点是自己 } } // 查找：找到 x 所在集合的代表元素（路径压缩） public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); // 路径压缩：直接连到根节点 } return parent[x]; } // 合并：将 x 和 y 所在的集合合并（按秩合并） public boolean union(int x, int y) { int rootX = find(x), rootY = find(y); if (rootX == rootY) return false; // 已经在同一集合 // 按秩合并：将矮树挂到高树上 if (rank[rootX] \u0026lt; rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] \u0026gt; rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; // 高度相同，随便挂，高度+1 } return true; } } /** * Kruskal算法：构建最小生成树 * 时间复杂度：O(E log E) * 核心思想：按边权从小到大排序，用并查集避免成环 */ int kruskal(int n, int[][] edges) { // 按边权从小到大排序 Arrays.sort(edges, (a, b) -\u0026gt; a[2] - b[2]); UnionFind uf = new UnionFind(n); int totalWeight = 0; int edgeCount = 0; for (int[] edge : edges) { // 如果两个节点不在同一集合，添加这条边 if (uf.union(edge[0], edge[1])) { totalWeight += edge[2]; edgeCount++; if (edgeCount == n - 1) break; // 最小生成树有 n-1 条边 } } return edgeCount == n - 1 ? totalWeight : -1; } 3. 回溯算法 组合问题 /** * 组合问题：从 n 个数中选 k 个数的所有组合 * 例如：n=4, k=2 -\u0026gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), 1, n, k); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int start, int n, int k) { // 递归终止条件：已选择 k 个数 if (path.size() == k) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 注意：要复制一份 return; } // 从 start 开始枚举，避免重复 for (int i = start; i \u0026lt;= n; i++) { path.add(i); // 做选择 backtrack(res, path, i + 1, n, k); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } 全排列 /** * 全排列问题：给定数组，返回所有可能的排列 * 例如：[1,2,3] -\u0026gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, new boolean[nums.length]); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, boolean[] used) { // 递归终止条件：所有数字都已使用 if (path.size() == nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } // 枚举所有数字 for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) continue; // 已使用过，跳过 path.add(nums[i]); // 做选择 used[i] = true; // 标记已使用 backtrack(res, path, nums, used); // 递归 used[i] = false; // 撤销标记（回溯） path.remove(path.size() - 1); // 撤销选择（回溯） } } 子集问题 /** * 子集问题：返回数组的所有子集（幂集） * 例如：[1,2,3] -\u0026gt; [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, int start) { // 每个状态都是一个子集 res.add(new ArrayList\u0026lt;\u0026gt;(path)); // 枚举后续元素 for (int i = start; i \u0026lt; nums.length; i++) { path.add(nums[i]); // 做选择 backtrack(res, path, nums, i + 1); // 递归 path.remove(path.size() - 1); // 撤销选择（回溯） } } N 皇后问题 /** * N皇后问题：在 n×n 的棋盘上放置 n 个皇后，使它们互不攻击 * 规则：任意两个皇后不能在同一行、同一列、同一对角线 */ List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); char[][] board = new char[n][n]; // 初始化棋盘：\u0026#39;.\u0026#39; 表示空位 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(board[i], \u0026#39;.\u0026#39;); } backtrack(res, board, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res, char[][] board, int row) { // 递归终止条件：所有行都放置完成 if (row == board.length) { res.add(construct(board)); // 将棋盘转换为字符串列表 return; } // 尝试在当前行的每一列放置皇后 for (int col = 0; col \u0026lt; board.length; col++) { if (!isValid(board, row, col)) continue; // 不合法，跳过 board[row][col] = \u0026#39;Q\u0026#39;; // 放置皇后 backtrack(res, board, row + 1); // 递归下一行 board[row][col] = \u0026#39;.\u0026#39;; // 撤销放置（回溯） } } // 检查在 (row, col) 位置放置皇后是否合法 boolean isValid(char[][] board, int row, int col) { int n = board.length; // 检查列：同一列不能有其他皇后 for (int i = 0; i \u0026lt; row; i++) { if (board[i][col] == \u0026#39;Q\u0026#39;) return false; } // 检查左上对角线 for (int i = row - 1, j = col - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } // 检查右上对角线 for (int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } return true; } // 将棋盘转换为字符串列表 List\u0026lt;String\u0026gt; construct(char[][] board) { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for (char[] row : board) { res.add(new String(row)); } return res; } 4. 动态规划 0-1 背包问题 /** * 0-1背包：每个物品只能选一次 * weights[i]: 第i个物品的重量 * values[i]: 第i个物品的价值 * capacity: 背包容量 * 返回：最大价值 */ int knapsack(int[] weights, int[] values, int capacity) { int n = weights.length; // dp[i][w] 表示前 i 个物品，背包容量为 w 时的最大价值 int[][] dp = new int[n + 1][capacity + 1]; for (int i = 1; i \u0026lt;= n; i++) { for (int w = 0; w \u0026lt;= capacity; w++) { // 如果当前物品的重量 \u0026lt;= 背包容量 if (weights[i - 1] \u0026lt;= w) { // 选择：max(不拿, 拿) dp[i][w] = Math.max( dp[i - 1][w], // 不拿第i个物品 dp[i - 1][w - weights[i - 1]] + values[i - 1] // 拿第i个物品 ); } else { // 放不下，只能不拿 dp[i][w] = dp[i - 1][w]; } } } return dp[n][capacity]; } /** * 0-1背包 - 空间优化版本 * 时间复杂度：O(n * capacity) * 空间复杂度：O(capacity) */ int knapsackOptimized(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：必须从后往前遍历，避免重复使用同一物品 for (int w = capacity; w \u0026gt;= weights[i]; w--) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 完全背包问题 /** * 完全背包：每个物品可以选无限次 * 与0-1背包的区别：内层循环从前往后遍历 */ int completeKnapsack(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { // 注意：从前往后遍历，允许重复使用物品 for (int w = weights[i]; w \u0026lt;= capacity; w++) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 最长公共子序列（LCS） /** * 最长公共子序列：找两个字符串的最长公共子序列长度 * 子序列：不要求连续 * 例如：\u0026#34;abcde\u0026#34; 和 \u0026#34;ace\u0026#34; 的LCS是 \u0026#34;ace\u0026#34;，长度为3 */ int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); // dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的LCS长度 int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (text1.charAt(i - 1) == text2.charAt(j - 1)) { // 字符相同：LCS长度+1 dp[i][j] = dp[i - 1][j - 1] + 1; } else { // 字符不同：取两种情况的最大值 dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; } 最长递增子序列（LIS） /** * 最长递增子序列 - O(n²) 动态规划解法 * dp[i] 表示以 nums[i] 结尾的最长递增子序列长度 */ int lengthOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; Arrays.fill(dp, 1); // 初始每个元素自己构成长度为1的子序列 int maxLen = 1; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { // 如果 nums[i] 可以接在 nums[j] 后面 if (nums[i] \u0026gt; nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } maxLen = Math.max(maxLen, dp[i]); } return maxLen; } /** * 最长递增子序列 - O(n log n) 二分解法 * tails[i] 表示长度为 i+1 的递增子序列的最小尾部元素 */ int lengthOfLISBinary(int[] nums) { List\u0026lt;Integer\u0026gt; tails = new ArrayList\u0026lt;\u0026gt;(); for (int num : nums) { // 二分查找：找到第一个 \u0026gt;= num 的位置 int left = 0, right = tails.size(); while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (tails.get(mid) \u0026lt; num) { left = mid + 1; } else { right = mid; } } // 如果 num 比所有元素都大，追加到末尾 if (left == tails.size()) { tails.add(num); } else { // 否则替换找到的位置 tails.set(left, num); } } return tails.size(); } 编辑距离 /** * 编辑距离：将 word1 转换为 word2 的最少操作次数 * 操作：插入、删除、替换 * 例如：\u0026#34;horse\u0026#34; -\u0026gt; \u0026#34;ros\u0026#34; 需要3步（删除h、删除r、替换s） */ int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); // dp[i][j] 表示 word1[0..i-1] 转换为 word2[0..j-1] 的最少操作数 int[][] dp = new int[m + 1][n + 1]; // 边界条件：一个字符串为空 for (int i = 0; i \u0026lt;= m; i++) dp[i][0] = i; // word1 -\u0026gt; 空串：删除i个字符 for (int j = 0; j \u0026lt;= n; j++) dp[0][j] = j; // 空串 -\u0026gt; word2：插入j个字符 for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { // 字符相同：不需要操作 dp[i][j] = dp[i - 1][j - 1]; } else { // 字符不同：三种操作取最小 dp[i][j] = Math.min( Math.min( dp[i - 1][j], // 删除 word1[i-1] dp[i][j - 1] // 插入 word2[j-1] ), dp[i - 1][j - 1] // 替换 word1[i-1] 为 word2[j-1] ) + 1; } } } return dp[m][n]; } 股票买卖问题 只能买卖一次\n/** * 买卖股票的最佳时机 I：只能买卖一次 * 贪心思想：记录最低价格，计算每天卖出的最大利润 */ int maxProfit(int[] prices) { int minPrice = Integer.MAX_VALUE; // 记录目前为止的最低价格 int maxProfit = 0; // 记录最大利润 for (int price : prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; } 可以买卖多次\n/** * 买卖股票的最佳时机 II：可以买卖多次 * 贪心思想：只要今天价格比昨天高，就在昨天买今天卖 */ int maxProfitMultiple(int[] prices) { int profit = 0; for (int i = 1; i \u0026lt; prices.length; i++) { // 如果今天价格更高，累加差价 if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } 最多买卖 k 次\n/** * 买卖股票的最佳时机 III/IV：最多买卖 k 次 * dp[i][j] 表示第 i 次交易后，第 j 天的最大利润 */ int maxProfitK(int k, int[] prices) { if (prices.length == 0) return 0; int n = prices.length; // 如果 k \u0026gt;= n/2，相当于无限次交易 if (k \u0026gt;= n / 2) { int profit = 0; for (int i = 1; i \u0026lt; n; i++) { if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } int[][] dp = new int[k + 1][n]; for (int i = 1; i \u0026lt;= k; i++) { int maxDiff = -prices[0]; // 第 i-1 次交易后买入的最大收益 for (int j = 1; j \u0026lt; n; j++) { // 不操作 vs 卖出 dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff); // 更新买入的最大收益 maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]); } } return dp[k][n - 1]; } 打家劫舍 /** * 打家劫舍 I：线性排列的房屋 * 不能抢相邻的房屋 * dp[i] = max(dp[i-1], dp[i-2] + nums[i]) */ int rob(int[] nums) { if (nums.length == 0) return 0; if (nums.length == 1) return nums[0]; int prev2 = 0, prev1 = 0; // prev2: dp[i-2], prev1: dp[i-1] for (int num : nums) { int temp = prev1; // 不抢 vs 抢 prev1 = Math.max(prev1, prev2 + num); prev2 = temp; } return prev1; } /** * 打家劫舍 II：环形排列的房屋 * 第一个和最后一个房屋相邻 * 思路：分两种情况，取最大值 * 1. 抢第一个房屋，不抢最后一个 * 2. 不抢第一个房屋，抢最后一个 */ int robCircular(int[] nums) { if (nums.length == 1) return nums[0]; return Math.max( robRange(nums, 0, nums.length - 2), robRange(nums, 1, nums.length - 1) ); } int robRange(int[] nums, int start, int end) { int prev2 = 0, prev1 = 0; for (int i = start; i \u0026lt;= end; i++) { int temp = prev1; prev1 = Math.max(prev1, prev2 + nums[i]); prev2 = temp; } return prev1; } 分割等和子集 /** * 分割等和子集：判断是否能将数组分成两个和相等的子集 * 本质：0-1背包问题，目标是找到和为 sum/2 的子集 */ boolean canPartition(int[] nums) { int sum = 0; for (int num : nums) sum += num; if (sum % 2 != 0) return false; // 和为奇数，不可能分割 int target = sum / 2; // dp[j] 表示能否凑出和为 j boolean[] dp = new boolean[target + 1]; dp[0] = true; // 和为0总是可以（不选任何数） for (int num : nums) { // 从后往前遍历，避免重复使用 for (int j = target; j \u0026gt;= num; j--) { dp[j] = dp[j] || dp[j - num]; // 不选 num 或 选 num } } return dp[target]; } 零钱兑换 /** * 零钱兑换 I：最少硬币数 * dp[i] 表示凑出金额 i 所需的最少硬币数 */ int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); // 初始化为不可能的大值 dp[0] = 0; // 凑出0元需要0个硬币 for (int i = 1; i \u0026lt;= amount; i++) { for (int coin : coins) { if (i \u0026gt;= coin) { // 选择使用当前硬币 dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } } return dp[amount] \u0026gt; amount ? -1 : dp[amount]; } /** * 零钱兑换 II：组成方案数 * dp[i] 表示凑出金额 i 的方案数 */ int change(int amount, int[] coins) { int[] dp = new int[amount + 1]; dp[0] = 1; // 凑出0元有1种方案（不选） // 外层遍历硬币，内层遍历金额（避免重复计数） for (int coin : coins) { for (int i = coin; i \u0026lt;= amount; i++) { dp[i] += dp[i - coin]; } } return dp[amount]; } 5. 双指针 对撞指针 // 两数之和（有序数组） int[] twoSum(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[left] + nums[right]; if (sum == target) { return new int[]{left, right}; } else if (sum \u0026lt; target) { left++; } else { right--; } } return new int[]{-1, -1}; } // 三数之和 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length - 2; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { res.add(Arrays.asList(nums[i], nums[left], nums[right])); while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; left++; right--; } else if (sum \u0026lt; 0) { left++; } else { right--; } } } return res; } 快慢指针 // 链表中点 ListNode findMiddle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } // 环形链表 boolean hasCycle(ListNode head) { if (head == null) return false; ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) return true; } return false; } // 找环的入口 ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { slow = head; while (slow != fast) { slow = slow.next; fast = fast.next; } return slow; } } return null; } 6. 单调栈 // 下一个更大元素 int[] nextGreaterElement(int[] nums) { int n = nums.length; int[] res = new int[n]; Arrays.fill(res, -1); Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; nums[stack.peek()] \u0026lt; nums[i]) { int idx = stack.pop(); res[idx] = nums[i]; } stack.push(i); } return res; } // 每日温度 int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] res = new int[n]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[stack.peek()] \u0026lt; temperatures[i]) { int idx = stack.pop(); res[idx] = i - idx; } stack.push(i); } return res; } // 柱状图中最大的矩形 int largestRectangleArea(int[] heights) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(-1); int maxArea = 0; for (int i = 0; i \u0026lt; heights.length; i++) { while (stack.peek() != -1 \u0026amp;\u0026amp; heights[stack.peek()] \u0026gt;= heights[i]) { int h = heights[stack.pop()]; int w = i - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } stack.push(i); } while (stack.peek() != -1) { int h = heights[stack.pop()]; int w = heights.length - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } return maxArea; } 7. 前缀和 // 一维前缀和 class PrefixSum { private int[] preSum; public PrefixSum(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 0; i \u0026lt; nums.length; i++) { preSum[i + 1] = preSum[i] + nums[i]; } } // 查询区间 [left, right] 的和 public int query(int left, int right) { return preSum[right + 1] - preSum[left]; } } // 二维前缀和 class MatrixPrefixSum { private int[][] preSum; public MatrixPrefixSum(int[][] matrix) { int m = matrix.length, n = matrix[0].length; preSum = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } // 查询子矩阵 [row1, col1] 到 [row2, col2] 的和 public int query(int row1, int col1, int row2, int col2) { return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]; } } 📌 总结 这份文档涵盖了：\nJava 集合框架：List、Set、Map、Queue、Stack 的完整使用方法 树算法：DFS、BFS、线段树 图算法：遍历、最短路径、最小生成树 经典算法：回溯、动态规划、二分查找、滑动窗口、双指针、单调栈、前缀和 建议配合 LeetCode 刷题使用，遇到问题时可以快速查阅对应的模板代码。\n持续更新中\u0026hellip; 🚀\n","permalink":"http://localhost:1313/posts/algorithm-with-java/","summary":"详细介绍java集合的使用,以及在刷算法题中需要使用到的一些板子","title":"算法刷题必备：Java集合与算法模板"},{"content":"一、Hugo 常用指令 1.1 创建新站点 # 创建一个新的 Hugo 站点 hugo new site mysite # 进入站点目录 cd mysite 1.2 创建新文章 # 在 content/posts 目录下创建新文章 hugo new posts/my-first-post.md # 在 content 目录下创建文章 hugo new about.md # 创建在特定子目录 hugo new blog/2024/new-post.md 1.3 本地预览 # 启动本地开发服务器（默认 http://localhost:1313） hugo server # 启动并显示草稿文章 hugo server -D # 启动并显示草稿、未来日期和过期的文章 hugo server -DEF # 指定端口 hugo server --port 8080 # 实时重载并打开浏览器 hugo server -D --navigateToChanged 1.4 主题管理 # 添加主题（使用 Git submodule） git submodule add https://github.com/username/theme-name.git themes/theme-name # 更新主题 git submodule update --remote --merge # 删除主题 git submodule deinit -f themes/theme-name rm -rf .git/modules/themes/theme-name git rm -f themes/theme-name 1.5 其他常用指令 # 查看 Hugo 版本 hugo version # 查看帮助 hugo help # 查看配置信息 hugo config # 列出所有内容 hugo list all # 列出草稿 hugo list drafts 二、Markdown Front Matter 配置 2.1 完整配置示例 --- # 基本信息 title: \u0026#34;我的第一篇文章\u0026#34; date: 2025-12-06T15:04:05+08:00 lastmod: 2025-12-07T10:00:00+08:00 draft: false # 作者信息 author: \u0026#34;Minjie\u0026#34; authorLink: \u0026#34;https://github.com/Minjie2003\u0026#34; # 分类和标签 categories: [\u0026#34;技术\u0026#34;] tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;, \u0026#34;博客\u0026#34;] series: [\u0026#34;Hugo教程\u0026#34;] # 摘要和描述 summary: \u0026#34;这是一篇关于 Hugo 和 Markdown 的完整指南\u0026#34; description: \u0026#34;详细介绍 Hugo 的使用方法和 Markdown 配置\u0026#34; # 特色图片 image: \u0026#34;/images/featured.jpg\u0026#34; cover: image: \u0026#34;/images/cover.jpg\u0026#34; alt: \u0026#34;封面图片描述\u0026#34; caption: \u0026#34;图片说明文字\u0026#34; # SEO 相关 keywords: [\u0026#34;Hugo\u0026#34;, \u0026#34;静态博客\u0026#34;, \u0026#34;Markdown\u0026#34;] slug: \u0026#34;hugo-markdown-guide\u0026#34; url: \u0026#34;/posts/hugo-guide/\u0026#34; # 显示控制 toc: true # 显示目录 comments: true # 允许评论 showToc: true # 显示目录 TocOpen: false # 默认展开目录 hidemeta: false # 隐藏元信息 disableShare: false # 禁用分享按钮 hideSummary: false # 隐藏摘要 ShowReadingTime: true # 显示阅读时间 ShowBreadCrumbs: true # 显示面包屑导航 ShowPostNavLinks: true # 显示文章导航链接 # 权重（用于排序） weight: 1 # 外部链接 externalLink: \u0026#34;https://example.com\u0026#34; # 是否在首页显示 showhome: true --- 2.2 常用字段说明 字段 说明 示例 title 文章标题 \u0026quot;我的文章\u0026quot; date 发布日期 2025-12-06 或 2025-12-06T15:04:05+08:00 draft 是否为草稿 true / false tags 标签（数组） [\u0026quot;Hugo\u0026quot;, \u0026quot;博客\u0026quot;] categories 分类（数组） [\u0026quot;技术\u0026quot;, \u0026quot;教程\u0026quot;] summary 文章摘要 \u0026quot;这是摘要\u0026quot; description SEO 描述 \u0026quot;页面描述\u0026quot; slug URL 友好名称 \u0026quot;my-post\u0026quot; url 自定义完整 URL \u0026quot;/posts/my-post/\u0026quot; weight 排序权重 1 (数字越小越靠前) toc 是否显示目录 true / false 三、Hugo Shortcodes（短代码） 3.1 内置 Shortcodes # 显示图片 {{\u0026lt; figure src=\u0026#34;/images/photo.jpg\u0026#34; title=\u0026#34;图片标题\u0026#34; \u0026gt;}} # 高亮文本 {{\u0026lt; highlight python \u0026gt;}} def hello(): print(\u0026#34;Hello!\u0026#34;) {{\u0026lt; /highlight \u0026gt;}} # YouTube 视频 {{\u0026lt; youtube VIDEO_ID \u0026gt;}} # X (Twitter) 推文（新版） {{\u0026lt; x user=\u0026#34;USERNAME\u0026#34; id=\u0026#34;TWEET_ID\u0026#34; \u0026gt;}} # GitHub Gist（已废弃，建议直接嵌入代码） # 可以使用 highlight 或直接用代码块替代 # 参数传递（需要在 Front Matter 中定义参数） {{\u0026lt; param \u0026#34;description\u0026#34; \u0026gt;}} 3.2 自定义 Shortcode 示例 在 layouts/shortcodes/note.html 创建：\n\u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; 使用时：\n{{\u0026lt; note \u0026gt;}} 这是一个提示框 {{\u0026lt; /note \u0026gt;}} 四、Markdown 基本语法 4.1 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 4.2 文本样式 **粗体文字** *斜体文字* ***粗斜体*** ~~删除线~~ `行内代码` 4.3 列表 # 无序列表 - 项目 1 - 项目 2 - 子项目 2.1 - 子项目 2.2 # 有序列表 1. 第一项 2. 第二项 1. 子项 2.1 2. 子项 2.2 4.4 链接和图片 # 链接 [链接文字](https://example.com) [带标题的链接](https://example.com \u0026#34;鼠标悬停显示\u0026#34;) # 图片 ![图片描述](/images/photo.jpg) ![图片](https://example.com/image.jpg \u0026#34;图片标题\u0026#34;) 4.5 引用 \u0026gt; 这是一段引用文字 \u0026gt; 可以多行 \u0026gt;\u0026gt; 嵌套引用 4.6 代码块 ```python def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) ``` ```javascript console.log(\u0026#34;Hello, World!\u0026#34;); ``` 4.7 表格 | 列1 | 列2 | 列3 | |-----|-----|-----| | 数据1 | 数据2 | 数据3 | | 数据4 | 数据5 | 数据6 | # 对齐方式 | 左对齐 | 居中 | 右对齐 | |:-------|:----:|-------:| | 内容 | 内容 | 内容 | 4.8 分隔线 --- *** ___ 4.9 任务列表 - [x] 已完成的任务 - [ ] 未完成的任务 - [ ] 另一个任务 五、实用技巧 5.1 文章模板 在 archetypes/default.md 创建默认模板：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true tags: [] categories: [] summary: \u0026#34;\u0026#34; --- ## 简介 内容开始... 5.2 多语言配置 在 Front Matter 中：\n--- title: \u0026#34;English Title\u0026#34; title.zh: \u0026#34;中文标题\u0026#34; --- 5.3 自定义 URL 结构 在 hugo.toml 中：\n[permalinks] posts = \u0026#34;/:year/:month/:slug/\u0026#34; 5.4 草稿快速发布 # 将草稿改为发布状态 sed -i \u0026#39;s/draft: true/draft: false/\u0026#39; content/posts/my-post.md ","permalink":"http://localhost:1313/posts/hugo-readme/","summary":"详细介绍 Hugo 常用指令、Markdown Front Matter 配置、基本语法和实用技巧的完整指南","title":"Hugo 常用指令与 Markdown 配置指南"},{"content":"👋 嗨，我是 Minjie 很高兴你能来到这里！这是我在互联网上的一个小角落，用来记录代码、想法和生活的点滴。\n🧑‍💻 关于我 我是一名在读研究生，研究方向包括区块链，web3.0，数据库管理等。当然，目前更加专注于 Java 后端开发。相比起\u0026quot;全栈工程师\u0026quot;这样的标签，我更喜欢把自己定义为一个对计算机技术充满好奇心的探索者。\n📖 这个博客写什么 这里主要记录我在技术道路上的成长轨迹，你可能会看到：\n技术笔记 - Java 后端开发的实践经验、框架使用心得、踩过的坑和解决方案\n项目复盘 - 从需求分析到上线部署，记录项目中的思考和收获\n学习记录 - 新技术的探索、算法题的思路、计算机基础知识的整理\n随笔杂谈 - 偶尔也会写写读书笔记、游戏感想，或者对技术趋势的一些思考\n我希望这里不仅是我个人的知识库,也能给同样在技术路上摸索的你带来一些启发或共鸣。\n🎯 技术栈 \u0026amp; 兴趣方向 后端开发：Java、Spring Boot、MyBatis、MySQL、Redis - 这是我的主战场\n折腾爱好：除了后端，我还喜欢写点爬虫玩玩，做些自动化小工具来解决日常遇到的重复性工作。总觉得能用代码解决的事情，就不该浪费时间手动操作。有时候为了实现一个自动化脚本，花的时间可能比手动做还多，但那种\u0026quot;一劳永逸\u0026quot;的快感真的很上头。\n探索中：对各种能提高效率的技术和工具都充满兴趣，正在不断拓展技术边界\u0026hellip;\n🎮 代码之外 游戏时光：Steam 上收藏了不少游戏，也会玩玩王者、原神这些。\n音乐陪伴：写代码的时候总要听点什么。古典音乐能让思路更清晰，ACG 音乐带来满满的回忆，偶尔也会跟着流行音乐哼哼唱唱。喜欢洗澡的时候k歌······当然，也是个半吊子吉他选手\n运动爱好：除了敲键盘，也喜欢出去动一动。篮球、羽毛球、乒乓球都有涉猎，虽然都不算精通，但也能过上两招。过去打篮球多一点，现在更想尝试羽毛球。\n历史爱好者：对历史有种莫名的着迷，喜欢看历史书籍、纪录片。主要包括近现代欧洲历史，唐史，春秋战国。\n💬 来聊聊？ 如果你也对后端开发感兴趣，或者想交流技术、分享项目经验，甚至只是想推荐个好玩的游戏或好听的歌，都欢迎联系我：\n📧 邮箱：zhongnagisa01@gmail.com 🐙 GitHub：Minjie2003 \u0026ldquo;流水不争先，争的是滔滔不绝\u0026rdquo;\n感谢你的访问，希望我们能在这里有更多交流！✨\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于我"}]