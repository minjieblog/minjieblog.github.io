[{"content":"一、Hugo 常用指令 1.1 创建新站点 # 创建一个新的 Hugo 站点 hugo new site mysite # 进入站点目录 cd mysite 1.2 创建新文章 # 在 content/posts 目录下创建新文章 hugo new posts/my-first-post.md # 在 content 目录下创建文章 hugo new about.md # 创建在特定子目录 hugo new blog/2024/new-post.md 1.3 本地预览 # 启动本地开发服务器（默认 http://localhost:1313） hugo server # 启动并显示草稿文章 hugo server -D # 启动并显示草稿、未来日期和过期的文章 hugo server -DEF # 指定端口 hugo server --port 8080 # 实时重载并打开浏览器 hugo server -D --navigateToChanged 1.4 主题管理 # 添加主题（使用 Git submodule） git submodule add https://github.com/username/theme-name.git themes/theme-name # 更新主题 git submodule update --remote --merge # 删除主题 git submodule deinit -f themes/theme-name rm -rf .git/modules/themes/theme-name git rm -f themes/theme-name 1.5 其他常用指令 # 查看 Hugo 版本 hugo version # 查看帮助 hugo help # 查看配置信息 hugo config # 列出所有内容 hugo list all # 列出草稿 hugo list drafts 二、Markdown Front Matter 配置 2.1 完整配置示例 --- # 基本信息 title: \u0026#34;我的第一篇文章\u0026#34; date: 2025-12-06T15:04:05+08:00 lastmod: 2025-12-07T10:00:00+08:00 draft: false # 作者信息 author: \u0026#34;Minjie\u0026#34; authorLink: \u0026#34;https://github.com/Minjie2003\u0026#34; # 分类和标签 categories: [\u0026#34;技术\u0026#34;] tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Markdown\u0026#34;, \u0026#34;博客\u0026#34;] series: [\u0026#34;Hugo教程\u0026#34;] # 摘要和描述 summary: \u0026#34;这是一篇关于 Hugo 和 Markdown 的完整指南\u0026#34; description: \u0026#34;详细介绍 Hugo 的使用方法和 Markdown 配置\u0026#34; # 特色图片 image: \u0026#34;/images/featured.jpg\u0026#34; cover: image: \u0026#34;/images/cover.jpg\u0026#34; alt: \u0026#34;封面图片描述\u0026#34; caption: \u0026#34;图片说明文字\u0026#34; # SEO 相关 keywords: [\u0026#34;Hugo\u0026#34;, \u0026#34;静态博客\u0026#34;, \u0026#34;Markdown\u0026#34;] slug: \u0026#34;hugo-markdown-guide\u0026#34; url: \u0026#34;/posts/hugo-guide/\u0026#34; # 显示控制 toc: true # 显示目录 comments: true # 允许评论 showToc: true # 显示目录 TocOpen: false # 默认展开目录 hidemeta: false # 隐藏元信息 disableShare: false # 禁用分享按钮 hideSummary: false # 隐藏摘要 ShowReadingTime: true # 显示阅读时间 ShowBreadCrumbs: true # 显示面包屑导航 ShowPostNavLinks: true # 显示文章导航链接 # 权重（用于排序） weight: 1 # 外部链接 externalLink: \u0026#34;https://example.com\u0026#34; # 是否在首页显示 showhome: true --- 2.2 常用字段说明 字段 说明 示例 title 文章标题 \u0026quot;我的文章\u0026quot; date 发布日期 2025-12-06 或 2025-12-06T15:04:05+08:00 draft 是否为草稿 true / false tags 标签（数组） [\u0026quot;Hugo\u0026quot;, \u0026quot;博客\u0026quot;] categories 分类（数组） [\u0026quot;技术\u0026quot;, \u0026quot;教程\u0026quot;] summary 文章摘要 \u0026quot;这是摘要\u0026quot; description SEO 描述 \u0026quot;页面描述\u0026quot; slug URL 友好名称 \u0026quot;my-post\u0026quot; url 自定义完整 URL \u0026quot;/posts/my-post/\u0026quot; weight 排序权重 1 (数字越小越靠前) toc 是否显示目录 true / false 三、Hugo Shortcodes（短代码） 3.1 内置 Shortcodes # 显示图片 {{\u0026lt; figure src=\u0026#34;/images/photo.jpg\u0026#34; title=\u0026#34;图片标题\u0026#34; \u0026gt;}} # 高亮文本 {{\u0026lt; highlight python \u0026gt;}} def hello(): print(\u0026#34;Hello!\u0026#34;) {{\u0026lt; /highlight \u0026gt;}} # YouTube 视频 {{\u0026lt; youtube VIDEO_ID \u0026gt;}} # X (Twitter) 推文（新版） {{\u0026lt; x user=\u0026#34;USERNAME\u0026#34; id=\u0026#34;TWEET_ID\u0026#34; \u0026gt;}} # GitHub Gist（已废弃，建议直接嵌入代码） # 可以使用 highlight 或直接用代码块替代 # 参数传递（需要在 Front Matter 中定义参数） {{\u0026lt; param \u0026#34;description\u0026#34; \u0026gt;}} 3.2 自定义 Shortcode 示例 在 layouts/shortcodes/note.html 创建：\n\u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; 使用时：\n{{\u0026lt; note \u0026gt;}} 这是一个提示框 {{\u0026lt; /note \u0026gt;}} 四、Markdown 基本语法 4.1 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 4.2 文本样式 **粗体文字** *斜体文字* ***粗斜体*** ~~删除线~~ `行内代码` 4.3 列表 # 无序列表 - 项目 1 - 项目 2 - 子项目 2.1 - 子项目 2.2 # 有序列表 1. 第一项 2. 第二项 1. 子项 2.1 2. 子项 2.2 4.4 链接和图片 # 链接 [链接文字](https://example.com) [带标题的链接](https://example.com \u0026#34;鼠标悬停显示\u0026#34;) # 图片 ![图片描述](/images/photo.jpg) ![图片](https://example.com/image.jpg \u0026#34;图片标题\u0026#34;) 4.5 引用 \u0026gt; 这是一段引用文字 \u0026gt; 可以多行 \u0026gt;\u0026gt; 嵌套引用 4.6 代码块 ```python def hello(): print(\u0026#34;Hello, Hugo!\u0026#34;) ``` ```javascript console.log(\u0026#34;Hello, World!\u0026#34;); ``` 4.7 表格 | 列1 | 列2 | 列3 | |-----|-----|-----| | 数据1 | 数据2 | 数据3 | | 数据4 | 数据5 | 数据6 | # 对齐方式 | 左对齐 | 居中 | 右对齐 | |:-------|:----:|-------:| | 内容 | 内容 | 内容 | 4.8 分隔线 --- *** ___ 4.9 任务列表 - [x] 已完成的任务 - [ ] 未完成的任务 - [ ] 另一个任务 五、实用技巧 5.1 文章模板 在 archetypes/default.md 创建默认模板：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true tags: [] categories: [] summary: \u0026#34;\u0026#34; --- ## 简介 内容开始... 5.2 多语言配置 在 Front Matter 中：\n--- title: \u0026#34;English Title\u0026#34; title.zh: \u0026#34;中文标题\u0026#34; --- 5.3 自定义 URL 结构 在 hugo.toml 中：\n[permalinks] posts = \u0026#34;/:year/:month/:slug/\u0026#34; 5.4 草稿快速发布 # 将草稿改为发布状态 sed -i \u0026#39;s/draft: true/draft: false/\u0026#39; content/posts/my-post.md ","permalink":"http://localhost:1313/posts/hugo-readme/","summary":"详细介绍 Hugo 常用指令、Markdown Front Matter 配置、基本语法和实用技巧的完整指南","title":"Hugo 常用指令与 Markdown 配置指南"},{"content":"论文基本信息 标题: Linking Souls to Humans: Blockchain Accounts with Credible Anonymity for Web 3.0 Decentralized Identity 作者: Taotao Wang, Zibin Lin, Shengli Zhang, Long Shi, Qing Yang, Boris Düdder 会议: WWW \u0026lsquo;25 (ACM Web Conference 2025) 时间: 2025年4月28日-5月2日，悉尼 机构: 深圳大学、南京理工大学、哥本哈根大学 研究背景 数字身份的三个发展阶段 数字身份系统经历了三个演进阶段，分别对应互联网的三个时代：\n阶段 身份类型 对应时代 特点 问题 1 中心化身份 Web 1.0 用户创建，应用提供商管理 多账户管理复杂，数据泄露风险 2 联盟身份 Web 2.0 少数大型提供商管理，可跨应用使用 数据霸权，用户数据集中在少数巨头手中 3 去中心化身份 Web 3.0 用户自主创建和管理（自主权身份） 完全匿名导致无法追溯真实社交关系 Web 3.0的核心价值 Web 3.0的革命性转变在于：\n用户拥有数据主权 数据不被应用提供商占有 需要去中心化身份系统支撑 当前区块链账户系统的问题 区块链账户系统是Web 3.0去中心化身份的理想原型，但存在以下问题：\n完全匿名的缺陷： 用户可以无需认证创建多个账户 无法准确记录真实用户之间的社交关系和互动 用户与区块链身份之间的映射关系模糊 Soulbound Token的局限性： Vitalik Buterin提出的\u0026quot;灵魂\u0026quot;（Soul）概念和\u0026quot;灵魂绑定代币\u0026quot;（Soulbound Token） 用户仍可创建多个\u0026quot;灵魂\u0026quot;账户来抹除、转移或隐藏关系 无法真实反映人类社会中的真实关系 研究方案：zkBID 核心目标 zkBID（Zero-Knowledge Blockchain-account-based Web 3.0 decentralized IDentity）旨在实现：\n一对一映射：将灵魂（区块链账户）与人类（用户）建立一对一关联 去中心化：无需第三方中心化机构参与 隐私保护：隐藏身份与账户之间的绑定关系（即匿名） 可信性：每个账户在区块链上的信用与对应的真实用户一对一映射 关键技术 zkBID采用三大核心技术：\n零知识证明（zkSNARK） 可链接环签名（Linkable Ring Signature） 区块链智能合约（Smart Contracts） 技术预备知识 1. 可验证凭证（Verifiable Credentials, VC） 由W3C提出的去中心化标识符（DID）体系中的关键组件。\n三个主要角色：\n颁发者（Issuer）：签发凭证 持有者（Holder）：拥有凭证 验证者（Verifier）：验证凭证 VC的数据结构（JSON对象）：\n{ \u0026#34;metadata\u0026#34;: \u0026#34;包含颁发者DID、颁发日期、声明类型\u0026#34;, \u0026#34;claims\u0026#34;: \u0026#34;关于持有者的断言，包括持有者DID\u0026#34;, \u0026#34;proofs\u0026#34;: \u0026#34;颁发者的数字签名\u0026#34; } 2. 人格凭证（Personhood Credentials, PHC） 定义：证明用户是真人而非AI的数字凭证\n运作流程：\n注册流程 用户向PHC颁发者证明自己是真人 → 颁发者签发PHC\n使用流程 第三方服务可要求用户出示PHC作为授权过程的一部分\n验证方法（颁发者确保用户是真人的三种主要方式）：\n现有身份文件 基于政府签发的身份证件 利用现有可信来源 生物识别信息 测量持久且唯一的人体特征（掌纹、虹膜、指纹） 确保是真人且限制每人只注册一次 信任网络（Web of Trust） 通过社交图谱分析区分真人和机器 检测用户是否曾获得过凭证 在zkBID中的应用：\nPHC以VC形式作为每个人类用户的身份凭证 3. zkSNARK算法 全称：Zero-knowledge Succinct Non-interactive Argument of Knowledge\n优势：\n简洁性（Succinct）：证明大小仅几个字节，验证时间短 非交互性（Non-interactive）：证明者和验证者无需同步通信 工作原理：\n使用算术电路表示，包含基本运算：加、减、乘、除\nF-算术电路：\n输入：$x \\in \\mathbb{F}^n$ 辅助输入（见证）：$w \\in \\mathbb{F}^h$ 输出：$C(x, w) \\in \\mathbb{F}^l$ 三个算法组件：\n密钥生成（KEYGEN）\n(PK, VK) ← KEYGEN(1^λ, C) 输入：安全参数λ和电路C 输出：证明密钥PK和验证密钥VK 证明生成（PROVE）\nπ ← PROVE(PK, x, W) 输入：PK、公开输入x、私密见证W 输出：证明π 证明验证（VERIFY）\n1/0 ← VERIFY(VK, x, π) 输入：VK、公开输入x、证明π 输出：接受（1）或拒绝（0） zkBID采用的算法：Groth16\n原因：验证速度快，证明紧凑 适用于大规模应用和大型区块链网络 4. 可链接环签名（Linkable Ring Signature） 基本环签名：\n验证者可以确认签名由预定义集合中的某个成员创建 但无法确定具体是哪个成员 可链接环签名的额外特性：\n允许验证者确定两个签名是否由同一签名者生成 四个算法组件：\n密钥生成（GEN）\n(pk, sk) ← GEN(1^k) 签名生成（SIG）\nσ ← SIG(1^k, 1^n, m, L, sk) 输入：安全参数k、环大小n、消息m、公钥环L、私钥sk 输出：签名σ 签名验证（VER）\n1/0 ← VER(1^k, 1^n, m, L, σ) 可链接性检查（LINK）\n1/0 ← LINK(1^k, 1^n, m1, m2, σ1, σ2, L1, L2) 判断两个签名是否由同一签名者生成 关键属性：\n签名者模糊性（Signer Ambiguity）： 攻击者正确猜测真实签名者的概率不超过 1/(n-t) 其中n是环大小，t是攻击者拥有的私钥数量 可链接性（Linkability）： 同一签名者（相同私钥）签名的两条消息可被验证为关联 zkBID采用的算法：MLSAGS（Multilayered Linkable Spontaneous Anonymous Group Signature）\n原因：实现可链接性的技术复杂度较低，适合在智能合约上实现 密钥图像（Key Image）机制：\ny₀ ← sk * Hₚ(pk) y₀对于给定的(sk, pk)对是唯一的 所有由同一签名者产生的签名都带有相同的密钥图像 即使环中的公钥改变，签名仍可链接 zkBID系统设计 整体架构 映射关系图 真实用户 → PHC（人格凭证）→ PHC哈希 → 种子公钥 → 灵魂账户 关系说明：\n实线：可见的一对一关系 虚线：不可见但可验证的关系 箭头：单向计算关系 核心设计理念 隐私保护： PHC的具体内容不上链，只存储零知识证明 灵魂账户与种子公钥的关联不可见 可信匿名： 账户是匿名的（无法追踪到真实身份） 账户是可信的（确实与真实用户一对一绑定） 完全去中心化： 所有数据由用户生成 通过区块链上的智能合约验证 IVAC流程（Identity Verification and Account Certification） zkBID通过三个子流程生成具有可信匿名性的灵魂账户：\n[用户] → [注册信息生成] → [用户身份验证] → [灵魂账户认证] → [灵魂账户] ↓ ↓ ↓ 零知识证明 智能合约验证 可链接环签名 详细设计 阶段1：注册信息生成 目标：生成隐私保护的注册信息，不泄露PHC的具体内容\nPHC格式设计 zkBID中的PHC采用VC格式，包含三个关键字段：\n{ \u0026#34;credentialSubject\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_holder\u0026#34; // 持有者公钥 }, \u0026#34;proof\u0026#34;: { \u0026#34;publicKeyMultibase\u0026#34;: \u0026#34;pk_issuer\u0026#34;, // 颁发者公钥 \u0026#34;signature\u0026#34;: \u0026#34;sig_issuer\u0026#34; // 颁发者签名 } } 零知识证明生成流程 Protocol 1: PHC的ZK证明生成\n输入： - hash_PHC：PHC的哈希值 - sig_holder：持有者的签名 - pk_issuer：颁发者的公钥 - PHC：完整的PHC数据 设置： (PK, VK) ← zkSNARK.KEYGEN(1^λ, C) 生成证明： 1. 公开输入 x ← (hash_PHC, sig_holder, pk_issuer) 2. 私密见证 W ← PHC 3. π ← zkSNARK.PROVE(PK, x, W) 输出：π（零知识证明） 算术电路验证逻辑 graph TD A[私密输入: PHC] --\u0026gt; B[计算PHC的哈希] C[公开输入: hash_PHC] --\u0026gt; B B --\u0026gt; D{哈希值是否相等?} A --\u0026gt; E[提取pk_holder] F[公开输入: sig_holder] --\u0026gt; G[验证sig_holder] E --\u0026gt; G G --\u0026gt; H{签名是否有效?} A --\u0026gt; I[提取sig_issuer] J[公开输入: pk_issuer] --\u0026gt; K[验证sig_issuer] I --\u0026gt; K K --\u0026gt; L{签名是否有效?} D --\u0026gt; M[AND] H --\u0026gt; M L --\u0026gt; M M --\u0026gt; N{输出TRUE/FALSE} 验证步骤：\n验证哈希正确性： 计算PHC的哈希 检查是否等于公开输入中的hash_PHC 确保hash_PHC确实从PHC计算得出 验证所有权： 从PHC中提取持有者公钥pk_holder 用pk_holder验证sig_holder 证明用户拥有PHC 验证PHC有效性： 从PHC中提取颁发者签名sig_issuer 用pk_issuer验证sig_issuer 证明PHC由可信颁发者签发 输出：\n如果所有检查通过：输出TRUE和证明π π证明的声明：\u0026ldquo;PHC哈希正确，持有者拥有PHC，PHC由颁发者签发\u0026rdquo; 关键：不泄露PHC的具体内容 阶段2：用户身份验证 目标：\n验证用户的真人身份（通过验证ZK证明） 防止重复注册（检查PHC哈希未被使用） 智能合约流程 Protocol 2: 用户身份验证智能合约\n输入： - π：零知识证明 - hash_PHC：PHC哈希 - sig_holder：持有者签名 - pk_seed：种子公钥 执行步骤： 1. pk_issuer ← GetIssuerPK() // 获取预定义的颁发者公钥 2. validation ← zkSNARK.VERIFY(VK, hash_PHC, pk_issuer, π) 3. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 4. stored ← Traverse(hash_PHC) // 检查是否已注册 5. if stored ≠ 0: return \u0026#34;已经注册\u0026#34; 6. Store(hash_PHC, pk_seed) // 存储为键值对 7. return \u0026#34;认证成功\u0026#34; 用户操作步骤 生成种子密钥对：\n(pk_seed, sk_seed) ← MLSAGS.GEN(1^k) 构造交易：\n数据字段包含：π, hash_PHC, sig_holder, pk_issuer, pk_seed 发送到身份验证合约地址 合约验证：\n验证颁发者公钥匹配 验证零知识证明 检查PHC哈希未被使用 链上记录：\n存储键值对：(hash_PHC, pk_seed) hash_PHC用于防止重复注册 pk_seed作为用户在下一阶段创建灵魂账户的凭证 安全保证：\nPHC的具体内容不上链 仍能验证PHC的所有权和有效性 防止同一PHC多次注册 阶段3：灵魂账户认证 目标：认证灵魂账户与合法种子公钥的一对一关联\n整体流程 生成灵魂账户（普通以太坊账户） 建立关联（使用可链接环签名） 链上验证（智能合约验证签名） 可链接环签名的生成和验证 graph LR A[用户端] --\u0026gt; B[签名生成] B --\u0026gt; C[智能合约] C --\u0026gt; D[签名验证] E[输入] --\u0026gt; B E --\u0026gt; |选择的L-1个种子公钥| B E --\u0026gt; |用户的种子公钥pk_seed| B E --\u0026gt; |用户的种子私钥sk_seed| B E --\u0026gt; |灵魂账户地址addr_soul| B E --\u0026gt; |密钥图像y₀| B B --\u0026gt; |签名σ| C F[公钥环L] --\u0026gt; C G[addr_soul] --\u0026gt; C D --\u0026gt; H{验证结果} H --\u0026gt; |True| I[认证成功] H --\u0026gt; |False| J[认证失败] 详细步骤 步骤1：生成灵魂账户\n(addr_soul, pk_soul, sk_soul) = 生成以太坊账户 步骤2：构造公钥环\n从已注册的种子公钥中选择L-1个 加上用户自己的pk_seed 形成大小为L的公钥环 步骤3：计算密钥图像\ny₀ ← sk_seed * Hₚ(pk_seed) y₀对于给定的(sk_seed, pk_seed)是唯一的 用于防止重复注册 步骤4：生成可链接环签名\nσ ← MLSAGS.SIG(1^k, 1^n, addr_soul, L, sk_seed) 消息m = addr_soul（要签名的是灵魂账户地址） 签名格式：σ = (y₀, \u0026hellip;) y₀作为签名的一部分 步骤5：智能合约验证\nProtocol 3: 灵魂账户认证智能合约\n输入： - σ：可链接环签名 - L：公钥环 - addr_soul：灵魂账户地址 执行步骤： 1. validation ← LRS.VER(1^k, 1^n, addr_soul, L, σ) 2. if validation ≠ 1: return \u0026#34;验证失败\u0026#34; 3. stored ← Traverse(σ.y₀) // 检查密钥图像是否已使用 4. if stored ≠ 0: return \u0026#34;已经认证\u0026#34; 5. Store(σ.y₀, addr_soul) // 存储密钥图像和灵魂账户 6. return \u0026#34;认证成功\u0026#34; 隐私保护机制 关键特性：\n签名者模糊性： 签名可以被验证为有效 但无法确定环L中哪个公钥是真正的签名者 攻击者猜对的概率：1/(n-t)，其中n是环大小，t是攻击者拥有的私钥数 一对一保证： 密钥图像y₀唯一对应一个种子密钥对 同一种子密钥对只能生成一个有效签名 确保一个PHC只能关联一个灵魂账户 可验证的匿名性： 任何人都可以验证灵魂账户与某个合法种子公钥关联 但无法确定具体是哪个种子公钥 实现\u0026quot;可信匿名\u0026quot; 链上数据 存储内容：\n(σ.y₀, addr_soul) 键值对 可见信息：\n所有种子公钥（从阶段2） 所有灵魂账户地址 所有密钥图像 不可见关联：\n哪个种子公钥对应哪个灵魂账户 哪个PHC哈希对应哪个灵魂账户 哪个真实用户对应哪个灵魂账户 安全性分析 安全前提条件 计算对手受限：攻击者为多项式时间的计算对手 验证者诚实：智能合约不会接受虚假验证请求 PHC唯一性：每个用户只能从颁发者获得一个PHC 安全目标 zkBID需要满足三个核心安全属性：\n安全属性 定义 目标 身份唯一性 防止重复注册 一个用户不能注册多个灵魂账户 不可伪造性 防止身份伪造 攻击者不能冒充诚实用户认证灵魂账户 匿名性 保护身份隐私 攻击者无法检测用户身份(PHC)与灵魂账户的关联 威胁模型与防御 1. 女巫攻击（Sybil Attack） 攻击场景： 攻击者已拥有一个灵魂账户，试图获取新的灵魂账户\n攻击方法：\n方法A：使用相同PHC关联新的种子公钥 → 用新种子公钥认证新灵魂账户\n方法B：直接使用已用过的种子公钥认证新灵魂账户\n防御分析：\n方法A的防御：\n在用户身份验证合约中： 1. 合约检查hash_PHC是否已存储 2. 由于哈希函数的抗碰撞性，每个PHC只能生成一个唯一哈希 3. zkSNARK的可靠性保证：攻击者通过伪造哈希成功的概率可忽略不计 4. 因此无法用同一PHC注册两个种子账户 方法B的防御：\n在灵魂账户认证合约中： 1. 合约检查密钥图像y₀是否已使用 2. 由于可链接环签名的可链接性，同一种子私钥无法构造两个不同y₀的有效签名 3. 因此无法用同一种子密钥对认证两个灵魂账户 结论：无法使用相同PHC或种子公钥注册两个灵魂账户\n2. 链接攻击（Linkage Attack） 攻击场景： 攻击者试图通过破解环签名的真实签名者，建立用户身份（PHC哈希）与灵魂账户的链接\n攻击方法： 分析链上存储的环签名，推断哪个种子公钥是真正的签名者\n防御分析：\n基于可链接环签名的签名者模糊性： - 假设环大小为n - 攻击者拥有t个私钥 - 攻击者正确识别真实签名者的概率 = 1/(n-t) 示例： - 环大小 n = 100 - 攻击者拥有 t = 10 个私钥 - 成功概率 = 1/90 ≈ 1.1% 结论：攻击者无法有效建立身份与账户的链接 环大小的影响：\n环越大 → 匿名性越强 但签名生成和验证成本增加 需要在匿名性和效率之间权衡 3. 伪造攻击（Forgery Attack） 攻击场景： 攻击者试图冒充诚实用户获取灵魂账户\n攻击方法：\n方法A：伪造holder签名生成有效zkSNARK证明\n攻击者获得诚实用户的PHC ↓ 伪造sig_holder ↓ 生成通过验证的zkSNARK证明 ↓ 注册种子公钥 ↓ 认证灵魂账户 方法B：伪造种子账户的环签名\n已注册的种子公钥公开可见 ↓ 伪造某个诚实用户的环签名sig_seed ↓ 认证新的灵魂账户 防御分析：\n方法A的防御：\n依赖两个密码学保证： 1. EdDSA算法的不可伪造性 → 攻击者无法伪造任何诚实用户的sig_holder 2. zkSNARK的可靠性 → 没有有效签名，无法创建有效的zkSNARK证明 结论：攻击者无法通过伪造签名获得种子公钥 方法B的防御：\n依赖可链接环签名的不可伪造性： - 攻击者无法伪造任何已注册种子账户的有效签名 - 即使种子公钥公开可见 结论：攻击者无法冒充诚实用户认证灵魂账户 总结：zkBID协议能够抵御伪造攻击\n安全性总结表 攻击类型 攻击目标 依赖的安全属性 防御结果 女巫攻击-方法A 重复注册PHC 哈希抗碰撞性 + zkSNARK可靠性 ✅ 安全 女巫攻击-方法B 重复使用种子密钥 可链接环签名的可链接性 ✅ 安全 链接攻击 破坏匿名性 可链接环签名的签名者模糊性 ✅ 安全 伪造攻击-方法A 伪造身份验证 EdDSA不可伪造性 + zkSNARK可靠性 ✅ 安全 伪造攻击-方法B 伪造账户认证 可链接环签名不可伪造性 ✅ 安全 实验评估 实验环境 测试网络配置 区块链测试网络：\n平台：阿里云 节点数：6个以太坊全节点 共识协议：工作量证明（PoW） 客户端：Go-Ethereum 网络拓扑：全连接（每个节点有独立IP） 用户节点：\n1个用户节点连接到1个以太坊节点 运行用户端功能 硬件配置（所有节点）：\n操作系统：Ubuntu 20.04 CPU：Intel(R) Core(TM) i7-10700 @ 2.90GHz 内存：48GB RAM 实现技术栈 智能合约：\n语言：Solidity 部署：以太坊测试网络 zkSNARK：\n算法：Groth16 平台：Circom 2 功能：Setup和证明生成 可链接环签名：\n算法：MLSAGS 用户端实现：Python（密钥生成、签名算法） 合约实现：Solidity（签名验证） 性能评估指标 指标 说明 重要性 ZK证明生成时间 Groth16证明算法的执行时间 影响用户体验 ZK证明大小 证明所占字节数 影响链上存储 ZK证明验证成本 智能合约验证所需Gas 影响使用成本 算术电路大小 R1CS约束数量 影响系统复杂度 MLSAGS签名生成时间 环签名生成的执行时间 影响用户体验 MLSAGS签名验证成本 智能合约验证所需Gas 影响使用成本 实验结果 1. Groth16性能测试 测试方案：\n使用单个算术电路验证多个PHC批次 测试不同批次大小下的性能表现 图表 6(a)：电路大小和证明大小 PHC批次大小 R1CS约束数量 ZK证明大小 1 ~19,000 192 Bytes 2 ~38,000 192 Bytes 4 ~76,000 192 Bytes 8 ~152,000 192 Bytes 16 ~304,000 192 Bytes 32 ~608,000 192 Bytes 64 ~1,216,000 192 Bytes 128 ~2,432,000 192 Bytes 关键发现：\n✨ 证明大小恒定：无论批次大小如何，证明始终为192字节 这是Groth16的核心优势：简洁性（Succinctness） 电路大小随批次线性增长 图表 6(b)：证明生成时间和验证成本 证明生成时间：\nPHC批次大小 生成时间 (ms) 增长趋势 1 ~2,000 基准 2 ~4,000 2x 4 ~8,000 4x 8 ~16,000 8x 16 ~32,000 16x 32 ~64,000 32x 证明验证成本（Gas）：\nPHC批次大小 验证Gas消耗 单个PHC平均Gas 1 215.7K 215.7K 2 247.2K 123.6K 4 310.2K 77.6K 8 436.2K 54.5K 16 688.2K 43.0K 32 1,040.0K 32.5K 关键发现：\n📈 线性增长：生成时间和验证成本都与批次大小呈线性关系\n💰\n批处理优势\n：批次大小为32时，单个PHC的Gas消耗仅为32.5K\n相比单独验证（215.7K），节省约85% 效率提升约7倍 ⚠️ 部署限制：批次大小≥64时，验证合约因以太坊合约大小限制无法部署\n最佳实践建议：\n推荐批次大小：16-32个PHC - 在合约大小限制内 - 获得显著的Gas优化 - 用户体验可接受 2. MLSAGS性能测试 测试方案：\n测试不同环大小L下的签名生成和验证性能 环大小影响匿名性和性能的权衡 图表 6(c)：MLSAGS性能指标 签名生成时间：\n环大小 L 生成时间 (ms) 增量时间 1 ~40 - 2 ~80 +40ms 4 ~160 +40ms 8 ~320 +40ms 16 ~640 +40ms 32 ~1,280 +40ms 64 ~2,560 +40ms 128 ~5,120 +40ms 签名验证成本（Gas）：\n环大小 L 验证Gas消耗 增量Gas 1 ~57K - 2 ~114K +57K 4 ~228K +57K 8 ~456K +57K 16 ~912K +57K 32 ~1,824K +57K 64 ~3,648K +57K 128 ~7,296K +57K 关键发现：\n📏\n完美线性关系\n：\n每增加1个公钥，生成时间增加约40ms 每增加1个公钥，验证Gas增加约57K ⚖️\n匿名性vs效率权衡\n：\n环越大 → 匿名性越强（攻击者猜中概率 = 1/L） 环越大 → 成本越高（时间和Gas） 匿名性分析：\n环大小 L 攻击者成功率 匿名性等级 Gas成本 10 10% 较弱 570K 50 2% 中等 2,850K 100 1% 强 5,700K 1000 0.1% 非常强 57,000K 实际应用建议：\n小规模应用（\u0026lt; 1000用户）： 环大小：10-20 匿名性：10%-5%攻击成功率 Gas成本：570K-1,140K（可接受） 中等规模应用（1000-10000用户）： 环大小：50-100 匿名性：2%-1%攻击成功率 Gas成本：2,850K-5,700K（需要优化） 大规模应用（\u0026gt; 10000用户）： 环大小：100+ 匿名性：\u0026lt; 1%攻击成功率 Gas成本：\u0026gt; 5,700K（需要Layer 2或批处理） 性能优化建议 1. 对于zkSNARK部分 批处理策略：\n低频场景（个人注册）： - 批次大小：1-4 - 适用：个人用户单次注册 - 优点：即时处理 - 缺点：Gas成本较高（215K-310K） 高频场景（批量注册）： - 批次大小：16-32 - 适用：组织批量入职、大规模注册活动 - 优点：Gas效率提升7倍 - 缺点：需要等待批次凑齐 2. 对于MLSAGS部分 环大小配置：\n# 根据用户总数动态调整 def calculate_ring_size(total_users, target_anonymity=0.01): \u0026#34;\u0026#34;\u0026#34; total_users: 系统总用户数 target_anonymity: 目标攻击成功率（如0.01 = 1%） \u0026#34;\u0026#34;\u0026#34; # 环大小不超过总用户数 ring_size = min(int(1 / target_anonymity), total_users) # 考虑Gas成本限制（假设单笔交易Gas上限为8M） max_affordable_ring = 8_000_000 / 57_000 # ≈ 140 return min(ring_size, max_affordable_ring) # 示例 calculate_ring_size(1000, 0.01) # 返回 100 calculate_ring_size(10000, 0.01) # 返回 100（受成本限制） calculate_ring_size(50, 0.01) # 返回 50（受用户数限制） 分层匿名策略：\nVIP用户/高价值账户： - 使用较大环（100+） - 提供更强匿名性 - 愿意支付更高Gas 普通用户： - 使用中等环（20-50） - 平衡匿名性和成本 - 实际应用最常见 测试/低价值账户： - 使用小环（10-20） - 基本匿名性 - 成本最低 实验结论 zkSNARK的优势： ✅ 证明大小恒定（192字节）：不受批次影响 ✅ 批处理优化显著：32个PHC可节省85% Gas ✅ 验证快速：链上验证成本可接受 MLSAGS的特性： ✅ 性能可预测：完美线性关系 ⚠️ 需要权衡：匿名性与成本呈正比 ✅ 灵活配置：可根据场景调整环大小 系统可行性： ✅ 在实际以太坊网络上完全可行 ✅ 通过参数优化可适应不同规模 ✅ 性能瓶颈明确且可优化 相关工作对比 现有方案分析 论文对比了8个相关的区块链身份方案：\n方案 年份 主要技术 应用场景 TradeMap [12] 2019 ZKP 符合FINMA的匿名KYC平台 Pauwels et al. [14] 2022 zkSNARK DeFi协议的KYC系统 Aydar et al. [3] 2019 Blockchain 数字身份验证框架 Singh et al. [18] 2020 Credential Protocol 保护个人属性的身份系统 Abraham et al. [1] 2020 SSI Model 支持凭证撤销的自主身份 ZEBRA [15] 2022 zkSNARK 链上匿名凭证验证 Zhang et al. [26] 2024 ZKP 能源交易身份认证 Kim et al. [10] 2023 SBT + DID 元宇宙的KYC系统 设计目标对比 方案 DG1 技术灵活性 DG2 身份匿名性 DG3 身份可信性 DG4 隐私存储 TradeMap [12] ✅ ❌ ❌ ❌ Pauwels [14] ✅ ❌ ✅ ✅ Aydar [3] ❌ ✅ ❌ ❌ Singh [18] ❌ ✅ ✅ ✅ Abraham [1] ✅ ✅ ❌ ❌ ZEBRA [15] ❌ ✅ ❌ ❌ Zhang [26] ✅ ❌ ✅ ❌ Kim [10] ❌ ✅ ❌ ❌ zkBID ✅ ✅ ✅ ✅ 设计目标说明：\nDG1 - 技术灵活性：不局限于特定的ZKP算法或区块链平台 DG2 - 身份匿名性：无法从链上活动推断用户真实身份 DG3 - 身份可信性：每个身份可信地连接到真实世界用户 DG4 - 隐私存储：身份文档保密存储，不公开可见 zkBID的独特优势 1. 唯一全面满足所有设计目标 其他方案的局限： ├─ TradeMap: 只关注合规性，缺乏匿名性和可信映射 ├─ Pauwels: DeFi场景，但身份匿名性不足 ├─ Aydar/Singh: 技术灵活性差，绑定特定实现 ├─ Abraham/ZEBRA: 缺乏与真实用户的可信绑定 ├─ Zhang: 特定场景（能源交易），匿名性不足 └─ Kim: 元宇宙场景，技术灵活性和可信性不足 zkBID的创新： ✅ 同时实现匿名性和可信性（看似矛盾的目标） ✅ 完全去中心化（无需可信第三方） ✅ 技术灵活（可替换ZKP算法和环签名方案） ✅ 隐私保护（身份信息不上链） 2. 技术组合的创新性 现有方案的技术使用：\n大多只使用zkSNARK进行凭证验证 少数使用环签名，但未实现身份-账户绑定 没有方案同时使用zkSNARK + 可链接环签名 zkBID的技术创新：\nzkSNARK（阶段1-2）： 目的：验证PHC有效性 优势：不泄露PHC内容 创新：批处理优化 可链接环签名（阶段3）： 目的：建立身份-账户映射 优势：保持匿名性的同时确保一对一 创新：使用密钥图像防止重复绑定 组合效果： = 可验证的身份 + 不可追踪的账户绑定 = 可信匿名（Credible Anonymity） 3. 实际应用价值 传统KYC系统的问题：\n中心化KYC： ❌ 隐私泄露风险 ❌ 数据被服务商控制 ❌ 跨平台不互通 区块链匿名账户： ❌ 无法防止女巫攻击 ❌ 信誉系统难以建立 ❌ 监管合规困难 zkBID的解决方案：\n对用户： ✅ 保护隐私（身份信息不泄露） ✅ 自主控制（无需信任中心化机构） ✅ 一次认证，多处使用 对平台： ✅ 防止女巫攻击（一人一账户） ✅ 建立信誉系统（账户可信） ✅ 满足监管要求（有认证机制） 对监管： ✅ 可验证的身份（PHC由可信机构签发） ✅ 可追责性（必要时可追踪） ✅ 隐私保护合规 应用场景 1. 去中心化社交网络 问题：\nTwitter/X上的机器人和假账户泛滥 难以区分真人和AI生成的内容 水军和虚假舆论操纵 zkBID解决方案：\n用户注册： 1. 用政府ID获取PHC 2. 通过zkBID认证获得灵魂账户 3. 使用灵魂账户在社交网络发布内容 效果： ✅ 每个账户对应一个真人 ✅ 保持用户匿名性 ✅ 机器人和假账户显著减少 ✅ 信誉系统可以建立在灵魂账户上 2. DAO治理 问题：\n一人多账户操纵投票 女巫攻击破坏治理公平性 难以验证投票者资格 zkBID解决方案：\n治理流程： 1. DAO成员通过zkBID认证 2. 每个灵魂账户 = 一个真实成员 3. 投票时保持匿名 4. 防止多重投票 效果： ✅ 一人一票（真正的民主） ✅ 投票匿名（防止胁迫和贿赂） ✅ 可验证（确保只有成员投票） ✅ 信誉加权（可基于历史贡献） 3. DeFi空投和激励 问题：\n空投被羊毛党多账户瓜分 难以识别真实用户 激励机制被滥用 zkBID解决方案：\n空投流程： 1. 要求使用zkBID认证的灵魂账户 2. 每个灵魂账户只能领取一次 3. 基于链上行为的信誉评分 效果： ✅ 公平分配（每人一份） ✅ 防止女巫攻击 ✅ 识别真实活跃用户 ✅ 建立长期激励机制 4. Web3游戏和元宇宙 问题：\n工作室多开刷金币 游戏经济被破坏 难以建立公平竞技环境 zkBID解决方案：\n游戏应用： 1. 玩家使用灵魂账户登录 2. 游戏内资产绑定到灵魂账户 3. 排行榜和竞技只认可灵魂账户 效果： ✅ 一人一号（公平竞争） ✅ 资产真实归属 ✅ 游戏经济稳定 ✅ 社交关系可信 5. 去中心化信用系统 问题：\n传统信用系统中心化 跨平台信用不互通 隐私泄露风险 zkBID解决方案：\n信用体系： 1. 灵魂账户作为信用载体 2. 链上行为建立信用历史 3. 跨DApp信用互认 4. 保护用户隐私 效果： ✅ 去中心化信用（不被单一机构控制） ✅ 可移植性（跨平台使用） ✅ 隐私保护（匿名但可信） ✅ 防止信用欺诈（一人一信用档案） 局限性与未来工作 当前局限性 1. 性能限制 Gas成本：\n当前状态： - 单次PHC验证：215.7K Gas - 环大小100的签名验证：5,700K Gas - 在以太坊主网上成本较高 影响： ❌ 大规模应用成本高 ❌ 限制了环大小（影响匿名性） 可能的解决方案：\nLayer 2方案（如Optimism、Arbitrum） 侧链部署 批处理优化 2. PHC依赖 当前状态：\n依赖可信的PHC颁发机构： - 政府机构 - 大型科技公司 - 其他可信第三方 问题： ❌ PHC系统尚未广泛部署 ❌ 不同颁发者的互操作性 ❌ 颁发者可能成为中心化风险点 3. 隐私权衡 匿名性级别：\n环大小的限制： - 小环（\u0026lt;20）：匿名性较弱 - 大环（100+）：成本高昂 - 实际应用中需要权衡 4. 撤销机制 当前缺失：\n无法撤销已认证的灵魂账户： ❌ 如果PHC被吊销怎么办？ ❌ 如果用户想注销怎么办？ ❌ 如果发现欺诈怎么办？ 需要设计： - 灵活的撤销机制 - 保持匿名性的撤销 - 防止滥用撤销权 未来研究方向 1. 性能优化 方向A：递归证明：\n使用递归zkSNARK： - 将多个证明聚合成一个 - 减少链上验证成本 - 提高批处理效率 预期效果： - Gas成本降低50%+ - 支持更大批次 方向B：量子抗性：\n替换为抗量子密码算法： - 格基密码学 - 哈希基签名 - 为后量子时代做准备 2. PHC生态系统 多颁发者互操作：\n标准化PHC格式： - 统一的VC模板 - 跨颁发者互认 - 去中心化颁发者网络 目标： - 减少单点故障 - 提高可用性 - 增强去中心化 去中心化PHC颁发：\n探索无需中心化颁发者的方案： - 基于生物识别的去中心化验证 - 社交图谱验证 - 组合多种验证方式 3. 隐私增强 方向A：动态环：\n允许用户动态选择环大小： - 根据交易重要性调整 - 重要交易用大环 - 普通交易用小环 效果： - 灵活性提高 - 成本优化 方向B：分层匿名：\n不同隐私级别的灵魂账户： - 公开级：最小匿名性，低成本 - 标准级：中等匿名性，中等成本 - 隐私级：高匿名性，高成本 4. 跨链支持 多链部署：\n扩展到其他区块链： - Polkadot/Cosmos生态 - 高性能链（Solana、Aptos） - 专用隐私链（Zcash、Monero概念） 跨链身份： - 一个PHC，多链认证 - 统一的身份层 5. 撤销和恢复机制 优雅的撤销：\n设计保护隐私的撤销： - 使用累加器（Accumulator） - 撤销列表不泄露身份 - 高效的撤销验证 恢复机制： - PHC过期后的更新流程 - 密钥丢失的恢复方案 - 保持连续性的信誉迁移 6. 合规和监管 可选的透明性：\n为监管场景设计： - 选择性披露机制 - 紧急情况下的去匿名化 - 法院命令的执行 平衡： - 保护普通用户隐私 - 满足反洗钱（AML）要求 - 支持合法调查 关键takeaways 技术创新 可信匿名的突破： 首次在区块链上实现\u0026quot;可信\u0026quot;+\u0026ldquo;匿名\u0026quot;的结合 通过零知识证明保护隐私 通过可链接环签名确保一对一映射 完全去中心化： 无需可信第三方参与验证 所有逻辑在智能合约中执行 用户完全控制自己的身份 实用性验证： 在真实以太坊测试网络上实现 性能指标明确可测 成本可接受且可优化 理论贡献 身份模型创新：\n传统模型：身份 → 账户（可见映射） zkBID模型：身份 → [ZK层] → 种子 → [环签名层] → 账户 创新点： - 两层隐私保护 - 可验证但不可追踪 - 数学上可证明的安全性 密码学组合：\nzkSNARK + 可链接环签名的首次组合应用 各取所长，弥补对方不足 为未来类似系统提供范式 实践意义 Web3基础设施： 为Web3提供关键的身份层 解决匿名性与可信性的矛盾 使去中心化应用更实用 防止AI冒充： 在AI时代区分人类和机器 PHC作为\u0026quot;数字人格证\u0026rdquo; 保护在线空间的人类性 新经济模式： 支持基于信誉的去中心化经济 公平的激励分配机制 可持续的社区治理 结论 zkBID是一个创新的Web 3.0去中心化身份方案，成功解决了区块链账户系统中匿名性与可信性的矛盾。\n核心成就 ✅ 技术突破：\n零知识证明保护身份隐私 可链接环签名确保一对一映射 完全去中心化的验证机制 ✅ 安全保证：\n抵御女巫攻击 抵御链接攻击 抵御伪造攻击 ✅ 实用验证：\n以太坊测试网络成功部署 性能指标满足实际应用需求 成本可通过参数优化控制 未来展望 zkBID为Web3去中心化身份提供了一个可行的解决方案，但仍有改进空间：\n继续优化性能和成本 推动PHC生态系统发展 探索跨链和多链支持 完善撤销和恢复机制 平衡隐私保护 ","permalink":"http://localhost:1313/posts/linking-souls-to-humans/","summary":"zkBID通过零知识证明和可链接环签名技术，首次实现了区块链账户的\u0026quot;可信匿名\u0026quot;：每个账户与真实用户一对一绑定（可信），但外界无法追踪具体对应关系（匿名）。系统采用三阶段IVAC流程，将人格凭证(PHC)通过零知识证明验证后绑定到种子公钥，再用环签名将种子公钥关联到灵魂账户。实验显示批处理可将验证成本降低85%，环大小灵活可调以平衡匿名性与效率。该方案为Web3提供了关键身份基础设施，可有效防止女巫攻击，支持去中心化社交、DAO治理、DeFi空投等场景。","title":"zkBID: 区块链账户与Web 3.0去中心化身份"},{"content":"📚 Part 1: Java 集合使用手册 1. List - 列表 ArrayList - 动态数组 // 初始化 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); List\u0026lt;Integer\u0026gt; list3 = new ArrayList\u0026lt;\u0026gt;(100); // 指定初始容量 // 增 list.add(1); // 尾部添加 list.add(0, 10); // 指定位置添加 list.addAll(Arrays.asList(2,3,4)); // 批量添加 // 删 list.remove(0); // 删除指定索引 list.remove(Integer.valueOf(1)); // 删除指定元素 list.clear(); // 清空 // 改 list.set(0, 100); // 修改指定位置 // 查 int val = list.get(0); // 获取元素 int size = list.size(); // 获取大小 boolean empty = list.isEmpty(); // 是否为空 boolean contains = list.contains(1); // 是否包含 int index = list.indexOf(1); // 查找索引 // 遍历 for (int num : list) { System.out.println(num); } // 或使用迭代器 Iterator\u0026lt;Integer\u0026gt; it = list.iterator(); while (it.hasNext()) { System.out.println(it.next()); } LinkedList - 双向链表 LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 头部操作 list.addFirst(1); list.removeFirst(); int first = list.getFirst(); // 尾部操作 list.addLast(2); list.removeLast(); int last = list.getLast(); // 作为队列使用 list.offer(3); // 入队 int head = list.poll(); // 出队 // 作为栈使用 list.push(4); // 入栈 int top = list.pop(); // 出栈 2. Set - 集合 HashSet - 无序不重复 // 初始化 Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); // 增 set.add(1); set.addAll(Arrays.asList(2, 3, 4)); // 删 set.remove(1); set.clear(); // 查 boolean contains = set.contains(1); int size = set.size(); boolean empty = set.isEmpty(); // 遍历 for (int num : set) { System.out.println(num); } TreeSet - 有序集合（红黑树） TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 基本操作同 HashSet set.add(3); set.add(1); set.add(2); System.out.println(set); // [1, 2, 3] 自动排序 // 特有方法 int first = set.first(); // 最小元素 int last = set.last(); // 最大元素 int lower = set.lower(2); // 小于 2 的最大元素 int higher = set.higher(2); // 大于 2 的最小元素 int floor = set.floor(2); // ≤ 2 的最大元素 int ceiling = set.ceiling(2); // ≥ 2 的最小元素 // 子集操作 SortedSet\u0026lt;Integer\u0026gt; subset = set.subSet(1, 3); // [1, 3) SortedSet\u0026lt;Integer\u0026gt; headSet = set.headSet(2); // \u0026lt; 2 SortedSet\u0026lt;Integer\u0026gt; tailSet = set.tailSet(2); // \u0026gt;= 2 LinkedHashSet - 保持插入顺序 Set\u0026lt;Integer\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); set.add(3); set.add(1); set.add(2); System.out.println(set); // [3, 1, 2] 保持插入顺序 3. Map - 映射 HashMap - 键值对 // 初始化 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 增/改 map.put(\u0026#34;apple\u0026#34;, 1); map.put(\u0026#34;banana\u0026#34;, 2); map.putIfAbsent(\u0026#34;apple\u0026#34;, 10); // 键不存在时才添加 // 删 map.remove(\u0026#34;apple\u0026#34;); map.clear(); // 查 int val = map.get(\u0026#34;apple\u0026#34;); int valOrDefault = map.getOrDefault(\u0026#34;orange\u0026#34;, 0); boolean hasKey = map.containsKey(\u0026#34;apple\u0026#34;); boolean hasValue = map.containsValue(1); int size = map.size(); // 遍历键值对 for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { String key = entry.getKey(); int value = entry.getValue(); } // 遍历键 for (String key : map.keySet()) { System.out.println(key); } // 遍历值 for (int value : map.values()) { System.out.println(value); } // Java 8+ 新方法 map.computeIfAbsent(\u0026#34;cherry\u0026#34;, k -\u0026gt; 3); map.merge(\u0026#34;apple\u0026#34;, 1, Integer::sum); // 累加 TreeMap - 有序映射（红黑树） TreeMap\u0026lt;Integer, String\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); map.put(3, \u0026#34;c\u0026#34;); map.put(1, \u0026#34;a\u0026#34;); map.put(2, \u0026#34;b\u0026#34;); // 基本操作同 HashMap // 特有方法 int firstKey = map.firstKey(); int lastKey = map.lastKey(); Map.Entry\u0026lt;Integer, String\u0026gt; firstEntry = map.firstEntry(); Map.Entry\u0026lt;Integer, String\u0026gt; lastEntry = map.lastEntry(); int lowerKey = map.lowerKey(2); // \u0026lt; 2 的最大键 int higherKey = map.higherKey(2); // \u0026gt; 2 的最小键 int floorKey = map.floorKey(2); // \u0026lt;= 2 的最大键 int ceilingKey = map.ceilingKey(2); // \u0026gt;= 2 的最小键 LinkedHashMap - 保持插入顺序 Map\u0026lt;String, Integer\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;c\u0026#34;, 3); map.put(\u0026#34;a\u0026#34;, 1); map.put(\u0026#34;b\u0026#34;, 2); // 遍历时保持插入顺序: c, a, b 4. Queue - 队列 普通队列 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 入队 queue.offer(1); queue.add(2); // 队列满时抛异常 // 出队 int head = queue.poll(); // 空时返回 null int head2 = queue.remove(); // 空时抛异常 // 查看队首 int peek = queue.peek(); // 空时返回 null int peek2 = queue.element(); // 空时抛异常 PriorityQueue - 优先队列（堆） // 小根堆（默认） PriorityQueue\u0026lt;Integer\u0026gt; minHeap = new PriorityQueue\u0026lt;\u0026gt;(); // 大根堆 PriorityQueue\u0026lt;Integer\u0026gt; maxHeap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); // 自定义对象 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); minHeap.offer(3); minHeap.offer(1); minHeap.offer(2); while (!minHeap.isEmpty()) { System.out.println(minHeap.poll()); // 1, 2, 3 } Deque - 双端队列 Deque\u0026lt;Integer\u0026gt; deque = new ArrayDeque\u0026lt;\u0026gt;(); // 头部操作 deque.offerFirst(1); deque.pollFirst(); deque.peekFirst(); // 尾部操作 deque.offerLast(2); deque.pollLast(); deque.peekLast(); // 作为栈使用 deque.push(3); int top = deque.pop(); 5. Stack - 栈 Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(1); // 入栈 int top = stack.pop(); // 出栈 int peek = stack.peek(); // 查看栈顶 boolean empty = stack.isEmpty(); int size = stack.size(); // 推荐使用 Deque 代替 Stack Deque\u0026lt;Integer\u0026gt; stack2 = new ArrayDeque\u0026lt;\u0026gt;(); 🧮 Part 2: 算法模板 1. 树的遍历 二叉树定义 class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } } DFS - 深度优先遍历 前序遍历（根-左-右）\n// 递归 void preorder(TreeNode root) { if (root == null) return; System.out.println(root.val); preorder(root.left); preorder(root.right); } // 迭代 List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); res.add(node.val); if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); } return res; } 中序遍历（左-根-右）\n// 递归 void inorder(TreeNode root) { if (root == null) return; inorder(root.left); System.out.println(root.val); inorder(root.right); } // 迭代 List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode curr = root; while (curr != null || !stack.isEmpty()) { while (curr != null) { stack.push(curr); curr = curr.left; } curr = stack.pop(); res.add(curr.val); curr = curr.right; } return res; } 后序遍历（左-右-根）\n// 递归 void postorder(TreeNode root) { if (root == null) return; postorder(root.left); postorder(root.right); System.out.println(root.val); } // 迭代 List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); res.add(node.val); if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); } Collections.reverse(res); return res; } BFS - 层序遍历 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); while (!queue.isEmpty()) { int size = queue.size(); List\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; size; i++) { TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } res.add(level); } return res; } 2. 线段树（Segment Tree） class SegmentTree { private int[] tree; private int n; public SegmentTree(int[] nums) { n = nums.length; tree = new int[4 * n]; build(nums, 0, 0, n - 1); } // 构建线段树 private void build(int[] nums, int node, int start, int end) { if (start == end) { tree[node] = nums[start]; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; int rightNode = 2 * node + 2; build(nums, leftNode, start, mid); build(nums, rightNode, mid + 1, end); tree[node] = tree[leftNode] + tree[rightNode]; } // 区间查询 [l, r] public int query(int l, int r) { return query(0, 0, n - 1, l, r); } private int query(int node, int start, int end, int l, int r) { if (l \u0026gt; end || r \u0026lt; start) return 0; if (l \u0026lt;= start \u0026amp;\u0026amp; end \u0026lt;= r) return tree[node]; int mid = start + (end - start) / 2; int leftSum = query(2 * node + 1, start, mid, l, r); int rightSum = query(2 * node + 2, mid + 1, end, l, r); return leftSum + rightSum; } // 单点更新 public void update(int index, int val) { update(0, 0, n - 1, index, val); } private void update(int node, int start, int end, int index, int val) { if (start == end) { tree[node] = val; return; } int mid = start + (end - start) / 2; int leftNode = 2 * node + 1; int rightNode = 2 * node + 2; if (index \u0026lt;= mid) { update(leftNode, start, mid, index, val); } else { update(rightNode, mid + 1, end, index, val); } tree[node] = tree[leftNode] + tree[rightNode]; } } // 使用示例 int[] nums = {1, 3, 5, 7, 9, 11}; SegmentTree segTree = new SegmentTree(nums); int sum = segTree.query(1, 3); // 查询 [1,3] 区间和 segTree.update(1, 10); // 更新 index=1 的值为 10 3. 图算法 图的表示 // 邻接表 Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; graph = new HashMap\u0026lt;\u0026gt;(); // 或 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); // 邻接矩阵 int[][] graph = new int[n][n]; DFS - 图的深度优先遍历 void dfs(int node, Set\u0026lt;Integer\u0026gt; visited, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { visited.add(node); System.out.println(node); for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { dfs(neighbor, visited, graph); } } } // 使用 Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); dfs(0, visited, graph); BFS - 图的广度优先遍历 void bfs(int start, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph) { Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(start); visited.add(start); while (!queue.isEmpty()) { int node = queue.poll(); System.out.println(node); for (int neighbor : graph.get(node)) { if (!visited.contains(neighbor)) { queue.offer(neighbor); visited.add(neighbor); } } } } 拓扑排序（Kahn 算法） List\u0026lt;Integer\u0026gt; topologicalSort(int n, int[][] edges) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] inDegree = new int[n]; for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { graph.get(edge[0]).add(edge[1]); inDegree[edge[1]]++; } Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (inDegree[i] == 0) { queue.offer(i); } } List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); while (!queue.isEmpty()) { int node = queue.poll(); res.add(node); for (int neighbor : graph.get(node)) { inDegree[neighbor]--; if (inDegree[neighbor] == 0) { queue.offer(neighbor); } } } return res.size() == n ? res : new ArrayList\u0026lt;\u0026gt;(); } Dijkstra 最短路径算法 int[] dijkstra(int n, int[][] edges, int start) { // 构建邻接表: {neighbor, weight} List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); } int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 优先队列: {distance, node} PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); pq.offer(new int[]{0, start}); while (!pq.isEmpty()) { int[] curr = pq.poll(); int d = curr[0], node = curr[1]; if (d \u0026gt; dist[node]) continue; for (int[] neighbor : graph.get(node)) { int next = neighbor[0], weight = neighbor[1]; int newDist = d + weight; if (newDist \u0026lt; dist[next]) { dist[next] = newDist; pq.offer(new int[]{newDist, next}); } } } return dist; } Bellman-Ford 算法（可处理负权边） int[] bellmanFord(int n, int[][] edges, int start) { int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; // 松弛 n-1 次 for (int i = 0; i \u0026lt; n - 1; i++) { for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { dist[v] = dist[u] + w; } } } // 检测负环 for (int[] edge : edges) { int u = edge[0], v = edge[1], w = edge[2]; if (dist[u] != Integer.MAX_VALUE \u0026amp;\u0026amp; dist[u] + w \u0026lt; dist[v]) { return null; // 存在负环 } } return dist; } Floyd-Warshall 全源最短路径 int[][] floydWarshall(int n, int[][] edges) { int[][] dist = new int[n][n]; // 初始化 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(dist[i], Integer.MAX_VALUE / 2); dist[i][i] = 0; } for (int[] edge : edges) { dist[edge[0]][edge[1]] = edge[2]; } // 动态规划 for (int k = 0; k \u0026lt; n; k++) { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]); } } } return dist; } Prim 最小生成树 int prim(int n, int[][] edges) { List\u0026lt;List\u0026lt;int[]\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { graph.get(edge[0]).add(new int[]{edge[1], edge[2]}); graph.get(edge[1]).add(new int[]{edge[0], edge[2]}); } boolean[] visited = new boolean[n]; PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[1] - b[1]); pq.offer(new int[]{0, 0}); // {node, weight} int totalWeight = 0; int edgeCount = 0; while (!pq.isEmpty() \u0026amp;\u0026amp; edgeCount \u0026lt; n) { int[] curr = pq.poll(); int node = curr[0], weight = curr[1]; if (visited[node]) continue; visited[node] = true; totalWeight += weight; edgeCount++; for (int[] neighbor : graph.get(node)) { if (!visited[neighbor[0]]) { pq.offer(neighbor); } } } return edgeCount == n ? totalWeight : -1; } Kruskal 最小生成树（并查集） class UnionFind { int[] parent, rank; public UnionFind(int n) { parent = new int[n]; rank = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } } public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); } return parent[x]; } public boolean union(int x, int y) { int rootX = find(x), rootY = find(y); if (rootX == rootY) return false; if (rank[rootX] \u0026lt; rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] \u0026gt; rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; } return true; } } int kruskal(int n, int[][] edges) { Arrays.sort(edges, (a, b) -\u0026gt; a[2] - b[2]); UnionFind uf = new UnionFind(n); int totalWeight = 0; int edgeCount = 0; for (int[] edge : edges) { if (uf.union(edge[0], edge[1])) { totalWeight += edge[2]; edgeCount++; if (edgeCount == n - 1) break; } } return edgeCount == n - 1 ? totalWeight : -1; } 4. 回溯算法 组合问题 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), 1, n, k); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int start, int n, int k) { if (path.size() == k) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for (int i = start; i \u0026lt;= n; i++) { path.add(i); backtrack(res, path, i + 1, n, k); path.remove(path.size() - 1); } } 全排列 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, new boolean[nums.length]); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, boolean[] used) { if (path.size() == nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) continue; path.add(nums[i]); used[i] = true; backtrack(res, path, nums, used); used[i] = false; path.remove(path.size() - 1); } } 子集问题 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); backtrack(res, new ArrayList\u0026lt;\u0026gt;(), nums, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; path, int[] nums, int start) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); for (int i = start; i \u0026lt; nums.length; i++) { path.add(nums[i]); backtrack(res, path, nums, i + 1); path.remove(path.size() - 1); } } N 皇后问题 List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); char[][] board = new char[n][n]; for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(board[i], \u0026#39;.\u0026#39;); } backtrack(res, board, 0); return res; } void backtrack(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res, char[][] board, int row) { if (row == board.length) { res.add(construct(board)); return; } for (int col = 0; col \u0026lt; board.length; col++) { if (!isValid(board, row, col)) continue; board[row][col] = \u0026#39;Q\u0026#39;; backtrack(res, board, row + 1); board[row][col] = \u0026#39;.\u0026#39;; } } boolean isValid(char[][] board, int row, int col) { int n = board.length; // 检查列 for (int i = 0; i \u0026lt; row; i++) { if (board[i][col] == \u0026#39;Q\u0026#39;) return false; } // 检查左上对角线 for (int i = row - 1, j = col - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } // 检查右上对角线 for (int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (board[i][j] == \u0026#39;Q\u0026#39;) return false; } return true; } List\u0026lt;String\u0026gt; construct(char[][] board) { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for (char[] row : board) { res.add(new String(row)); } return res; } 5. 动态规划 0-1 背包问题 int knapsack(int[] weights, int[] values, int capacity) { int n = weights.length; int[][] dp = new int[n + 1][capacity + 1]; for (int i = 1; i \u0026lt;= n; i++) { for (int w = 0; w \u0026lt;= capacity; w++) { if (weights[i - 1] \u0026lt;= w) { dp[i][w] = Math.max( dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1] ); } else { dp[i][w] = dp[i - 1][w]; } } } return dp[n][capacity]; } // 空间优化版本 int knapsackOptimized(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { for (int w = capacity; w \u0026gt;= weights[i]; w--) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 完全背包问题 int completeKnapsack(int[] weights, int[] values, int capacity) { int[] dp = new int[capacity + 1]; for (int i = 0; i \u0026lt; weights.length; i++) { for (int w = weights[i]; w \u0026lt;= capacity; w++) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } return dp[capacity]; } 最长公共子序列（LCS） int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (text1.charAt(i - 1) == text2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; } 最长递增子序列（LIS） // O(n^2) 解法 int lengthOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; Arrays.fill(dp, 1); int maxLen = 1; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { if (nums[i] \u0026gt; nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } maxLen = Math.max(maxLen, dp[i]); } return maxLen; } // O(n log n) 二分解法 int lengthOfLISBinary(int[] nums) { List\u0026lt;Integer\u0026gt; tails = new ArrayList\u0026lt;\u0026gt;(); for (int num : nums) { int left = 0, right = tails.size(); while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (tails.get(mid) \u0026lt; num) { left = mid + 1; } else { right = mid; } } if (left == tails.size()) { tails.add(num); } else { tails.set(left, num); } } return tails.size(); } 编辑距离 int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i \u0026lt;= m; i++) dp[i][0] = i; for (int j = 0; j \u0026lt;= n; j++) dp[0][j] = j; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = Math.min( Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] ) + 1; } } } return dp[m][n]; } 股票买卖问题 只能买卖一次\nint maxProfit(int[] prices) { int minPrice = Integer.MAX_VALUE; int maxProfit = 0; for (int price : prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; } 可以买卖多次\nint maxProfitMultiple(int[] prices) { int profit = 0; for (int i = 1; i \u0026lt; prices.length; i++) { if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } 最多买卖 k 次\nint maxProfitK(int k, int[] prices) { if (prices.length == 0) return 0; int n = prices.length; if (k \u0026gt;= n / 2) { // 退化为无限次交易 int profit = 0; for (int i = 1; i \u0026lt; n; i++) { if (prices[i] \u0026gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } int[][] dp = new int[k + 1][n]; for (int i = 1; i \u0026lt;= k; i++) { int maxDiff = -prices[0]; for (int j = 1; j \u0026lt; n; j++) { dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff); maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]); } } return dp[k][n - 1]; } 打家劫舍 // 基础版：线性排列 int rob(int[] nums) { if (nums.length == 0) return 0; if (nums.length == 1) return nums[0]; int prev2 = 0, prev1 = 0; for (int num : nums) { int temp = prev1; prev1 = Math.max(prev1, prev2 + num); prev2 = temp; } return prev1; } // 环形排列 int robCircular(int[] nums) { if (nums.length == 1) return nums[0]; return Math.max( robRange(nums, 0, nums.length - 2), robRange(nums, 1, nums.length - 1) ); } int robRange(int[] nums, int start, int end) { int prev2 = 0, prev1 = 0; for (int i = start; i \u0026lt;= end; i++) { int temp = prev1; prev1 = Math.max(prev1, prev2 + nums[i]); prev2 = temp; } return prev1; } 分割等和子集 boolean canPartition(int[] nums) { int sum = 0; for (int num : nums) sum += num; if (sum % 2 != 0) return false; int target = sum / 2; boolean[] dp = new boolean[target + 1]; dp[0] = true; for (int num : nums) { for (int j = target; j \u0026gt;= num; j--) { dp[j] = dp[j] || dp[j - num]; } } return dp[target]; } 零钱兑换 // 最少硬币数 int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); dp[0] = 0; for (int i = 1; i \u0026lt;= amount; i++) { for (int coin : coins) { if (i \u0026gt;= coin) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } } return dp[amount] \u0026gt; amount ? -1 : dp[amount]; } // 组成方案数 int change(int amount, int[] coins) { int[] dp = new int[amount + 1]; dp[0] = 1; for (int coin : coins) { for (int i = coin; i \u0026lt;= amount; i++) { dp[i] += dp[i - coin]; } } return dp[amount]; } 6. 二分查找 标准二分查找 int binarySearch(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else { right = mid - 1; } } return -1; } 查找左边界 int leftBound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else { right = mid - 1; } } return left \u0026lt; nums.length \u0026amp;\u0026amp; nums[left] == target ? left : -1; } 查找右边界 int rightBound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt;= target) { left = mid + 1; } else { right = mid - 1; } } return right \u0026gt;= 0 \u0026amp;\u0026amp; nums[right] == target ? right : -1; } 旋转数组查找 int searchRotated(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; // 左半部分有序 if (nums[left] \u0026lt;= nums[mid]) { if (target \u0026gt;= nums[left] \u0026amp;\u0026amp; target \u0026lt; nums[mid]) { right = mid - 1; } else { left = mid + 1; } } // 右半部分有序 else { if (target \u0026gt; nums[mid] \u0026amp;\u0026amp; target \u0026lt;= nums[right]) { left = mid + 1; } else { right = mid - 1; } } } return -1; } 7. 滑动窗口 固定窗口大小 // 最大和的子数组（固定长度 k） int maxSumSubarray(int[] nums, int k) { int sum = 0; for (int i = 0; i \u0026lt; k; i++) { sum += nums[i]; } int maxSum = sum; for (int i = k; i \u0026lt; nums.length; i++) { sum += nums[i] - nums[i - k]; maxSum = Math.max(maxSum, sum); } return maxSum; } 可变窗口大小 // 最小覆盖子串 String minWindow(String s, String t) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (char c : t.toCharArray()) { need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0; int valid = 0; int start = 0, len = Integer.MAX_VALUE; while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; if (need.containsKey(c)) { window.put(c, window.getOrDefault(c, 0) + 1); if (window.get(c).equals(need.get(c))) { valid++; } } while (valid == need.size()) { if (right - left \u0026lt; len) { start = left; len = right - left; } char d = s.charAt(left); left++; if (need.containsKey(d)) { if (window.get(d).equals(need.get(d))) { valid--; } window.put(d, window.get(d) - 1); } } } return len == Integer.MAX_VALUE ? \u0026#34;\u0026#34; : s.substring(start, start + len); } // 无重复字符的最长子串 int lengthOfLongestSubstring(String s) { Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0; int maxLen = 0; while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); while (window.get(c) \u0026gt; 1) { char d = s.charAt(left); left++; window.put(d, window.get(d) - 1); } maxLen = Math.max(maxLen, right - left); } return maxLen; } 8. 双指针 对撞指针 // 两数之和（有序数组） int[] twoSum(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[left] + nums[right]; if (sum == target) { return new int[]{left, right}; } else if (sum \u0026lt; target) { left++; } else { right--; } } return new int[]{-1, -1}; } // 三数之和 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length - 2; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { res.add(Arrays.asList(nums[i], nums[left], nums[right])); while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; left++; right--; } else if (sum \u0026lt; 0) { left++; } else { right--; } } } return res; } 快慢指针 // 链表中点 ListNode findMiddle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } // 环形链表 boolean hasCycle(ListNode head) { if (head == null) return false; ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) return true; } return false; } // 找环的入口 ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { slow = head; while (slow != fast) { slow = slow.next; fast = fast.next; } return slow; } } return null; } 9. 单调栈 // 下一个更大元素 int[] nextGreaterElement(int[] nums) { int n = nums.length; int[] res = new int[n]; Arrays.fill(res, -1); Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; nums[stack.peek()] \u0026lt; nums[i]) { int idx = stack.pop(); res[idx] = nums[i]; } stack.push(i); } return res; } // 每日温度 int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] res = new int[n]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[stack.peek()] \u0026lt; temperatures[i]) { int idx = stack.pop(); res[idx] = i - idx; } stack.push(i); } return res; } // 柱状图中最大的矩形 int largestRectangleArea(int[] heights) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(-1); int maxArea = 0; for (int i = 0; i \u0026lt; heights.length; i++) { while (stack.peek() != -1 \u0026amp;\u0026amp; heights[stack.peek()] \u0026gt;= heights[i]) { int h = heights[stack.pop()]; int w = i - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } stack.push(i); } while (stack.peek() != -1) { int h = heights[stack.pop()]; int w = heights.length - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } return maxArea; } 10. 前缀和 // 一维前缀和 class PrefixSum { private int[] preSum; public PrefixSum(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 0; i \u0026lt; nums.length; i++) { preSum[i + 1] = preSum[i] + nums[i]; } } // 查询区间 [left, right] 的和 public int query(int left, int right) { return preSum[right + 1] - preSum[left]; } } // 二维前缀和 class MatrixPrefixSum { private int[][] preSum; public MatrixPrefixSum(int[][] matrix) { int m = matrix.length, n = matrix[0].length; preSum = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } // 查询子矩阵 [row1, col1] 到 [row2, col2] 的和 public int query(int row1, int col1, int row2, int col2) { return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]; } } 📌 总结 这份文档涵盖了：\nJava 集合框架：List、Set、Map、Queue、Stack 的完整使用方法 树算法：DFS、BFS、线段树 图算法：遍历、最短路径、最小生成树 经典算法：回溯、动态规划、二分查找、滑动窗口、双指针、单调栈、前缀和 建议配合 LeetCode 刷题使用，遇到问题时可以快速查阅对应的模板代码。\n持续更新中\u0026hellip; 🚀\n","permalink":"http://localhost:1313/posts/algorithm-with-java/","summary":"详细介绍java集合的使用,以及在刷算法题中需要使用到的一些板子","title":"算法刷题必备：Java集合与算法模板"},{"content":"👋 嗨，我是 Minjie 很高兴你能来到这里！这是我在互联网上的一个小角落，用来记录代码、想法和生活的点滴。\n🧑‍💻 关于我 我是一名在读研究生，研究方向包括区块链，web3.0，数据库管理等。当然，目前更加专注于 Java 后端开发。相比起\u0026quot;全栈工程师\u0026quot;这样的标签，我更喜欢把自己定义为一个对计算机技术充满好奇心的探索者。\n📖 这个博客写什么 这里主要记录我在技术道路上的成长轨迹，你可能会看到：\n技术笔记 - Java 后端开发的实践经验、框架使用心得、踩过的坑和解决方案\n项目复盘 - 从需求分析到上线部署，记录项目中的思考和收获\n学习记录 - 新技术的探索、算法题的思路、计算机基础知识的整理\n随笔杂谈 - 偶尔也会写写读书笔记、游戏感想，或者对技术趋势的一些思考\n我希望这里不仅是我个人的知识库,也能给同样在技术路上摸索的你带来一些启发或共鸣。\n🎯 技术栈 \u0026amp; 兴趣方向 后端开发：Java、Spring Boot、MyBatis、MySQL、Redis - 这是我的主战场\n折腾爱好：除了后端，我还喜欢写点爬虫玩玩，做些自动化小工具来解决日常遇到的重复性工作。总觉得能用代码解决的事情，就不该浪费时间手动操作。有时候为了实现一个自动化脚本，花的时间可能比手动做还多，但那种\u0026quot;一劳永逸\u0026quot;的快感真的很上头。\n探索中：对各种能提高效率的技术和工具都充满兴趣，正在不断拓展技术边界\u0026hellip;\n🎮 代码之外 游戏时光：Steam 上收藏了不少游戏，也会玩玩王者、原神这些。\n音乐陪伴：写代码的时候总要听点什么。古典音乐能让思路更清晰，ACG 音乐带来满满的回忆，偶尔也会跟着流行音乐哼哼唱唱。喜欢洗澡的时候k歌······当然，也是个半吊子吉他选手\n运动爱好：除了敲键盘，也喜欢出去动一动。篮球、羽毛球、乒乓球都有涉猎，虽然都不算精通，但也能过上两招。过去打篮球多一点，现在更想尝试羽毛球。\n历史爱好者：对历史有种莫名的着迷，喜欢看历史书籍、纪录片。主要包括近现代欧洲历史，唐史，春秋战国。\n💬 来聊聊？ 如果你也对后端开发感兴趣，或者想交流技术、分享项目经验，甚至只是想推荐个好玩的游戏或好听的歌，都欢迎联系我：\n📧 邮箱：zhongnagisa01@gmail.com 🐙 GitHub：Minjie2003 \u0026ldquo;代码改变世界，但别忘了偶尔抬头看看星空。\u0026rdquo;\n感谢你的访问，希望我们能在这里有更多交流！✨\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于我"}]