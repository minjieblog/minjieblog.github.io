---
title: "数学基础算法篇"
date: 2025-12-21T15:50:54+08:00
draft: false
tags: ["算法", "哈希", "算法分析", "尾不等式", "数据流"]
categories: ["研究生课程"]
summary: |
    本笔记涵盖数学基础算法篇的完整内容，包括算法分析与相似度搜索、尾不等式及其应用、数据流算法（频繁元素检测、滑动窗口模型）、分布式数据流处理、哈希技术（布隆过滤器、LSH）、线性规划与整数规划、内存计算架构、社区发现算法以及子模函数应用等核心理论与实践。
description: |
    金老师主讲的研究生课程《数学基础算法篇》完整笔记，从算法分析基础开始，系统介绍相似度搜索、概率不等式、流式数据处理、分布式计算、哈希技术、优化算法、图算法等内容，理论与实践相结合，为解决大规模数据处理问题提供数学和算法基础。
comments: true
---

## 第一讲 算法分析

### 一、算法简介

算法分析是计算机科学的基础，用于评估算法的效率和资源消耗。

**算法复杂度分析：**
- **时间复杂度**：衡量算法执行时间随输入规模增长的趋势
- **空间复杂度**：衡量算法所需存储空间随输入规模增长的趋势
- **渐近分析**：O、Ω、Θ记号

**常见复杂度类型：**
- O(1)：常数时间
- O(log n)：对数时间
- O(n)：线性时间
- O(n log n)：线性对数时间
- O(n²)：平方时间
- O(2ⁿ)：指数时间

**算法设计范式：**
- 分治法（Divide and Conquer）
- 动态规划（Dynamic Programming）
- 贪心算法（Greedy Algorithm）
- 回溯法（Backtracking）
- 分支界定法（Branch and Bound）

### 二、相似度搜索

相似度搜索是在大规模数据中找到与查询对象相似的数据项。

**相似度度量：**
- **欧氏距离（Euclidean Distance）**：
  ```
  d(x, y) = √(Σ(xᵢ - yᵢ)²)
  ```
- **曼哈顿距离（Manhattan Distance）**：
  ```
  d(x, y) = Σ|xᵢ - yᵢ|
  ```
- **余弦相似度（Cosine Similarity）**：
  ```
  sim(x, y) = (x·y) / (||x|| ||y||)
  ```
- **Jaccard相似度**：
  ```
  J(A, B) = |A ∩ B| / |A ∪ B|
  ```

**应用场景：**
- 推荐系统
- 图像检索
- 文档相似度检测
- 近似最近邻搜索（ANN）

**朴素方法的局限：**
线性扫描的时间复杂度为O(n)，对于大规模数据集不可行。

### 三、高维空间的相似性搜索

在高维空间中，传统的索引结构（如KD树）性能退化严重，这被称为"维度灾难"。

**维度灾难（Curse of Dimensionality）：**
- 数据点之间的距离趋于相等
- 数据点趋向于分布在空间的"表面"
- 索引结构的效率降低

**解决方案：**

**1. 降维技术：**
- 主成分分析（PCA）
- 随机投影
- t-SNE

**2. 近似算法：**
- **局部敏感哈希（LSH）**：将相似的点以高概率映射到同一个桶
- **乘积量化（Product Quantization）**：将向量空间分解为子空间
- **HNSW（Hierarchical Navigable Small World）**：基于图的近似最近邻搜索

**LSH的基本原理：**
- 使用哈希函数族h，满足：相似的对象碰撞概率高，不相似的对象碰撞概率低
- 通过多个哈希函数和多个哈希表提高召回率
- 查询时只需检查哈希到同一桶的候选点

---

## 第二讲 尾不等式

### 一、尾不等式分析概要

尾不等式用于界定随机变量偏离其期望值的概率，在算法分析和概率算法设计中具有重要作用。

**为什么需要尾不等式：**
- 期望值只描述了平均情况
- 需要了解"坏情况"发生的概率
- 为随机算法提供性能保证

**应用领域：**
- 随机算法分析
- 负载均衡
- 哈希表性能分析
- 采样算法

### 二、三个常见的尾不等式

**1. Markov不等式（马尔可夫不等式）：**

对于非负随机变量X和a > 0：
```
P(X ≥ a) ≤ E[X] / a
```

**特点：**
- 只需要知道期望
- 界比较松
- 适用于任何非负随机变量

**2. Chebyshev不等式（切比雪夫不等式）：**

对于随机变量X，有：
```
P(|X - E[X]| ≥ a) ≤ Var(X) / a²
```

**特点：**
- 需要知道期望和方差
- 比Markov不等式更紧
- 不需要独立性假设

**3. Chernoff界（切尔诺夫界）：**

对于独立的随机变量X₁, X₂, ..., Xₙ ∈ [0,1]，令X = ΣXᵢ，μ = E[X]：
```
P(X ≥ (1+δ)μ) ≤ e^(-δ²μ/3)  (0 < δ ≤ 1)
P(X ≤ (1-δ)μ) ≤ e^(-δ²μ/2)  (0 < δ ≤ 1)
```

**特点：**
- 界最紧，指数级衰减
- 需要独立性假设
- 广泛应用于随机算法分析

### 三、计数问题

**问题描述：**
估计一个数据流中不同元素的个数（基数估计）。

**朴素方法的问题：**
- 存储所有元素需要O(n)空间
- 对于大规模数据流不可行

**概率计数算法：**

**Flajolet-Martin算法：**
1. 使用哈希函数h将元素映射到[0, 2^L-1]
2. 对每个元素计算其哈希值的尾部0的个数
3. 记录观察到的最大尾部0个数R
4. 估计值：2^R

**原理：**
- 如果有n个不同元素，期望看到log₂(n)个尾部0
- 使用多个哈希函数取平均值提高精度
- 空间复杂度：O(log log n)

**HyperLogLog算法：**
- Flajolet-Martin的改进版本
- 使用调和平均数代替算术平均数
- 精度更高，误差约为1.04/√m（m为桶数）
- 空间效率极高

---

## 第三讲 数据流

### 一、数据流模型

数据流模型描述了数据以流的形式到达，只能顺序访问一次或有限次的计算场景。

**数据流的特点：**
- 数据量巨大，无法全部存储
- 数据到达速度快，需要实时处理
- 只能进行一次或有限次扫描
- 需要在有限空间内近似计算

**典型应用：**
- 网络流量监控
- 金融交易分析
- 社交媒体数据处理
- IoT传感器数据

**数据流算法的目标：**
- 使用亚线性（sublinear）空间
- 提供可证明的近似保证
- 单次扫描或少量扫描

### 二、频繁元素-确定性算法

**问题定义：**
找出数据流中出现频率超过某个阈值的元素（heavy hitters）。

**Misra-Gries算法：**

**算法描述：**
1. 维护最多k个计数器
2. 对于每个到来的元素：
   - 如果已有计数器，增加其计数
   - 如果没有计数器且有空位，创建新计数器
   - 如果没有空位，所有计数器减1，删除值为0的计数器
3. 输出计数器中的元素

**性能保证：**
- 空间复杂度：O(k)
- 如果元素出现次数 > n/k，一定会被找到
- 可能有假阳性，但可以通过二次扫描验证

**应用：**
- 找出访问量最大的网页
- 检测网络中的大流量
- 识别热门话题

### 三、频繁元素-随机算法

**Count-Min Sketch算法：**

**数据结构：**
- d × w 的二维计数器数组
- d个独立的哈希函数h₁, h₂, ..., h_d

**算法操作：**

**更新（插入元素x）：**
```
对于 i = 1 到 d：
    count[i][hᵢ(x)] += 1
```

**查询（估计元素x的频率）：**
```
返回 min{count[i][hᵢ(x)] : i = 1..d}
```

**性能保证：**
- 空间复杂度：O(d × w)
- 误差界：ε·n (n为总元素数)，概率至少1-δ
- 选择w = ⌈e/ε⌉, d = ⌈ln(1/δ)⌉
- 只会高估，不会低估

**优势：**
- 空间效率高
- 支持点查询和范围查询
- 可以处理删除操作（使用带符号的计数）

### 四、滑动窗口模型

**问题描述：**
只关心最近W个元素的统计特性，更早的数据被丢弃。

**挑战：**
- 无法存储所有W个元素
- 需要及时更新统计信息

**DGIM算法（用于计数）：**

**基本思想：**
- 将窗口划分为桶（bucket）
- 每个桶代表一段连续的1
- 桶的大小是2的幂次
- 维护O(log W)个桶

**桶的性质：**
1. 每种大小的桶最多2个
2. 桶按时间戳排序
3. 最老的桶可能不完整

**查询操作：**
统计窗口内1的个数 ≈ 完整桶的大小之和 + 半个最老桶

**误差保证：**
- 相对误差：最多50%
- 可以通过增加每种大小桶的数量来降低误差

**应用扩展：**
- 滑动窗口中的平均值
- 滑动窗口中的中位数（近似）
- 滑动窗口中的distinct计数

---

## 第四讲 分布式数据流

### 一、分布式数据流模型

在分布式环境中，数据流分散在多个节点上，需要协调多个节点进行计算。

**系统架构：**
- **多个监测节点**：每个节点观察部分数据流
- **协调节点**：汇总和处理来自监测节点的信息
- **通信约束**：最小化节点间的通信量

**挑战：**
- 数据分散性
- 通信开销
- 同步问题
- 节点故障

**典型场景：**
- 分布式网络监控
- 多数据中心的日志分析
- 边缘计算
- CDN流量统计

### 二、聚集查询

**问题定义：**
计算分布在多个节点上的数据的聚集函数（如SUM、COUNT、AVG）。

**基本方法：**

**1. 连续聚集：**
- 每个节点维护本地的统计信息
- 周期性发送给协调节点
- 协调节点汇总计算全局结果

**2. 快照聚集：**
- 在特定时刻获取全局快照
- 需要处理同步问题
- 使用逻辑时钟或物理时钟

**优化技术：**

**采样与估计：**
- 不发送所有数据，只发送样本
- 使用统计方法估计全局结果
- 权衡精度和通信开销

**增量更新：**
- 只发送变化部分
- 减少冗余通信
- 适用于变化缓慢的数据

**数据结构支持：**
- 使用Count-Min Sketch等概要结构
- 可以在协调节点合并
- 支持分布式查询

### 三、topk监控

**问题定义：**
实时监控分布式系统中全局的top-k元素（如最热门的k个商品、最活跃的k个用户）。

**挑战：**
- 全局top-k可能不在任何单个节点的局部top-k中
- 需要在精度和通信量之间平衡
- 数据分布可能高度倾斜

**解决方案：**

**1. 阈值算法：**
- 协调节点维护全局top-k的阈值θ
- 每个节点报告超过θ的元素
- 动态调整θ以平衡通信量

**算法流程：**
```
初始化：θ = 0
循环：
  1. 每个节点报告频率 > θ 的元素
  2. 协调节点更新全局top-k
  3. 计算新阈值θ（如第k大元素的频率）
  4. 将θ广播给各节点
```

**2. 采样方法：**
- 各节点以概率p采样元素
- 上传采样的数据到协调节点
- 基于采样数据估计全局top-k

**3. 层次化监控：**
- 构建监控树
- 中间节点聚合子节点的信息
- 减少单点通信压力

**性能优化：**
- **局部过滤**：只上传可能进入全局top-k的元素
- **批量通信**：积累一定数量的更新后批量发送
- **缓存机制**：利用时间局部性减少通信

**实际应用：**
- 实时热搜榜
- 分布式缓存的热点识别
- 网络安全中的异常检测
- 广告系统的CTR监控

---

## 第五讲 哈希

### 一、哈希函数和哈希表

哈希技术是一种通过哈希函数将数据映射到固定大小的表中的方法，实现快速的数据存储和检索。

**核心概念：**
- **哈希函数**：将任意大小的数据映射到固定大小的值
- **哈希表**：基于数组实现的数据结构，通过哈希函数计算索引位置
- **冲突处理**：当不同的键映射到相同位置时的解决策略
  - 链地址法（Chaining）
  - 开放地址法（Open Addressing）

**时间复杂度：**
- 平均情况：O(1) 查找、插入、删除
- 最坏情况：O(n)（当所有元素都冲突时）

### 二、布隆过滤器（Bloom Filter）

布隆过滤器是一种空间高效的概率型数据结构，用于判断一个元素是否在集合中。

**特点：**
- 可能产生假阳性（False Positive）：说存在但实际不存在
- 不会产生假阴性（False Negative）：说不存在就一定不存在
- 不支持删除操作（标准版本）

**应用场景：**
- 网页URL去重
- 垃圾邮件过滤
- 缓存穿透防护
- 大数据去重

**工作原理：**
1. 使用k个不同的哈希函数
2. 将元素映射到位数组的k个位置
3. 查询时检查这k个位置是否都为1

### 三、最小哈希和LSH（Locality-Sensitive Hashing）

**最小哈希（MinHash）：**
用于估计两个集合的Jaccard相似度，常用于文档去重和相似度检测。

**局部敏感哈希（LSH）：**
一种降维技术，使得相似的数据项以高概率被映射到相同的桶中。

**应用：**
- 近似最近邻搜索
- 图像相似度检测
- 文本去重
- 推荐系统

---

## 第六讲 线性规划与整数规划

- 线性规划问题研究在资源约束条件下的最大化或最小化目标问题,表示方式有**标准型和松弛型**,单纯形算法来求解线性规划问题
- 整数规划比线性规划有更多约束条件
- 分支界定法是解决整数规划问题的有效方法，但是当**变量数量多**的时候效率会下降
- 切平面法是解决整数规划问题的有效方法

### 一、线性规划:单纯形算法

#### 1. 线性函数与线性规划

**线性函数的定义:**

给定一组实数 $a_1, a_2, ..., a_n$ 和一组变量 $x_1, x_2, ..., x_n$,定义在这些变量上的线性函数为:

$$f(x_1, x_2, ..., x_n) = a_1x_1 + a_2x_2 + ... + a_nx_n$$

**线性约束的定义:**

如果 $b$ 是一个实数,而 $f$ 是一个线性函数,则:

- $f(x_1, x_2, ..., x_n) = b$ 是**线性等式**
- $f(x_1, x_2, ..., x_n) \geq b$ 和 $f(x_1, x_2, ..., x_n) \leq b$ 是**线性不等式**

线性约束表示线性等式或者线性不等式。

**线性规划问题的定义:**

一个线性规划问题是指:一个线性函数最小化或最大化的问题,该线性函数服从一组有限个线性约束。

可以分为:

- **最小化线性规划** vs. **最大化线性规划**

**线性规划的几何意义:**

- **可行解**:满足所有约束条件的 $x_1, x_2$ 的取值称为一个可行解
- **可行区域**:所有可行解构成的区域

**示例:**

$$
\begin{align}
\text{最大化} \quad & x_1 + x_2 \\
\text{满足约束条件:} \quad & 4x_1 - x_2 \leq 8 \\
& 2x_1 + x_2 \leq 10 \\
& 5x_1 - 2x_2 \geq -2 \\
& x_1, x_2 \geq 0
\end{align}
$$

在图示中,可行区域为一个多边形区域,最优解 $x_1 + x_2 = 8$ 出现在可行域的**顶点**处。

**重要性质:** 线性规划的最优解通常出现在可行域的顶点处。

---

#### 2. 线性规划转标准型

**标准型的定义:**

已知 $n$ 个实数 $c_1, c_2, ..., c_n$;   $m$ 个实数 $b_1, b_2, ..., b_m$;   以及 $mn$ 个实数 $a_{ij}$,  其中 $i = 1,2,...,m$;$j = 1,2,...,n$。需要找到 $n$ 个实数 $x_1, x_2,...,x_n$。

**一般形式:**

$$
\begin{align}
\text{最大化} \quad & c_1x_1 + c_2x_2 + ... + c_nx_n \quad \text{(目标函数)} \\
\text{满足约束条件:} \quad & a_{i1}x_1 + a_{i2}x_2 + ... + a_{in}x_n \leq b_i \quad (i = 1,2,...,m) \quad \text{(约束)} \\
& x_j \geq 0 \quad (j = 1,2,..., n) \quad \text{(非负约束)}
\end{align}
$$

**矩阵表示形式:**

构造:

- $m \times n$ 矩阵 $A = (a_{ij})$
- 一个 $m$ 维向量 $b = (b_i)$
- 一个 $n$ 维向量 $c = (c_i)$
- 一个 $n$ 维向量 $x = (x_i)$

标准型可表示为:

$$
\begin{align}
\text{最大化} \quad & c^Tx \quad \text{(目标函数)} \\
\text{满足约束条件:} \quad & Ax \leq b \quad \text{(约束)} \\
& x \geq 0 \quad \text{(非负约束)}
\end{align}
$$

可用元组 **(A, b, c)** 表达一个标准的线性规划问题。

**标准型的特点:**

- 目标函数是**最大化**
- 所有约束都是**不等式**(小于等于号)
- 所有变量都有**非负约束**

---

**转换为标准型的技巧:**

一个线性规划问题可能不是标准型,可能的原因及解决方法包括:

**(1)目标函数是最小化而非最大化**

**解决方法:** 将目标函数中的系数取负数

**示例:**

$$
\begin{aligned}
\text{最小化} \quad & -2x_1 + 3x_2 \\
\text{满足约束:} \quad & x_1 + x_2 = 7 \\
& x_1 - 2x_2 \leq 4 \\
& x_1 \geq 0
\end{aligned}
\quad \rightarrow \quad
\begin{aligned}
\text{最大化} \quad & 2x_1 - 3x_2 \\
\text{满足约束:} \quad & x_1 + x_2 = 7 \\
& x_1 - 2x_2 \leq 4 \\
& x_1 \geq 0
\end{aligned}
$$

---

**(2)变量不具有非负约束**

**解决方法:** 将该变量 $x_j$ 每次出现的地方都改为 $x_j' - x_j''$,且 $x_j'$ 和 $x_j''$ 均 $\geq 0$

**示例:**

$$
\begin{aligned}
\text{最大化} \quad & 2x_1 - 3x_2 \\
\text{满足约束:} \quad & x_1 + x_2 = 7 \\
& x_1 - 2x_2 \leq 4 \\
& x_1 \geq 0
\end{aligned}
\quad \rightarrow \quad
\begin{aligned}
\text{最大化} \quad & 2x_1 - 3x_2' + 3x_2'' \\
\text{满足约束:} \quad & x_1 + x_2' - x_2'' = 7 \\
& x_1 - 2x_2' + 2x_2'' \leq 4 \\
& x_1, x_2', x_2'' \geq 0
\end{aligned}
$$ {e}

---

---

**(3)可能有等式约束**

**解决方法:** 转化成一对不等式

**示例:**

$$
\begin{aligned}
\text{最大化} \quad & 2x_1 - 3x_2' + 3x_2'' \\
\text{满足约束:} \quad & x_1 + x_2' - x_2'' = 7 \\
& x_1 - 2x_2' + 2x_2'' \leq 4 \\
& x_1, x_2', x_2'' \geq 0
\end{aligned}
\quad \rightarrow \quad
\begin{aligned}
\text{最大化} \quad & 2x_1 - 3x_2' + 3x_2'' \\
\text{满足约束:} \quad & x_1 + x_2' - x_2'' \leq 7 \\
& x_1 + x_2' - x_2'' \geq 7 \\
& x_1 - 2x_2' + 2x_2'' \leq 4 \\
& x_1, x_2', x_2'' \geq 0
\end{aligned}
$$

---

**(4)可能有不等式约束,但不是小于等于号,而是大于等于号**

**解决方法:** 更改约束的符号(两边同时乘以 $-1$)

**示例:**

$$
\begin{aligned}
\text{最大化} \quad & 2x_1 - 3x_2' + 3x_2'' \\
\text{满足约束:} \quad & x_1 + x_2' - x_2'' \leq 7 \\
& x_1 + x_2' - x_2'' \geq 7 \\
& x_1 - 2x_2' + 2x_2'' \leq 4 \\
& x_1, x_2', x_2'' \geq 0
\end{aligned}
\quad \rightarrow \quad
\begin{aligned}
\text{最大化} \quad & 2x_1 - 3x_2' + 3x_2'' \\
\text{满足约束:} \quad & x_1 + x_2' - x_2'' \leq 7 \\
& -x_1 - x_2' + x_2'' \leq -7 \\
& x_1 - 2x_2' + 2x_2'' \leq 4 \\
& x_1, x_2', x_2'' \geq 0
\end{aligned}
$$

---

#### 3. 线性规划转松弛型

**松弛型的定义:**

**松弛型(Slack Form)**:约束都是等式(除了要求变量非负的约束)

**标准型 vs 松弛型:**

- **标准型**:所有的约束都是不等式
- **松弛型**:约束都是等式(除了要求变量非负的约束)

---

**引入松弛变量:**

通过引入新变量,将不等式改变成等式:

$$\sum_{j=1}^{n} a_{ij}x_j \leq b_i \quad \rightarrow \quad s = b_i - \sum_{j=1}^{n} a_{ij}x_j, \quad s \geq 0$$

称 $s$ 为**松弛变量**,因为它度量了以上不等式左右两边的松弛或差别。

---

**更简洁的表示:**

去除关于"最大化"、"满足约束"这些词,直接写成等式形式。

**示例:**

原标准型:

$$
\begin{align}
\text{最大化} \quad & 2x_1 - 3x_2 + 3x_3 \\
\text{满足约束条件:} \quad & x_1 + x_2 - x_3 \leq 7 \\
& -x_1 - x_2 + x_3 \leq -7 \\
& x_1 - 2x_2 + 2x_3 \leq 4 \\
& x_1, x_2, x_3 \geq 0
\end{align}
$$

转换为松弛型(引入松弛变量 $x_4, x_5, x_6$):

$$
\begin{align}
z &= 2x_1 - 3x_2 + 3x_3 \\
x_4 &= 7 - x_1 - x_2 + x_3 \\
x_5 &= -7 + x_1 + x_2 - x_3 \\
x_6 &= 4 - x_1 + 2x_2 - 2x_3
\end{align}
$$

**重要概念:**

- **等式左边:基本变量**(在等式左边的变量)
- **等式右边:非基本变量**(在等式右边的变量)

---

**松弛型的元组表示:**

可用元组 **(N, B, A, b, c, v)** 表示松弛型。

**示例:**

$$
\begin{align}
z &= 28 - \frac{x_3}{6} - \frac{x_5}{6} - \frac{2x_6}{3} \\
x_1 &= 8 + \frac{x_3}{6} + \frac{x_5}{6} - \frac{x_6}{3} \\
x_2 &= 4 - \frac{8x_3}{3} - \frac{2x_5}{3} + \frac{x_6}{3} \\
x_4 &= 18 - \frac{x_3}{2} + \frac{x_5}{2}
\end{align}
$$

**元组表示:**

- $B = \{1, 2, 4\}$(基本变量集合)
- $N = \{3, 5, 6\}$(非基本变量集合)
- $c = (c_3, c_5, c_6)^T = (-1/6, -1/6, -2/3)^T$
- $v = 28$

矩阵 $A$:

$$
A = \begin{pmatrix}
a_{13} & a_{15} & a_{16} \\
a_{23} & a_{25} & a_{26} \\
a_{43} & a_{45} & a_{46}
\end{pmatrix} = \begin{pmatrix}
1/6 & 1/6 & -1/3 \\
-8/3 & -2/3 & 1/3 \\
-1/2 & 1/2 & 0
\end{pmatrix}
$$

向量 $b$:

$$
b = \begin{pmatrix}
b_1 \\
b_2 \\
b_4
\end{pmatrix} = \begin{pmatrix}
8 \\
4 \\
18
\end{pmatrix}
$$

---

#### 4. 单纯形算法

**算法核心思想:**

单纯形算法的本质是从可行域的一个顶点出发,沿着目标函数值改进的方向移动到相邻顶点,直到找到最优解。

**基本解的概念:**

松弛型等式系统拥有无限个解。我们集中于**基本解**:

- 把等式右边所有(非基本)变量设为 $0$
- 再计算等式左边(基本)变量的值
- 再计算目标值

**每次迭代的目标:** 重新整理线性规划,使得基本解有一个更大的目标值。

---

**算法详细步骤(以最大化问题为例):**

**初始问题:**

$$
\begin{align}
\text{最大化} \quad z &= 3x_1 + x_2 + 2x_3 \\
\text{满足约束条件:} \quad & x_1 + x_2 + 3x_3 \leq 30 \\
& 2x_1 + 2x_2 + 5x_3 \leq 24 \\
& 4x_1 + x_2 + 2x_3 \leq 36 \\
& x_1, x_2, x_3 \geq 0
\end{align}
$$

**步骤1:转换为松弛型**

引入松弛变量 $x_4, x_5, x_6$:

$$
\begin{align}
z &= 3x_1 + x_2 + 2x_3 \\
x_4 &= 30 - x_1 - x_2 - 3x_3 \\
x_5 &= 24 - 2x_1 - 2x_2 - 5x_3 \\
x_6 &= 36 - 4x_1 - x_2 - 2x_3
\end{align}
$$

**初始基本解:**

- 基本解:$(\bar{x}_1, \bar{x}_2, ..., \bar{x}_6) = (0, 0, 0, 30, 24, 36)$
- 目标值:$z = 3 \times 0 + 1 \times 0 + 2 \times 0 = 0$

---

**步骤2:第一次迭代**

**观察分析:**

- 考虑增加 $x_1$ 的值(因为其系数为正,可以增加目标值),使所有值保持非负
- 从三个约束式可知:
  - $x_1$ 超过 $30$ 时,$x_4$ 变负
  - $x_1$ 超过 $12$ 时,$x_5$ 变负
  - $x_1$ 超过 $9$ 时,$x_6$ 变负
- 因此,$x_1$ 最多取 $9$,此时 $x_6 = 0$
- **互换 $x_1$ 和 $x_6$**($x_1$ 入基,$x_6$ 出基)

**第一次迭代后:**

$$
\begin{align}
z &= 27 + \frac{x_2}{4} + \frac{x_3}{2} - \frac{3x_6}{4} \\
x_1 &= 9 - \frac{x_2}{4} - \frac{x_3}{2} - \frac{x_6}{4} \\
x_4 &= 21 - \frac{3x_2}{4} - \frac{5x_3}{2} + \frac{x_6}{4} \\
x_5 &= 6 - \frac{3x_2}{2} - 4x_3 + \frac{x_6}{2}
\end{align}
$$

**新基本解:**

- 基本解:$(9, 0, 0, 21, 6, 0)$
- 目标值:$z = 27$

---

**步骤3:第二次迭代**

**观察分析:**

- 增加 $x_2$ 或 $x_3$ 都可增加目标值
- 设选择 $x_3$,从三个式子可知 $x_3$ 的最大值分别为 $18, 42/5, 3/2$
- 因此,选择第3个约束($x_3$ 最多取 $3/2$),围绕 $x_3$ 和 $x_5$ 进行转动
- **互换 $x_3$ 和 $x_5$**($x_3$ 入基,$x_5$ 出基)

**第二次迭代后:**

$$
\begin{align}
z &= \frac{111}{4} + \frac{x_2}{16} - \frac{x_5}{8} - \frac{11x_6}{16} \\
x_1 &= \frac{33}{4} - \frac{x_2}{16} + \frac{x_5}{8} - \frac{5x_6}{16} \\
x_3 &= \frac{3}{2} - \frac{3x_2}{8} - \frac{x_5}{4} + \frac{x_6}{8} \\
x_4 &= \frac{69}{4} + \frac{3x_2}{16} + \frac{5x_5}{8} - \frac{x_6}{16}
\end{align}
$$

---

**步骤4:第三次迭代**

**第三次迭代后:**

$$
\begin{align}
z &= 28 - \frac{x_3}{6} - \frac{x_5}{6} - \frac{2x_6}{3} \\
x_1 &= 8 + \frac{x_3}{6} + \frac{x_5}{6} - \frac{x_6}{3} \\
x_2 &= 4 - \frac{8x_3}{3} - \frac{2x_5}{3} + \frac{x_6}{3} \\
x_4 &= 18 - \frac{x_3}{2} + \frac{x_5}{2}
\end{align}
$$

**最终基本解:**

- 此时,基本解是 $(8, 4, 0, 18, 0, 0)$
- 目标值 $z = 28$
- **因为目标函数中所有非基本变量的系数都是负数,无法继续增加目标值,求解结束!**

**最优解:** $x_1 = 8, x_2 = 4, x_3 = 0$,最大值 $z = 28$

---

**算法总结:**

1. **转换为松弛型**:引入松弛变量将不等式转换为等式

2. **找到初始基本可行解**:将所有非基本变量设为 $0$

3. **检验是否最优**:检查目标函数中非基本变量的系数
   - 如果都 $\leq 0$(最大化问题),则达到最优
   - 如果都 $\geq 0$(最小化问题),则达到最优

4. **选择入基变量**:选择目标函数系数为正(最大化)或负(最小化)的非基本变量

5. **选择出基变量**:选择使入基变量取值最小的约束对应的基本变量

6. **基变换**:通过代数运算更新松弛型

7. **重复步骤3-6**:直到达到最优或判定无界

### 二、整数规划：问题定义

#### 1. 整数规划的基本概念

**整数规划的定义:**

**整数规划(Integer Programming, IP)** 是在线性规划基础上,要求部分或全部决策变量必须取整数值的优化问题。

**一般形式:**

$$
\begin{align}
\text{最大化(或最小化)} \quad & \sum_{i=1}^{n} c_ix_i \\
\text{满足约束条件:} \quad & \sum_{i=1}^{n} a_{ji}x_i \leq b_j \quad (j = 1,2,...,m) \\
& x_i \geq 0, \quad x_i \in \mathbb{Z} \quad (\text{部分或全部}\ i)
\end{align}
$$

---

**整数规划的分类:**

根据变量的整数要求不同,整数规划可分为三类:

**(1)混合整数规划(Mixed Integer Programming, MIP)**

部分变量必须是整数,部分变量可以是连续值。对部分域所有$x_i$,满足:$x_i \geq 0$且为整数。

**(2)纯整数规划(Pure Integer Programming, PIP)**

所有决策变量都必须取整数值。对每个$x_i$,满足:$x_i \geq 0$且为整数。

**(3)0-1整数规划(Binary Integer Programming)**

变量只能取0或1两个值,用于表示"是/否"决策。对每个$x_i$,满足:$x_i \in \{0,1\}$。

---

#### 2. 整数规划的实际应用示例

**运输问题:**

需要运输180台电视和110台洗衣机。有两种运输方式:

- **小型货车**:可装载20台电视和20台洗衣机,成本360元
- **大型卡车**:可装载40台电视和10台洗衣机,成本400元

**数学模型:**

$$
\begin{align}
\text{最小化} \quad & 360x_1 + 400x_2 \\
\text{满足约束条件:} \quad & 20x_1 + 40x_2 \geq 180 \\
& 20x_1 + 10x_2 \geq 110 \\
& x_1, x_2 \geq 0, \quad x_1, x_2 \in \mathbb{Z}
\end{align}
$$

其中$x_1$表示使用小型货车的数量,$x_2$表示使用大型卡车的数量。

---

#### 3. 整数规划的建模技术

**技术1:定义二元变量**

除了约定部分或所有变量必须为整数值之外,也允许定义二元变量,即:$x_i \in \{0,1\}$。

**优势**：能够引入逻辑约束

**示例**：假设$x_i \in \{0,1\}$:

- 如果选择了$x_1$,则不能选择$x_2$,那么可以表示成:$x_1 + x_2 \leq 1$;

- 如果选择了$x_1$,则必须选择$x_2$,那么可以表示成:$x_1 \leq x_2$;

- 必须选择$x_1$或$x_2$,或两者均选取,那么可以表示成:$x_1 + x_2 \geq 1$;

---

**技术2:限定变量的范围**

**目标**：限定变量$x$的范围是:$x \leq 2$或者$x \geq 6$

**方法:**

挑选一个二元变量$w = \begin{cases} 1, & x \leq 2 \\ 0, & x \geq 6 \end{cases}$

设定$M$是一个很大的数,转变成为IP约束:

$$
\begin{align}
x &\leq 2 + M(1-w) \\
x &\geq 6 - Mw \\
w &\in \{0,1\}
\end{align}
$$

**验证:**

- 如果$x \leq 2$,则令$w = 1$:约束变为$x \leq 2$和$x \geq 6 - M$(后者自动满足)
- 如果$x \geq 6$,则令$w = 0$:约束变为$x \leq 2 + M$(自动满足)和$x \geq 6$

在两种情况下,IP约束都被满足。

---

**技术3:表达复杂表达式之间的"或"关系**

**目标**：表达复杂表达式之间的"或"关系

**示例**：$x_1 + 2x_2 \geq 12$或$4x_2 - 10x_3 \leq 1$

**整数规划建模:**

$$
\begin{align}
x_1 + 2x_2 &\geq 12 - M(1-w) \\
4x_2 - 10x_3 &\leq 1 + Mw \\
w &\in \{0,1\}
\end{align}
$$

**验证:**

- 如果$w = 1$,则第一个约束生效:$x_1 + 2x_2 \geq 12$
- 如果$w = 0$,则第二个约束生效:$4x_2 - 10x_3 \leq 1$

---

**技术4:考虑分段线性函数**

**目标**：表达分段线性函数

**示例:**

$$
y = \begin{cases}
2x, & \text{if } 0 \leq x \leq 3 \\
9-x, & \text{if } 4 \leq x \leq 7 \\
-5+x, & \text{if } 8 \leq x \leq 9
\end{cases}
$$

**建模方法:**

每段分别定义$w_i$和$x_i$:

$$
w_1 = \begin{cases} 1, & 0 \leq x \leq 3 \\ 0, & \text{otherwise} \end{cases}, \quad
x_1 = \begin{cases} x, & 0 \leq x \leq 3 \\ 0, & \text{otherwise} \end{cases}
$$

类似地定义$w_2, x_2$和$w_3, x_3$

**约束系统:**

$$
\begin{align}
& 0 \leq x_1 \leq 3w_1, \quad w_1 \in \{0,1\} \\
& 4w_2 \leq x_2 \leq 7w_2, \quad w_2 \in \{0,1\} \\
& 8w_3 \leq x_3 \leq 9w_3, \quad w_3 \in \{0,1\} \\
& w_1 + w_2 + w_3 = 1 \\
& x = x_1 + x_2 + x_3 \\
& x_i \text{ integer } \forall i
\end{align}
$$

**最终表达式:**

$$y = 2x_1 + (9w_2 - x_2) + (-5w_3 + x_3)$$

---

#### 4. 整数规划问题求解:从两个变量开始

**案例问题:**

$$
\begin{align}
\text{Maximize: } z &= 3x + 4y \\
\text{Subject to: } & 5x + 8y \leq 24 \\
& x, y \geq 0, \quad x, y \in \mathbb{Z}
\end{align}
$$

**简单的解法:**

- 先求解线性规划(忽略整数要求),得到$x = 4.8, y = 0$和$z = 14.4$
- 四舍五入,得到$x = 5, y = 0$,但此解不可行!
- 取整,得到$x = 4, y = 0$,且$z = 12$。该解与$x = 0, y = 3$时的解值相同。

**最优解:**$x = 3, y = 1$,且$z = 13$

**结论:**

- Q1:最优整数解是什么? $(3, 1)$
- Q2:能否使用线性规划来解决整数规划问题? 不能直接使用,需要专门的算法

### 三、整数规划：分支界定法（Branch and Bound）

#### 1. 枚举树 - 完全枚举思想

**0-1背包问题示例:**

有6件物品,背包容量不超过14,求最大利用率:

| 物品 | iPad | server | Brass Rat | Au Bon Pain | 6.041 tutoring | 15.053 dinner |
|------|------|--------|-----------|-------------|----------------|---------------|
| 价格 | 5 | 7 | 4 | 3 | 4 | 6 |
| 利用率 | 16 | 22 | 12 | 8 | 11 | 19 |

**数学模型:**
$$
\begin{align}
\text{Maximize: } & 16x_1 + 22x_2 + 12x_3 + 8x_4 + 11x_5 + 19x_6 \\
\text{Subject to: } & 5x_1 + 7x_2 + 4x_3 + 3x_4 + 4x_5 + 6x_6 \leq 14 \\
& x_i \in \{0,1\} \quad \text{for } 1 \leq i \leq 6
\end{align}
$$

**枚举法分析:**

- 考虑决策变量的所有可能值,即:$n \rightarrow 2^n$
- 想法:将问题分成两部分迭代。首次迭代时,考虑$x_1 \in \{0,1\}$的情况
- 树中的每个节点代表原始问题加上额外的约束条件

![](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAMjaVoBTouvp1AvSDp_b3CmLWbTp4EAApsNaxtn5tFW6-nZU-GZ9swBAAMCAAN3AAM4BA.png)

**枚举树基本概念:**

- **节点2和节点3**被称为枝举树中节点1的**子节点**
- **IP(1)** 是原始的整数规划问题
- **IP(2)** 通过向IP(1)添加约束条件"$x_1 = 0$"得到
- **IP(3)** 通过向IP(1)添加约束条件"$x_1 = 1$"得到
- **IP(1)的最优解**可以通过从IP(2)和IP(3)中选取最好的解来获得（*整数解*）
- **最优解也可能**在IP(2)和IP(3)两个分支中

#### 2. 整数规划线性松弛

**线性松弛(LP relaxation)的定义:**

如果去掉变量必须为整数的要求,就称其为整数规划问题的**线性松弛**。

**背包问题的线性松弛:**

$$
\begin{align}
\text{最大化: } & 24x_1 + 2x_2 + 20x_3 + 4x_4 \\
\text{约束条件: } & 8x_1 + 1x_2 + 5x_3 + 4x_4 \leq 9 \\
& 0 \leq x_i \leq 1, \quad \text{对于 } 1 \leq i \leq 4
\end{align}
$$

**贪心算法求解:**

背包问题的线性松弛可以通过"贪心算法"来求解:

可以将目标函数看作是美元金额,并将约束条件视为对重量的限制。

| item | 1 | 2 | 3 | 4 |
|------|---|---|---|---|
| value/lb. | \$3 | \$2 | \$4 | \$1 |

**求解策略:**

如果按照每磅价值从高到低依次将物品放入背包,会得到什么结果?

通过求解每个整数规划问题的线性松弛,可为每个整数规划问题得到一个界限。

**（1） LP(k)的求解结果会给出一个具体的界限值。**

**示例:LP(4)的求解**

$$
\begin{align}
\text{Maximize: } & 24x_1 + 2x_2 + 20x_3 + 4x_4 \\
\text{Subject to: } & 8x_1 + 1x_2 + 5x_3 + 4x_4 \leq 9 \\
& x_1 = 0, x_2 = 0 \\
& 0 \leq x_i \leq 1 \text{ for } 3 \leq i \leq 4
\end{align}
$$

- LP(4)的最优解:$x_1 = 0, x_2 = 0, x_3 = 1, x_4 = 1, z = 24$
- 如果LP(k)的最优解对于IP(k)也是可行的,那么它也是IP(k)的最优解

**重要性质:**

对于所有$j$来说,$z_{IP}(j) \leq z_{LP}(j)$,例如:$z_{IP}(1) \leq 32$

不直接求解IP(k),而是求其线性松弛(LP relaxation),以获得边界值。

**（2）当前最优解(incumbent)的定义:**

算法偶然找到的、具有最佳目标函数值的可行整数解。

**注意**：当前最优解是整数规划问题的一个可行解,且是迄今为止找到的最佳解。

**LP(1)的求解:**

$$
\begin{align}
\text{Maximize: } & 24x_1 + 2x_2 + 20x_3 + 4x_4 \\
\text{Subject to: } & 8x_1 + 1x_2 + 5x_3 + 4x_4 \leq 9 \\
& 0 \leq x_i \leq 1 \text{ for } i = 1 \text{ to } 4
\end{align}
$$

- LP(1)的最优解:$x_1 = 1/2, x_2 = 0, x_3 = 1, x_4 = 0, z = 32$

**重要观察:**

对于所有$j$来说,$z_{IP}(j) \leq z_{LP}(j)$,例如:$z_{IP}(1) \leq 32$

**（3） 剪枝**

**推论**：如果$z_{LP}(k) \leq z_I$,可以剪枝活动节点$k$的IP(k),其中$z_I$是当前最优解的目标函数值。

**活动节点**：节点尚未被剪枝,并且LP(k)还没有被解出来

**LP(2)的分析:**

$$
\begin{align}
\text{Maximize: } & 24x_1 + 2x_2 + 20x_3 + 4x_4 \\
\text{Subject to: } & 8x_1 + 1x_2 + 5x_3 + 4x_4 \leq 9 \\
& x_1 = 0 \\
& 0 \leq x_i \leq 1 \text{ for } i = 2 \text{ to } 4
\end{align}
$$

- LP(2)的最优解为:$z_{LP}(2) = 25$
- 假设我们已经知道了一组解:$x_1 = 1, x_2 = 1, x_3 = 0, x_4 = 0, z_I = 26$,则可以剪枝LP(2)

---

#### 3. 分支界定算法的完整流程

**在什么条件下,我们不能从最大化的分支定界树中剪枝活动节点$j$?**

**算法伪代码:**

```
while there is some active nodes do
    select an active node j
    mark j as inactive
    Solve LP(j): denote solution as x(j);
    Case 1 -- if z_LP(j) ≤ z_I then prune node j;
    Case 2 -- if z_LP(j) > z_I and
              if x(j) is feasible for IP(j)
              then Incumbent := x(j), and z_I := z_LP(j);
              then prune node j;
    Case 3 -- if z_LP(j) > z_I and
              if x(j) is not feasible for IP(j) then
              mark the children of node j as active
endwhile
```

**中文说明:**

当存在某些活动节点时,执行以下操作:
- 选择一个活动节点$j$
- 将$j$标记为不活动
- 求解LP(j):令$x(j)$表示解决方案;
- **情况1**--如果$z_{LP}(j) \leq z_I$,则剪枝节点$j$;
- **情况2**--如果$z_{LP}(j) > z_I$且$x(j)$是IP(j)的可行解,则Incumbent $:= x(j)$,$z_I := z_{LP}(j)$;然后剪枝节点$j$;
- **情况3**--如果$z_{LP}(j) > z_I$且$x(j)$不是IP(j)可行解,则标记节点$j$的子节点为活动节点

结束循环

---

#### 4. 分支界定法案例

![](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAMkaVoGiOWpcgq6az-mMRXSFgP_1cQAArsNaxtn5tFWpVsQCV-DqPwBAAMCAAN4AAM4BA.png)

**初始状态:LP(1)**
$$
\begin{align}
\text{Maximize: } & 24x_1 + 2x_2 + 20x_3 + 4x_4 \\
\text{Subject to: } & 8x_1 + 1x_2 + 5x_3 + 4x_4 \leq 9 \\
& 0 \leq x_i \leq 1 \text{ for } i = 1 \text{ to } 4
\end{align}
$$

- 没有当前最优解,$z_I = -\infty$
- LP(1)的最优方案是:$x_1 = 1/2, x_2 = 0, x_3 = 1, x_4 = 0, z_{LP}(2) = 32$

**分支到LP(2):**

- LP(2)的最优方案是:$x_1 = 0, x_2 = 1, x_3 = 1, x_4 = 3/4, z_{LP}(2) = 25$

**分支到LP(3):**

- 没有当前最优解,$z_I = -\infty$,$z_{LP}(1) = 32$
- LP(3)的最终方案是:$x_1 = 1, x_2 = 0, x_3 = 1/5, x_4 = 0, z_{LP}(3) = 28$

**分支到LP(4):**

- 没有当前最优解,$z_I = -\infty$,$z_{LP}(1) = 32$
- LP(4)的最优解:$x_1 = 0, x_2 = 0, x_3 = 1, x_4 = 1, z_{LP}(4) = 24$
- **剪枝完毕(因为都是整数)**，更新$z_I = 24$

**分支到LP(5):**

- 最优可行解$z_I = 24$
- LP(5)的最终方案是:$x_1 = 0, x_2 = 1, x_3 = 1, x_4 = 3/4, z_{LP}(5) = 25$

**分支到LP(6):**

- 当前最优解$z_I = 24$
- LP(6)的最优方案是:$x_1 = 1, x_2 = 0, x_3 = 1/5, x_4 = 0, z_{LP}(6) = 28$

**分支到LP(7):**

- 当前最优解$z_I = 24$
- LP(7)的最优解:$x_1 = 1, x_2 = 1, x_3 = 0, x_4 = 0, z_{LP}(7) = 26$
- **剪枝完毕(界限剪枝)**

**分支到LP(8):**

- 当前最优解$z_I = 26$  **(更新)**
- LP(8)的最优解:$x_1 = 0, x_2 = 1, x_3 = 1, x_4 = 1, z_{LP}(8) = 6$
- **子树剪枝(界限剪枝,因为$z_{LP}(8) < z_I$)**

**分支到LP(9):**

- 当前最优解$z_I = 26$
- LP(9)的最优解:$x_1 = 0, x_2 = 1, x_3 = 1, x_4 = 3/4, z_{LP}(9) = 25$
- **子树剪枝(界限剪枝,因为$z_{LP}(9) < z_I$)**

**分支到LP(10):**

- 当前最优解$z_I = 26$
- LP(10)的最优解:$x_1 = 1, x_2 = 0, x_3 = 0, x_4 = 1/4, z_{LP}(10) = 25$
- **子树剪枝(界限剪枝,因为$z_{LP}(10) < z_I$)**

**最终分支LP(11):**

- 当前最优解$z_I = 26$
- LP(11)的最优解:**无可行解,可被剪枝**
- **剪枝完毕(不可行剪枝)**

**最终结果:**

- 最优整数解:$x_1 = 0, x_2 = 1, x_3 = 1, x_4 = 1, z^* = 26$
---

#### 5. 分支界定法的经验总结

**算法优势:**

- 分支定界法可以加快搜索速度,仅解决**部分节点**的线性规划问题

**算法局限:**

- 分支定界法依赖于**剪枝子树**,这可能是因为节点处的整数规划(IP)问题已经被解决,或者因为该IP解不可能是最优解
- 当变量很多时,完全枚举不可能负担(即使是仅50个变量也有很大消耗)

**加速技巧:**

- **技巧一**：能够"智能地"选择最佳分支变量的启发式规则
- **技巧二**：使用"取整",例如,将非整数解通过向上或向下取整转换为整数解,以此来快速获得可行解,从而缩小搜索范围
- **示例:**$x_1 + x_2 \leq 1.5 \rightarrow x_1 + x_2 \leq 1$,or $z_{IP} \leq z_{LP} = 5.5 \rightarrow z_{IP} \leq 5$

### 四、整数规划：切平面法（Cutting Plane Method）

#### 1. 有效不等式(Valid Inequalities)

**定义:**

整数规划(IP)的有效不等式是指任何**不会排除任何可行整数解**的约束条件。

**示例问题:**

最大化目标函数:$z = 3x + 4y$

约束条件:$5x + 8y \leq 24$
$0 \leq x, y \in \mathbb{Z}$(即x和y都是非负整数)

**有效不等式的特点:**

- 约束条件$x \leq 5$是一个有效不等式
- 约束条件$x \leq 4$同样是一个有效不等式
- 整数规划的一个有效不等式也被称为**切割平面**或**切面**

**目标:**

希望找到能排除部分线性规划可行区域的切割平面。

![有效不等式图示](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAMlaVoR1E2YTnF2FhTwYl6bxsZpUzoAAvQNaxtn5tFW7ufGbh4AAcs6AQADAgADeQADOAQ.png)

---

#### 2. 取整(Rounding)技术

**基本原理:**

一个分数形式的整数变量**边界可以被截断**。

**示例:**

$x \leq 1.5 \rightarrow x \leq 1$

**整数系数约束的取整:**

给定一个涉及所有整数变量且系数也为整数的约束条件:

$3x + 6y + 9z \leq 11$ 可以转化为 $x + 2y + 3z \leq \lfloor 11/3 \rfloor = 3$

**非负整数变量约束的取整:**

对于涉及非负整数变量的约束条件:

$\sum a_i x_i \leq b$ 可以转化为 $\sum \lfloor b/a_i \rfloor x_i \leq \lfloor b \rfloor$

**注意事项:**

注意左边是整数,因此右边也可以被截断,但这并不一定比原始约束条件更严格。

---

#### 3. Gomory切割(Gomory Cuts)

**定义:**

Gomory切割用于**向所有整数规划问题(IPs)中添加有效不等式**(也称为切割),对于**改进界限**非常有用。

**核心思想:**

Gomory切割是从线性规划(LP)松弛的最优单纯形表中的单个约束条件获得的。

**假设前提:**

这里假设所有变量必须取整数值。

**情况一:所有左侧系数都在0到1之间**

约束形式:$0.2x_1 + 0.3x_2 + 0.3x_3 + 0.5x_4 + x_5 = 1.8$

有效不等式(忽略来自$x_5$的贡献):

$0.2x_1 + 0.3x_2 + 0.3x_3 + 0.5x_4 \geq 0.8$

这种有效不等式通过从最优解中提取信息并创建新的约束条件,有助于排除非整数解,从而提高求解效率。

**情况二:所有左边的系数都是非负的**

约束形式:$1.2x_1 + 0.3x_2 + 2.3x_3 + 2.5x_4 + x_5 = 4.8$

有效不等式(focus on fractional parts):

$0.2x_1 + 0.3x_2 + 0.3x_3 + 0.5x_4 \geq 0.8$

**情况三:通用情况**

约束形式:$1.2x_1 - 1.3x_2 - 2.4x_3 + 11.8x_4 + x_5 = 2.9$

向下取整(特别担心负数):

$1x_1 - 2x_2 - 3x_3 + 11x_4 + x_5 \leq 2$

有效不等式(前面两个式子相减):

$0.2x_1 + 0.7x_2 + 0.6x_3 + 0.8x_4 \geq 0.9$

---

#### 4. 凸包(Convex Hull)

**定义:**

凸包是包含所有整数解的最小线性规划可行区域。

**示例1:**

最大化:$z = 3x + 4y$

约束条件:$5x + 8y \leq 24$ 
$0 \leq x, y \in \mathbb{Z}$

**添加凸包** ：  $ x + y ≤ 4,2x + 3y ≤ 9$

![凸包图示1](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAMmaVoTIED8Jx_l_NbxNkksTOwvIg4AAvoNaxtn5tFWthiy-L85d48BAAMCAAN4AAM4BA.png)

**示例2:**

最大化:$z = x + y$

约束条件:$-5x + 4y \leq 0$
$6x + 2y \leq 17$
$0 \leq x, y \in \mathbb{Z}$

使用取整技术添加约束条件： $x ≤ 2,y ≤ x$

![凸包图示2](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAMnaVoUFo5v-hVxICr6VmaZhEmAnrQAAvwNaxtn5tFWcVULVP5ieN8BAAMCAAN5AAM4BA.png)

---

#### 5. 切平面算法

**算法步骤:**

**步骤1**：求解线性规划松弛问题

**步骤2**：如果线性规划解是整数解,则它是原始问题的最优解。任务完成!

**步骤3**：如果线性规划解不是整数解,找到一个线性约束条件,该条件**排除线性规划解**但不排除任何整数点(总是可能的);

**步骤4**：加入切割约束条件;

**步骤5**：返回步骤1。

---

#### 6. 切平面法案例详解

**初始问题:**

最大化:$z = x + y$

约束条件:$-5x + 4y \leq 0$
$6x + 2y \leq 17$
$0 \leq x, y \in \mathbb{Z}$

有效不等式:$0 \leq x, y \in \mathbb{Z}$

最优解 = 4.5（$x = 2,y=2.5$）

![初始问题图示](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAMqaVoVlJHCGdBIm-27MjKILL7tAAEfAAMOaxtn5tFWlQVbfx2xXokBAAMCAAN4AAM4BA.png)

**迭代1:添加约束y ≤ 2**

- 最优解 z = 4.1667（$x = 13/6,y=2$）
- 移除整数约束以获得线性松弛
- 最优解是对最优成本的一个上界
- 如果解是整数,则它是原始问题的最优解

![迭代1图示](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAMsaVoXTU7vQnKpXJjsmMcRVQg_C7EAAgYOaxtn5tFW3pbpHT5zMDsBAAMCAAN4AAM4BA.png)

**分析:**

约束条件$y \leq 2$是一个有效的切割,因为它排除了最优的线性规划解,但没有排除任何整数点。

现在求解这个新问题的线性规划松弛。

一个切割必须同时排除线性规划解,同时保留所有可行的整数点。至少存在一个有效的切割。

*此时，仍然有变量不完全是整数。再加一个切割！*

**迭代2:添加约束x ≤ 2**

最大化:$z = x + y$

约束条件:$-5x + 4y \leq 0$
$6x + 2y \leq 17$
$y \leq 2$
$x \leq 2$
$0 \leq x, y \in \mathbb{Z}$

最优解:$ x = 2, y = 2, z = 4$

![最终解图示](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAMpaVoVT_stb7HITVRFa9qYrbd-3aYAAv8Naxtn5tFWCWS5apr0heUBAAMCAAN5AAM4BA.png)

*线性规划的解都是整数，因此也是整数规划问题的最优解*

---

#### 7. 切平面法的特点总结

**算法优势:**

- 通过添加切割约束逐步收紧可行域
- 每次迭代都会改进上界
- 最终必定收敛到整数最优解

**算法局限:**

- 可能需要多次迭代
- 每次迭代需要求解一个线性规划问题
- 选择合适的切割平面需要一定技巧

**与分支界定法的比较:**

- 切平面法通过添加约束收紧可行域
- 分支界定法通过分支和剪枝搜索解空间
- 实际应用中常将两种方法结合使用(分支切割法)

---

## 第七讲 内存计算

### 一、海量内存概述

#### 1. 传统数据处理模式 vs 内存数据处理模式

**传统数据处理模式：**

- CPU与内存之间频繁交互
- 内存与磁盘(硬盘)之间存在I/O瓶颈
- 数据需要从磁盘加载到内存，处理后再写回磁盘
- **I/O操作**成为性能瓶颈

**内存数据处理模式：**

- CPU**直接与内存交互**，减少I/O操作
- 数据主要存储和处理都在内存中完成
- 大幅减少或消除磁盘I/O瓶颈
- 显著提升数据处理速度

**核心理念：** Jim Gray在2006年提出的著名观点：

- "Tape is Dead"（磁带已死）
- "Disk is Tape"（磁盘就是磁带）
- "Flash is Disk"（闪存就是磁盘）
- "RAM Locality is King"（**内存局部性为王**）

**解释：** 随着技术发展，存储介质的角色在不断演变。**内存**成为数据处理的核心，其他存储介质逐渐降级为备份或归档用途。

#### 2. 海量内存技术的发展趋势

**硬件发展：**

- **存储器芯片集成度**不断提高
- 内存价格持续下降（如图所示，从1955年到2020年呈指数级下降）
- 内存容量大幅增长，使得海量数据内存处理成为可能

**新型硬件架构：**

- **3D XPoint™ Technology**（英特尔傲腾技术）等新型存储技术的出现

**带来的机遇与挑战：** 海量内存给传统的数据管理、数据挖掘方法带来了新的机遇和挑战，需要重新设计算法和系统架构。

#### 3. 内存计算的优势

根据Aberdeen Group 2011年的研究数据对比：

![](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAMtaVoeE59BlQfj4t0X4ahe8HAKTqMAAiwOaxtn5tFW1WsewFiTD8sBAAMCAAN5AAM4BA.png)

| 性能指标                      | 使用内存计算 (n=33) | 不使用 (n=163)     | 内存计算优势      |
| ----------------------------- | ------------------- | ------------------ | ----------------- |
| **活跃业务数据量（中位数）**  | 38 TB               | 18 TB              | **2.1倍数据量**   |
| **分析数据量（中位数）**      | 14 TB (37%全部数据) | 4 TB (22%全部数据) | **3.5倍数据量**   |
| **数据分析/查询平均响应时间** | 42秒                | 75分钟             | **107倍速度提升** |
| **每小时处理数据量**          | 1200 TB             | 3.2 TB             | **375倍效率提升** |

**主要优势：**

1. **消除了磁盘的I/O瓶颈**
2. **提高了单位时间内数据处理的能力与数据访问速度**
3. **实现了对大规模海量数据的实时分析和运算**
4. **提升数据挖掘的效率和准确度**

### 二、基于单机版内存增大优势

#### 1.关联规则

**购物篮模型**：从庞大的消费者记录中抽取关于**购物模式的信息**。

- 频繁项集是购物篮模型最基本的问题——
  - 哪些商品经常被消费者同时购买（营销）
  - 也被称为"关联规则"
  - 从病例中寻找患某种疾病的病人的共同特征等。

**关联规则挖掘**：发现大量数据中**项集之间的相关联系**，是数据挖掘中最活跃的研究领域之一。

**关联规则定义**：设I = {I₁, I₂, ..., Iₘ}是一个项目的集合，事务tᵢ(i = 1,2,...,n)是I的一个子集，则由一系列具有唯一标识TID的事务组成的D = {t₁, t₂, ..., tₙ}称为事务数据库。

![](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAMuaVpJOJXGp6bmdSq9xPErzavBbpkAAlgLaxtn5tlW-LoCJ-HaN-IBAAMCAAN5AAM4BA.png)

关联规则形如X ⇒ Y的蕴含式，X ⊆ I，Y ⊆ I，X∩Y = ∅。

![](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAMvaVpJz1bgQe-NDV3fv9FOJiMvM70AAl0Laxtn5tlW8LqsxQABEw8xAQADAgADeAADOAQ.png)

**度量指标**：

- 支持度(support)：support(面包,牛奶,尿布) = 2/5，计算公式为同时购买面包,牛奶,尿布的记录数/数据集记录总数
- 置信度(confidence)：confidence(面包⇒牛奶,尿布) = 2/4，计算公式为同时购买面包,牛奶,尿布的记录数/数据集中购买面包的记录数

**关联规则挖掘包含两个子问题**：

- ①发现**频繁项目集**(基础和研究重点)：寻找所有满足支持度不小于用户给定的minsupport的项目集
- ②生成关联规则：在已经发现的最大频繁项目集中，寻找置信度不小于用户给定的minconfidence的关联规则（一条规则的置信度很容易从支持度计数中推出；生成关联规则相对简单，且在内存、I/O、算法效率上的改进余地不大）

#### 2.Apriori算法

**基本信息**：最经典的关联规则挖掘算法，由Agrawal等人于1993年提出。

**基本思路**：逐层迭代，通过连接和剪枝来生成频繁项集。流程为：数据库 → 候选1-项集 →(剪枝)→ 频繁1-项集 →(连接)→ 候选2-项集 → ... → 频繁k-项集

**两条定理——先验性质**：

- 如果一个集合是频繁项集，则它的所有子集都是频繁项集
- 如果一个集合不是频繁项集，则它的所有超集都不是频繁项集

**基本步骤**：

1. 假设规模为k的频繁项集为Lₖ，它的候选项集为Cₖ。
2. 扫描数据库，对每一项进行累加计数，寻找规模为1的满足minsupport的频繁项集，然后迭代进行以下三步操作，生成所有的频繁项集：
   - ①从规模为k的频繁项集中生成规模为k+1的频繁项集的候选集Cₖ₊₁；
   - ②扫描数据库，计算候选项集中每一个候选的支持度；
   - ③将满足最小支持度的项加入Lₖ₊₁。

**发现频繁项集**：以minsupport=2（绝对支持度计数）为例，通过多趟扫描逐步生成C₁→L₁→C₂→L₂→C₃→L₃。

![](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAMwaVpNgZm8EZj3RNcfQnavZQbn9-gAAmoLaxtn5tlW7BKOu9_vQawBAAMCAAN3AAM4BA.png)

**生成关联规则**：给定一个频繁项集I，对于它的每个非空子集a，生成满足minconfidence的规则a ⇒ (I-a)，该规则的confidence = support(I) / support(a)。示例：L₂中频繁项{I₁,I₂}，规则I₁⇒I₂的置信度 = 4/6，规则I₂⇒I₁的置信度 = 4/7。

![](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAMxaVpOQQeqG9aLfhr7-Ruu0597WdgAAm8Laxtn5tlWfOnZQiv5Km4BAAMCAAN3AAM4BA.pngg)

**算法分析**：虽然简单且易于实现，是最具代表性的关联规则挖掘算法，

**缺点**：

1. 但随着数据集规模的不断增长，逐渐显现出一定的局限性：需多次扫描数据库，很大的I/O负载，算法的执行效率较低；
2. 产生大量的候选项目集，会消耗大量的内存；
3. 对于每一趟扫描，只有当内存大小足够容纳需要进行计数的候选集时才能正确执行。如果内存不够大，要么使用一种空间复杂度更小的算法，要么只能对一个候选集进行多次扫描，否则将会出现"**内存抖动**"的情况，即在一趟扫描中页面频繁地移进移出内存，造成运行时间的剧增。

**观察**：在Apriori算法的整个过程中，第一趟扫描时只需对规模为1的项计数，相对于对规模为2的项进行计数所需的空间而言是非常小的，而在第二趟扫描时，所有的可用空间基本都投入用于对候选集C₂进行计数。通过实验发现Apriori算法的内存瓶颈在**第二趟**扫描时出现，即对候选集C₂进行计数比对候选集C₃、C₄或规模更大的候选集进行计数所需的空间更大。

#### 3.PCY算法

**基本信息**：得名于作者Park、Chen和Yu，1995年提出。将哈希技术引入频繁项集发现中，利用第一趟扫描时未使用的大量内存空间来完整地存放一张哈希表，**减少了第二趟扫描时候选集C₂的数量。**

**主要思想**：

- 第一趟扫描：对单个项进行计数的同时将商品对散列到对应的桶中，并将该桶的计数加1。频繁桶为最终计数值不小于minsupport的桶，非频繁桶为最终最终计数值小于minsupport的桶。
- 第二趟扫描：即使一个2-项集中的每一项都是频繁的，但如果它被**散列**到非频繁桶中，它就不可能是频繁项集，可以从候选项集中删除，这样就可大大减少要考虑的2-项集。
- 第一趟扫描与第二趟扫描之间：把桶替换成对应的二进制位的位图，如果对应的是频繁桶则该位为1，否则为0。一个占32位(4字节)的桶被换成了1位，在第二趟扫描时只需要1/32的空间并销，因此在第二趟扫描时，PCY算法可用来计数的空间几乎和Apriori算法一样大。

**步骤**：第一遍扫描生成频繁1-项集，同时对2-项集进行哈希得到哈希表和位向量；第二遍扫描通过L₁自连接生成候选集，使用位图过滤（只有哈希到频繁桶的才是候选），对候选项对计数。结果是候选2-项集的数目大大减少。

- 第一步：确定每个项的 order（顺序编号）

  根据字母顺序：

  - **A 的 order = 1**
  - **B 的 order = 2**
  - **C 的 order = 3**
  - **D 的 order = 4**
  - **E 的 order = 5**

- 第二步：计算每个2-项集的哈希位置
  - 例子1：{A, C}

    ``` 
    h(A,C) = (1 × 10 + 3) mod 7
           = 13 mod 7
           = 6  ✅ 映射到位置6
    ```

  - 例子2：{B, C}

    ``` 
    h(B,C) = (2 × 10 + 3) mod 7
           = 23 mod 7
           = 2  ✅ 映射到位置2
    ```

- 第三步：进行位向量统计
  - 统计当前桶的元素个数是否$>=2$
  - 得到如下位向量<1,0,1,0,1,0,1>

![](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAMyaVpPV-fTVf_xvopMEywhtDq5t4QAAnwLaxtn5tlWAAHwclooRoU_AQADAgADdwADOAQ.png)

**优点**：高效地产生频繁项集，提升了性能；减少了数据库的扫描次数；减少计数所需的内存空间的大小。

**分析**：最差的情况是所有桶都是频繁桶，则第二遍扫描中PCY算法需要计算的相对数目与Apriori算法相比没有任何减少。在寻找频繁3-项集以及更多项集时，PCY算法与Apriori算法相同。

#### 4.多阶段算法

**主要思路**：

- 在PCY的第一遍和第二遍之间插入额外的扫描过程，将2-项集哈希到另外的**独立的哈希表**中（使用不同的哈希函数）。
- 在每个中间过程中，只需哈希那些在以往扫描中哈希到频繁桶的频繁项。
- 需要三次扫描数据库。

**步骤**：

![](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAMzaVpV0b8nyHumOHDu0hNE2BaDkKYAApALaxtn5tlWv8ydwdyCoqwBAAMCAAN3AAM4BA.png)

1. 第一趟扫描与PCY算法相同；
2. 第二趟扫描中2-项集{i,j}被哈希需满足①i和j都是频繁项、②第一趟扫描时{i,j}被哈希到了一个频繁桶，使用**不同的哈希函数**建立哈希表2；
3. 第三趟扫描中{i,j}是候选2-项集需满足①i和j都是频繁项、②第一趟扫描时{i,j}被哈希到频繁桶(查询Bitmap1)、③第二趟扫描时{i,j}被哈希到频繁桶(查询Bitmap2)。

**分析**：

- Pass3的第③个条件是多阶段算法与PCY算法最本质的区别。
  - 因为在第二趟扫描时，不是所有的2-项集都被散列到桶中，因此桶的计数值变得比第一趟扫描时更小，最终结果是**更多的桶变成非频繁桶**；(过滤更多)
  - 由于两次扫描采用的**哈希函数不同**，那些在第一趟扫描时被散列到频繁桶中的非频繁2-项集很可能在第二趟扫描时被哈希到一个非频繁桶中，故排除很多通过了前两个条件判断的2-项集。
- 多阶段算法寻找频繁2-项集不只局限于使用3次扫描，
  - 可以执行更多次用桶进行哈希的扫描，并且每次使用不同的哈希函数，后面的每一趟扫描都能排除更多的2-项集；
  - 但是如果扫描的次数过多，不仅算法的执行次数更长，也有可能导致最终可用的内存小到无法对所有的频繁2-项集进行计数。

#### 5.多哈希算法

**定义**：多哈希算法(Multihash Algorithm)是PCY算法的一种变形。

**思路**：对PCY算法的第一遍扫描进行修改，将内存划分为**多张哈希表**，第二遍扫描只需对所有哈希表中都哈希到频繁桶的两个频繁项组成的项对计数。

**与多阶段算法的区别**：多阶段算法是在连续的扫描过程中使用两个不同的哈希函数和哈希表，多哈希算法是在第一次扫描的过程中同时使用两个哈希函数和两张哈希表。

**步骤**：第一遍扫描统计频繁项，同时维护哈希表1和哈希表2；第二遍扫描输入频繁项+位图1+位图2，对同时在两个哈希表中都哈希到频繁桶的候选项对计数。

**分析**：

- **优点**是只要桶的平均计数不小于阈值，频繁桶的数目仍然比较多，这样一个非频繁2-项集同时哈希到两个哈希表的频繁桶内的**概率就更低**，可以减少第二遍扫描的运算量。
- **风险**是使用两个哈希表时，每个哈希表仅有PCY算法的一半的桶，这样每个桶上的平均计数会翻倍，必须保证大多数桶的**计数不会达到阈值**。
- 多哈希算法也**不只局限于使用两个哈希表**，风险是桶的平均计数可能会超过阈值。

### 三、基于共享式内存和分布式内存结合架构优势

#### 1.三种系统架构

**SMP (对称多处理)**
- 也称UMA (一致性存储访问)
- **各处理器平等,访问内存任何地址时间相同**
- 共享相同物理内存、总线结构和系统资源
- 主要特征是"**共享**",单一寻址空间,编程简单
- 缺点:受**总线**限制,可扩展性差

**MPP (大规模并行处理)**

- **多个SMP服务器**通过互联网络连接
- "**完全无共享(shared-nothing)**"架构
- 每个节点只访问**本地资源**,通过消息传递机制交互
- 优点:可扩展性好
- 缺点:**通信开销大**,编程困难

**NUMA (非一致性存储访问)**

- **访问本地内存速度远高于远端内存**
- 具有多个CPU模块,每个模块有独立的CPU、内存、I/O
- **每个CPU可访问系统中所有物理内存空间**
- 结合SMP和MPP优势:保持对称性和单一地址空间,同时具备可扩展能力
- 属于分布/共享内存结构

#### 2.SPADE算法

**基本思想**
- 利用**垂直数据格式**和**连接-剪枝策略**
- 只需对数据库进行**三次扫描**
- 产生频繁序列时只需对垂直数据序列进行**交集操作**

**数据表示:垂直格式**
- 将序列数据库从水平格式转换为垂直格式
- 每个项用**ID_list**表示,包含(CID, TID)对
  - CID: 客户/序列标识
  - TID: 事务/时间标识
- 通过扫描数据库构建每个项的ID_list
- 计算support: 统计ID_list中distinct CID数目

**算法流程**

*第一步: 生成频繁1-序列*

![](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAM0aVpfTSa9b05mRJF5_uKQazgpzbEAAqkLaxtn5tlWwRomaXlblkEBAAMCAAN3AAM4BA.png)

- 扫描数据库,构建每个单项的ID_list
- 统计每个项的distinct CID数目
- 与minsupport比较,得到频繁1-序列

*第二步: 连接生成候选k-序列*

**示例: 从频繁1-序列生成频繁2-序列**

频繁1-序列的ID_list:

| 项b |  |  | 项c |  |
|-----|-----|-----|-----|-----|
| CID | TID | | CID | TID |
| 1 | 2 | | 2 | 3 |
| 1 | 3 | | 3 | 2 |
| 2 | 1 | | 3 | 5 |
| 2 | 4 | | | |
| 3 | 2 | | | |

**连接过程详解:**

要生成b→c(表示b在c之前发生):
- 查找同一个CID中,TID(b) < TID(c)的记录
- CID=1: b出现在TID=2,3; c出现在TID=无 → **没有满足条件的**
- CID=2: b出现在TID=1,4; c出现在TID=3 → TID(b)=1 < TID(c)=3 ✓
- CID=3: b出现在TID=2; c出现在TID=2,5 → TID(b)=2 < TID(c)=5 ✓

要生成c→b(表示c在b之前发生):
- 查找同一个CID中,TID(c) < TID(b)的记录
- CID=1: c出现在TID=无; b出现在TID=2,3 → **没有c,不满足**
- CID=2: c出现在TID=3; b出现在TID=1,4 → TID(c)=3 < TID(b)=4 ✓
- CID=3: c出现在TID=2,5; b出现在TID=2 → TID(c)=2不小于TID(b)=2 ✗


连接后生成的频繁2-序列ID_list:
| b→c (序列模式) |        |        | c→b (序列模式) |        |        |
| -------------- | ------ | ------ | -------------- | ------ | ------ |
| CID            | TID(b) | TID(c) | CID            | TID(c) | TID(b) |
| 2              | 1      | 3      | 2              | 3      | 4      |
| 3              | 2      | 5      |                |        |        |

- 频繁(k-1)-序列与频繁(k-1)-序列连接形成候选k-序列
- **连接规则**(必须同时满足):
  1. 共享相同的CID
  2. 前面项的TID必须在后面项的TID之前(遵守时间顺序)
- 通过两个序列的ID_list交集操作生成新序列的ID_list
- 例如: b→c表示在同一CID中,b的TID < c的TID

*第三步: 剪枝得到频繁k-序列*

**判断哪些候选序列是频繁的:**

假设最小支持度minsupport = 2(至少要在2个客户中出现)

- **b→c序列**: distinct CID = {2, 3} → 2个客户 → support=2 ≥ minsupport ✓ **保留,是频繁序列**
- **c→b序列**: distinct CID = {2} → 1个客户 → support=1 < minsupport ✗ **剪枝,不是频繁序列**

**最终得到频繁2-序列:**

| b→c (频繁序列) |        |        |
| -------------- | ------ | ------ |
| CID            | TID(b) | TID(c) |
| 2              | 1      | 3      |
| 3              | 2      | 5      |

**算法的实际意义:**

SPADE算法用于**序列模式挖掘** - 发现用户购买行为的规律:
**终止条件**

- 找不到频繁序列,或
- 无法通过连接形成候选序列时,算法结束

**优化特性**
- ID_list会随着频繁序列长度增加而减小
- 连接操作速度随之加快
- 减少了内存占用和计算开销

**等价类划分(搜索空间划分)**
- 采用**基于后缀的等价类**划分搜索空间
- 形如Y→X和YX的序列都归入后缀类[X]
- 每个等价类是独立的,包含生成所有共享相同后缀的频繁序列所需的完整信息
- 可以在内存中独立处理每个等价类
- 为pSPADE的并行化提供基础

#### 3.pSPADE算法

**算法背景**
- 第一个应用共享式内存架构进行并行序列模式挖掘的算法
- 工作在SGI Origin 2000系统(NUMA体系结构)的12台处理器上
- 采用硬件分布式共享存储(HDSM)架构

**任务拆分**
- 利用SPADE算法的等价类划分性质
- 所有处理器访问整个数据库的一份拷贝
- 并行地工作于不同的等价类,异步处理全局计算树
- 每个类的挖掘工作独立,处理器不需要同步

**负载均衡策略**

![](https://telegraph-image-43w.pages.dev/file/AgACAgUAAyEGAATTNkFKAAM3aVpltKCdutU0wKTjZeTW6Idd2GYAAtMLaxtn5tlWXDm5bdbfyrwBAAMCAAN3AAM4BA.png)

*静态负载均衡(SLB)*

- 根据等价类中**元素数量**分配权重
- 按权重递减顺序排序,依次分配给当前权值和最小的处理器
- 分配完毕后完全异步,无需同步或交互
- **示例**：P0预先分配好了C1和C3，P1预先分配好了C2。然后就按照这个分配方案来实施。即使P1已经执行完毕所有任务了，它也无法分担P0的任务。

*类间动态负载均衡(CDLB)*

- 按权重将所有类递减排列成逻辑中心任务队列
- 处理器动态从队列获取类,处理完后自动获取下一个
- **示例**：首先预估所有任务的工作量，进行排序，得C1, C2, C3。然后，分配P0来执行C1，分配P1来执行C2。结束早的那个处理器来执行C3。

*递归动态负载均衡(RDLB)*
- 有空闲处理器时,在树的每一新层递归运用**CDLB方法**
- 不同处理器能够处理新层次上的不同类
- **示例**：首先预估工作量，排序得C1、C2、C3。然后P0预先分配好了C1和C3，P1预先分配好了C2，P1执行较快，则又执行C3。此时P0已经执行完毕，则它能够分配C3的子任务（X3）。依次类推，直到完全结束。

**算法优点**
- 减少数据库扫描次数,降低I/O操作开销
- 采用异步机制,只在负载失衡时同步
- 将搜索空间分成基于后缀的类,可独立处理
- 数据局域性最大化,同步最小化
- 动态负载均衡保证处理器负载均衡
- 解决大型数据库中搜索空间大、可扩展性差的问题

---

## 第八讲 社区发现

社区发现是复杂网络分析中的重要问题，目标是找出网络中紧密连接的节点群组。

### 一、图切割（Graph Partitioning）

#### 1. 社区划分问题

给定无向图 $G = (V, E)$，其中：

- $V$ 表示所有的顶点（节点）集合
- $E$ 表示所有的边集合

**任务：** 将所有顶点分成两个不相交的组：

- 组 $A$：包含一部分节点
- 组 $B = V\backslash A$：包含剩余的所有节点（即 $V$ 中除了 $A$ 之外的所有节点）

**核心问题：** 如何评判这个划分的好坏？

#### 2. 评判准则

一个良好的社区划分应该满足：

- **最大化社区内部的连接数**：同一个社区内的节点之间应该有尽可能多的边连接
- **最小化社区之间的连接数**：不同社区之间的连接应该尽可能少

#### 3. 割（Cut）的定义

为了量化划分的质量，我们引入"割"的概念。

**割(cut)** 是指：只有一个端点在社区 $A$ 内，另一个端点在社区 $A$ 外的所有边的权重之和。

数学表达式：

$$cut(A) = \sum_{i \in A, j \notin A} w_{ij}$$

**公式解释：**

- $i \in A$：节点 $i$ 在社区 $A$ 中
- $j \notin A$：节点 $j$ 不在社区 $A$ 中（即在社区 $B$ 中）
- $w_{ij}$：连接节点 $i$ 和节点 $j$ 的边的权重（如果是无权图，权重为1）
- $\sum$：对所有满足条件的边进行求和

**通俗理解：** 割就是"跨越两个社区的边的总权重"，这个值越小，说明两个社区之间的连接越少，划分越好。

**求解方法：** 存在多项式时间算法来求解最小割问题，特别是 **Edmonds-Karp 算法**，其时间复杂度为 $O(|V| \cdot |E|^2)$。

#### 4. 最小割 (Minimum-cut)

**目标：** 找到一个划分 $(A, B)$，使得 $cut(A,B)$ 的值最小。

$$\arg\min_{A,B} cut(A,B)$$

**公式解释：**

- $\arg\min$：表示"使得后面的值最小的参数"
- 即找到使 $cut(A,B)$ 最小的划分方式 $(A, B)$

**最小割的局限性：**

虽然最小割能找到连接最少的划分，但存在明显的问题：

- **只考虑簇间的联通性**：只关心两个社区之间有多少连接
- **不考虑簇内的连通性**：不关心每个社区内部的结构
- **可能产生不平衡的划分**：例如，将一个孤立的节点分离出来，只需要切断很少的边，但这样的划分是没有意义的

**举例说明：** 假设有一个图，其中有一个节点只通过一条边连接到主图，那么最小割会将这个节点单独分离出来（只需切断1条边），但这样的划分显然不合理。

#### 5. 归一化切割 (Normalized-cut)

为了解决最小割的问题，我们引入归一化切割，它同时考虑了簇间的连通性和各簇的规模。

**体积（Volume）的定义：** 首先需要定义社区 $A$ 的"体积" $vol(A)$：

$$vol(A) = \sum_{i \in A} k_i$$

其中 $k_i$ 是节点 $i$ 的度（degree），即连接到节点 $i$ 的所有边的权重之和。$vol(A)$ 表示至少有一个端点在社区 $A$ 中的所有边的总权重，反映了社区 $A$ 的"规模"或"密度"。

**归一化切割的定义：**

$$ncut(A,B) = \frac{cut(A,B)}{vol(A)} + \frac{cut(A,B)}{vol(B)}$$

**公式解释：**

- 第一项 $\frac{cut(A,B)}{vol(A)}$：割的大小相对于社区 $A$ 的规模
- 第二项 $\frac{cut(A,B)}{vol(B)}$：割的大小相对于社区 $B$ 的规模
- 两项相加：综合考虑两个社区的规模

**为什么要归一化？** 通过除以各自的体积，我们将割的大小"标准化"了。这样如果一个社区很大（$vol$ 很大），即使割的值不变，归一化后的值也会变小，从而避免了将单个节点分离出来的情况（因为单个节点的 $vol$ 很小，归一化后的值会很大）。

**优势：**

- 使划分更加平衡，避免产生极小的社区
- 同时考虑了社区间的连接和社区的规模

**挑战：**

- 计算归一化割是 NP-hard 问题
- 需要使用近似算法或启发式方法来高效地找到好的划分

#### 6. 练习题详解

[![image.png](https://i.postimg.cc/d0KTvKjj/image.png)](https://postimg.cc/0zcNdF3z)

**题目：** 对于给定的图(红色节点和绿色节点)，分别计算最优切割和最小切割的 $ncut$ 值。

**题目分析：** 从图中可以看到两种切割方式：

- **最优切割**（蓝色虚线）：在红色社区（左侧）和绿色社区（右侧）之间进行切割
- **最小切割**（红色虚线）：将右下角单个绿色节点孤立出来

**（1）最小切割的 $ncut$ 值计算**

划分方式：社区 $A$ 为右下角单个绿色节点，社区 $B$ 为其余所有节点。

- $cut(A,B) = 1$（只有1条边连接孤立节点）
- $vol(A) = 0$（节点完全孤立，内部没有边）
- $ncut_{\text{min}} = \frac{1}{0} + \frac{1}{vol(B)} = +\infty$

这说明**将单个节点完全孤立是一个极差的划分**！

**（2）最优切割的 $ncut$ 值计算**

划分方式：社区 $A$ 为所有红色节点（左侧6个节点），社区 $B$ 为所有绿色节点（右侧10个节点）。

- $cut(A,B) = 2$（2条边跨越蓝色虚线）
- $vol(A) = 2 \times 9 = 18$（红色区域内部9条边）
- $vol(B) = 2 \times 15 = 30$（绿色区域内部15条边）
- $ncut_{\text{optimal}} = \frac{2}{30} + \frac{2}{18} = \frac{1}{15} + \frac{1}{9} = \frac{8}{45} \approx 0.178$

**结果对比：**

| 切割方式 | $cut(A,B)$ | $vol(A)$ | $vol(B)$ | $ncut$ 值 |
| -------- | ---------- | -------- | -------- | --------- |
| 最小切割 | 1          | 0        | >0       | $+\infty$ |
| 最优切割 | 2          | 18       | 30       | 0.178     |

**结论：**

1. 最小切割将单个节点孤立后，$vol(A) = 0$ 导致 $ncut$ 值趋向无穷大，这是最差的划分
2. 最优切割虽然 $cut$ 值不是最小，但 $ncut$ 值很小，实现了平衡且合理的划分
3. 归一化切割通过考虑社区规模，避免了不合理的极端划分，$ncut$ 值越小说明划分越好

### 二、边介数（Edge Betweenness）

#### 1. 边介数的定义

**边介数（Edge Betweenness）**：通过该边的最短路径的数量。

**作用：**
- 用于衡量图中一条边的重要性或中心性
- 反映图中有多少条最短路径经过该边

**重要性判断：**
- 若很多最短路径都经过该边，则该边对于保持图的高效连接性就非常重要
- 相反，如果仅少数最短路径经过该边，则该边的重要性就较低

**应用价值：**

边介数有助于识别图中的关键连接，即这些连接一旦断裂会显著影响图中节点之间的通信效率。

**示例：**

[![image.png](https://i.postimg.cc/L892K9J7/image.png)](https://postimg.cc/mt507GNN)

在下图中，不同的边具有不同的边介数值：
- 左侧的边：$b = 16$（有16条最短路径经过）
- 右侧的边：$b = 7.5$（有7.5条最短路径经过）

边介数越大，该边在网络中的重要性越高。

#### 2. Girvan-Newman方法（简称GN方法）

**GN方法定义：**

Girvan-Newman方法是一种基于边介数概念的层次聚类算法，适用于无向无权网络。

**算法流程：**

重复以下步骤直到没有边剩余：
1. **计算边介数**：计算网络中所有边的边介数
2. **移除边介数最高的边**：找到边介数最大的边并将其从图中删除
3. **重新计算**：在每个步骤后，需要重新计算剩余边的边介数

**输出结果：**
- 相连接的边构成社区
- 可输出网络的层次分解

**重要提示：** 在每个步骤，均需重新计算边介数，因为移除一条边会影响其他边的最短路径。

#### 3. GN方法案例分析

考虑下图所示的网络，应用GN方法进行社区划分：

[![image.png](https://i.postimg.cc/QNQDn96X/image.png)](https://postimg.cc/JtzSsnVg)

**Step 1：** 计算所有边的边介数，移除边介数最高的边（边7-8，边介数为49）

结果：图被分成两个主要部分

**Step 2：** 重新计算剩余边的边介数，继续移除边介数最高的边

结果：进一步细分，形成更小的社区

**Step 3：** 持续迭代，直到所有边都被移除

结果：每个节点成为独立的社区

**最终输出：层次状的网络划分**

通过记录每次移除边的顺序，可以构建一个层次树（dendrogram），展示网络在不同粒度下的社区结构。

#### 4. 如何计算边介数

**（1）基本方法：构建根节点到其余子节点的最短路径数量**  

**步骤1：构建最短路径树**

从起始节点（如节点A）开始，使用BFS构建到所有其他节点的最短路径树，并标记每个节点的层次：
- 第0层：起始节点A
- 第1层：与A直接相连的节点（B, C, D, E）
- 第2层：距离A为2的节点（F, G, H）
- 第3层：距离A为3的节点（I, J）
- 第4层：距离A为4的节点（K）

**步骤2：计算最短路径数量**

计算从起始节点A到网络中其他每个节点的最短路径数量。

**公式：**

从A到某个节点X的最短路径数量 = 所有能到达X的**父节点**的最短路径数量之和

**示例：**

[![image.png](https://i.postimg.cc/0QgrRzLg/image.png)](https://postimg.cc/xkR9L1fg)

- 从A到H的最短路径数量 = 从A到D的最短路径数量 + 从A到E的最短路径数量
- 从A到K的最短路径数量 = 从A到I的最短路径数量 + 从A到J的最短路径数量

**（2）自底向上计算边介数**：如果存在多条最短路径，则可按比例划分边介数。

**算法步骤：**

1. **添加边流**
   - 初始化：每个节点的流 = 1 + 其所有子边的流之和
   - 根据父节点的值分配流

2. **对于每个起始节点U，重复广度优先搜索过程**

**详细计算规则：**

对于某条边 $(X, Y)$，其边介数的计算遵循以下规则：
- 如果从A到Y只有一条最短路径经过X，则该边获得完整的流
- 如果从A到Y有多条最短路径（通过不同的父节点），则按照各父节点的最短路径数量比例分配流

**具体案例：**

[![image.png](https://i.postimg.cc/bvGrGxQt/image.png)](https://postimg.cc/8FSN9rXp)

以节点为K为例：
- K对于A而言是**叶子节点**，所以他的流为1（根据算法规则：子节点的流为0），
- 共有2条最短路径可被分配，根据I，J各有三条最短路径，为3：3，即1：1，因此每条边分配 $\frac{1}{2}$

以节点I为例：
- A-I的最短路径总和算1，外加经过I到K的0.5，所以I的流为1.5
- I有1.5可被分配，按照2:1的比例划分（因为A到F有2条最短路径，到G有1条最短路径）
- 故边$V_{F,I}$得到的流为1，边$V_{G,I}$得到的流为0.5

以此自下而上故能得到所有边的边介数

#### 5. 练习题

**题目**：给定下图所示的网络结构，请计算从节点B开始的路径边介数。

[![image.png](https://i.postimg.cc/Y0bsBHGx/image.png)](https://postimg.cc/CnnNb94Z)



**步骤1：构建最短路径树**

从起始节点B开始，使用BFS构建到所有其他节点的最短路径树，并标记每个节点的层次：

- 第0层：起始节点B
- 第1层：与B直接相连的节点（A，C，F）
- 第2层：距离B为2的节点（D，E，I）
- 第3层：距离B为3的节点（G，H，K）
- 第4层：距离B为4的节点（J）

**步骤2：计算最短路径数量**

计算从起始节点B到网络中其他每个节点的最短路径数量。定义节点B到节点I的最短路径数量的方法为$N(i)$，故

- 第0层：起始节点B
- 第1层：与B直接相连的节点$N(A) = 1$,$N(C) = 1$,$N(F) = 1$
- 第2层：距离B为2的节点$N(D) = N(A)=1$,$N(E) = N(A)=1$,$N(I)=N(F) = 1$
- 第3层：距离B为3的节点$N(G) = N(D)+N(I)=2$,$N(H) = N(D)+N(E)=2$,$N(K)=N(I) = 1$
- 第4层：距离B为4的节点$N(J) = N(G)+N(H)+N(K) = 5$

**步骤3：自底向上计算边介数**

每个节点的流 = 1 + 其所有子边的流之和，根据父节点的最短路径数量按比例分配流。

- 第4层：距离B为4的节点（J），J为叶子节点，所以J的流为1，分配边流：
  $$V_{G,J} = \frac{N(G)}{N(J)} \times 1 = \frac{2}{5}, \quad V_{H,J} = \frac{N(H)}{N(J)} \times 1 = \frac{2}{5}, \quad V_{K,J} = \frac{N(K)}{N(J)} \times 1 = \frac{1}{5}$$

- 第3层：距离B为3的节点（G，H，K），计算各自的流：
  - G的流 $= 1 + \frac{2}{5} = \frac{7}{5}$，分配边流：$V_{D,G} = \frac{N(D)}{N(G)} \times \frac{7}{5} = \frac{1}{2} \times \frac{7}{5} = \frac{7}{10}$，$V_{I,G} = \frac{N(I)}{N(G)} \times \frac{7}{5} = \frac{1}{2} \times \frac{7}{5} = \frac{7}{10}$
  - H的流 $= 1 + \frac{2}{5} = \frac{7}{5}$，分配边流：$V_{D,H} = \frac{N(D)}{N(H)} \times \frac{7}{5} = \frac{1}{2} \times \frac{7}{5} = \frac{7}{10}$，$V_{E,H} = \frac{N(E)}{N(H)} \times \frac{7}{5} = \frac{1}{2} \times \frac{7}{5} = \frac{7}{10}$
  - K的流 $= 1 + \frac{1}{5} = \frac{6}{5}$，分配边流：$V_{I,K} = \frac{N(I)}{N(K)} \times \frac{6}{5} = 1 \times \frac{6}{5} = \frac{6}{5}$

- 第2层：距离B为2的节点（D，E，I），计算各自的流：
  - D的流 $= 1 + \frac{7}{10} + \frac{7}{10} = 1 + \frac{14}{10} = \frac{12}{5}$，分配边流：$V_{A,D} = \frac{N(A)}{N(D)} \times \frac{12}{5} = 1 \times \frac{12}{5} = \frac{12}{5}$
  - E的流 $= 1 + \frac{7}{10} = \frac{17}{10}$，分配边流：$V_{A,E} = \frac{N(A)}{N(E)} \times \frac{17}{10} = 1 \times \frac{17}{10} = \frac{17}{10}$
  - I的流 $= 1 + \frac{7}{10} + \frac{6}{5} = 1 + \frac{7}{10} + \frac{12}{10} = \frac{29}{10}$，分配边流：$V_{F,I} = \frac{N(F)}{N(I)} \times \frac{29}{10} = 1 \times \frac{29}{10} = \frac{29}{10}$

- 第1层：距离B为1的节点（A，C，F），计算各自的流：
  - A的流 $= 1 + \frac{12}{5} + \frac{17}{10} = 1 + \frac{24}{10} + \frac{17}{10} = \frac{51}{10}$，分配边流：$V_{B,A} = \frac{51}{10} = 5.1$
  - C的流 $= 1 + 0 = 1$，分配边流：$V_{B,C} = 1$
  - F的流 $= 1 + \frac{29}{10} = \frac{39}{10}$，分配边流：$V_{B,F} = \frac{39}{10} = 3.9$

****

### 三、模块度（Modularity）

#### 1.模块度

模块度（Modularity）是衡量图结构划分优劣的重要指标。

令 G=(V,E) 为一个无向图，其邻接矩阵为 A：

$$A_{ij} = \begin{cases} 
1, & \text{if } (v_i, v_j) \in E \\
0, & \text{otherwise}
\end{cases}$$

模块度的定义为：

$$Q = \frac{1}{2m}\sum_{i,j} \left(A_{ij} - \frac{k_i k_j}{2m}\right)\delta(C_i, C_j)$$

其中，m 表示边的数量，Ci 表示第 i 个社区。ki 是顶点 vi 的度（即与顶点 vi 相连的边的数量），δ(Ci, Cj) = 1（如果 Ci = Cj），否则为 0。

**模块度的直观解读：**

模块度用于衡量网络被划分为社区的好坏程度的一种度量。给定网络被划分为一组 c ∈ C 的情况：

$$Q \propto \sum_{i,j}\left(A_{ij} - \frac{k_i k_j}{2m}\right)\delta(C_i, C_j) = \left[\sum_{i,j} A_{ij} - \sum_{i,j} \frac{k_i k_j}{2m}\right]\delta(C_i, C_j)$$

$$= \sum_{c \in C} [(\# \text{ edges within group } c) - (\text{expected } \# \text{ edges within group } c)]$$

给定一个图 G，含 n 个节点和 m 条边，构建一个随机图 G'：
- 保持相同的度分布，但边是随机生成
- G' 是一个多重图

**模块度计算：**

$$Q = \frac{1}{2m}\sum_{c \in C}\sum_{i \in c}\sum_{j \in c}\left(A_{ij} - \frac{k_i k_j}{2m}\right)$$

- 模块度的取值范围是 [-1, 1]
- 如果组内边的数量超过了预期数量，则模块度值为正
- 当模块度 M 大于 0.3 至 0.7 时，意味着输入图中存在显著的社区结构
- 是用于评估社区结构好坏的度量

**模块度案例：**

m = 8, k₁ = 2, k₂ = 2, k₃ = 3, k₄ = 3, k₅ = 2, k₆ = 2, k₇ = 2

划分方案1（社区A={1,2,3}，社区B={4,5,6,7}）：Q = 51/128

划分方案2（社区A={1,2}，社区B={3,4,5,6,7}）：Q = 19/128

**针对加权图的模块度：**

给定一个无向图 G = (V, E)，其邻接矩阵为 A，该图并关联一个权重矩阵 W：

$$W_{ij} = \begin{cases} 
w_{ij}, & \text{if } A_{ij} = 1 \\
0, & \text{otherwise}
\end{cases}$$

模块度被定义为：

$$Q = \frac{1}{2m}\sum_{i,j}\left(W_{ij} - \frac{k_i k_j}{2m}\right)\delta(C_i, C_j)$$

其中，m 表示图中总的边权重，Ci 表示图中的第 i 个社区，ki 不再是节点 vi 的度，而是连接到 vi 的所有边的权重之和。

**针对有向图的模块度：**

给定有向图 G = (V, E)，其邻接矩阵为 A：

$$A_{ij} = \begin{cases} 
1, & \text{if } (v_i, v_j) \in E \\
0, & \text{otherwise}
\end{cases}$$

模块度被定义为：

$$Q = \frac{1}{m}\sum_{i,j}\left(A_{ij} - \frac{k_i^{out} k_j^{in}}{m}\right)\delta(C_i, C_j)$$

其中，m 表示图中总的边数，Ci 表示图中的第 i 个社区，ki^out 和 ki^in 分别是节点 vi 的出度和入度。

**模块度矩阵：**

对无向图来说，模块度还有一种矩阵形式的定义。定义一个 n × k 的矩阵 S，Sij 表示顶点 vi 属于第 j 个社区，Sij=0 表示节点 vi 不属于第 j 个社区。则：δ(Ci, Cj) = Σr Sir Sjr

定义实对称矩阵 B，其元素满足：Bij = Aij - kikj/2m

则社区结构模块度可以改写为：

$$Q = \frac{1}{2m}\sum_{ij}\left(A_{ij} - \frac{k_i k_j}{2m}\right)\delta(i,j)$$

$$= \frac{1}{2m}\sum_{ij} B_{ij}\sum_r S_{ir}S_{jr}$$

$$= \frac{1}{2m}\sum_{ij}\sum_r B_{ij}S_{ir}S_{jr}$$

$$= \frac{1}{2m}Tr(S^T BS)$$

其中，Tr(S^T BS) 为矩阵的迹，即对角元素之和。

#### 2.谱方法

谱方法：自顶向下的迭代式社区发现方法，基于分裂思想。

- 每次只将一个图分成两个社区，以此类推，直到模块度不再变化为止
- 假设每次划分时，划分的两个社区分别为社区1和社区2。顶点要么落在社区1，要么在社区2

因此定义变量：

$$s_i = \begin{cases} 
1, & \text{如果顶点 } v_i \text{ 在社区1} \\
-1, & \text{否则}
\end{cases}$$

因此，二分社区的模块度可以改写为：

$$Q = \frac{1}{4m}\sum_{i,j}\left(A_{ij} - \frac{k_i k_j}{2m}\right)(s_i s_j + 1)$$

$$= \frac{1}{4m}\sum_{i,j}\left(A_{ij} - \frac{k_i k_j}{2m}\right)s_i s_j$$

$$= \frac{1}{4m}s^T Bs$$

其中 Bij = Aij - kikj/2m 被称为模块度矩阵。注意到在模块度矩阵 B 中，它的每一行和每一列之和都为 0，所以向量 (1,1,……,1) 为特征值 0 对应的特征向量。

假设模块度矩阵 B 所有的 n 个正交的特征向量为 u。

因此，s = Σi=1^n ai ui，其中 s=(s₁, s₂,…, sn)，ai = ui^T·s。

进一步的，该社区的模块度可以改写为：

$$Q = \frac{1}{4m}\sum_i a_i u_i^T B \sum_j a_j u_j = \frac{1}{4m}\sum_i^n (u_i^T \cdot s)^2 \beta_i$$

其中 βi 是特征向量 ui 对应的特征值，而且 β₁ ≥ β₂ ≥ · ≥ βn。

给定图 G，其模块度矩阵的特征值和特征向量都固定了，通过上式不难发现，可以选择合适的划分向量 s=(s₁, s₂, ···, sn) 使得模块度最大。

最大化模块度需要考虑所有特征值 βi，因为计算矩阵所有特征值是比较困难的。

退而求其次，仅考虑最大的那几个特征值或者最大的特征值 β₁。

如果对划分向量 s=(s₁, s₂,…,sn) 没有其他的限制，可以选择划分向量 s=(s₁,s₂,…,sn) 与最大特征值对应的特征向量 u₁ 平行即可。

不幸的是，划分向量 s 的每个分量只能取 1 或者 -1，因此将问题简化为最大化点积 u₁^T·s，因此定义划分向量为：

$$s_i = \begin{cases} 
1, & \text{如果 } u_{1i} > 0 \\
-1, & \text{否则}
\end{cases}$$

也就是说，在最大特征值对应的特征向量 u₁ 中，根据其分量的符号确定对应顶点的社区，所有同号的分量对应的顶点在一个社区，不同号的分量对应的顶点在不同的社区。

**扩展到多个社区的划分：**

鉴于图中可能包含超过 2 个社区，因此希望可以划分为更多个部分。

解决这一问题，可采用前述方法重复进行二分：
- 首先，将网络分成两部分，然后继续分割，依此类推
- 也就是说，在将图二分之后，简单地删除落在两部分之间的边，然后再次将算法应用于每个子图

注意：这种方法并不正确
- 模块度会在边删除之后发生变化
- 因此，任何后续的模块度最大化都将放大错误量

解决方案：每次划分一个子社区时，仅希望最大化模块度的增量 Q。假设一个子社区 g 的大小为 n，希望将社区 g 一分为二，那么其模块度的增量 ΔQ 可以计算为：

$$\Delta Q = \frac{1}{2m}\left[\frac{1}{2}\sum_{i,j \in g} B_{ij}(s_i s_j + 1) - \sum_{i,j \in g} B_{ij}\right]$$

$$= \frac{1}{4m}\left[\sum_{i,j \in g} B_{ij} s_i s_j - \sum_{i,j \in g} B_{ij}\right]$$

$$= \frac{1}{4m}\sum_{i,j \in g}\left[B_{ij} - \delta_{ij}\sum_{k \in g} B_{ik}\right] s_i s_j$$

$$= \frac{1}{4m}s^T B^{(g)} s$$

其中 (1/2)Σi,j∈g Bij(sisj+1) 和 Σi,j∈g Bij 分别表示子社区划分后和划分前模块度的大小，当 i=j 时 δij =1，否则其值为 0。

因此，只有当每次社区划分导致模块度增量 ΔQ>0 时，才进一步划分这个子社区，否则这个子社区就不会再进一步划分。因此，每次划分都会保证整个社区结构的模块度是在不断增加的。

### 四、Louvain方法

#### 1. Louvain方法概述

Louvain方法是一种社区检测的贪心算法，具有以下特点：

- 支持有向图和加权图
- 提供层次化分区
- 社区数量不是超参数，算法自动确定
- 广泛用于研究大型网络，因为：
  - 快速：运行时间仅为 O(|E|)，其中 |E| 是边的数量
  - 收敛速度快
  - 输出的模块度高（即"更好的社区"）

Louvain算法以贪心方式逐步最大化模块度。每次遍历包含两个阶段，迭代重复这些遍历，直到模块度不再增加为止。

#### 2. 模块度重写

在Louvain方法中，模块度可以重写为更便于计算的形式：

$$M = \frac{1}{2m}\sum_{i,j}(A_{ij} - \frac{k_i k_j}{2m})\delta(C_i, C_j)$$

$$= [\sum_{i,j}\frac{A_{ij}}{2m} - \frac{\sum_i k_i \sum_j k_j}{4m^2}]\delta(C_i, C_j)$$

$$= \sum_{c \in C}[\frac{\sum_{in}^c}{2m} - (\frac{\sum_{tot}^c}{2m})^2]$$

其中：
- $\Sigma_{in}^c$ 是社区 c 内部顶点之间的边权重之和
- $\Sigma_{tot}^c$ 是社区 c 中所有顶点的边权重总和
- m 是图中所有边的权重总和

#### 3. Louvain方法：阶段1（模块度优化）

**初始化：**
将图中的每个顶点放入一个独立的社区（每个社区一个顶点）

**迭代过程：**
对于每个顶点 $v_i$，算法执行以下计算：

1. 计算当把顶点 $v_i$ 从其当前社区移动到某个邻近顶点 $v_j$ 的社区时模块度的增量（ΔQ）
2. 将 $v_i$ 移动到能够产生最大模块度增量 ΔQ 的社区
3. 循环运行直到没有移动能带来增益为止

第一阶段在达到模块度的局部最大值时停止，即当任何单个移动都不能再改进模块度时。需要注意的是，算法的输出依赖于考虑顶点的顺序，但研究表明顶点的顺序对模块度的影响并不显著。

#### 4. 模块度增益计算

**模块度变化的两个部分：**

模块度的变化分为两个部分：
- **增益**：ΔQ($v_i$→C) 表示如果我们把顶点 $v_i$ 移动到社区 C 时模块度 Q 的增益
- **损失**：ΔQ(D→$v_i$) 表示如果我们把顶点 $v_i$ 从社区 D 中移出时模块度 Q 的损失

**将顶点 $v_i$ 移入社区 C 的增益：**

$$\Delta Q(v_i \to C) = [\frac{\sum_{in}^C + k_{i,in}^C}{2m} - (\frac{\sum_{tot}^C + k_i}{2m})^2] - [\frac{\sum_{in}^C}{2m} - (\frac{\sum_{tot}^C}{2m})^2 - (\frac{k_i}{2m})^2]$$

$$= [\frac{k_{i,in}^C}{2m} - \frac{\sum_{tot}^C \cdot k_i}{2m^2}]$$

其中：
- $k_{i,in}^C$ 是顶点 $v_i$ 与社区 C 内部顶点之间的边权重之和
- $k_i$ 是顶点 $v_i$ 的度（所有相连边的权重之和）

**将顶点 $v_i$ 从社区 D 中移出的损失：**

设 D' 是移出 $v_i$ 后的社区 D，则：

$$\Delta Q(D \to v_i) = -\Delta Q(v_i \to D')$$

$$= \frac{\sum_{tot}^{D'} \cdot k_i}{2m^2} - \frac{k_{i,in}^{D'}}{2m}$$

**总的模块度变化：**

$$\Delta Q = \Delta Q(v_i \to C) + \Delta Q(D \to v_i)$$

#### 5. Louvain方法：阶段2（社区聚合）

在第一阶段获得的分区被收缩成超级节点，并按照以下方式创建加权网络：

1. **超级节点的连接**：如果对应社区之间的顶点之间至少存在一条边，则超级节点之间是连接的
2. **边权重的计算**：两个超级节点之间边的权重是它们对应分区之间所有边的权重之和
3. **自环的处理**：社区内部的边成为超级节点的自环

聚合之后，图成为一个加权图，然后在这个新图上重复执行阶段1的过程。

#### 6. Louvain方法的完整流程

**第一次遍历（1ST PASS）：**
- **STEP I（模块度优化）**：从原始图开始，每个节点初始为独立社区，通过移动节点优化模块度
- **STEP II（社区聚合）**：将第一步得到的社区收缩为超级节点，形成新的加权图

**第二次遍历（2ND PASS）：**
- **STEP I（模块度优化）**：在聚合后的图上继续优化模块度
- **STEP II（社区聚合）**：再次聚合社区，形成更粗粒度的图

重复这个过程直到模块度不再增加，最终得到层次化的社区结构。

#### 7. Louvain方法的优势

**计算效率：**
- 该算法运行速度快，因为在第一次遍历后社区的数量急剧减少，使得后续遍历中的计算量大大减少
- 模块度的增益也非常容易计算
- 时间复杂度为 O(|E|)，对于包含100万个顶点的图，找到社区结构所需时间不到1分钟

**其他优势：**
- 社区数量不是一个超参数，算法自动确定最优社区数量
- 可以用于评估社区结构的质量
- 通过模块度曲线可以确定最佳的簇数量

**模块度用于确定簇的数量：**

在层次聚类等方法中，可以通过计算不同切割高度下的模块度，选择模块度最大时对应的簇数量作为最优划分。模块度曲线通常呈现先上升后下降的趋势，峰值对应最佳的社区划分。

---

# 第九讲 子模函数及其应用

## 一、应用背景

#### 1.特征选择（Feature Selection）
- **问题描述**：给定一组特征 X₁, ..., Xₙ，构造子集 A = (Xᵢ₁, ..., Xᵢₖ) 用以预测目标变量 Y
- **核心问题**：如何选取 k 个特征，使子集信息量最丰富？
- **信息增益**：I(A; Y) = H(Y) − H(Y | A)
  - H(Y)：Y 的熵（表示不确定性）
  - H(Y | A)：给定 A 条件下 Y 的条件熵
  - I(A; Y) 描述通过知道 A 能够获得关于 Y 的信息量

#### 2.影响力最大化（Influence Maximization）
- 基于社交网络，向哪些用户投放广告以达到最佳传播效果
- 找出最具影响力的博客或个人，将信息快速、有效地传播给受众

#### 3.传感器部署（Sensor Placement）
- **问题**：给定水分配网络，如何部署传感器以快速检测污染？
- **函数定义**：f(A) 表示在子集 A 处部署传感器的效用值
- **效用特性**：
  - 信息量高的配置（如 A = {1, 2, 3}）：f(A) 值大
  - 信息冗余度大的配置（如 A = {1, 4, 5}）：f(A) 值较低

#### 4.图的割函数（Graph Cut）
- **定义**：对无向图 G(V, E)，割函数 f(S) = |{(u, v) | u ∈ S ⊂ V, v ∈ Sᶜ}|
- **含义**：集合 S 与其补集之间的边数
- **示例**：S = {1, 2, 3} 时 f(S) = 1；S = {1, 2} 时 f(S) = 2

---

## 二、子模函数

#### 1. 集合函数基础

**定义**

- 给定有限集合 V = {1, 2, ···, n}
- 集合函数：f : 2^V → R（或 f : {0, 1}ⁿ → R）
- 2^V 是集合 V 的幂集

**集合函数的基本性质**

1. **单调性**：若 A ⊆ B ⊆ X，则 F(A) ≤ F(B)
2. **非负性**：对于所有 S ⊆ X，F(A) ≥ 0
3. **规范化**：F(∅) = 0

#### 2.子模性定义

**定义1：基本形式**

对于函数 f : 2^V → R，如果对于所有 A, B ⊆ V，均有：
```
f(A) + f(B) ≥ f(A ∪ B) + f(A ∩ B)
```
则该函数是子模的。

等价形式：
```
f(A) − f(A ∩ B) ≥ f(A ∪ B) − f(B)
```

**定义2：边际效用递减**

对于所有 S ⊆ T ⊆ V，对于所有 v ∈ V \ T：
```
f(S ∪ {v}) − f(S) ≥ f(T ∪ {v}) − f(T)
```

**经济学解释**：对象在更大的上下文中增加的价值逐渐减少

**定义3：群体边际效用递减**

对于所有 S ⊆ T ⊆ V，且 C ⊆ V \ T：
```
f(S ∪ C) − f(S) ≥ f(T ∪ C) − f(T)
```

#### 3. 离散优化：从凹性到子模性

**连续优化中的凹函数**

- 若 f : Rⁿ → R 是凹函数，则可高效获取最大值
- 连接凹函数图像上任意两点的线段总在函数图像之下或恰好位于图像上
- 导数 f'(x) 随 x 增加而非递增

**离散情况下的子模性**

- 对于函数 f : {0,1}ⁿ → R
- 离散导数：∂ᵢf(x) = f(x + eᵢ) − f(x)
- 若 ∂ᵢf(x) 随 x 增加而非递增，则函数是子模的
- eᵢ 表示第 i 个分量为 1，其余分量为 0 的单位向量

#### 4. 子模性的闭合性质

子模性在非负线性组合下具有闭合性质：

1. **非负线性组合**：若 f₁ 和 f₂ 都是子模函数，a₁, a₂ ≥ 0，则 a₁f₁ + a₂f₂ 是子模函数

2. **集合限制**：若 S ⊂ V 是固定集合，则 f'(A) = f(A ∩ S) 和 f(A) = f(Aᶜ) 都是子模的

3. **期望保持**：若 fθ(A) 是子模的，则 Σθ P(θ)fθ(A) 也是子模的

4. **多目标优化**：若 f₁, ···, fₘ 都是子模的，且 λᵢ > 0，则 Σᵢλᵢfᵢ(A) 也是子模的

#### 5. 典型案例

**案例1：传感器部署**

- **边际效应**：Δf(s|A) = f(A ∪ {s}) − f(A)
- 若 A = {1, 2}，增加部署 s 的效果显著
- 若 A = {1, 2, 3}，增加部署 s 的效果一般
- **验证子模性**：∀A ⊂ B，s ∉ B，Δf(s|A) ≥ Δf(s|B)

**案例2：计算不同颜色数量**

- 给定一组球的集合 S，f(S) 计算不同颜色的数量
- 子模性：对象在更大上下文中增加的价值逐渐减少

**案例3：集合覆盖**

- C 的覆盖定义为：f(C) = |⋃_{sᵢ∈C} sᵢ|
- 满足单调性和子模性

---

## 三、集合覆盖问题

#### 1. k-最大覆盖问题

**问题定义**

- **集合覆盖**：每个条目 u 是由某些基础元素组成的子集
- **覆盖函数**：f(S) = |⋃_{u∈S} u|（所有属于 S 中子集的并集的大小）
- **边际覆盖增加**：f(S ∪ {v}) − f(S)

**k-最大覆盖问题**

- **目标**：寻找 k 个子集，使联合覆盖尽可能大
- **复杂性**：NP-hard 问题（无多项式时间算法，除非 P=NP）

**示例（k=2）**

- 给定：
  - 真实集合：{a, b, c, d, e, f, g, h, i, j, k, l}
  - 子集：
    - A₁ = {a, b, c, d}
    - A₂ = {e, f, g, h}
    - A₃ = {i, j, k, l}
    - A₄ = {a, e}
    - A₅ = {i, b, f, g}
    - A₆ = {c, d, g, h, k, l}
    - A₇ = {l}

- **计算**：
  - A₆ 有 6 个元素，A₁, A₂, A₃, A₅ 各有 4 个元素
  - |A₅ ∪ A₆| = 9（最大）

- **结果**：C = {A₅, A₆} 是最大覆盖集合

#### 2. 抽取式文本摘要问题

**给定**：
- 关键词集合 W = {w₁, w₂, ···, wₙ}
- 句子集合 S = {s₁, s₂, ···, sₘ}
- 每个 sⱼ = {wₖ | wₖ ∈ W}

**目标**：找到 k 个句子，包含尽可能多的关键词

**数学表达**：
```
最大化：Σⱼ₌₁ⁿ Σᵢ₌₁ᵐ Xᵢsᵢⱼ
约束条件：Σᵢ₌₁ᵐ Xᵢ = k
```

其中：
- Xᵢ = 1（若 sᵢ ∈ C），0（否则）
- sᵢⱼ = 1（若 wᵢ ∈ sⱼ），0（否则）

#### 3. 爬山算法（Greedy Algorithm）

**算法流程**

```
1. 初始化 C = ∅
2. for i = 1 to k do
3.   c = arg max_{s∈S\C} [f(C ∪ {s}) − f(C)]
4.   C = C ∪ {c}
5. output C
```

**理论保证**

若集合函数 f 是单调、子模的，且 f(∅) = 0，则贪心算法可达到 **(1 − 1/e)** 的近似率：

```
f(S) ≥ (1 − 1/e) max_{S'⊆V, |S'|=k} f(S')
```

其中 e ≈ 2.718（自然常数）

**算法示例**

- **给定**：
  - 关键词集合 W = {w₁, w₂, ···, w₈}
  - 9个句子 s₁, s₂, ..., s₉
  - 目标：选择 k=3 个句子
- **第一轮**：
  - 计算每个句子的覆盖增益 Δ(Sᵢ)
  - s₄ 具有最大覆盖增益（Δ = 4），被选中
  - C = {s₄}
- **第二轮**：
  - 在剩余句子中计算边际增益
  - s₅ 和 s₈ 具有最大边际增益（Δ = 2）
  - 选择 s₅
  - C = {s₄, s₅}
- **第三轮**：
  - s₁, s₈, s₉ 具有相同边际增益（Δ = 1）
  - 选择 s₁
  - C = {s₄, s₅, s₁}

- **最终输出**：C = {s₄, s₅, s₁}

#### 4. 最小规模集合覆盖问题

**问题定义**

- **输入**：
  - 元素集合 X = {e₁, e₂, ..., eₙ}
  - m 个子集 S₁, S₂, ..., Sₘ ⊆ E
- **输出**：找到集合 I ⊆ {1,2,...,m}，满足：
  - ⋃ᵢ∈I Sᵢ = X
  - |I| 最小化

- **注意**：顶点覆盖问题是集合覆盖问题的特例

**实际案例**

软件公司员工各有不同技能（C++, Python, Linux, Database, Network...）
- 项目需要多种技能 a₁, a₂, ...
- 如何组建最精干的队伍完成项目？

**贪心近似算法**

```
Greedy-Set-Cover(X, F)
1. U ← X
2. I ← ∅
3. while U ≠ ∅
4.   选择 Sᵢ 使得 |Sᵢ ∩ U| 最大
5.   U ← U − Sᵢ
6.   I ← I ∪ {i}
7. return I
```

**理论结果**

**定理**：GREEDY-SET-COVER 是一个多项式时间的 ρ(n) 近似算法，其中：
```
ρ(n) = H(max{|S| : S ∈ F})
```
H 是调和级数：H(d) = 1 + 1/2 + 1/3 + ... + 1/d
